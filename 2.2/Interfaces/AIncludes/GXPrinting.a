;
;	File:		GXPrinting.a
;
;	Contains:	This file contains all printing APIs except for driver/extension specific ones.
;
;	Version:	Technology:	Quickdraw GX 1.1
;				Package:	Universal Interfaces 2.2 in “MPW” on ETO #20
;
;	Copyright:	© 1984-1995 by Apple Computer, Inc.
;				All rights reserved.
;
;	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter
;				stack.  Include the file and version information (from above)
;				in the problem description and send to:
;					Internet:	apple.bugs@applelink.apple.com
;					AppleLink:	APPLE.BUGS
;
;

	IF &TYPE('__GXPRINTING__') = 'UNDEFINED' THEN
__GXPRINTING__ SET 1


	IF &TYPE('__COLLECTIONS__') = 'UNDEFINED' THEN
	include 'Collections.a'
	ENDIF
;		include 'Types.a'											;
;			include 'ConditionalMacros.a'							;
;		include 'MixedMode.a'										;

	IF &TYPE('__CONDITIONALMACROS__') = 'UNDEFINED' THEN
	include 'ConditionalMacros.a'
	ENDIF

	IF &TYPE('__DIALOGS__') = 'UNDEFINED' THEN
	include 'Dialogs.a'
	ENDIF
;		include 'Errors.a'											;
;		include 'Memory.a'											;
;		include 'Menus.a'											;
;			include 'Quickdraw.a'									;
;				include 'QuickdrawText.a'							;
;		include 'Controls.a'										;
;		include 'Windows.a'										;
;			include 'Events.a'										;
;				include 'OSUtils.a'								;
;		include 'TextEdit.a'										;

	IF &TYPE('__ERRORS__') = 'UNDEFINED' THEN
	include 'Errors.a'
	ENDIF

	IF &TYPE('__FILES__') = 'UNDEFINED' THEN
	include 'Files.a'
	ENDIF
;		include 'Finder.a'											;

	IF &TYPE('__GXFONTS__') = 'UNDEFINED' THEN
	include 'GXFonts.a'
	ENDIF
;		include 'GXMath.a'											;
;			include 'FixMath.a'									;
;		include 'GXTypes.a'										;
;		include 'ScalerTypes.a'									;
;			include 'SFNTTypes.a'									;

	IF &TYPE('__GXMATH__') = 'UNDEFINED' THEN
	include 'GXMath.a'
	ENDIF

	IF &TYPE('__GXTYPES__') = 'UNDEFINED' THEN
	include 'GXTypes.a'
	ENDIF

	IF &TYPE('__LISTS__') = 'UNDEFINED' THEN
	include 'Lists.a'
	ENDIF

	IF &TYPE('__MENUS__') = 'UNDEFINED' THEN
	include 'Menus.a'
	ENDIF

	IF &TYPE('__GXMESSAGES__') = 'UNDEFINED' THEN
	include 'GXMessages.a'
	ENDIF

	IF &TYPE('__PRINTING__') = 'UNDEFINED' THEN
	include 'Printing.a'
	ENDIF

	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF

gestaltGXPrintingMgrVersion		EQU		'pmgr'
gestaltGXVersion				EQU		'qdgx'

; typedef unsigned long 	gxOwnerSignature
	IF OLDROUTINENAMES  THEN
; typedef unsigned long 	Signature
	ENDIF
; typedef struct gxPrivatePrinterRecord  *gxPrinter
; typedef struct gxPrivateJobRecord  *gxJob
; typedef struct gxPrivateFormatRecord  *gxFormat
; typedef struct gxPrivatePaperTypeRecord  *gxPaperType
; typedef struct gxPrivatePrintFileRecord  *gxPrintFile
; typedef Boolean 			gxLoopStatus

gxStopLooping					EQU		false
gxKeepLooping					EQU		true

; typedef gxViewDeviceProcPtr  gxViewDeviceProc
; typedef gxFormatProcPtr 	gxFormatProc
; typedef gxPaperTypeProcPtr  gxPaperTypeProc
; typedef gxPrintingFlattenProcPtr  gxPrintingFlattenProc
;
;	The following constants are used to set collection item flags in printing
;	collections. The Printing Manager purges certain items whenever a driver
;	switch occurs. If the formatting driver changes, all items marked as
;	gxVolatileFormattingDriverCategory will be purged.  If the output driver
;	changes, all items marked as gxVolatileOutputDriverCategory will be purged.
;	Note that to prevent items from being flattened when GXFlattenJob is called,
;	you should unset the collectionPersistenceBit (defined in Collections.h),
;	which is on by default.
;
; Structure stored in collection items' user attribute bits 
; typedef short 			gxCollectionCategory

gxNoCollectionCategory			EQU		$0000
gxOutputDriverCategory			EQU		$0001
gxFormattingDriverCategory		EQU		$0002
gxDriverVolatileCategory		EQU		$0004
gxVolatileOutputDriverCategory	EQU		gxOutputDriverCategory + gxDriverVolatileCategory
gxVolatileFormattingDriverCategory EQU		gxFormattingDriverCategory + gxDriverVolatileCategory

;
;
;	>>>>>> JOB COLLECTION ITEMS <<<<<<
;
;
; gxJobInfo COLLECTION ITEM 
gxJobTag						EQU		'job '

gxJobInfo 				RECORD	0
numPages				 ds.l   1		; offset: $0 (0)		; Number of pages in the document 
priority				 ds.l   1		; offset: $4 (4)		; Priority of this job plus "is it on hold?" 
timeToPrint				 ds.l   1		; offset: $8 (8)		; When to print job, if scheduled 
jobTimeout				 ds.l   1		; offset: $C (12)		; Timeout value, in ticks 
firstPageToPrint		 ds.l   1		; offset: $10 (16)		; Start printing from this page 
jobAlert				 ds.w   1		; offset: $14 (20)		; How to alert user when printing 
appName					 ds.l   8		; offset: $16 (22)		; Which application printed the document 
documentName			 ds.l   8		; offset: $36 (54)		; The name of the document being printed 
userName				 ds.l   8		; offset: $56 (86)		; The owner name of the machine that printed the document 
sizeof					 EQU *			; size:   $76 (118)
						ENDR

; typedef struct gxJobInfo 	gxJobInfo
; priority field constants 

gxPrintJobHoldingBit			EQU		$00001000			; This bit is set if the job is on hold. 

gxPrintJobUrgent				EQU		$00000001
gxPrintJobAtTime				EQU		$00000002
gxPrintJobASAP					EQU		$00000003
gxPrintJobHolding				EQU		(gxPrintJobHoldingBit + gxPrintJobASAP)
gxPrintJobHoldingAtTime			EQU		(gxPrintJobHoldingBit + gxPrintJobAtTime)
gxPrintJobHoldingUrgent			EQU		(gxPrintJobHoldingBit + gxPrintJobUrgent)

; jobAlert field constants 
gxNoPrintTimeAlert				EQU		0					; Don't alert user when we print 
gxAlertBefore					EQU		1					; Alert user before we print 
gxAlertAfter					EQU		2					; Alert user after we print 
gxAlertBothTimes				EQU		3					; Alert before and after we print 

; jobTimeout field constants 
gxThirtySeconds					EQU		1800				; 30 seconds in ticks 
gxTwoMinutes					EQU		7200				; 2 minutes in ticks 

; gxCollationTag COLLECTION ITEM 
gxCollationTag					EQU		'sort'

gxCollationInfo 		RECORD	0
collation				 ds.b   1		; offset: $0 (0)		; True if copies are to be collated 
padByte					 ds.b   1		; offset: $1 (1)
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxCollationInfo  gxCollationInfo
; gxCopiesTag COLLECTION ITEM 

gxCopiesTag						EQU		'copy'

gxCopiesInfo 			RECORD	0
copies					 ds.l   1		; offset: $0 (0)		; Number of copies of the document to print 
sizeof					 EQU *			; size:   $4 (4)
						ENDR

; typedef struct gxCopiesInfo  gxCopiesInfo
; gxPageRangeTag COLLECTION ITEM 

gxPageRangeTag					EQU		'rang'

gxSimplePageRangeInfo 	RECORD	0
optionChosen			 ds.b   1		; offset: $0 (0)		; From options listed below 
printAll				 ds.b   1		; offset: $1 (1)		; True if user wants to print all pages 
fromPage				 ds.l   1		; offset: $2 (2)		; For gxDefaultPageRange, current value 
toPage					 ds.l   1		; offset: $6 (6)		; For gxDefaultPageRange, current value 
sizeof					 EQU *			; size:   $A (10)
						ENDR

; typedef struct gxSimplePageRangeInfo  gxSimplePageRangeInfo
gxPageRangeInfo 		RECORD	0
simpleRange				 ds     gxSimplePageRangeInfo ; offset: $0 (0) ; Info which will be returned for GetJobPageRange 
fromString				 ds.l   8		; offset: $A (10)		; For gxCustomizePageRange, current value 
toString				 ds.l   8		; offset: $2A (42)		; For gxCustomizePageRange, current value 
minFromPage				 ds.l   1		; offset: $4A (74)		; For gxDefaultPageRange, we parse with this, ignored if nil 
maxToPage				 ds.l   1		; offset: $4E (78)		; For gxDefaultPageRange, we parse with this, ignored if nil 
replaceString			 ds.b   1		; offset: $52 (82)		; For gxReplacePageRange, string to display 
						 ORG 84
sizeof					 EQU *			; size:   $54 (84)
						ENDR

; typedef struct gxPageRangeInfo  gxPageRangeInfo
; optionChosen field constants for SimplePageRangeInfo 

gxDefaultPageRange				EQU		0
gxReplacePageRange				EQU		1
gxCustomizePageRange			EQU		2

; gxQualityTag COLLECTION ITEM 
gxQualityTag					EQU		'qual'

gxQualityInfo 			RECORD	0
disableQuality			 ds.b   1		; offset: $0 (0)		; True to disable standard quality controls 
padByte					 ds.b   1		; offset: $1 (1)
defaultQuality			 ds.w   1		; offset: $2 (2)		; The default quality value 
currentQuality			 ds.w   1		; offset: $4 (4)		; The current quality value 
qualityCount			 ds.w   1		; offset: $6 (6)		; The number of quality menu items in popup menu 
qualityNames			 ds.b   1		; offset: $8 (8)		; An array of packed pascal strings for popup menu titles 
						 ORG 10
sizeof					 EQU *			; size:   $A (10)
						ENDR

; typedef struct gxQualityInfo  gxQualityInfo
; gxFileDestinationTag COLLECTION ITEM 

gxFileDestinationTag			EQU		'dest'

gxFileDestinationInfo 	RECORD	0
toFile					 ds.b   1		; offset: $0 (0)		; True if destination is a file 
padByte					 ds.b   1		; offset: $1 (1)
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxFileDestinationInfo  gxFileDestinationInfo
; gxFileLocationTag COLLECTION ITEM 

gxFileLocationTag				EQU		'floc'

gxFileLocationInfo 		RECORD	0
fileSpec				 ds     FSSpec	; offset: $0 (0)		; Location to put file, if destination is file 
sizeof					 EQU *			; size:   $46 (70)
						ENDR

; typedef struct gxFileLocationInfo  gxFileLocationInfo
; gxFileFormatTag COLLECTION ITEM 

gxFileFormatTag					EQU		'ffmt'

gxFileFormatInfo 		RECORD	0
fileFormatName			 ds.l   8		; offset: $0 (0)		; Name of file format (e.g. "PostScript") if destination is file 
sizeof					 EQU *			; size:   $20 (32)
						ENDR

; typedef struct gxFileFormatInfo  gxFileFormatInfo
; gxFileFontsTag COLLECTION ITEM 

gxFileFontsTag					EQU		'incf'

gxFileFontsInfo 		RECORD	0
includeFonts			 ds.b   1		; offset: $0 (0)		; Which fonts to include, if destination is file 
padByte					 ds.b   1		; offset: $1 (1)
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxFileFontsInfo  gxFileFontsInfo
; includeFonts field constants 

gxIncludeNoFonts				EQU		1					; Include no fonts 
gxIncludeAllFonts				EQU		2					; Include all fonts 
gxIncludeNonStandardFonts		EQU		3					; Include only fonts that aren't in the standard LW set 

; gxPaperFeedTag COLLECTION ITEM 
gxPaperFeedTag					EQU		'feed'

gxPaperFeedInfo 		RECORD	0
autoFeed				 ds.b   1		; offset: $0 (0)		; True if automatic feed, false if manual 
padByte					 ds.b   1		; offset: $1 (1)
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxPaperFeedInfo  gxPaperFeedInfo
; gxTrayFeedTag COLLECTION ITEM 

gxTrayFeedTag					EQU		'tray'

; typedef long 				gxTrayIndex
gxTrayFeedInfo 			RECORD	0
feedTrayIndex			 ds.l   1		; offset: $0 (0)		; Tray to feed paper from 
manualFeedThisPage		 ds.b   1		; offset: $4 (4)		; Signals manual feeding for the page 
padByte					 ds.b   1		; offset: $5 (5)
sizeof					 EQU *			; size:   $6 (6)
						ENDR

; typedef struct gxTrayFeedInfo  gxTrayFeedInfo
; gxManualFeedTag COLLECTION ITEM 

gxManualFeedTag					EQU		'manf'

gxManualFeedInfo 		RECORD	0
numPaperTypeNames		 ds.l   1		; offset: $0 (0)		; Number of paperTypes to manually feed 
paperTypeNames			 ds.l   8		; offset: $4 (4)		; Array of names of paperTypes to manually feed 
sizeof					 EQU *			; size:   $24 (36)
						ENDR

; typedef struct gxManualFeedInfo  gxManualFeedInfo
; gxNormalMappingTag COLLECTION ITEM 

gxNormalMappingTag				EQU		'nmap'

gxNormalMappingInfo 	RECORD	0
normalPaperMapping		 ds.b   1		; offset: $0 (0)		; True if not overriding normal paper mapping 
padByte					 ds.b   1		; offset: $1 (1)
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxNormalMappingInfo  gxNormalMappingInfo
; gxSpecialMappingTag COLLECTION ITEM 

gxSpecialMappingTag				EQU		'smap'

gxSpecialMappingInfo 	RECORD	0
specialMapping			 ds.b   1		; offset: $0 (0)		; Enumerated redirect, scale or tile setting 
padByte					 ds.b   1		; offset: $1 (1)
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxSpecialMappingInfo  gxSpecialMappingInfo
; specialMapping field constants 

gxRedirectPages					EQU		1					; Redirect pages to a papertype and clip if necessary 
gxScalePages					EQU		2					; Scale pages if necessary 
gxTilePages						EQU		3					; Tile pages if necessary 

; gxTrayMappingTag COLLECTION ITEM 
gxTrayMappingTag				EQU		'tmap'

gxTrayMappingInfo 		RECORD	0
mapPaperToTray			 ds.l   1		; offset: $0 (0)		; Tray to map all paper to 
sizeof					 EQU *			; size:   $4 (4)
						ENDR

; typedef struct gxTrayMappingInfo  gxTrayMappingInfo
; gxPaperMappingTag COLLECTION ITEM 
; This collection item contains a flattened paper type resource 

gxPaperMappingTag				EQU		'pmap'

; gxPrintPanelTag COLLECTION ITEM 
gxPrintPanelTag					EQU		'ppan'

gxPrintPanelInfo 		RECORD	0
startPanelName			 ds.l   8		; offset: $0 (0)		; Name of starting panel in Print dialog 
sizeof					 EQU *			; size:   $20 (32)
						ENDR

; typedef struct gxPrintPanelInfo  gxPrintPanelInfo
; gxFormatPanelTag COLLECTION ITEM 

gxFormatPanelTag				EQU		'fpan'

gxFormatPanelInfo 		RECORD	0
startPanelName			 ds.l   8		; offset: $0 (0)		; Name of starting panel in Format dialog 
sizeof					 EQU *			; size:   $20 (32)
						ENDR

; typedef struct gxFormatPanelInfo  gxFormatPanelInfo
; gxTranslatedDocumentTag COLLECTION ITEM 

gxTranslatedDocumentTag			EQU		'trns'

gxTranslatedDocumentInfo RECORD	0
translatorInfo			 ds.l   1		; offset: $0 (0)		; Information from the translation process 
sizeof					 EQU *			; size:   $4 (4)
						ENDR

; typedef struct gxTranslatedDocumentInfo  gxTranslatedDocumentInfo
;
;
;	>>>>>> FORMAT COLLECTION ITEMS <<<<<<
;
;
; gxPaperTypeLockTag COLLECTION ITEM 

gxPaperTypeLockTag				EQU		'ptlk'

gxPaperTypeLockInfo 	RECORD	0
paperTypeLocked			 ds.b   1		; offset: $0 (0)		; True if format's paperType is locked 
padByte					 ds.b   1		; offset: $1 (1)
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxPaperTypeLockInfo  gxPaperTypeLockInfo
; gxOrientationTag COLLECTION ITEM 

gxOrientationTag				EQU		'layo'

gxOrientationInfo 		RECORD	0
orientation				 ds.b   1		; offset: $0 (0)		; An enumerated orientation value 
padByte					 ds.b   1		; offset: $1 (1)
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxOrientationInfo  gxOrientationInfo
; orientation field constants 

gxPortraitLayout				EQU		0					; Portrait 
gxLandscapeLayout				EQU		1					; Landscape 
gxRotatedPortraitLayout			EQU		2					; Portrait, rotated 180° 
gxRotatedLandscapeLayout		EQU		3					; Landscape, rotated 180°  

; gxScalingTag COLLECTION ITEM 
gxScalingTag					EQU		'scal'

gxScalingInfo 			RECORD	0
horizontalScaleFactor	 ds.l   1		; offset: $0 (0)		; Current horizontal scaling factor 
verticalScaleFactor		 ds.l   1		; offset: $4 (4)		; Current vertical scaling factor 
minScaling				 ds.w   1		; offset: $8 (8)		; Minimum scaling allowed 
maxScaling				 ds.w   1		; offset: $A (10)		; Maximum scaling allowed 
sizeof					 EQU *			; size:   $C (12)
						ENDR

; typedef struct gxScalingInfo  gxScalingInfo
; gxDirectModeTag COLLECTION ITEM 

gxDirectModeTag					EQU		'dirm'

gxDirectModeInfo 		RECORD	0
directModeOn			 ds.b   1		; offset: $0 (0)		; True if a direct mode is enabled 
padByte					 ds.b   1		; offset: $1 (1)
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxDirectModeInfo  gxDirectModeInfo
; gxFormatHalftoneTag COLLECTION ITEM 

gxFormatHalftoneTag				EQU		'half'

gxFormatHalftoneInfo 	RECORD	0
numHalftones			 ds.l   1		; offset: $0 (0)		; Number of halftone records 
halftones				 ds     gxHalftone ; offset: $4 (4)		; The halftone records 
sizeof					 EQU *			; size:   $38 (56)
						ENDR

; typedef struct gxFormatHalftoneInfo  gxFormatHalftoneInfo
; gxInvertPageTag COLLECTION ITEM 

gxInvertPageTag					EQU		'invp'

gxInvertPageInfo 		RECORD	0
padByte					 ds.b   1		; offset: $0 (0)
invert					 ds.b   1		; offset: $1 (1)		; If true, invert page 
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxInvertPageInfo  gxInvertPageInfo
; gxFlipPageHorizontalTag COLLECTION ITEM 

gxFlipPageHorizontalTag			EQU		'flph'

gxFlipPageHorizontalInfo RECORD	0
padByte					 ds.b   1		; offset: $0 (0)
flipHorizontal			 ds.b   1		; offset: $1 (1)		; If true, flip x coordinates on page 
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxFlipPageHorizontalInfo  gxFlipPageHorizontalInfo
; gxFlipPageVerticalTag COLLECTION ITEM 

gxFlipPageVerticalTag			EQU		'flpv'

gxFlipPageVerticalInfo 	RECORD	0
padByte					 ds.b   1		; offset: $0 (0)
flipVertical			 ds.b   1		; offset: $1 (1)		; If true, flip y coordinates on page 
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxFlipPageVerticalInfo  gxFlipPageVerticalInfo
; gxPreciseBitmapsTag COLLECTION ITEM 

gxPreciseBitmapsTag				EQU		'pbmp'

gxPreciseBitmapInfo 	RECORD	0
preciseBitmaps			 ds.b   1		; offset: $0 (0)		; If true, scale page by 96% 
padByte					 ds.b   1		; offset: $1 (1)
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxPreciseBitmapInfo  gxPreciseBitmapInfo
;
;
;	>>>>>> PAPERTYPE COLLECTION ITEMS <<<<<<
;
;
; gxBaseTag COLLECTION ITEM 

gxBaseTag						EQU		'base'

gxBaseInfo 				RECORD	0
baseType				 ds.l   1		; offset: $0 (0)		; PaperType's base type 
sizeof					 EQU *			; size:   $4 (4)
						ENDR

; typedef struct gxBaseInfo  gxBaseInfo
; baseType field constants 

gxUnknownBase					EQU		0					; Base paper type from which this paper type is 
gxUSLetterBase					EQU		1					; derived.  This is not a complete set. 
gxUSLegalBase					EQU		2
gxA4LetterBase					EQU		3
gxB5LetterBase					EQU		4
gxTabloidBase					EQU		5

; gxCreatorTag COLLECTION ITEM 
gxCreatorTag					EQU		'crea'

gxCreatorInfo 			RECORD	0
creator					 ds.l   1		; offset: $0 (0)		; PaperType's creator 
sizeof					 EQU *			; size:   $4 (4)
						ENDR

; typedef struct gxCreatorInfo  gxCreatorInfo
; gxUnitsTag COLLECTION ITEM 

gxUnitsTag						EQU		'unit'

gxUnitsInfo 			RECORD	0
units					 ds.b   1		; offset: $0 (0)		; PaperType's units (used by PaperType Editor). 
padByte					 ds.b   1		; offset: $1 (1)
sizeof					 EQU *			; size:   $2 (2)
						ENDR

; typedef struct gxUnitsInfo  gxUnitsInfo
; units field constants 

gxPicas							EQU		0					; Pica measurement 
gxMMs							EQU		1					; Millimeter measurement 
gxInches						EQU		2					; Inches measurement 

; gxFlagsTag COLLECTION ITEM 
gxFlagsTag						EQU		'flag'

gxFlagsInfo 			RECORD	0
flags					 ds.l   1		; offset: $0 (0)		; PaperType's flags 
sizeof					 EQU *			; size:   $4 (4)
						ENDR

; typedef struct gxFlagsInfo  gxFlagsInfo
; flags field constants 

gxOldPaperTypeFlag				EQU		$00800000			; Indicates a paper type for compatibility printing 
gxNewPaperTypeFlag				EQU		$00400000			; Indicates a paper type for QuickDraw GX-aware printing 
gxOldAndNewFlag					EQU		$00C00000			; Indicates a paper type that's both old and new 
gxDefaultPaperTypeFlag			EQU		$00100000			; Indicates the default paper type in the group 

; gxCommentTag COLLECTION ITEM 
gxCommentTag					EQU		'cmnt'

gxCommentInfo 			RECORD	0
comment					 ds.l   64		; offset: $0 (0)		; PaperType's comment 
sizeof					 EQU *			; size:   $100 (256)
						ENDR

; typedef struct gxCommentInfo  gxCommentInfo
;
;
;	>>>>>> PRINTER VIEWDEVICE TAGS <<<<<<
;
;
; gxPenTableTag COLLECTION ITEM 

gxPenTableTag					EQU		'pent'

gxPenTableEntry 		RECORD	0
penName					 ds.l   8		; offset: $0 (0)		; Name of the pen 
penColor				 ds     gxColor	; offset: $20 (32)		; Color to use from the color set 
penThickness			 ds.l   1		; offset: $30 (48)		; Size of the pen 
penUnits				 ds.w   1		; offset: $34 (52)		; Specifies units in which pen thickness is defined 
penPosition				 ds.w   1		; offset: $36 (54)		; Pen position in the carousel, -1 (kPenNotLoaded) if not loaded 
sizeof					 EQU *			; size:   $38 (56)
						ENDR

; typedef struct gxPenTableEntry  gxPenTableEntry
gxPenTable 				RECORD	0
numPens					 ds.l   1		; offset: $0 (0)		; Number of pen entries in the following array 
pens					 ds     gxPenTableEntry ; offset: $4 (4) ; Array of pen entries 
sizeof					 EQU *			; size:   $3C (60)
						ENDR

; typedef struct gxPenTable  gxPenTable, *gxPenTablePtr, **gxPenTableHdl
; penUnits field constants 

gxDeviceUnits					EQU		0
gxMMUnits						EQU		1
gxInchesUnits					EQU		2

; penPosition field constants 
gxPenNotLoaded					EQU		-1

;
;
;	>>>>>> DIALOG-RELATED CONSTANTS AND TYPES <<<<<<
;
;
; typedef long 				gxDialogResult

gxCancelSelected				EQU		0
gxOKSelected					EQU		1
gxRevertSelected				EQU		2

gxEditMenuRecord 		RECORD	0
editMenuID				 ds.w   1		; offset: $0 (0)
cutItem					 ds.w   1		; offset: $2 (2)
copyItem				 ds.w   1		; offset: $4 (4)
pasteItem				 ds.w   1		; offset: $6 (6)
clearItem				 ds.w   1		; offset: $8 (8)
undoItem				 ds.w   1		; offset: $A (10)
sizeof					 EQU *			; size:   $C (12)
						ENDR

; typedef struct gxEditMenuRecord  gxEditMenuRecord
;
;
;	>>>>>> JOB FORMAT MODE CONSTANTS AND TYPES <<<<<<
;
;
; typedef OSType 			gxJobFormatMode
gxJobFormatModeTable 	RECORD	0
numModes				 ds.l   1		; offset: $0 (0)		; Number of job format modes to choose from 
modes					 ds.l   1		; offset: $4 (4)		; The job format modes 
sizeof					 EQU *			; size:   $8 (8)
						ENDR

; typedef struct gxJobFormatModeTable  gxJobFormatModeTable, *gxJobFormatModeTablePtr, **gxJobFormatModeTableHdl

gxGraphicsJobFormatMode			EQU		'grph'
gxTextJobFormatMode				EQU		'text'
gxPostScriptJobFormatMode		EQU		'post'

; typedef long 				gxQueryType

gxGetJobFormatLineConstraintQuery EQU		0
gxGetJobFormatFontsQuery		EQU		1
gxGetJobFormatFontCommonStylesQuery EQU		2
gxGetJobFormatFontConstraintQuery EQU		3
gxSetStyleJobFormatCommonStyleQuery EQU		4

; Structures used for Text mode field constants 
gxPositionConstraintTable RECORD	0
phase					 ds     gxPoint	; offset: $0 (0)		; Position phase 
offset					 ds     gxPoint	; offset: $8 (8)		; Position offset 
numSizes				 ds.l   1		; offset: $10 (16)		; Number of available font sizes 
sizes					 ds.l   1		; offset: $14 (20)		; The available font sizes 
sizeof					 EQU *			; size:   $18 (24)
						ENDR

; typedef struct gxPositionConstraintTable  gxPositionConstraintTable, *gxPositionConstraintTablePtr, **gxPositionConstraintTableHdl
; numSizes field constants 

gxConstraintRange				EQU		-1

gxStyleNameTable 		RECORD	0
numStyleNames			 ds.l   1		; offset: $0 (0)		; Number of style names 
styleNames				 ds.l   64		; offset: $4 (4)		; The style names 
sizeof					 EQU *			; size:   $104 (260)
						ENDR

; typedef struct gxStyleNameTable  gxStyleNameTable, *gxStyleNameTablePtr, **gxStyleNameTableHdl
gxFontTable 			RECORD	0
numFonts				 ds.l   1		; offset: $0 (0)		; Number of font references 
fonts					 ds.l   1		; offset: $4 (4)		; The font references 
sizeof					 EQU *			; size:   $8 (8)
						ENDR

; typedef struct gxFontTable  gxFontTable, *gxFontTablePtr, **gxFontTableHdl
; ------------------------------------------------------------------------------
;
;								Printing Manager API Functions
;
;-------------------------------------------------------------------------------- 
;
; pascal OSErr GXInitPrinting(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXInitPrinting
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0000
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXInitPrinting
	ENDIF

;
; pascal OSErr GXExitPrinting(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXExitPrinting
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0001
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXExitPrinting
	ENDIF

;
;	Error-Handling Routines
;
;
; pascal OSErr GXGetJobError(gxJob aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetJobError
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$000E
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetJobError
	ENDIF

;
; pascal void GXSetJobError(gxJob aJob, OSErr anErr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSetJobError
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$000F
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSetJobError
	ENDIF

;
;	Job Routines
;
;
; pascal OSErr GXNewJob(gxJob *aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXNewJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0002
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXNewJob
	ENDIF

;
; pascal OSErr GXDisposeJob(gxJob aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXDisposeJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0003
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXDisposeJob
	ENDIF

;
; pascal void GXFlattenJob(gxJob aJob, gxPrintingFlattenProc flattenProc, void *aVoid)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXFlattenJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0004
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXFlattenJob
	ENDIF

;
; pascal gxJob GXUnflattenJob(gxJob aJob, gxPrintingFlattenProc flattenProc, void *aVoid)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXUnflattenJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0005
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXUnflattenJob
	ENDIF

;
; pascal Handle GXFlattenJobToHdl(gxJob aJob, Handle aHdl)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXFlattenJobToHdl
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0006
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXFlattenJobToHdl
	ENDIF

;
; pascal gxJob GXUnflattenJobFromHdl(gxJob aJob, Handle aHdl)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXUnflattenJobFromHdl
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0007
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXUnflattenJobFromHdl
	ENDIF

;
; pascal void GXInstallApplicationOverride(gxJob aJob, short messageID, void *override)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXInstallApplicationOverride
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0008
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXInstallApplicationOverride
	ENDIF

;
; pascal Collection GXGetJobCollection(gxJob aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetJobCollection
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$001D
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetJobCollection
	ENDIF

;
; pascal void *GXGetJobRefCon(gxJob aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetJobRefCon
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$001E
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetJobRefCon
	ENDIF

;
; pascal void GXSetJobRefCon(gxJob aJob, void *refCon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSetJobRefCon
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$001F
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSetJobRefCon
	ENDIF

;
; pascal gxJob GXCopyJob(gxJob srcJob, gxJob dstJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCopyJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0020
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCopyJob
	ENDIF

;
; pascal void GXSelectJobFormattingPrinter(gxJob aJob, Str31 printerName)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSelectJobFormattingPrinter
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0021
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSelectJobFormattingPrinter
	ENDIF

;
; pascal void GXSelectJobOutputPrinter(gxJob aJob, Str31 printerName)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSelectJobOutputPrinter
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0022
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSelectJobOutputPrinter
	ENDIF

;
; pascal void GXForEachJobFormatDo(gxJob aJob, gxFormatProc formatProc, void *refCon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXForEachJobFormatDo
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0023
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXForEachJobFormatDo
	ENDIF

;
; pascal long GXCountJobFormats(gxJob aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCountJobFormats
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0024
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCountJobFormats
	ENDIF

;
; pascal Boolean GXUpdateJob(gxJob aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXUpdateJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0025
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXUpdateJob
	ENDIF

;
; pascal void GXConvertPrintRecord(gxJob aJob, THPrint hPrint)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXConvertPrintRecord
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0026
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXConvertPrintRecord
	ENDIF

;
; pascal void GXIdleJob(gxJob aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXIdleJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0057
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXIdleJob
	ENDIF

;
;	Job Format Modes Routines
;
;
; pascal void GXSetAvailableJobFormatModes(gxJob aJob, gxJobFormatModeTableHdl formatModeTable)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSetAvailableJobFormatModes
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$003B
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSetAvailableJobFormatModes
	ENDIF

;
; pascal gxJobFormatMode GXGetPreferredJobFormatMode(gxJob aJob, Boolean *directOnly)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetPreferredJobFormatMode
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$003C
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetPreferredJobFormatMode
	ENDIF

;
; pascal gxJobFormatMode GXGetJobFormatMode(gxJob aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetJobFormatMode
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$003D
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetJobFormatMode
	ENDIF

;
; pascal void GXSetJobFormatMode(gxJob aJob, gxJobFormatMode formatMode)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSetJobFormatMode
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$003E
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSetJobFormatMode
	ENDIF

;
; pascal void GXJobFormatModeQuery(gxJob aJob, gxQueryType aQueryType, void *srcData, void *dstData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXJobFormatModeQuery
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$003F
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXJobFormatModeQuery
	ENDIF

;
;	Format Routines
;
;
; pascal gxFormat GXNewFormat(gxJob aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXNewFormat
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0009
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXNewFormat
	ENDIF

;
; pascal void GXDisposeFormat(gxFormat aFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXDisposeFormat
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$000A
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXDisposeFormat
	ENDIF

;
; pascal gxFormat GXGetJobFormat(gxJob aJob, long whichFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetJobFormat
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0013
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetJobFormat
	ENDIF

;
; pascal gxJob GXGetFormatJob(gxFormat aFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetFormatJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0014
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetFormatJob
	ENDIF

;
; pascal gxPaperType GXGetFormatPaperType(gxFormat aFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetFormatPaperType
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0015
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetFormatPaperType
	ENDIF

;
; pascal void GXGetFormatDimensions(gxFormat aFormat, gxRectangle *pageSize, gxRectangle *paperSize)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetFormatDimensions
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0016
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetFormatDimensions
	ENDIF

;
; pascal Collection GXGetFormatCollection(gxFormat aFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetFormatCollection
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0033
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetFormatCollection
	ENDIF

;
; pascal void GXChangedFormat(gxFormat aFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXChangedFormat
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0034
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXChangedFormat
	ENDIF

;
; pascal gxFormat GXCopyFormat(gxFormat srcFormat, gxFormat dstFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCopyFormat
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0035
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCopyFormat
	ENDIF

;
; pascal gxFormat GXCloneFormat(gxFormat aFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCloneFormat
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0036
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCloneFormat
	ENDIF

;
; pascal long GXCountFormatOwners(gxFormat aFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCountFormatOwners
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0037
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCountFormatOwners
	ENDIF

;
; pascal void GXGetFormatMapping(gxFormat aFormat, gxMapping *fmtMapping)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetFormatMapping
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0038
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetFormatMapping
	ENDIF

;
; pascal gxShape GXGetFormatForm(gxFormat aFormat, gxShape *mask)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetFormatForm
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0039
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetFormatForm
	ENDIF

;
; pascal void GXSetFormatForm(gxFormat aFormat, gxShape form, gxShape mask)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSetFormatForm
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$003A
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSetFormatForm
	ENDIF

;
;	PaperType Routines
;
;
; pascal gxPaperType GXNewPaperType(gxJob aJob, Str31 name, gxRectangle *pageSize, gxRectangle *paperSize)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXNewPaperType
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$000B
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXNewPaperType
	ENDIF

;
; pascal void GXDisposePaperType(gxPaperType aPaperType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXDisposePaperType
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$000C
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXDisposePaperType
	ENDIF

;
; pascal gxPaperType GXGetNewPaperType(gxJob aJob, short resID)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetNewPaperType
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$000D
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetNewPaperType
	ENDIF

;
; pascal long GXCountJobPaperTypes(gxJob aJob, Boolean forFormatDevice)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCountJobPaperTypes
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0042
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCountJobPaperTypes
	ENDIF

;
; pascal gxPaperType GXGetJobPaperType(gxJob aJob, long whichPaperType, Boolean forFormatDevice, gxPaperType aPaperType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetJobPaperType
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0043
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetJobPaperType
	ENDIF

;
; pascal void GXForEachJobPaperTypeDo(gxJob aJob, gxPaperTypeProc aProc, void *refCon, Boolean forFormattingPrinter)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXForEachJobPaperTypeDo
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0044
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXForEachJobPaperTypeDo
	ENDIF

;
; pascal gxPaperType GXCopyPaperType(gxPaperType srcPaperType, gxPaperType dstPaperType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCopyPaperType
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0045
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCopyPaperType
	ENDIF

;
; pascal void GXGetPaperTypeName(gxPaperType aPaperType, Str31 papertypeName)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetPaperTypeName
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0046
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetPaperTypeName
	ENDIF

;
; pascal void GXGetPaperTypeDimensions(gxPaperType aPaperType, gxRectangle *pageSize, gxRectangle *paperSize)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetPaperTypeDimensions
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0047
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetPaperTypeDimensions
	ENDIF

;
; pascal gxJob GXGetPaperTypeJob(gxPaperType aPaperType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetPaperTypeJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0048
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetPaperTypeJob
	ENDIF

;
; pascal Collection GXGetPaperTypeCollection(gxPaperType aPaperType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetPaperTypeCollection
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0049
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetPaperTypeCollection
	ENDIF

;
;	Printer Routines
;
;
; pascal gxPrinter GXGetJobFormattingPrinter(gxJob aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetJobFormattingPrinter
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0027
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetJobFormattingPrinter
	ENDIF

;
; pascal gxPrinter GXGetJobOutputPrinter(gxJob aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetJobOutputPrinter
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0028
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetJobOutputPrinter
	ENDIF

;
; pascal gxPrinter GXGetJobPrinter(gxJob aJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetJobPrinter
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0029
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetJobPrinter
	ENDIF

;
; pascal gxJob GXGetPrinterJob(gxPrinter aPrinter)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetPrinterJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$002A
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetPrinterJob
	ENDIF

;
; pascal void GXForEachPrinterViewDeviceDo(gxPrinter aPrinter, gxViewDeviceProc aProc, void *refCon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXForEachPrinterViewDeviceDo
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$002B
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXForEachPrinterViewDeviceDo
	ENDIF

;
; pascal long GXCountPrinterViewDevices(gxPrinter aPrinter)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCountPrinterViewDevices
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$002C
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCountPrinterViewDevices
	ENDIF

;
; pascal gxViewDevice GXGetPrinterViewDevice(gxPrinter aPrinter, long whichViewDevice)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetPrinterViewDevice
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$002D
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetPrinterViewDevice
	ENDIF

;
; pascal void GXSelectPrinterViewDevice(gxPrinter aPrinter, long whichViewDevice)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSelectPrinterViewDevice
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$002E
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSelectPrinterViewDevice
	ENDIF

;
; pascal void GXGetPrinterName(gxPrinter aPrinter, Str31 printerName)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetPrinterName
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$002F
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetPrinterName
	ENDIF

;
; pascal OSType GXGetPrinterType(gxPrinter aPrinter)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetPrinterType
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0030
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetPrinterType
	ENDIF

;
; pascal void GXGetPrinterDriverName(gxPrinter aPrinter, Str31 driverName)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetPrinterDriverName
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0031
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetPrinterDriverName
	ENDIF

;
; pascal OSType GXGetPrinterDriverType(gxPrinter aPrinter)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetPrinterDriverType
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0032
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetPrinterDriverType
	ENDIF

;
;	Dialog Routines
;
;
; pascal gxDialogResult GXJobDefaultFormatDialog(gxJob aJob, gxEditMenuRecord *anEditMenuRec)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXJobDefaultFormatDialog
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0010
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXJobDefaultFormatDialog
	ENDIF

;
; pascal gxDialogResult GXJobPrintDialog(gxJob aJob, gxEditMenuRecord *anEditMenuRec)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXJobPrintDialog
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0011
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXJobPrintDialog
	ENDIF

;
; pascal gxDialogResult GXFormatDialog(gxFormat aFormat, gxEditMenuRecord *anEditMenuRec, StringPtr title)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXFormatDialog
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0012
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXFormatDialog
	ENDIF

;
; pascal void GXEnableJobScalingPanel(gxJob aJob, Boolean enabled)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXEnableJobScalingPanel
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0040
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXEnableJobScalingPanel
	ENDIF

;
; pascal void GXGetJobPanelDimensions(gxJob aJob, Rect *panelArea)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetJobPanelDimensions
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0041
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetJobPanelDimensions
	ENDIF

;
;	Spooling Routines
;
;
; pascal void GXGetJobPageRange(gxJob theJob, long *firstPage, long *lastPage)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetJobPageRange
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0017
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetJobPageRange
	ENDIF

;
; pascal void GXStartJob(gxJob theJob, StringPtr docName, long pageCount)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXStartJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0018
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXStartJob
	ENDIF

;
; pascal void GXPrintPage(gxJob theJob, long pageNumber, gxFormat theFormat, gxShape thePage)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXPrintPage
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0019
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXPrintPage
	ENDIF

;
; pascal Boolean GXStartPage(gxJob theJob, long pageNumber, gxFormat theFormat, long numViewPorts, gxViewPort *viewPortList)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXStartPage
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$001A
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXStartPage
	ENDIF

;
; pascal void GXFinishPage(gxJob theJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXFinishPage
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$001B
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXFinishPage
	ENDIF

;
; pascal void GXFinishJob(gxJob theJob)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXFinishJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$001C
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXFinishJob
	ENDIF

;
;	PrintFile Routines
;
;
; pascal gxPrintFile GXOpenPrintFile(gxJob theJob, FSSpecPtr anFSSpec, char permission)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXOpenPrintFile
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$004A
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXOpenPrintFile
	ENDIF

;
; pascal void GXClosePrintFile(gxPrintFile aPrintFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXClosePrintFile
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$004B
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXClosePrintFile
	ENDIF

;
; pascal gxJob GXGetPrintFileJob(gxPrintFile aPrintFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetPrintFileJob
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$004C
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetPrintFileJob
	ENDIF

;
; pascal long GXCountPrintFilePages(gxPrintFile aPrintFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCountPrintFilePages
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$004D
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCountPrintFilePages
	ENDIF

;
; pascal void GXReadPrintFilePage(gxPrintFile aPrintFile, long pageNumber, long numViewPorts, gxViewPort *viewPortList, gxFormat *pgFormat, gxShape *pgShape)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXReadPrintFilePage
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$004E
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXReadPrintFilePage
	ENDIF

;
; pascal void GXReplacePrintFilePage(gxPrintFile aPrintFile, long pageNumber, gxFormat aFormat, gxShape aShape)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXReplacePrintFilePage
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$004F
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXReplacePrintFilePage
	ENDIF

;
; pascal void GXInsertPrintFilePage(gxPrintFile aPrintFile, long atPageNumber, gxFormat pgFormat, gxShape pgShape)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXInsertPrintFilePage
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0050
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXInsertPrintFilePage
	ENDIF

;
; pascal void GXDeletePrintFilePageRange(gxPrintFile aPrintFile, long fromPageNumber, long toPageNumber)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXDeletePrintFilePageRange
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0051
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXDeletePrintFilePageRange
	ENDIF

;
; pascal void GXSavePrintFile(gxPrintFile aPrintFile, FSSpec *anFSSpec)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSavePrintFile
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0052
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSavePrintFile
	ENDIF

;
;	ColorSync Routines
;
;
; pascal long GXFindPrinterProfile(gxPrinter aPrinter, void *searchData, long index, gxColorProfile *returnedProfile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXFindPrinterProfile
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0053
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXFindPrinterProfile
	ENDIF

;
; pascal long GXFindFormatProfile(gxFormat aFormat, void *searchData, long index, gxColorProfile *returnedProfile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXFindFormatProfile
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0054
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXFindFormatProfile
	ENDIF

;
; pascal void GXSetPrinterProfile(gxPrinter aPrinter, gxColorProfile oldProfile, gxColorProfile newProfile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSetPrinterProfile
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0055
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSetPrinterProfile
	ENDIF

;
; pascal void GXSetFormatProfile(gxFormat aFormat, gxColorProfile oldProfile, gxColorProfile newProfile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSetFormatProfile
			dc.w 	$203C
			dc.w 	$0000
			dc.w 	$0056
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSetFormatProfile
	ENDIF

;***********************************************************************
;						Start of old "GXPrintingResEquates.h/a/p" interface file.
;				************************************************************************
;	------------------------------------
;				Basic client types
;	------------------------------------ 

gxPrintingManagerType			EQU		'pmgr'
gxImagingSystemType				EQU		'gxis'
gxPrinterDriverType				EQU		'pdvr'
gxPrintingExtensionType			EQU		'pext'
gxUnknownPrinterType			EQU		'none'
gxAnyPrinterType				EQU		'univ'
gxQuickdrawPrinterType			EQU		'qdrw'
gxPortableDocPrinterType		EQU		'gxpd'
gxRasterPrinterType				EQU		'rast'
gxPostscriptPrinterType			EQU		'post'
gxVectorPrinterType				EQU		'vect'

; All pre-defined printing collection items have this ID 
gxPrintingTagID					EQU		-28672

;	----------------------------------------------------------------------
;
;		Resource types and IDs used by both extension and driver writers
;
;	---------------------------------------------------------------------- 
; Resources in a printer driver or extension must be based off of these IDs 
gxPrintingDriverBaseID			EQU		-27648
gxPrintingExtensionBaseID		EQU		-27136

;	Override resources tell the system what messages a driver or extension
;		is overriding.  A driver may have a series of these resources. 
gxOverrideType					EQU		'over'

;	--------------------------------------------------------------
;
;		Message ID definitions by both extension and driver writers
;
;	--------------------------------------------------------------- 
; Identifiers for universal message overrides. 
gxInitializeMsg					EQU		0
gxShutDownMsg					EQU		1
gxJobIdleMsg					EQU		2
gxJobStatusMsg					EQU		3
gxPrintingEventMsg				EQU		4
gxJobDefaultFormatDialogMsg		EQU		5
gxFormatDialogMsg				EQU		6
gxJobPrintDialogMsg				EQU		7
gxFilterPanelEventMsg			EQU		8
gxHandlePanelEventMsg			EQU		9
gxParsePageRangeMsg				EQU		10
gxDefaultJobMsg					EQU		11
gxDefaultFormatMsg				EQU		12
gxDefaultPaperTypeMsg			EQU		13
gxDefaultPrinterMsg				EQU		14
gxCreateSpoolFileMsg			EQU		15
gxSpoolPageMsg					EQU		16
gxSpoolDataMsg					EQU		17
gxSpoolResourceMsg				EQU		18
gxCompleteSpoolFileMsg			EQU		19
gxCountPagesMsg					EQU		20
gxDespoolPageMsg				EQU		21
gxDespoolDataMsg				EQU		22
gxDespoolResourceMsg			EQU		23
gxCloseSpoolFileMsg				EQU		24
gxStartJobMsg					EQU		25
gxFinishJobMsg					EQU		26
gxStartPageMsg					EQU		27
gxFinishPageMsg					EQU		28
gxPrintPageMsg					EQU		29
gxSetupImageDataMsg				EQU		30
gxImageJobMsg					EQU		31
gxImageDocumentMsg				EQU		32
gxImagePageMsg					EQU		33
gxRenderPageMsg					EQU		34
gxCreateImageFileMsg			EQU		35
gxOpenConnectionMsg				EQU		36
gxCloseConnectionMsg			EQU		37
gxStartSendPageMsg				EQU		38
gxFinishSendPageMsg				EQU		39
gxWriteDataMsg					EQU		40
gxBufferDataMsg					EQU		41
gxDumpBufferMsg					EQU		42
gxFreeBufferMsg					EQU		43
gxCheckStatusMsg				EQU		44
gxGetDeviceStatusMsg			EQU		45
gxFetchTaggedDataMsg			EQU		46
gxGetDTPMenuListMsg				EQU		47
gxDTPMenuSelectMsg				EQU		48
gxHandleAlertFilterMsg			EQU		49
gxJobFormatModeQueryMsg			EQU		50
gxWriteStatusToDTPWindowMsg		EQU		51
gxInitializeStatusAlertMsg		EQU		52
gxHandleAlertStatusMsg			EQU		53
gxHandleAlertEventMsg			EQU		54
gxCleanupStartJobMsg			EQU		55
gxCleanupStartPageMsg			EQU		56
gxCleanupOpenConnectionMsg		EQU		57
gxCleanupStartSendPageMsg		EQU		58
gxDefaultDesktopPrinterMsg		EQU		59
gxCaptureOutputDeviceMsg		EQU		60
gxOpenConnectionRetryMsg		EQU		61
gxExamineSpoolFileMsg			EQU		62
gxFinishSendPlaneMsg			EQU		63
gxDoesPaperFitMsg				EQU		64
gxChooserMessageMsg				EQU		65
gxFindPrinterProfileMsg			EQU		66
gxFindFormatProfileMsg			EQU		67
gxSetPrinterProfileMsg			EQU		68
gxSetFormatProfileMsg			EQU		69
gxHandleAltDestinationMsg		EQU		70
gxSetupPageImageDataMsg			EQU		71

; Identifiers for Quickdraw message overrides. 
gxPrOpenDocMsg					EQU		0
gxPrCloseDocMsg					EQU		1
gxPrOpenPageMsg					EQU		2
gxPrClosePageMsg				EQU		3
gxPrintDefaultMsg				EQU		4
gxPrStlDialogMsg				EQU		5
gxPrJobDialogMsg				EQU		6
gxPrStlInitMsg					EQU		7
gxPrJobInitMsg					EQU		8
gxPrDlgMainMsg					EQU		9
gxPrValidateMsg					EQU		10
gxPrJobMergeMsg					EQU		11
gxPrGeneralMsg					EQU		12
gxConvertPrintRecordToMsg		EQU		13
gxConvertPrintRecordFromMsg		EQU		14
gxPrintRecordToJobMsg			EQU		15

; Identifiers for raster imaging message overrides. 
gxRasterDataInMsg				EQU		0
gxRasterLineFeedMsg				EQU		1
gxRasterPackageBitmapMsg		EQU		2

; Identifiers for PostScript imaging message overrides. 
gxPostscriptQueryPrinterMsg		EQU		0
gxPostscriptInitializePrinterMsg EQU		1
gxPostscriptResetPrinterMsg		EQU		2
gxPostscriptExitServerMsg		EQU		3
gxPostscriptGetStatusTextMsg	EQU		4
gxPostscriptGetPrinterTextMsg	EQU		5
gxPostscriptScanStatusTextMsg	EQU		6
gxPostscriptScanPrinterTextMsg	EQU		7
gxPostscriptGetDocumentProcSetListMsg EQU		8
gxPostscriptDownloadProcSetListMsg EQU		9
gxPostscriptGetPrinterGlyphsInformationMsg EQU		10
gxPostscriptStreamFontMsg		EQU		11
gxPostscriptDoDocumentHeaderMsg	EQU		12
gxPostscriptDoDocumentSetUpMsg	EQU		13
gxPostscriptDoDocumentTrailerMsg EQU		14
gxPostscriptDoPageSetUpMsg		EQU		15
gxPostscriptSelectPaperTypeMsg	EQU		16
gxPostscriptDoPageTrailerMsg	EQU		17
gxPostscriptEjectPageMsg		EQU		18
gxPostscriptProcessShapeMsg		EQU		19
gxPostScriptEjectPendingPageMsg	EQU		20

; Identifiers for Vector imaging message overrides. 
gxVectorPackageDataMsg			EQU		0
gxVectorLoadPensMsg				EQU		1
gxVectorVectorizeShapeMsg		EQU		2

; Dialog related resource types 
gxPrintingAlertType				EQU		'plrt'
gxStatusType					EQU		'stat'
gxExtendedDITLType				EQU		'xdtl'
gxPrintPanelType				EQU		'ppnl'
gxCollectionType				EQU		'cltn'

; Communication resource types 
;
;	The looker resource is used by the Chooser PACK to determine what kind
;	of communications this driver supports. (In order to generate/handle the 
;	pop-up menu for "Connect via:".
;	
;	The looker resource is also used by PrinterShare to determine the AppleTalk NBP Type
;	for servers created for this driver.
;
gxLookerType					EQU		'look'
gxLookerID						EQU		-4096

; The communications method and private data used to connect to the printer 
gxDeviceCommunicationsType		EQU		'comm'

;	-------------------------------------------------
;
;	Resource types and IDs used by extension writers
;
;	------------------------------------------------- 
gxExtensionUniversalOverrideID	EQU		gxPrintingExtensionBaseID

gxExtensionImagingOverrideSelectorID EQU		gxPrintingExtensionBaseID

gxExtensionScopeType			EQU		'scop'
gxDriverScopeID					EQU		gxPrintingExtensionBaseID
gxPrinterScopeID				EQU		gxPrintingExtensionBaseID + 1
gxPrinterExceptionScopeID		EQU		gxPrintingExtensionBaseID + 2

gxExtensionLoadType				EQU		'load'
gxExtensionLoadID				EQU		gxPrintingExtensionBaseID

gxExtensionLoadFirst			EQU		$00000100
gxExtensionLoadAnywhere			EQU		$7FFFFFFF
gxExtensionLoadLast				EQU		$FFFFFF00

gxExtensionOptimizationType		EQU		'eopt'
gxExtensionOptimizationID		EQU		gxPrintingExtensionBaseID

;	-----------------------------------------------
;
;	Resource types and IDs used by driver writers
;
;	----------------------------------------------- 
gxDriverUniversalOverrideID		EQU		gxPrintingDriverBaseID
gxDriverImagingOverrideID		EQU		gxPrintingDriverBaseID + 1
gxDriverCompatibilityOverrideID	EQU		gxPrintingDriverBaseID + 2

gxDriverFileFormatType			EQU		'pfil'
gxDriverFileFormatID			EQU		gxPrintingDriverBaseID

gxDestinationAdditionType		EQU		'dsta'
gxDestinationAdditionID			EQU		gxPrintingDriverBaseID

; IMAGING RESOURCES 
;	The imaging system resource specifies which imaging system a printer
;		driver wishes to use. 
gxImagingSystemSelectorType		EQU		'isys'
gxImagingSystemSelectorID		EQU		gxPrintingDriverBaseID

; 'exft' resource ID -- exclude font list 
kExcludeFontListType			EQU		'exft'
kExcludeFontListID				EQU		gxPrintingDriverBaseID

; Resource for type for color matching 
gxColorMatchingDataType			EQU		'prof'
gxColorMatchingDataID			EQU		gxPrintingDriverBaseID

; Resource type and id for the tray count 
gxTrayCountDataType				EQU		'tray'
gxTrayCountDataID				EQU		gxPrintingDriverBaseID

; Resource type for the tray names 
gxTrayNameDataType				EQU		'tryn'

; Resource type for manual feed preferences, stored in DTP. 
gxManualFeedAlertPrefsType		EQU		'mfpr'
gxManualFeedAlertPrefsID		EQU		gxPrintingDriverBaseID

; Resource type for desktop printer output characteristics, stored in DTP. 
gxDriverOutputType				EQU		'outp'
gxDriverOutputTypeID			EQU		1

; IO Resources 
; Resource type and ID for default IO and buffering resources 
gxUniversalIOPrefsType			EQU		'iobm'
gxUniversalIOPrefsID			EQU		gxPrintingDriverBaseID

;	Resource types and IDs for default implementation of CaptureOutputDevice.
;		The default implementation of CaptureOutputDevice only handles PAP devices 
gxCaptureType					EQU		'cpts'
gxCaptureStringID				EQU		gxPrintingDriverBaseID
gxReleaseStringID				EQU		gxPrintingDriverBaseID + 1
gxUncapturedAppleTalkType		EQU		gxPrintingDriverBaseID + 2
gxCapturedAppleTalkType			EQU		gxPrintingDriverBaseID + 3

; Resource type and ID for custom halftone matrix 
gxCustomMatrixType				EQU		'dmat'
gxCustomMatrixID				EQU		gxPrintingDriverBaseID

; Resource type and ID for raster driver rendering preferences 
gxRasterPrefsType				EQU		'rdip'
gxRasterPrefsID					EQU		gxPrintingDriverBaseID

; Resource type for specifiying a colorset 
gxColorSetResType				EQU		'crst'

; Resource type and ID for raster driver packaging preferences 
gxRasterPackType				EQU		'rpck'
gxRasterPackID					EQU		gxPrintingDriverBaseID

; Resource type and ID for raster driver packaging options 
gxRasterNumNone					EQU		0					; Number isn't output at all 
gxRasterNumDirect				EQU		1					; Lowest minWidth bytes as data 
gxRasterNumToASCII				EQU		2					; minWidth ASCII characters 

gxRasterPackOptionsType			EQU		'ropt'
gxRasterPackOptionsID			EQU		gxPrintingDriverBaseID

; Resource type for the PostScript imaging system procedure set control resource 
gxPostscriptProcSetControlType	EQU		'prec'

; Resource type for the PostScript imaging system printer font resource 
gxPostscriptPrinterFontType		EQU		'pfnt'

; Resource type and id for the PostScript imaging system imaging preferences 
gxPostscriptPrefsType			EQU		'pdip'
gxPostscriptPrefsID				EQU		gxPrintingDriverBaseID

; Resource type and id for the PostScript imaging system default scanning code 
gxPostscriptScanningType		EQU		'scan'
gxPostscriptScanningID			EQU		gxPrintingDriverBaseID

; Old Application Support Resources 
gxCustType						EQU		'cust'
gxCustID						EQU		-8192

gxReslType						EQU		'resl'
gxReslID						EQU		-8192

gxDiscreteResolution			EQU		0

gxStlDialogResID				EQU		-8192

gxJobDialogResID				EQU		-8191

gxScaleTableType				EQU		'stab'
gxDITLControlType				EQU		'dctl'

;	The default implementation of gxPrintDefault loads and
;	PrValidates a print record stored in the following driver resource. 
gxPrintRecordType				EQU		'PREC'
gxDefaultPrintRecordID			EQU		0

;
;	-----------------------------------------------
;
;	Resource types and IDs used in papertype files
;
;	-----------------------------------------------
;
; Resource type and ID for driver papertypes placed in individual files 
gxSignatureType					EQU		'sig '
gxPapertypeSignatureID			EQU		0

; Papertype creator types 
gxDrvrPaperType					EQU		'drpt'
gxSysPaperType					EQU		'sypt'				; System paper type creator 
gxUserPaperType					EQU		'uspt'				; User paper type creator 
; Driver creator types == driver file's creator value 
gxPaperTypeType					EQU		'ptyp'

;********************************************************************
;					Start of old "GXPrintingMessages.h/a/p" interface file.
;			*********************************************************************
; ------------------------------------------------------------------------------
;
;									Constants and Types
;
;-------------------------------------------------------------------------------- 
;
;
;	ABSTRACT DATA TYPES
;
;
; typedef struct gxPrivateFileRecord  *gxSpoolFile
; typedef long 				gxPanelEvent
; Dialog panel event equates 

gxPanelNoEvt					EQU		0
gxPanelOpenEvt					EQU		1					; Initialize and draw 
gxPanelCloseEvt					EQU		2					; Your panel is going away (panel switch, confirm or cancel) 
gxPanelHitEvt					EQU		3					; There's a hit in your panel 
gxPanelActivateEvt				EQU		4					; The dialog window has just been activated 
gxPanelDeactivateEvt			EQU		5					; The dialog window is about to be deactivated 
gxPanelIconFocusEvt				EQU		6					; The focus changes from the panel to the icon list 
gxPanelPanelFocusEvt			EQU		7					; The focus changes from the icon list to the panel 
gxPanelFilterEvt				EQU		8					; Every event is filtered 
gxPanelCancelEvt				EQU		9					; The user has cancelled the dialog 
gxPanelConfirmEvt				EQU		10					; The user has confirmed the dialog 
gxPanelDialogEvt				EQU		11					; Event to be handle by dialoghandler 
gxPanelOtherEvt					EQU		12					; osEvts, etc. 
gxPanelUserWillConfirmEvt		EQU		13					; User has selected confirm, time to parse panel interdependencies 

; Constants for panel responses to dialog handler calls 
; typedef long 				gxPanelResult

gxPanelNoResult					EQU		0
gxPanelCancelConfirmation		EQU		1					; Only valid from panelUserWillConfirmEvt - used to keep the dialog from going away 

; Panel event info record for FilterPanelEvent and HandlePanelEvent messages 
gxPanelInfoRecord 		RECORD	0
panelEvt				 ds.l   1		; offset: $0 (0)		; Why we were called 
panelResId				 ds.w   1		; offset: $4 (4)		; 'ppnl' resource id of current panel 
pDlg					 ds.l   1		; offset: $6 (6)		; Pointer to dialog 
theEvent				 ds.l   1		; offset: $A (10)		; Pointer to event 
itemHit					 ds.w   1		; offset: $E (14)		; Actual item number as Dialog Mgr thinks 
itemCount				 ds.w   1		; offset: $10 (16)		; Number of items before your items 
evtAction				 ds.w   1		; offset: $12 (18)		; Once this event is processed, the action that will result 
; (evtAction is only meaningful during filtering) 
errorStringId			 ds.w   1		; offset: $14 (20)		; STR id of string to put in error alert (0 means no string) 
theFormat				 ds.l   1		; offset: $16 (22)		; The current format (only meaningful in a format dialog) 
refCon					 ds.l   1		; offset: $1A (26)		; refCon passed in PanelSetupRecord 
sizeof					 EQU *			; size:   $1E (30)
						ENDR

; typedef struct gxPanelInfoRecord  gxPanelInfoRecord
; Constants for the evtAction field in PanelInfoRecord 

gxOtherAction					EQU		0					; Current item will not change 
gxClosePanelAction				EQU		1					; Panel will be closed 
gxCancelDialogAction			EQU		2					; Dialog will be cancelled 
gxConfirmDialogAction			EQU		3					; Dialog will be confirmed 

; Constants for the panelKind field in gxPanelSetupRecord 
; typedef long 				gxPrintingPanelKind
; The gxPanelSetupInfo structure is passed to GXSetupDialogPanel 
gxPanelSetupRecord 		RECORD	0
panelKind				 ds.l   1		; offset: $0 (0)
panelResId				 ds.w   1		; offset: $4 (4)
resourceRefNum			 ds.w   1		; offset: $6 (6)
refCon					 ds.l   1		; offset: $8 (8)
sizeof					 EQU *			; size:   $C (12)
						ENDR

; typedef struct gxPanelSetupRecord  gxPanelSetupRecord

gxApplicationPanel				EQU		0
gxExtensionPanel				EQU		1
gxDriverPanel					EQU		2

; Constants returned by gxParsePageRange message 
; typedef long 				gxParsePageRangeResult

gxRangeNotParsed				EQU		0					; Default initial value 
gxRangeParsed					EQU		1					; Range has been parsed 
gxRangeBadFromValue				EQU		2					; From value is bad 
gxRangeBadToValue				EQU		3					; To value is bad 

;
;
;	STATUS-RELATED CONSTANTS AND TYPES
;
;
; Structure for status messages 
gxStatusRecord 			RECORD	0
statusType				 ds.w   1		; offset: $0 (0)		; One of the ids listed above (nonFatalError, etc. ) 
statusId				 ds.w   1		; offset: $2 (2)		; Specific status (out of paper, etc.) 
statusAlertId			 ds.w   1		; offset: $4 (4)		;	Printing alert id (if any) for status 
statusOwner				 ds.l   1		; offset: $6 (6)		; Creator type of status owner 
statResId				 ds.w   1		; offset: $A (10)		; ID for 'stat' resource 
statResIndex			 ds.w   1		; offset: $C (12)		; Index into 'stat' resource for this status 
dialogResult			 ds.w   1		; offset: $E (14)		; ID of button string selected on dismissal of printing alert 
bufferLen				 ds.w   1		; offset: $10 (16)		; Number of bytes in status buffer - total record size must be <= 512 
statusBuffer			 ds.b   1		; offset: $12 (18)		; User response from alert 
						 ORG 20
sizeof					 EQU *			; size:   $14 (20)
						ENDR

; typedef struct gxStatusRecord  gxStatusRecord
; Constants for statusType field of gxStatusRecord 

gxNonFatalError					EQU		1					; An error occurred, but the job can continue 
gxFatalError					EQU		2					; A fatal error occurred-- halt job 
gxPrinterReady					EQU		3					; Tells QDGX to leave alert mode 
gxUserAttention					EQU		4					; Signals initiation of a modal alert 
gxUserAlert						EQU		5					; Signals initiation of a moveable modal alert 
gxPageTransmission				EQU		6					; Signals page sent to printer, increments page count in strings to user 
gxOpenConnectionStatus			EQU		7					; Signals QDGX to begin animation on printer icon 
gxInformationalStatus			EQU		8					; Default status type, no side effects 
gxSpoolingPageStatus			EQU		9					; Signals page spooled, increments page count in spooling dialog 
gxEndStatus						EQU		10					; Signals end of spooling 
gxPercentageStatus				EQU		11					; Signals QDGX as to the amount of the job which is currently complete 

; Structure for gxWriteStatusToDTPWindow message 
gxDisplayRecord 		RECORD	0
useText					 ds.b   1		; offset: $0 (0)		; Use text as opposed to a picture 
padByte					 ds.b   1		; offset: $1 (1)
hPicture				 ds.l   1		; offset: $2 (2)		; if !useText, the picture handle 
theText					 ds.l   64		; offset: $6 (6)		; if useText, the text 
sizeof					 EQU *			; size:   $106 (262)
						ENDR

; typedef struct gxDisplayRecord  gxDisplayRecord
;-----------------------------------------------
; paper mapping-related constants and types...  
;-----------------------------------------------
; typedef long 				gxTrayMapping

gxDefaultTrayMapping			EQU		0
gxConfiguredTrayMapping			EQU		1

; ------------------------------------------------------------------------------
;
;				API Functions callable only from within message overrides
;
;-------------------------------------------------------------------------------- 
	IF ¬ GENERATINGPOWERPC  THEN
	ENDIF
;
; gxJob GXGetJob(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetJob
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$0001
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetJob
	ENDIF

;
; short GXGetMessageHandlerResFile(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetMessageHandlerResFile
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$0002
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetMessageHandlerResFile
	ENDIF

;
; Boolean GXSpoolingAborted(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSpoolingAborted
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$0003
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSpoolingAborted
	ENDIF

;
; OSErr GXJobIdle(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXJobIdle
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$0004
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXJobIdle
	ENDIF

;
; OSErr GXReportStatus(long statusID, unsigned long statusIndex)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXReportStatus
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$0005
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXReportStatus
	ENDIF

;
; OSErr GXAlertTheUser(gxStatusRecord *statusRec)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXAlertTheUser
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$0006
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXAlertTheUser
	ENDIF

;
; OSErr GXSetupDialogPanel(gxPanelSetupRecord *panelRec)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSetupDialogPanel
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$0007
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSetupDialogPanel
	ENDIF

;
; OSErr GXCountTrays(gxTrayIndex *numTrays)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCountTrays
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$0008
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCountTrays
	ENDIF

;
; OSErr GXGetTrayName(gxTrayIndex trayNumber, Str31 trayName)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetTrayName
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$0009
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetTrayName
	ENDIF

;
; OSErr GXSetTrayPaperType(gxTrayIndex whichTray, gxPaperType aPapertype)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXSetTrayPaperType
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$000A
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXSetTrayPaperType
	ENDIF

;
; OSErr GXGetTrayPaperType(gxTrayIndex whichTray, gxPaperType aPapertype)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetTrayPaperType
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$000B
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetTrayPaperType
	ENDIF

;
; OSErr GXGetTrayMapping(gxTrayMapping *trayMapping)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXGetTrayMapping
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$000C
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXGetTrayMapping
	ENDIF

;
; void GXCleanupStartJob(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCleanupStartJob
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$000D
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCleanupStartJob
	ENDIF

;
; void GXCleanupStartPage(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCleanupStartPage
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$000E
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCleanupStartPage
	ENDIF

;
; void GXCleanupOpenConnection(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCleanupOpenConnection
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$000F
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCleanupOpenConnection
	ENDIF

;
; void GXCleanupStartSendPage(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GXCleanupStartSendPage
			dc.w 	$203C
			dc.w 	$0001
			dc.w 	$0010
			dc.w 	$ABFE
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GXCleanupStartSendPage
	ENDIF

; ------------------------------------------------------------------------------
;
;					Constants and types for Universal Printing Messages
;
;-------------------------------------------------------------------------------- 
; Options for gxCreateSpoolFile message 
gxNoCreateOptions				EQU		$00000000			; Just create the file 
gxInhibitAlias					EQU		$00000001			; Do not create an alias in the PMD folder 
gxInhibitUniqueName				EQU		$00000002			; Do not append to the filename to make it unique 
gxResolveBitmapAlias			EQU		$00000004			; Resolve bitmap aliases and duplicate data in file 

; Options for gxCloseSpoolFile message 
gxNoCloseOptions				EQU		$00000000			; Just close the file 
gxDeleteOnClose					EQU		$00000001			; Delete the file rather than closing it 
gxUpdateJobData					EQU		$00000002			; Write current job information into file prior to closing 
gxMakeRemoteFile				EQU		$00000004			; Mark job as a remote file 

; Options for gxCreateImageFile message 
gxNoImageFile					EQU		$00000000			; Don't create image file 
gxMakeImageFile					EQU		$00000001			; Create an image file 
gxEachPlane						EQU		$00000002			; Only save up planes before rewinding 
gxEachPage						EQU		$00000004			; Save up entire pages before rewinding 
gxEntireFile					EQU		gxEachPlane + gxEachPage ; Save up the entire file before rewinding 

; Options for gxBufferData message 
gxNoBufferOptions				EQU		$00000000
gxMakeBufferHex					EQU		$00000001
gxDontSplitBuffer				EQU		$00000002

; Structure for gxDumpBuffer and gxFreeBuffer messages 
gxPrintingBuffer 		RECORD	0
size					 ds.l   1		; offset: $0 (0)		; Size of buffer in bytes 
userData				 ds.l   1		; offset: $4 (4)		; Client assigned id for the buffer 
data					 ds.b   1		; offset: $8 (8)		; Array of size bytes 
						 ORG 10
sizeof					 EQU *			; size:   $A (10)
						ENDR

; typedef struct gxPrintingBuffer  gxPrintingBuffer
; Structure for gxRenderPage message 
gxPageInfoRecord 		RECORD	0
docPageNum				 ds.l   1		; offset: $0 (0)		; Number of page being printed 
copyNum					 ds.l   1		; offset: $4 (4)		; Copy number being printed 
formatChanged			 ds.b   1		; offset: $8 (8)		; True if format changed from last page 
pageChanged				 ds.b   1		; offset: $9 (9)		; True if page contents changed from last page 
internalUse				 ds.l   1		; offset: $A (10)		; Private 
sizeof					 EQU *			; size:   $E (14)
						ENDR

; typedef struct gxPageInfoRecord  gxPageInfoRecord
; ------------------------------------------------------------------------------
;
;								Universal Printing Messages
;
;-------------------------------------------------------------------------------- 
; typedef GXJobIdleProcPtr 	GXJobIdleProc
;
; OSErr Send_GXJobIdle(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXJobIdle
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0002
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXJobIdle
	ENDIF

;
; OSErr Forward_GXJobIdle(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXJobIdle
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXJobIdle
	ENDIF

; typedef GXJobStatusProcPtr  GXJobStatusProc
;
; OSErr Send_GXJobStatus(gxStatusRecord *pStatus)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXJobStatus
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0003
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXJobStatus
	ENDIF

;
; OSErr Forward_GXJobStatus(gxStatusRecord *pStatus)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXJobStatus
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXJobStatus
	ENDIF

; typedef GXPrintingEventProcPtr  GXPrintingEventProc
;
; OSErr Send_GXPrintingEvent(EventRecord *evtRecord, Boolean filterEvent)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXPrintingEvent
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0004
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXPrintingEvent
	ENDIF

;
; OSErr Forward_GXPrintingEvent(EventRecord *evtRecord, Boolean filterEvent)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXPrintingEvent
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXPrintingEvent
	ENDIF

; typedef GXJobDefaultFormatDialogProcPtr  GXJobDefaultFormatDialogProc
;
; OSErr Send_GXJobDefaultFormatDialog(gxDialogResult *dlgResult)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXJobDefaultFormatDialog
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0005
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXJobDefaultFormatDialog
	ENDIF

;
; OSErr Forward_GXJobDefaultFormatDialog(gxDialogResult *dlgResult)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXJobDefaultFormatDialog
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXJobDefaultFormatDialog
	ENDIF

; typedef GXFormatDialogProcPtr  GXFormatDialogProc
;
; OSErr Send_GXFormatDialog(gxFormat theFormat, StringPtr title, gxDialogResult *dlgResult)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXFormatDialog
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0006
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXFormatDialog
	ENDIF

;
; OSErr Forward_GXFormatDialog(gxFormat theFormat, StringPtr title, gxDialogResult *dlgResult)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXFormatDialog
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXFormatDialog
	ENDIF

; typedef GXJobPrintDialogProcPtr  GXJobPrintDialogProc
;
; OSErr Send_GXJobPrintDialog(gxDialogResult *dlgResult)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXJobPrintDialog
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0007
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXJobPrintDialog
	ENDIF

;
; OSErr Forward_GXJobPrintDialog(gxDialogResult *dlgResult)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXJobPrintDialog
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXJobPrintDialog
	ENDIF

; typedef GXFilterPanelEventProcPtr  GXFilterPanelEventProc
;
; OSErr Send_GXFilterPanelEvent(gxPanelInfoRecord *pHitInfo, Boolean *returnImmed)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXFilterPanelEvent
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0008
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXFilterPanelEvent
	ENDIF

; typedef GXHandlePanelEventProcPtr  GXHandlePanelEventProc
;
; OSErr Send_GXHandlePanelEvent(gxPanelInfoRecord *pHitInfo, gxPanelResult *panelResponse)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXHandlePanelEvent
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0009
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXHandlePanelEvent
	ENDIF

; typedef GXParsePageRangeProcPtr  GXParsePageRangeProc
;
; OSErr Send_GXParsePageRange(StringPtr fromString, StringPtr toString, gxParsePageRangeResult *result)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXParsePageRange
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$000A
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXParsePageRange
	ENDIF

;
; OSErr Forward_GXParsePageRange(StringPtr fromString, StringPtr toString, gxParsePageRangeResult *result)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXParsePageRange
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXParsePageRange
	ENDIF

; typedef GXDefaultJobProcPtr  GXDefaultJobProc
;
; OSErr Send_GXDefaultJob(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXDefaultJob
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$000B
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXDefaultJob
	ENDIF

;
; OSErr Forward_GXDefaultJob(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXDefaultJob
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXDefaultJob
	ENDIF

; typedef GXDefaultFormatProcPtr  GXDefaultFormatProc
;
; OSErr Send_GXDefaultFormat(gxFormat theFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXDefaultFormat
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$000C
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXDefaultFormat
	ENDIF

;
; OSErr Forward_GXDefaultFormat(gxFormat theFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXDefaultFormat
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXDefaultFormat
	ENDIF

; typedef GXDefaultPaperTypeProcPtr  GXDefaultPaperTypeProc
;
; OSErr Send_GXDefaultPaperType(gxPaperType thePaperType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXDefaultPaperType
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$000D
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXDefaultPaperType
	ENDIF

;
; OSErr Forward_GXDefaultPaperType(gxPaperType thePaperType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXDefaultPaperType
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXDefaultPaperType
	ENDIF

; typedef GXDefaultPrinterProcPtr  GXDefaultPrinterProc
;
; OSErr Send_GXDefaultPrinter(gxPrinter thePrinter)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXDefaultPrinter
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$000E
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXDefaultPrinter
	ENDIF

;
; OSErr Forward_GXDefaultPrinter(gxPrinter thePrinter)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXDefaultPrinter
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXDefaultPrinter
	ENDIF

; typedef GXCreateSpoolFileProcPtr  GXCreateSpoolFileProc
;
; OSErr Send_GXCreateSpoolFile(FSSpecPtr pFileSpec, long createOptions, gxSpoolFile *theSpoolFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXCreateSpoolFile
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$000F
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXCreateSpoolFile
	ENDIF

;
; OSErr Forward_GXCreateSpoolFile(FSSpecPtr pFileSpec, long createOptions, gxSpoolFile *theSpoolFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXCreateSpoolFile
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXCreateSpoolFile
	ENDIF

; typedef GXSpoolPageProcPtr  GXSpoolPageProc
;
; OSErr Send_GXSpoolPage(gxSpoolFile theSpoolFile, gxFormat theFormat, gxShape thePage)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXSpoolPage
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0010
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXSpoolPage
	ENDIF

;
; OSErr Forward_GXSpoolPage(gxSpoolFile theSpoolFile, gxFormat theFormat, gxShape thePage)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXSpoolPage
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXSpoolPage
	ENDIF

; typedef GXSpoolDataProcPtr  GXSpoolDataProc
;
; OSErr Send_GXSpoolData(gxSpoolFile theSpoolFile, Ptr data, long *length)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXSpoolData
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0011
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXSpoolData
	ENDIF

;
; OSErr Forward_GXSpoolData(gxSpoolFile theSpoolFile, Ptr data, long *length)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXSpoolData
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXSpoolData
	ENDIF

; typedef GXSpoolResourceProcPtr  GXSpoolResourceProc
;
; OSErr Send_GXSpoolResource(gxSpoolFile theSpoolFile, Handle theResource, ResType theType, long id)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXSpoolResource
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0012
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXSpoolResource
	ENDIF

;
; OSErr Forward_GXSpoolResource(gxSpoolFile theSpoolFile, Handle theResource, ResType theType, long id)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXSpoolResource
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXSpoolResource
	ENDIF

; typedef GXCompleteSpoolFileProcPtr  GXCompleteSpoolFileProc
;
; OSErr Send_GXCompleteSpoolFile(gxSpoolFile theSpoolFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXCompleteSpoolFile
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0013
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXCompleteSpoolFile
	ENDIF

;
; OSErr Forward_GXCompleteSpoolFile(gxSpoolFile theSpoolFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXCompleteSpoolFile
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXCompleteSpoolFile
	ENDIF

; typedef GXCountPagesProcPtr  GXCountPagesProc
;
; OSErr Send_GXCountPages(gxSpoolFile theSpoolFile, long *numPages)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXCountPages
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0014
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXCountPages
	ENDIF

;
; OSErr Forward_GXCountPages(gxSpoolFile theSpoolFile, long *numPages)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXCountPages
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXCountPages
	ENDIF

; typedef GXDespoolPageProcPtr  GXDespoolPageProc
;
; OSErr Send_GXDespoolPage(gxSpoolFile theSpoolFile, long numPages, gxFormat theFormat, gxShape *thePage, Boolean *formatChanged)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXDespoolPage
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0015
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXDespoolPage
	ENDIF

;
; OSErr Forward_GXDespoolPage(gxSpoolFile theSpoolFile, long numPages, gxFormat theFormat, gxShape *thePage, Boolean *formatChanged)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXDespoolPage
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXDespoolPage
	ENDIF

; typedef GXDespoolDataProcPtr  GXDespoolDataProc
;
; OSErr Send_GXDespoolData(gxSpoolFile theSpoolFile, Ptr data, long *length)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXDespoolData
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0016
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXDespoolData
	ENDIF

;
; OSErr Forward_GXDespoolData(gxSpoolFile theSpoolFile, Ptr data, long *length)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXDespoolData
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXDespoolData
	ENDIF

; typedef GXDespoolResourceProcPtr  GXDespoolResourceProc
;
; OSErr Send_GXDespoolResource(gxSpoolFile theSpoolFile, ResType theType, long id, Handle *theResource)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXDespoolResource
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0017
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXDespoolResource
	ENDIF

;
; OSErr Forward_GXDespoolResource(gxSpoolFile theSpoolFile, ResType theType, long id, Handle *theResource)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXDespoolResource
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXDespoolResource
	ENDIF

; typedef GXCloseSpoolFileProcPtr  GXCloseSpoolFileProc
;
; OSErr Send_GXCloseSpoolFile(gxSpoolFile theSpoolFile, long closeOptions)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXCloseSpoolFile
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0018
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXCloseSpoolFile
	ENDIF

;
; OSErr Forward_GXCloseSpoolFile(gxSpoolFile theSpoolFile, long closeOptions)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXCloseSpoolFile
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXCloseSpoolFile
	ENDIF

; typedef GXStartJobProcPtr  GXStartJobProc
;
; OSErr Send_GXStartJob(StringPtr docName, long pageCount)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXStartJob
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0019
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXStartJob
	ENDIF

;
; OSErr Forward_GXStartJob(StringPtr docName, long pageCount)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXStartJob
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXStartJob
	ENDIF

; typedef GXFinishJobProcPtr  GXFinishJobProc
;
; OSErr Send_GXFinishJob(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXFinishJob
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$001A
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXFinishJob
	ENDIF

;
; OSErr Forward_GXFinishJob(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXFinishJob
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXFinishJob
	ENDIF

; typedef GXStartPageProcPtr  GXStartPageProc
;
; OSErr Send_GXStartPage(gxFormat theFormat, long numViewPorts, gxViewPort *viewPortList)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXStartPage
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$001B
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXStartPage
	ENDIF

;
; OSErr Forward_GXStartPage(gxFormat theFormat, long numViewPorts, gxViewPort *viewPortList)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXStartPage
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXStartPage
	ENDIF

; typedef GXFinishPageProcPtr  GXFinishPageProc
;
; OSErr Send_GXFinishPage(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXFinishPage
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$001C
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXFinishPage
	ENDIF

;
; OSErr Forward_GXFinishPage(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXFinishPage
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXFinishPage
	ENDIF

; typedef GXPrintPageProcPtr  GXPrintPageProc
;
; OSErr Send_GXPrintPage(gxFormat theFormat, gxShape thePage)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXPrintPage
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$001D
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXPrintPage
	ENDIF

;
; OSErr Forward_GXPrintPage(gxFormat theFormat, gxShape thePage)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXPrintPage
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXPrintPage
	ENDIF

; typedef GXSetupImageDataProcPtr  GXSetupImageDataProc
;
; OSErr Send_GXSetupImageData(void *imageData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXSetupImageData
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$001E
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXSetupImageData
	ENDIF

;
; OSErr Forward_GXSetupImageData(void *imageData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXSetupImageData
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXSetupImageData
	ENDIF

; typedef GXImageJobProcPtr  GXImageJobProc
;
; OSErr Send_GXImageJob(gxSpoolFile theSpoolFile, long *closeOptions)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXImageJob
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$001F
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXImageJob
	ENDIF

;
; OSErr Forward_GXImageJob(gxSpoolFile theSpoolFile, long *closeOptions)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXImageJob
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXImageJob
	ENDIF

; typedef GXImageDocumentProcPtr  GXImageDocumentProc
;
; OSErr Send_GXImageDocument(gxSpoolFile theSpoolFile, void *imageData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXImageDocument
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0020
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXImageDocument
	ENDIF

;
; OSErr Forward_GXImageDocument(gxSpoolFile theSpoolFile, void *imageData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXImageDocument
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXImageDocument
	ENDIF

; typedef GXImagePageProcPtr  GXImagePageProc
;
; OSErr Send_GXImagePage(gxSpoolFile theSpoolFile, long pageNumber, gxFormat theFormat, void *imageData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXImagePage
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0021
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXImagePage
	ENDIF

;
; OSErr Forward_GXImagePage(gxSpoolFile theSpoolFile, long pageNumber, gxFormat theFormat, void *imageData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXImagePage
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXImagePage
	ENDIF

; typedef GXRenderPageProcPtr  GXRenderPageProc
;
; OSErr Send_GXRenderPage(gxFormat theFormat, gxShape thePage, gxPageInfoRecord *pageInfo, void *imageData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXRenderPage
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0022
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXRenderPage
	ENDIF

;
; OSErr Forward_GXRenderPage(gxFormat theFormat, gxShape thePage, gxPageInfoRecord *pageInfo, void *imageData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXRenderPage
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXRenderPage
	ENDIF

; typedef GXCreateImageFileProcPtr  GXCreateImageFileProc
;
; OSErr Send_GXCreateImageFile(FSSpecPtr pFileSpec, long imageFileOptions, long *theImageFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXCreateImageFile
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0023
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXCreateImageFile
	ENDIF

;
; OSErr Forward_GXCreateImageFile(FSSpecPtr pFileSpec, long imageFileOptions, long *theImageFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXCreateImageFile
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXCreateImageFile
	ENDIF

; typedef GXOpenConnectionProcPtr  GXOpenConnectionProc
;
; OSErr Send_GXOpenConnection(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXOpenConnection
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0024
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXOpenConnection
	ENDIF

;
; OSErr Forward_GXOpenConnection(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXOpenConnection
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXOpenConnection
	ENDIF

; typedef GXCloseConnectionProcPtr  GXCloseConnectionProc
;
; OSErr Send_GXCloseConnection(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXCloseConnection
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0025
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXCloseConnection
	ENDIF

;
; OSErr Forward_GXCloseConnection(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXCloseConnection
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXCloseConnection
	ENDIF

; typedef GXStartSendPageProcPtr  GXStartSendPageProc
;
; OSErr Send_GXStartSendPage(gxFormat theFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXStartSendPage
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0026
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXStartSendPage
	ENDIF

;
; OSErr Forward_GXStartSendPage(gxFormat theFormat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXStartSendPage
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXStartSendPage
	ENDIF

; typedef GXFinishSendPageProcPtr  GXFinishSendPageProc
;
; OSErr Send_GXFinishSendPage(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXFinishSendPage
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0027
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXFinishSendPage
	ENDIF

;
; OSErr Forward_GXFinishSendPage(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXFinishSendPage
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXFinishSendPage
	ENDIF

; typedef GXWriteDataProcPtr  GXWriteDataProc
;
; OSErr Send_GXWriteData(Ptr data, long length)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXWriteData
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0028
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXWriteData
	ENDIF

;
; OSErr Forward_GXWriteData(Ptr data, long length)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXWriteData
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXWriteData
	ENDIF

; typedef GXBufferDataProcPtr  GXBufferDataProc
;
; OSErr Send_GXBufferData(Ptr data, long length, long bufferOptions)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXBufferData
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0029
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXBufferData
	ENDIF

;
; OSErr Forward_GXBufferData(Ptr data, long length, long bufferOptions)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXBufferData
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXBufferData
	ENDIF

; typedef GXDumpBufferProcPtr  GXDumpBufferProc
;
; OSErr Send_GXDumpBuffer(gxPrintingBuffer *theBuffer)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXDumpBuffer
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$002A
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXDumpBuffer
	ENDIF

;
; OSErr Forward_GXDumpBuffer(gxPrintingBuffer *theBuffer)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXDumpBuffer
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXDumpBuffer
	ENDIF

; typedef GXFreeBufferProcPtr  GXFreeBufferProc
;
; OSErr Send_GXFreeBuffer(gxPrintingBuffer *theBuffer)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXFreeBuffer
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$002B
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXFreeBuffer
	ENDIF

;
; OSErr Forward_GXFreeBuffer(gxPrintingBuffer *theBuffer)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXFreeBuffer
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXFreeBuffer
	ENDIF

; typedef GXCheckStatusProcPtr  GXCheckStatusProc
;
; OSErr Send_GXCheckStatus(Ptr data, long length, long statusType, gxOwnerSignature owner)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXCheckStatus
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$002C
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXCheckStatus
	ENDIF

;
; OSErr Forward_GXCheckStatus(Ptr data, long length, long statusType, gxOwnerSignature owner)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXCheckStatus
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXCheckStatus
	ENDIF

; typedef GXGetDeviceStatusProcPtr  GXGetDeviceStatusProc
;
; OSErr Send_GXGetDeviceStatus(Ptr cmdData, long cmdSize, Ptr responseData, long *responseSize, Str255 termination)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXGetDeviceStatus
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$002D
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXGetDeviceStatus
	ENDIF

;
; OSErr Forward_GXGetDeviceStatus(Ptr cmdData, long cmdSize, Ptr responseData, long *responseSize, Str255 termination)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXGetDeviceStatus
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXGetDeviceStatus
	ENDIF

; typedef GXFetchTaggedDataProcPtr  GXFetchTaggedDataProc
;
; OSErr Send_GXFetchTaggedData(ResType theType, long id, Handle *dataHdl, gxOwnerSignature owner)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXFetchTaggedData
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$002E
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXFetchTaggedData
	ENDIF

;
; OSErr Forward_GXFetchTaggedData(ResType theType, long id, Handle *dataHdl, gxOwnerSignature owner)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXFetchTaggedData
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXFetchTaggedData
	ENDIF

; typedef GXGetDTPMenuListProcPtr  GXGetDTPMenuListProc
;
; OSErr Send_GXGetDTPMenuList(MenuHandle menuHdl)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXGetDTPMenuList
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$002F
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXGetDTPMenuList
	ENDIF

;
; OSErr Forward_GXGetDTPMenuList(MenuHandle menuHdl)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXGetDTPMenuList
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXGetDTPMenuList
	ENDIF

; typedef GXDTPMenuSelectProcPtr  GXDTPMenuSelectProc
;
; OSErr Send_GXDTPMenuSelect(long id)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXDTPMenuSelect
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0030
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXDTPMenuSelect
	ENDIF

;
; OSErr Forward_GXDTPMenuSelect(long id)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXDTPMenuSelect
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXDTPMenuSelect
	ENDIF

; typedef GXHandleAlertFilterProcPtr  GXHandleAlertFilterProc
;
; OSErr Send_GXHandleAlertFilter(gxJob theJob, gxStatusRecord *pStatusRec, DialogPtr pDialog, EventRecord *theEvent, short *itemHit, Boolean *returnImmed)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXHandleAlertFilter
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0031
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXHandleAlertFilter
	ENDIF

;
; OSErr Forward_GXHandleAlertFilter(gxJob theJob, gxStatusRecord *pStatusRec, DialogPtr pDialog, EventRecord *theEvent, short *itemHit, Boolean *returnImmed)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXHandleAlertFilter
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXHandleAlertFilter
	ENDIF

; typedef GXJobFormatModeQueryProcPtr  GXJobFormatModeQueryProc
;
; OSErr Send_GXJobFormatModeQuery(gxQueryType theQuery, void *srcData, void *dstData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXJobFormatModeQuery
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0032
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXJobFormatModeQuery
	ENDIF

;
; OSErr Forward_GXJobFormatModeQuery(gxQueryType theQuery, void *srcData, void *dstData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXJobFormatModeQuery
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXJobFormatModeQuery
	ENDIF

; typedef GXWriteStatusToDTPWindowProcPtr  GXWriteStatusToDTPWindowProc
;
; OSErr Send_GXWriteStatusToDTPWindow(gxStatusRecord *pStatusRec, gxDisplayRecord *pDisplay)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXWriteStatusToDTPWindow
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0033
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXWriteStatusToDTPWindow
	ENDIF

;
; OSErr Forward_GXWriteStatusToDTPWindow(gxStatusRecord *pStatusRec, gxDisplayRecord *pDisplay)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXWriteStatusToDTPWindow
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXWriteStatusToDTPWindow
	ENDIF

; typedef GXInitializeStatusAlertProcPtr  GXInitializeStatusAlertProc
;
; OSErr Send_GXInitializeStatusAlert(gxStatusRecord *pStatusRec, DialogPtr *pDialog)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXInitializeStatusAlert
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0034
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXInitializeStatusAlert
	ENDIF

;
; OSErr Forward_GXInitializeStatusAlert(gxStatusRecord *pStatusRec, DialogPtr *pDialog)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXInitializeStatusAlert
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXInitializeStatusAlert
	ENDIF

; typedef GXHandleAlertStatusProcPtr  GXHandleAlertStatusProc
;
; OSErr Send_GXHandleAlertStatus(gxStatusRecord *pStatusRec)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXHandleAlertStatus
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0035
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXHandleAlertStatus
	ENDIF

;
; OSErr Forward_GXHandleAlertStatus(gxStatusRecord *pStatusRec)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXHandleAlertStatus
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXHandleAlertStatus
	ENDIF

; typedef GXHandleAlertEventProcPtr  GXHandleAlertEventProc
;
; OSErr Send_GXHandleAlertEvent(gxStatusRecord *pStatusRec, DialogPtr pDialog, EventRecord *theEvent, short *response)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXHandleAlertEvent
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0036
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXHandleAlertEvent
	ENDIF

;
; OSErr Forward_GXHandleAlertEvent(gxStatusRecord *pStatusRec, DialogPtr pDialog, EventRecord *theEvent, short *response)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXHandleAlertEvent
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXHandleAlertEvent
	ENDIF

; typedef GXCleanupStartJobProcPtr  GXCleanupStartJobProc
;
; void Send_GXCleanupStartJob(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXCleanupStartJob
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0037
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXCleanupStartJob
	ENDIF

;
; void Forward_GXCleanupStartJob(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXCleanupStartJob
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXCleanupStartJob
	ENDIF

; typedef GXCleanupStartPageProcPtr  GXCleanupStartPageProc
;
; void Send_GXCleanupStartPage(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXCleanupStartPage
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0038
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXCleanupStartPage
	ENDIF

;
; void Forward_GXCleanupStartPage(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXCleanupStartPage
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXCleanupStartPage
	ENDIF

; typedef GXCleanupOpenConnectionProcPtr  GXCleanupOpenConnectionProc
;
; void Send_GXCleanupOpenConnection(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXCleanupOpenConnection
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0039
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXCleanupOpenConnection
	ENDIF

;
; void Forward_GXCleanupOpenConnection(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXCleanupOpenConnection
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXCleanupOpenConnection
	ENDIF

; typedef GXCleanupStartSendPageProcPtr  GXCleanupStartSendPageProc
;
; void Send_GXCleanupStartSendPage(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXCleanupStartSendPage
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$003A
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXCleanupStartSendPage
	ENDIF

;
; void Forward_GXCleanupStartSendPage(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXCleanupStartSendPage
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXCleanupStartSendPage
	ENDIF

; typedef GXDefaultDesktopPrinterProcPtr  GXDefaultDesktopPrinterProc
;
; OSErr Send_GXDefaultDesktopPrinter(Str31 dtpName)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXDefaultDesktopPrinter
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$003B
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXDefaultDesktopPrinter
	ENDIF

;
; OSErr Forward_GXDefaultDesktopPrinter(Str31 dtpName)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXDefaultDesktopPrinter
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXDefaultDesktopPrinter
	ENDIF

; typedef GXCaptureOutputDeviceProcPtr  GXCaptureOutputDeviceProc
;
; OSErr Send_GXCaptureOutputDevice(Boolean capture)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXCaptureOutputDevice
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$003C
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXCaptureOutputDevice
	ENDIF

;
; OSErr Forward_GXCaptureOutputDevice(Boolean capture)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXCaptureOutputDevice
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXCaptureOutputDevice
	ENDIF

; typedef GXOpenConnectionRetryProcPtr  GXOpenConnectionRetryProc
;
; OSErr Send_GXOpenConnectionRetry(ResType theType, void *aVoid, Boolean *retryopenPtr, OSErr anErr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXOpenConnectionRetry
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$003D
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXOpenConnectionRetry
	ENDIF

;
; OSErr Forward_GXOpenConnectionRetry(ResType theType, void *aVoid, Boolean *retryopenPtr, OSErr anErr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXOpenConnectionRetry
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXOpenConnectionRetry
	ENDIF

; typedef GXExamineSpoolFileProcPtr  GXExamineSpoolFileProc
;
; OSErr Send_GXExamineSpoolFile(gxSpoolFile theSpoolFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXExamineSpoolFile
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$003E
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXExamineSpoolFile
	ENDIF

;
; OSErr Forward_GXExamineSpoolFile(gxSpoolFile theSpoolFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXExamineSpoolFile
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXExamineSpoolFile
	ENDIF

; typedef GXFinishSendPlaneProcPtr  GXFinishSendPlaneProc
;
; OSErr Send_GXFinishSendPlane(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXFinishSendPlane
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$003F
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXFinishSendPlane
	ENDIF

;
; OSErr Forward_GXFinishSendPlane(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXFinishSendPlane
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXFinishSendPlane
	ENDIF

; typedef GXDoesPaperFitProcPtr  GXDoesPaperFitProc
;
; OSErr Send_GXDoesPaperFit(gxTrayIndex whichTray, gxPaperType paper, Boolean *fits)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXDoesPaperFit
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0040
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXDoesPaperFit
	ENDIF

;
; OSErr Forward_GXDoesPaperFit(gxTrayIndex whichTray, gxPaperType paper, Boolean *fits)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXDoesPaperFit
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXDoesPaperFit
	ENDIF

; typedef GXChooserMessageProcPtr  GXChooserMessageProc
;
; OSErr Send_GXChooserMessage(long message, long caller, StringPtr objName, StringPtr zoneName, ListHandle theList, long p2)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXChooserMessage
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0041
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXChooserMessage
	ENDIF

;
; OSErr Forward_GXChooserMessage(long message, long caller, StringPtr objName, StringPtr zoneName, ListHandle theList, long p2)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXChooserMessage
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXChooserMessage
	ENDIF

; typedef GXFindPrinterProfileProcPtr  GXFindPrinterProfileProc
;
; OSErr Send_GXFindPrinterProfile(gxPrinter thePrinter, void *searchData, long index, gxColorProfile *returnedProfile, long *numProfiles)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXFindPrinterProfile
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0042
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXFindPrinterProfile
	ENDIF

;
; OSErr Forward_GXFindPrinterProfile(gxPrinter thePrinter, void *searchData, long index, gxColorProfile *returnedProfile, long *numProfiles)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXFindPrinterProfile
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXFindPrinterProfile
	ENDIF

; typedef GXFindFormatProfileProcPtr  GXFindFormatProfileProc
;
; OSErr Send_GXFindFormatProfile(gxFormat theFormat, void *searchData, long index, gxColorProfile *returnedProfile, long *numProfiles)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXFindFormatProfile
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0043
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXFindFormatProfile
	ENDIF

;
; OSErr Forward_GXFindFormatProfile(gxFormat theFormat, void *searchData, long index, gxColorProfile *returnedProfile, long *numProfiles)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXFindFormatProfile
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXFindFormatProfile
	ENDIF

; typedef GXSetPrinterProfileProcPtr  GXSetPrinterProfileProc
;
; OSErr Send_GXSetPrinterProfile(gxPrinter thePrinter, gxColorProfile oldProfile, gxColorProfile newProfile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXSetPrinterProfile
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0044
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXSetPrinterProfile
	ENDIF

;
; OSErr Forward_GXSetPrinterProfile(gxPrinter thePrinter, gxColorProfile oldProfile, gxColorProfile newProfile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXSetPrinterProfile
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXSetPrinterProfile
	ENDIF

; typedef GXSetFormatProfileProcPtr  GXSetFormatProfileProc
;
; OSErr Send_GXSetFormatProfile(gxFormat theFormat, gxColorProfile oldProfile, gxColorProfile newProfile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXSetFormatProfile
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0045
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXSetFormatProfile
	ENDIF

;
; OSErr Forward_GXSetFormatProfile(gxFormat theFormat, gxColorProfile oldProfile, gxColorProfile newProfile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXSetFormatProfile
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXSetFormatProfile
	ENDIF

; typedef GXHandleAltDestinationProcPtr  GXHandleAltDestinationProc
;
; OSErr Send_GXHandleAltDestination(Boolean *userCancels)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXHandleAltDestination
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0046
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXHandleAltDestination
	ENDIF

;
; OSErr Forward_GXHandleAltDestination(Boolean *userCancels)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXHandleAltDestination
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXHandleAltDestination
	ENDIF

; typedef GXSetupPageImageDataProcPtr  GXSetupPageImageDataProc
;
; OSErr Send_GXSetupPageImageData(gxFormat theFormat, gxShape thePage, void *imageData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Send_GXSetupPageImageData
			moveq	#50,d0
			dc.w 	$223C
			dc.w 	$0000
			dc.w 	$0047
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Send_GXSetupPageImageData
	ENDIF

;
; OSErr Forward_GXSetupPageImageData(gxFormat theFormat, gxShape thePage, void *imageData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_Forward_GXSetupPageImageData
			moveq	#54,d0
			dc.w 	$ABFB
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	Forward_GXSetupPageImageData
	ENDIF

;******************************************************************
;					Start of old "GXPrintingErrors.h/a/p" interface file.
;			*******************************************************************

gxPrintingResultBase			EQU		-510				;First QuickDraw GX printing error code.

;RESULT CODES FOR QUICKDRAW GX PRINTING OPERATIONS
gxAioTimeout					EQU		(gxPrintingResultBase) ;-510 : Timeout condition occurred during operation
gxAioBadRqstState				EQU		(gxPrintingResultBase - 1) ;-511 : Async I/O request in invalid state for operation
gxAioBadConn					EQU		(gxPrintingResultBase - 2) ;-512 : Invalid Async I/O connection refnum
gxAioInvalidXfer				EQU		(gxPrintingResultBase - 3) ;-513 : Read data transfer structure contained bad values
gxAioNoRqstBlks					EQU		(gxPrintingResultBase - 4) ;-514 : No available request blocks to process request
gxAioNoDataXfer					EQU		(gxPrintingResultBase - 5) ;-515 : Data transfer structure pointer not specified
gxAioTooManyAutos				EQU		(gxPrintingResultBase - 6) ;-516 : Auto status request already active
gxAioNoAutoStat					EQU		(gxPrintingResultBase - 7) ;-517 : Connection not configured for auto status
gxAioBadRqstID					EQU		(gxPrintingResultBase - 8) ;-518 : Invalid I/O request identifier
gxAioCantKill					EQU		(gxPrintingResultBase - 9) ;-519 : Comm. protocol doesn't support I/O term
gxAioAlreadyExists				EQU		(gxPrintingResultBase - 10) ;-520 : Protocol spec. data already specified
gxAioCantFind					EQU		(gxPrintingResultBase - 11) ;-521 : Protocol spec. data does not exist
gxAioDeviceDisconn				EQU		(gxPrintingResultBase - 12) ;-522 : Machine disconnected from printer
gxAioNotImplemented				EQU		(gxPrintingResultBase - 13) ;-523 : Function not implemented
gxAioOpenPending				EQU		(gxPrintingResultBase - 14) ;-524 : Opening a connection for protocol, but another open pending
gxAioNoProtocolData				EQU		(gxPrintingResultBase - 15) ;-525 : No protocol specific data specified in request
gxAioRqstKilled					EQU		(gxPrintingResultBase - 16) ;-526 : I/O request was terminated
gxBadBaudRate					EQU		(gxPrintingResultBase - 17) ;-527 : Invalid baud rate specified
gxBadParity						EQU		(gxPrintingResultBase - 18) ;-528 : Invalid parity specified
gxBadStopBits					EQU		(gxPrintingResultBase - 19) ;-529 : Invalid stop bits specified
gxBadDataBits					EQU		(gxPrintingResultBase - 20) ;-530 : Invalid data bits specified
gxBadPrinterName				EQU		(gxPrintingResultBase - 21) ;-531 : Bad printer name specified
gxAioBadMsgType					EQU		(gxPrintingResultBase - 22) ;-532 : Bad masType field in transfer info structure
gxAioCantFindDevice				EQU		(gxPrintingResultBase - 23) ;-533 : Cannot locate target device
gxAioOutOfSeq					EQU		(gxPrintingResultBase - 24) ;-534 : Non-atomic SCSI requests submitted out of sequence
gxPrIOAbortErr					EQU		(gxPrintingResultBase - 25) ;-535 : I/O operation aborted
gxPrUserAbortErr				EQU		(gxPrintingResultBase - 26) ;-536 : User aborted
gxCantAddPanelsNowErr			EQU		(gxPrintingResultBase - 27) ;-537 : Can only add panels during driver switch or dialog setup
gxBadxdtlKeyErr					EQU		(gxPrintingResultBase - 28) ;-538 : Unknown key for xdtl - must be radiobutton, etc
gxXdtlItemOutOfRangeErr			EQU		(gxPrintingResultBase - 29) ;-539 : Referenced item does not belong to panel
gxNoActionButtonErr				EQU		(gxPrintingResultBase - 30) ;-540 : Action button is nil
gxTitlesTooLongErr				EQU		(gxPrintingResultBase - 31) ;-541 : Length of buttons exceeds alert maximum width
gxUnknownAlertVersionErr		EQU		(gxPrintingResultBase - 32) ;-542 : Bad version for printing alerts
gxGBBufferTooSmallErr			EQU		(gxPrintingResultBase - 33) ;-543 : Buffer too small.
gxInvalidPenTable				EQU		(gxPrintingResultBase - 34) ;-544 : Invalid vector driver pen table.
gxIncompletePrintFileErr		EQU		(gxPrintingResultBase - 35) ;-545 : Print file was not completely spooled
gxCrashedPrintFileErr			EQU		(gxPrintingResultBase - 36) ;-546 : Print file is corrupted
gxInvalidPrintFileVersion		EQU		(gxPrintingResultBase - 37) ;-547 : Print file is incompatible with current QuickDraw GX version
gxSegmentLoadFailedErr			EQU		(gxPrintingResultBase - 38) ;-548 : Segment loader error
gxExtensionNotFoundErr			EQU		(gxPrintingResultBase - 39) ;-549 : Requested printing extension could not be found
gxDriverVersionErr				EQU		(gxPrintingResultBase - 40) ;-550 : Driver too new for current version of QuickDraw GX
gxImagingSystemVersionErr		EQU		(gxPrintingResultBase - 41) ;-551 : Imaging system too new for current version of QuickDraw GX
gxFlattenVersionTooNew			EQU		(gxPrintingResultBase - 42) ;-552 : Flattened object format too new for current version of QDGX
gxPaperTypeNotFound				EQU		(gxPrintingResultBase - 43) ;-553 : Requested papertype could not be found
gxNoSuchPTGroup					EQU		(gxPrintingResultBase - 44) ;-554 : Requested papertype group could not be found
gxNotEnoughPrinterMemory		EQU		(gxPrintingResultBase - 45) ;-555 : Printer does not have enough memory for fonts in document
gxDuplicatePanelNameErr			EQU		(gxPrintingResultBase - 46) ;-556 : Attempt to add more than 10 panels with the same name
gxExtensionVersionErr			EQU		(gxPrintingResultBase - 47) ;-557 : Extension too new for current version of QuickDraw GX

	ENDIF ; __GXPRINTING__

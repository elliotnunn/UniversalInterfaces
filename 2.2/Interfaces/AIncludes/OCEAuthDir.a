;
;	File:		OCEAuthDir.a
;
;	Contains:	Apple Open Collaboration Environment Authentication Interfaces.
;
;	Version:	Technology:	AOCE Toolbox 1.02
;				Package:	Universal Interfaces 2.2 in “MPW” on ETO #20
;
;	Copyright:	© 1984-1995 by Apple Computer, Inc.
;				All rights reserved.
;
;	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter
;				stack.  Include the file and version information (from above)
;				in the problem description and send to:
;					Internet:	apple.bugs@applelink.apple.com
;					AppleLink:	APPLE.BUGS
;
;

	IF &TYPE('__OCEAUTHDIR__') = 'UNDEFINED' THEN
__OCEAUTHDIR__ SET 1


	IF &TYPE('__EVENTS__') = 'UNDEFINED' THEN
	include 'Events.a'
	ENDIF
;		include 'Types.a'											;
;			include 'ConditionalMacros.a'							;
;		include 'Quickdraw.a'										;
;			include 'MixedMode.a'									;
;			include 'QuickdrawText.a'								;
;		include 'OSUtils.a'										;
;			include 'Memory.a'										;

	IF &TYPE('__NOTIFICATION__') = 'UNDEFINED' THEN
	include 'Notification.a'
	ENDIF

	IF &TYPE('__APPLEEVENTS__') = 'UNDEFINED' THEN
	include 'AppleEvents.a'
	ENDIF
;		include 'Errors.a'											;
;		include 'EPPC.a'											;
;			include 'AppleTalk.a'									;
;			include 'Files.a'										;
;				include 'Finder.a'									;
;			include 'PPCToolbox.a'									;
;			include 'Processes.a'									;

	IF &TYPE('__APPLETALK__') = 'UNDEFINED' THEN
	include 'AppleTalk.a'
	ENDIF

	IF &TYPE('__FILES__') = 'UNDEFINED' THEN
	include 'Files.a'
	ENDIF

	IF &TYPE('__OSUTILS__') = 'UNDEFINED' THEN
	include 'OSUtils.a'
	ENDIF

	IF &TYPE('__TYPES__') = 'UNDEFINED' THEN
	include 'Types.a'
	ENDIF

	IF &TYPE('__OCE__') = 'UNDEFINED' THEN
	include 'OCE.a'
	ENDIF
;		include 'Aliases.a'										;
;		include 'Script.a'											;
;			include 'IntlResources.a'								;

kRC4KeySizeInBytes				EQU		8					; size of an RC4 key 
kRefNumUnknown					EQU		0

kEnumDistinguishedNameBit		EQU		0
kEnumAliasBit					EQU		1
kEnumPseudonymBit				EQU		2
kEnumDNodeBit					EQU		3
kEnumInvisibleBit				EQU		4

; Values of DirEnumChoices 
kEnumDistinguishedNameMask		EQU		1
kEnumAliasMask					EQU		2
kEnumPseudonymMask				EQU		4
kEnumDNodeMask					EQU		8
kEnumInvisibleMask				EQU		16
kEnumAllMask					EQU		31

; typedef unsigned long 	DirEnumChoices
; Values of DirSortOption 

kSortByName						EQU		0
kSortByType						EQU		1

; Values of DirSortDirection 
kSortForwards					EQU		0
kSortBackwards					EQU		1

; Values of DirMatchWith 
kMatchAll						EQU		0
kExactMatch						EQU		1
kBeginsWith						EQU		2
kEndingWith						EQU		3
kContaining						EQU		4

; typedef unsigned char 	DirMatchWith

kCurrentOCESortVersion			EQU		1

;  Access controls are implemented on three levels:
; *  	DNode, Record, and Attribute Type levels
; *  Some access control bits apply to the container itself, and some apply to its contents.
; *
; *  The Catalog Toolbox supports six functions.  These calls are:
; *  DSGetDNodeAccessControl : to get Access Controls at the DNode level
; *	DSGetRecordAccessControl  : to get Access Controls at the record level
; *  DSGetAttributeAccessControl : to get Access Privileges at the attribute type level
; * 
; *  The GetXXXAccessControl calls will return access control masks for various categories
; *  of users.  Please refer to the access control document for a description of the
; *  categories of users.  In general these are:
; *  	ThisRecordOwner 		- means the identity of the record itself
; *  	Friends 				 - means any one of the assigned friends for the record
; *  	AuthenticatedInDNode     - means any valid user that is an authenticated entity
; *  		in the DNode in which this record is located
; *  	AuthenticatedInDirectory - means any valid authenticated catalog user
; *  	Guest 					 - means an unauthenticated user.
; *  Bit masks for various permitted access controls are defined below.
; *
; *  GetXXXAccessControl calls will return access control masks for various categories of
; *  users for this record. In addition they also return the level of access controls
; *  that the user (who is making the GetXXXAccessControl call) has for the DNode,
; *  record, or attribute type.
; *
; *  For records, the access control granted will be minimum of the DNode access
; *  control and record access control masks.  For example, to add an attribute type to a
; *  record, a user must have access control kCreateAttributeTypes at the record and
; *  DNode levels.  Similarly, at the attribute type level, access controls will be the
; *  minimum of the DNode, record, and attribute type access controls.
; *
; *  
; 
; access privileges bit numbers 
kSeeBit							EQU		0
kAddBit							EQU		1
kDeleteBit						EQU		2
kChangeBit						EQU		3
kRenameBit						EQU		4
kChangePrivsBit					EQU		5
kSeeFoldersBit					EQU		6

; Values of AccessMask 
kSeeMask						EQU		1
kAddMask						EQU		2
kDeleteMask						EQU		4
kChangeMask						EQU		8
kRenameMask						EQU		16
kChangePrivsMask				EQU		32
kSeeFoldersMask					EQU		64

kAllPrivs						EQU		127
kNoPrivs						EQU		0

;
;
;kSupportsDNodeNumberBit:
;If this bit is set, a DNode can be referenced using DNodeNumbers. 
;RecordLocationInfo can be specified using DNodeNumber and PathName component can be nil. 
;If this bit is not set, a DNode can be referenced only by PathName to the DNode. In the 
;later case DNodeNumber component inside record location info must be set to zero.
;
;kSupportsRecordCreationIDBit:
;If this bit is set, a record can be referenced by specifying CreationID 
;in most catalog manager calls. If this bit is not set recordName and recordType are 
;required in the recordID specification for all catalog manager calls.
;
;kSupportsAttributeCreationIDBit:
;If this bit is set, an attribute value can be obtained by specifying it's 
;CreationID in Lookup call staring point and also can be used in operations 
;like DeleteAttributeValue and ChangeAttributeValue an Attribute can be 
;specified by AttributeType and CreationID.
;
;*************************************************************************
;Implicit assumption with creationID's and dNodeNumbers are, when supported
;they are persistent and will preserved across boots and life of the system.
;*************************************************************************
;
;Following three bits are for determining the sort order in enumeration.
;kSupportsMatchAllBit:
;If this bit is set, enumeration of all the records is supported
;
;kSupportsBeginsWithBit:
;If this bit is set, enumeration of records matching prefix (e.g. Begin with abc)
;is supported
;
;kSupportsExactMatchBit:
;If this bit is set, existence of a record matching exact matchNameString and recordType
;is supported.
;
;kSupportsEndsWithBit:
;If this bit is set, enumeration of records matching suffix (e.g. end with abc)
;is supported.
;
;kSupportsContainsBit:
;If this bit is set, enumeration of records containing a matchNameString (e.g. containing abc)
;is supported
;
;
;Implicit assumption in all these is, a record type can be specified either as one of the above or
;a type list(more then one) to match exact type.
;The Following four bits will indicate sort ordering in enumeration.
;
;kSupportsOrderedEnumerationBit:
;If this bit is set, Enumerated records or in some order possibly in name order.
;
;kCanSupportNameOrderBit:
;If this is set, catalog will support sortbyName option in Enumerate.
;
;kCanSupportTypeOrderBit:
;If this bit is set, catalog will support sortbyType option in enumearte.
;
;kSupportSortBackwardsBit:
;If this bit is set, catalog supports backward sorting.
;
;kSupportIndexRatioBit:
;If this bit is set, it indicates that enumeration will return approximate position
;of a record (percentile) among all records.
;
;kSupportsEnumerationContinueBit:
;If this bit is set, catalog supports enumeration continue.
;
;kSupportsLookupContinueBit:
;If this bit is set, catalog supports lookup continue.
;
;kSupportsEnumerateAttributeTypeContinueBit:
;If this bit is set, catalog supports EnumerateAttributeType continue.
;
;kSupportsEnumeratePseudonymContinueBit:
;If this bit is set, catalog supports EnumeratePseudonym continue.
;
;kSupportsAliasesBit:
;If this bit is set, catalog supports create/delte/enumerate 
;of Alias Records.
;
;kSupportPseudonymBit: 
;If this bit is set, catalog supports create/delte/enumerate of 
;pseudonyms for a record.
;
;kSupportsPartialPathNameBit:
;If this bit is set, catalog nodes can be specified using DNodeNumber of a 
;intermediate DNode and a partial name starting from that DNode to the intended 
;DNode.
;
;kSupportsAuthenticationBit:
;If this bit is set, catalog supports authentication manager calls.
;
;kSupportsProxiesBit:
;If this bit is set, catalog supports proxy related calls in authentication manager. 
;
;kSupportsFindRecordBit:
;If this bit is set, catalog supports find record call.
;
;Bits and corresponding masks are as defined below.
;
kSupportsDNodeNumberBit			EQU		0
kSupportsRecordCreationIDBit	EQU		1
kSupportsAttributeCreationIDBit	EQU		2
kSupportsMatchAllBit			EQU		3
kSupportsBeginsWithBit			EQU		4
kSupportsExactMatchBit			EQU		5
kSupportsEndsWithBit			EQU		6
kSupportsContainsBit			EQU		7
kSupportsOrderedEnumerationBit	EQU		8
kCanSupportNameOrderBit			EQU		9
kCanSupportTypeOrderBit			EQU		10
kSupportSortBackwardsBit		EQU		11
kSupportIndexRatioBit			EQU		12
kSupportsEnumerationContinueBit	EQU		13
kSupportsLookupContinueBit		EQU		14
kSupportsEnumerateAttributeTypeContinueBit EQU		15
kSupportsEnumeratePseudonymContinueBit EQU		16
kSupportsAliasesBit				EQU		17
kSupportsPseudonymsBit			EQU		18
kSupportsPartialPathNamesBit	EQU		19
kSupportsAuthenticationBit		EQU		20
kSupportsProxiesBit				EQU		21
kSupportsFindRecordBit			EQU		22

; values of DirGestalt 
kSupportsDNodeNumberMask		EQU		1
kSupportsRecordCreationIDMask	EQU		2
kSupportsAttributeCreationIDMask EQU		4
kSupportsMatchAllMask			EQU		8
kSupportsBeginsWithMask			EQU		16
kSupportsExactMatchMask			EQU		32
kSupportsEndsWithMask			EQU		64
kSupportsContainsMask			EQU		128
kSupportsOrderedEnumerationMask	EQU		256
kCanSupportNameOrderMask		EQU		512
kCanSupportTypeOrderMask		EQU		1024
kSupportSortBackwardsMask		EQU		2048
kSupportIndexRatioMask			EQU		4096
kSupportsEnumerationContinueMask EQU		8192
kSupportsLookupContinueMask		EQU		16384
kSupportsEnumerateAttributeTypeContinueMask EQU		32768
kSupportsEnumeratePseudonymContinueMask EQU		65536
kSupportsAliasesMask			EQU		131072
kSupportsPseudonymsMask			EQU		262144
kSupportsPartialPathNamesMask	EQU		524288
kSupportsAuthenticationMask		EQU		1048576
kSupportsProxiesMask			EQU		2097152
kSupportsFindRecordMask			EQU		4194304

; Values of AuthLocalIdentityOp 
kAuthLockLocalIdentityOp		EQU		1
kAuthUnlockLocalIdentityOp		EQU		2
kAuthLocalIdentityNameChangeOp	EQU		3

; Values of AuthLocalIdentityLockAction 
kAuthLockPending				EQU		1
kAuthLockWillBeDone				EQU		2

; Values of AuthNotifications 
kNotifyLockBit					EQU		0
kNotifyUnlockBit				EQU		1
kNotifyNameChangeBit			EQU		2

kNotifyLockMask					EQU		1
kNotifyUnlockMask				EQU		2
kNotifyNameChangeMask			EQU		4

kPersonalDirectoryFileCreator	EQU		'kl03'
kPersonalDirectoryFileType		EQU		'pabt'
kBusinessCardFileType			EQU		'bust'
kDirectoryFileType				EQU		'dirt'
kDNodeFileType					EQU		'dnod'
kDirsRootFileType				EQU		'drtt'
kRecordFileType					EQU		'rcrd'

; typedef unsigned short 	DirSortOption
; typedef unsigned short 	DirSortDirection
; typedef unsigned long 	AccessMask
; typedef unsigned long 	DirGestalt
; typedef unsigned long 	AuthLocalIdentityOp
; typedef unsigned long 	AuthLocalIdentityLockAction
; typedef unsigned long 	AuthNotifications
DNodeID 				RECORD	0
dNodeNumber				 ds.l   1		; offset: $0 (0)		; dNodenumber  
reserved1				 ds.l   1		; offset: $4 (4)
name					 ds.l   1		; offset: $8 (8)
reserved2				 ds.l   1		; offset: $C (12)
sizeof					 EQU *			; size:   $10 (16)
						ENDR

; typedef struct DNodeID 	DNodeID
DirEnumSpec 			RECORD	0
enumFlag				 ds.l   1		; offset: $0 (0)
indexRatio				 ds.w   1		; offset: $4 (4)		; Approx Record Position between 1 and 100 If supported, 0 If not supported 
recordIdentifier		 ds.l   4		; offset: $6 (6)
						 ORG 6
dNodeIdentifier			 ds     DNodeID	; offset: $6 (6)
						 ORG 22
sizeof					 EQU *			; size:   $16 (22)
						ENDR

; typedef struct DirEnumSpec  DirEnumSpec
DirMetaInfo 			RECORD	0
info					 ds.l   4		; offset: $0 (0)
sizeof					 EQU *			; size:   $10 (16)
						ENDR

; typedef struct DirMetaInfo  DirMetaInfo
SLRV 					RECORD	0
script					 ds.w   1		; offset: $0 (0)		;   Script code in which entries are sorted 
language				 ds.w   1		; offset: $2 (2)		;   Language code in which entries are sorted 
regionCode				 ds.w   1		; offset: $4 (4)		;   Region code in which entries are sorted 
version					 ds.w   1		; offset: $6 (6)		;  version of oce sorting software 
sizeof					 EQU *			; size:   $8 (8)
						ENDR

; typedef struct SLRV 		SLRV
; Catalog types and operations 
; unique identifier for an identity 
; typedef unsigned long 	AuthIdentity
; Umbrella LocalIdentity 
; typedef AuthIdentity 		LocalIdentity
; A DES key is 8 bytes of data 
DESKey 					RECORD	0
desA					 ds.l   1		; offset: $0 (0)
desB					 ds.l   1		; offset: $4 (4)
sizeof					 EQU *			; size:   $8 (8)
						ENDR

; typedef struct DESKey 	DESKey
; typedef Byte 				RC4Key[kRC4KeySizeInBytes]
; typedef unsigned long 	AuthKeyType
; key type followed by its data 
AuthKey 				RECORD	0
keyType					 ds.l   1		; offset: $0 (0)
des						 ds     DESKey	; offset: $4 (4)
						 ORG 4
rc4						 ds.l   2		; offset: $4 (4)
						 ORG 12
sizeof					 EQU *			; size:   $C (12)
						ENDR

; typedef struct AuthKey 	AuthKey
; typedef AuthKey 			*AuthKeyPtr
; typedef union AuthParamBlock  AuthParamBlock
; typedef AuthParamBlock 	*AuthParamBlockPtr
;
;This header is common to all the parameter blocks.  Clients should not directly
;touch any of these fields except ioCompletion.  ioCompletion is the
;completion routine pointer for async calls; it is ignored for sync calls.
;ioResult is the result code from the call.
;
;****************************************************************************
;
;
;		Authentication Manager operations 
;
;****************************************************************************
;
;kAuthResolveCreationID:
;userRecord will contain the user information whose creationID has to be
;returned. A client must make this call when he does not know the creaitionID.
;The creationID must be set to nil before making the call. The server will attempt
;to match the recordid's in the data base which match the user name and
;type in the record.  Depending on number of matchings, following
;results will be returned.
;Exactly One Match : CreationID in RecordID and also in buffer (if buffer is given)
;totalMatches = actualMatches = 1.
;> 1 Match:
;	Buffer is Large Enough:
;	totalMatches = actualMatches
;	Buffer will contain all the CIDs, kOCEAmbiguousMatches error.
;> 1 Match:
;	Buffer is not Large Enough:
;	totalMatches > actualMatches
;	Buffer will contain all the CIDs (equal to actualMatches), daMoreDataError error.
;0 Matches:
; kOCENoSuchRecord error
;
AuthResolveCreationIDPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
userRecord				 ds.l   1		; offset: $3E (62)		;  --> OCE name(Record) of the user 
bufferLength			 ds.l   1		; offset: $42 (66)		;  --> Buffer Size to hold duplicate Info 
buffer					 ds.l   1		; offset: $46 (70)		;  --> Buffer  to hold duplicate Info 
totalMatches			 ds.l   1		; offset: $4A (74)		; <--  Total Number of matching names found 
actualMatches			 ds.l   1		; offset: $4E (78)		; <--  Number of matches returned in the buffer 
sizeof					 EQU *			; size:   $52 (82)
						ENDR

; typedef struct AuthResolveCreationIDPB  AuthResolveCreationIDPB
;
;kAuthBindSpecificIdentity:
;userRecord will contain the user information whose identity has to be
;verified. userKey will contain the userKey. An Identity is returned which
;binds the key and the userRecord. The identity returned can be used in the 'identity'
;field in the header portion (AuthParamHeader) for authenticating the Catalog and
;Authentication manager calls.
;
AuthBindSpecificIdentityPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
userIdentity			 ds.l   1		; offset: $3E (62)		; <--  binding identity 
userRecord				 ds.l   1		; offset: $42 (66)		;  --> OCE name(Record) of the user 
userKey					 ds.l   1		; offset: $46 (70)		;  --> OCE Key for the user 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct AuthBindSpecificIdentityPB  AuthBindSpecificIdentityPB
;
;kAuthUnbindSpecificIdentity:
;This call will unbind the userRecord and key which were bind earlier.
;
AuthUnbindSpecificIdentityPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
userIdentity			 ds.l   1		; offset: $3E (62)		;  --> identity to be deleted 
sizeof					 EQU *			; size:   $42 (66)
						ENDR

; typedef struct AuthUnbindSpecificIdentityPB  AuthUnbindSpecificIdentityPB
;
;kAuthGetSpecificIdentityInfo:
;This call will return the userRecord for the given identity. Note: key is not
;returned because this would compromise security.
;
AuthGetSpecificIdentityInfoPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
userIdentity			 ds.l   1		; offset: $3E (62)		;  --> identity of initiator 
userRecord				 ds.l   1		; offset: $42 (66)		; <--  OCE name(Record) of the user 
sizeof					 EQU *			; size:   $46 (70)
						ENDR

; typedef struct AuthGetSpecificIdentityInfoPB  AuthGetSpecificIdentityInfoPB
;
;kAuthAddKey:
;userRecord will contain the user information whose identity has to be
;created. userKey will point to the key to be created. password points to
;an RString containing the password used to generate the key.
;
AuthAddKeyPB 			RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
userRecord				 ds.l   1		; offset: $3E (62)		;  --> OCE name(Record) of the user 
userKey					 ds.l   1		; offset: $42 (66)		; <--  OCE Key for the user 
password				 ds.l   1		; offset: $46 (70)		;  --> Pointer to password string 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct AuthAddKeyPB  AuthAddKeyPB
;
;kAuthChangeKey:
;userRecord will contain the user information whose identity has to be
;created. userKey will point to the key to be created. password points to
;an RString containing the password used to generate the key.
;
AuthChangeKeyPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
userRecord				 ds.l   1		; offset: $3E (62)		;  --> OCE name(Record) of the user 
userKey					 ds.l   1		; offset: $42 (66)		; <--  New OCE Key for the user 
password				 ds.l   1		; offset: $46 (70)		;  -->Pointer to the new password string 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct AuthChangeKeyPB  AuthChangeKeyPB
;
;AuthDeleteKey:
;userRecord will contain the user information whose Key has to be deleted.
;
AuthDeleteKeyPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
userRecord				 ds.l   1		; offset: $3E (62)		;  --> OCE name(Record) of the user 
sizeof					 EQU *			; size:   $42 (66)
						ENDR

; typedef struct AuthDeleteKeyPB  AuthDeleteKeyPB
; AuthPasswordToKey: Converts an RString into a key. 
AuthPasswordToKeyPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
userRecord				 ds.l   1		; offset: $3E (62)		;  --> OCE name(Record) of the user 
key						 ds.l   1		; offset: $42 (66)		; <--  
password				 ds.l   1		; offset: $46 (70)		;  -->Pointer to the new password string 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct AuthPasswordToKeyPB  AuthPasswordToKeyPB
;
;kAuthGetCredentials:
;userRecord will contain the user information whose identity has to be
;kMailDeletedMask. keyType (e.g. asDESKey) will indicate what type of key has to
;be deleted.
;
AuthGetCredentialsPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
userIdentity			 ds.l   1		; offset: $3E (62)		;  --> identity of initiator 
recipient				 ds.l   1		; offset: $42 (66)		;  --> OCE name of recipient 
sessionKey				 ds.l   1		; offset: $46 (70)		; <--  session key 
expiry					 ds.l   1		; offset: $4A (74)		; <--> desired/actual expiry 
credentialsLength		 ds.l   1		; offset: $4E (78)		; <--> max/actual credentials size 
credentials				 ds.l   1		; offset: $52 (82)		; <--  buffer where credentials are returned 
sizeof					 EQU *			; size:   $56 (86)
						ENDR

; typedef struct AuthGetCredentialsPB  AuthGetCredentialsPB
;
;AuthDecryptCredentialsPB:
;Changes:
;userKey is changed userIdentity.
;userRecord is changed to initiatorRecord. User must supply buffer
;to hold initiatorRecord.
;agentList has changed to agent. There wil be no call back.
;User must supply buffer to hold agent Record.
;An additional boolean parameter 'hasAgent' is included.
;Toolbox will set this if an 'Agent' record is found in the
;credentials. If RecordIDPtr is 'nil', no agent record will
;be copied. However user can examine 'hasAgent', If true user
;can reissue this call with apprpriate buffer for getting a recordID.
;agent has changed to intermediary.  User must supply buffer to hold 
;intermediary Record.  The toolbox will set 'hasIntermediary' if an
;'intermediary' record is found in the credentials. 
;
AuthDecryptCredentialsPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
userIdentity			 ds.l   1		; offset: $3E (62)		;  --> user's Identity 
initiatorRecord			 ds.l   1		; offset: $42 (66)		; <--  OCE name of the initiator 
sessionKey				 ds.l   1		; offset: $46 (70)		; <--  session key 
expiry					 ds.l   1		; offset: $4A (74)		; <--  credentials expiry time 
credentialsLength		 ds.l   1		; offset: $4E (78)		;  --> actual credentials size 
credentials				 ds.l   1		; offset: $52 (82)		;  --> credentials to be decrypted 
issueTime				 ds.l   1		; offset: $56 (86)		; <--  credentials expiry time 
hasIntermediary			 ds.b   1		; offset: $5A (90)		; <--  if true, An intermediary Record was found in credentials 
filler1					 ds.b   1		; offset: $5B (91)
intermediary			 ds.l   1		; offset: $5C (92)		; <--  recordID of the intermediary 
sizeof					 EQU *			; size:   $60 (96)
						ENDR

; typedef struct AuthDecryptCredentialsPB  AuthDecryptCredentialsPB
AuthMakeChallengePB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
key						 ds.l   1		; offset: $3E (62)		;  --> UnEncrypted SessionKey 
challenge				 ds.l   1		; offset: $42 (66)		; <--  Encrypted Challenge 
challengeBufferLength	 ds.l   1		; offset: $46 (70)		;  ->length of challenge buffer 
challengeLength			 ds.l   1		; offset: $4A (74)		;  <-length of Encrypted Challenge 
sizeof					 EQU *			; size:   $4E (78)
						ENDR

; typedef struct AuthMakeChallengePB  AuthMakeChallengePB
AuthMakeReplyPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
key						 ds.l   1		; offset: $3E (62)		;  --> UnEncrypted SessionKey 
challenge				 ds.l   1		; offset: $42 (66)		;  --> Encrypted Challenge 
reply					 ds.l   1		; offset: $46 (70)		; <--  Encrypted Reply 
replyBufferLength		 ds.l   1		; offset: $4A (74)		;  -->length of challenge buffer 
challengeLength			 ds.l   1		; offset: $4E (78)		;  --> length of Encrypted Challenge 
replyLength				 ds.l   1		; offset: $52 (82)		; <--  length of Encrypted Reply 
sizeof					 EQU *			; size:   $56 (86)
						ENDR

; typedef struct AuthMakeReplyPB  AuthMakeReplyPB
AuthVerifyReplyPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
key						 ds.l   1		; offset: $3E (62)		;  --> UnEncrypted SessionKey 
challenge				 ds.l   1		; offset: $42 (66)		;  --> Encrypted Challenge 
reply					 ds.l   1		; offset: $46 (70)		;  --> Encrypted Reply 
challengeLength			 ds.l   1		; offset: $4A (74)		;  --> length of Encrypted Challenge 
replyLength				 ds.l   1		; offset: $4E (78)		;  --> length of Encrypted Reply 
sizeof					 EQU *			; size:   $52 (82)
						ENDR

; typedef struct AuthVerifyReplyPB  AuthVerifyReplyPB
;
;kAuthGetUTCTime:
;RLI will contain a valid RLI for a cluster server.
;UTC(GMT) time from one of the cluster server will be returned.
;An 'offSet' from UTC(GMT) to Mac Local Time will also be returned.
;If RLI is nil Map DA is used to determine UTC(GMT).
;Mac Local Time = theUTCTime + theUTCOffset.
;
AuthGetUTCTimePB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
pRLI					 ds.l   1		; offset: $3E (62)		;  --> packed RLI of the Node, whose server's UTC is requested 
theUTCTime				 ds.l   1		; offset: $42 (66)		; <--  current UTC(GMT) Time utc seconds since 1/1/1904 
theUTCOffset			 ds.l   1		; offset: $46 (70)		; <--  offset from UTC(GMT) seconds EAST of Greenwich 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct AuthGetUTCTimePB  AuthGetUTCTimePB
;
;kAuthMakeProxy:
;A user represented bu the 'userIdentity' can make a proxy using this call.
;'recipient' is the RecordID of the recipient whom user is requesting proxy.
;'intermediary' is the RecordID of the intermediary holding proxy for the user.
;'firstValid' is time at which proxy becomes valid.
;'expiry' is the time at which proxy must expire.
;'proxyLength' will have the length of the buffer pointed by 'proxy' as input.
;When the call completes, it will hold the actual length of proxy. If the
;call completes 'kOCEMoreData' error, client can reissue the call with the
;buffer size as 'proxyLength' returned.
;expiry is a suggestion, and may be adjusted to be earlier by the ADAP/OCE server.
;The 'proxy' obtained like this might be used by the 'intermediary' to obtain credentials
;for the server using TradeProxyForCredentials call.
;authDataLength and authData are intended for possible future work, but are
;ignored for now.
;
AuthMakeProxyPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
userIdentity			 ds.l   1		; offset: $3E (62)		;  --> identity of principal 
recipient				 ds.l   1		; offset: $42 (66)		;  --> OCE name of recipient 
firstValid				 ds.l   1		; offset: $46 (70)		;  --> time at which proxy becomes valid 
expiry					 ds.l   1		; offset: $4A (74)		;  --> time at which proxy expires 
authDataLength			 ds.l   1		; offset: $4E (78)		;  --> size of authorization data 
authData				 ds.l   1		; offset: $52 (82)		;  --> pointer to authorization data 
proxyLength				 ds.l   1		; offset: $56 (86)		; <--> max/actual proxy size 
proxy					 ds.l   1		; offset: $5A (90)		; <--> buffer where proxy is returned 
intermediary			 ds.l   1		; offset: $5E (94)		;  --> RecordID of intermediary 
sizeof					 EQU *			; size:   $62 (98)
						ENDR

; typedef struct AuthMakeProxyPB  AuthMakeProxyPB
;
;kAuthTradeProxyForCredentials:
;Using this call, intermediary holding a 'proxy' for a recipient may obtain credentials
;for that recipient. 'userIdentity' is the identity for the 'intermediary'.
;'recipient' is the RecordID for whom credetials are requested.
;'principal' is the RecordID of the user who created the proxy.
;'proxyLength' is the length of data pointed by 'proxy.
;If the call is succesfull, credentials will be returned in the
;buffer pointed by 'credentials'. 'expiry' is the desired expiry time at input.
;When call succeds this will have expiry time of credentials.
;This is very similar to GetCredentials except that we (of course) need the proxy,
;but we also need the name of the principal who created the proxy.
;
AuthTradeProxyForCredentialsPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
userIdentity			 ds.l   1		; offset: $3E (62)		;  --> identity of intermediary 
recipient				 ds.l   1		; offset: $42 (66)		;  --> OCE name of recipient 
sessionKey				 ds.l   1		; offset: $46 (70)		; <--  session key 
expiry					 ds.l   1		; offset: $4A (74)		; <--> desired/actual expiry 
credentialsLength		 ds.l   1		; offset: $4E (78)		; <--> max/actual credentials size 
credentials				 ds.l   1		; offset: $52 (82)		; <--> buffer where credentials are returned 
proxyLength				 ds.l   1		; offset: $56 (86)		;  --> actual proxy size 
proxy					 ds.l   1		; offset: $5A (90)		;  --> buffer containing proxy 
principal				 ds.l   1		; offset: $5E (94)		;  --> RecordID of principal 
sizeof					 EQU *			; size:   $62 (98)
						ENDR

; typedef struct AuthTradeProxyForCredentialsPB  AuthTradeProxyForCredentialsPB
; API for Local Identity Interface 
;
;AuthGetLocalIdentityPB:
;A Collaborative application intended to work under the umbrella of LocalIdentity
;for the OCE toolbox will have to make this call to obtain LocalIdentity.
;If LocalIdentity has not been setup, then application will get
;'kOCEOCESetupRequired.'. In this case application should put the dialog
;recommended by the OCE Setup document and guide the user through OCE Setup.
;If the OCESetup contains local identity, but user has not unlocked, it will get
;kOCELocalAuthenticationFail. In this case application should use SDPPromptForLocalIdentity
;to prompt user for the password.
;If a backGround application or stand alone code requires LocalIdentity, if it gets the
;OSErr from LocalIdentity and can not call SDPPromptForLocalIdentity, it should it self
;register with the toolbox using kAuthAddToLocalIdentityQueue call. It will be notified
;when a LocalIdentity gets created by a foreground application.
;
AuthGetLocalIdentityPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
theLocalIdentity		 ds.l   1		; offset: $3E (62)		; <--  LocalIdentity 
sizeof					 EQU *			; size:   $42 (66)
						ENDR

; typedef struct AuthGetLocalIdentityPB  AuthGetLocalIdentityPB
;
;kAuthUnlockLocalIdentity:
;The LocalIdentity can be created using this call.
;The userName and password correspond to the LocalIdentity setup.
;If the password matches, then collabIdentity will be returned.
;Typically SDPPromptForLocalIdentity call will make this call.
;All applications which are registered through kAuthAddToLocalIdentityQueue
;will be notified.
;
AuthUnlockLocalIdentityPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
theLocalIdentity		 ds.l   1		; offset: $3E (62)		; <--  LocalIdentity 
userName				 ds.l   1		; offset: $42 (66)		;  --> userName 
password				 ds.l   1		; offset: $46 (70)		;  -->user password 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct AuthUnlockLocalIdentityPB  AuthUnlockLocalIdentityPB
;
;kAuthLockLocalIdentity:
;With this call existing LocalIdentity can be locked. If the ASDeleteLocalIdetity
;call fails with 'kOCEOperationDenied' error, name will contain the application which
;denied the operation. This name will be supplied by the application
;when it registered through kAuthAddToLocalIdentityQueue call
;
AuthLockLocalIdentityPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
theLocalIdentity		 ds.l   1		; offset: $3E (62)		;  --> LocalIdentity 
name					 ds.l   1		; offset: $42 (66)		; <--  name of the app which denied delete 
sizeof					 EQU *			; size:   $46 (70)
						ENDR

; typedef struct AuthLockLocalIdentityPB  AuthLockLocalIdentityPB
; typedef NotificationUPP 	NotificationProc
;
;kAuthAddToLocalIdentityQueue:
;An application requiring notification of locking/unlocking of the
;LocalIdentity can install itself using this call. The function provided
;in 'notifyProc' will be called whenever the requested event happens.
;When an AuthLockLocalIdentity call is made to the toolbox, the notificationProc
;will be called with 'kAuthLockPending'. The application may refuse the lock by returning
;a 'true' value. If all the registered entries return 'false' value, locking will be done
;successfully. Otherwise 'kOCEOperationDenied' error is returned to the caller. The appName
;(registered with the notificationProc) of the application which denied locking is also
;returned to the caller making the AuthLockIdentity call.
;
AuthAddToLocalIdentityQueuePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
notifyProc				 ds.l   1		; offset: $3E (62)		;  --> notification procedure 
notifyFlags				 ds.l   1		; offset: $42 (66)		;  --> notifyFlags 
appName					 ds.l   1		; offset: $46 (70)		;  --> name of application to be returned in Delete/Stop 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct AuthAddToLocalIdentityQueuePB  AuthAddToLocalIdentityQueuePB
;
;kAuthRemoveFromLocalIdentityQueue:
AuthRemoveFromLocalIdentityQueuePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
notifyProc				 ds.l   1		; offset: $3E (62)		;  --> notification procedure 
sizeof					 EQU *			; size:   $42 (66)
						ENDR

; typedef struct AuthRemoveFromLocalIdentityQueuePB  AuthRemoveFromLocalIdentityQueuePB
;
;kAuthSetupLocalIdentity:
;The LocalIdentity can be Setup using this call.
;The userName and password correspond to the LocalIdentity setup.
;If a LocalIdentity Setup already exists 'kOCELocalIdentitySetupExists' error
;will be returned.
;
AuthSetupLocalIdentityPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aReserved				 ds.l   1		; offset: $3E (62)		;  --  
userName				 ds.l   1		; offset: $42 (66)		;  --> userName 
password				 ds.l   1		; offset: $46 (70)		;  -->user password 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct AuthSetupLocalIdentityPB  AuthSetupLocalIdentityPB
;
;kAuthChangeLocalIdentity:
;An existing LocalIdentity  Setup can be changed using this call.
;The userName and password correspond to the LocalIdentity setup.
;If a LocalIdentity Setup does not exists 'kOCEOCESetupRequired' error
;will be returned. The user can use  kAuthSetupLocalIdentity call to setit up.
;If the 'password' does not correspond to the existing setup, 'kOCELocalAuthenticationFail'
;OSErr will be returned. If successful, LocalID will have new name as 'userName' and
;password as 'newPassword' and if any applications has installed into 
;LocalIdentityQueue with kNotifyNameChangeMask set, it will be notified with 
;kAuthLocalIdentityNameChangeOp action value. 
;
;
AuthChangeLocalIdentityPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aReserved				 ds.l   1		; offset: $3E (62)		;  --  
userName				 ds.l   1		; offset: $42 (66)		;  --> userName 
password				 ds.l   1		; offset: $46 (70)		;  --> current password 
newPassword				 ds.l   1		; offset: $4A (74)		;  --> new password 
sizeof					 EQU *			; size:   $4E (78)
						ENDR

; typedef struct AuthChangeLocalIdentityPB  AuthChangeLocalIdentityPB
;
;kAuthRemoveLocalIdentity:
;An existing LocalIdentity  Setup can be removed using this call.
;The userName and password correspond to the LocalIdentity setup.
;If a LocalIdentity Setup does not exists 'kOCEOCESetupRequired' error
;will be returned.
;If the 'password' does not correspond to the existing setup, 'kOCELocalAuthenticationFail'
;OSErr will be returned. If successful, LocalIdentity will be removed from the OCE Setup.
;This is a very distructive operation, user must be warned enough before actually making
;this call.
;
AuthRemoveLocalIdentityPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aReserved				 ds.l   1		; offset: $3E (62)		;  --  
userName				 ds.l   1		; offset: $42 (66)		;  --> userName 
password				 ds.l   1		; offset: $46 (70)		;  --> current password 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct AuthRemoveLocalIdentityPB  AuthRemoveLocalIdentityPB
;
;kOCESetupAddDirectoryInfo:
;Using this call identity for a catalog can be setup under LocalIdentity umbrella.
;ASCreateLocalIdentity should have been done succesfully before making this call.
;directoryRecordCID -> is the record creationID obtained when DirAddOCEDirectory or
;DirAddDSAMDirectory call was made.
;rid-> is the recordID in which the identity for the catalog will be established.
;password-> the password associated with the rid in the catalog world.
;
OCESetupAddDirectoryInfoPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
directoryRecordCID		 ds.l   2		; offset: $3E (62)		;  --> CreationID for the catalog 
recordID				 ds.l   1		; offset: $46 (70)		;  --> recordID for the identity 
password				 ds.l   1		; offset: $4A (74)		;  --> password in the catalog world 
sizeof					 EQU *			; size:   $4E (78)
						ENDR

; typedef struct OCESetupAddDirectoryInfoPB  OCESetupAddDirectoryInfoPB
;
;kOCESetupChangeDirectoryInfo:
;Using this call an existing identity for a catalog under LocalIdentity umbrella
;can be changed.
;ASCreateLocalIdentity should have been done succesfully before making this call.
;directoryRecordCID -> is the record creationID obtained when DirAddOCEDirectory or
;DirAddDSAMDirectory call was made.
;rid-> is the recordID in which the identity for the catalog will be established.
;password-> the password associated with the rid in the catalog world.
;newPassword -> the new password for the catalog
;
OCESetupChangeDirectoryInfoPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
directoryRecordCID		 ds.l   2		; offset: $3E (62)		;  --> CreationID for the catalog 
recordID				 ds.l   1		; offset: $46 (70)		;  --> recordID for the identity 
password				 ds.l   1		; offset: $4A (74)		;  --> password in the catalog world 
newPassword				 ds.l   1		; offset: $4E (78)		;  --> new password in the catalog 
sizeof					 EQU *			; size:   $52 (82)
						ENDR

; typedef struct OCESetupChangeDirectoryInfoPB  OCESetupChangeDirectoryInfoPB
;
;kOCESetupRemoveDirectoryInfo:
;Using this call an existing identity for a catalog under LocalIdentity umbrella
;can be changed.
;ASCreateLocalIdentity should have been done succesfully before making this call.
;directoryRecordCID -> is the record creationID obtained when DirAddOCEDirectory or
;
OCESetupRemoveDirectoryInfoPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
directoryRecordCID		 ds.l   2		; offset: $3E (62)		;  --> CreationID for the catalog 
sizeof					 EQU *			; size:   $46 (70)
						ENDR

; typedef struct OCESetupRemoveDirectoryInfoPB  OCESetupRemoveDirectoryInfoPB
;
;kOCESetupGetDirectoryInfo:
;Using this call info on an existing identity for a particular catalog under LocalIdentity umbrella
;can be obtained.
;For the specified catalog 'directoryName' and 'discriminator', rid and nativeName will
;returned. Caller must provide appropriate buffer to get back rid and nativeName.
;'password' will be returned  for  non-ADAP Catalogs.
;
OCESetupGetDirectoryInfoPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
directoryName			 ds.l   1		; offset: $3E (62)		;  --> catalog name 
discriminator			 ds.l   2		; offset: $42 (66)		;  --> discriminator for the catalog 
recordID				 ds.l   1		; offset: $4A (74)		; <--  rid for the catalog identity 
nativeName				 ds.l   1		; offset: $4E (78)		; <--  user name in the catalog world 
password				 ds.l   1		; offset: $52 (82)		; <--  password in the catalog world 
sizeof					 EQU *			; size:   $56 (86)
						ENDR

; typedef struct OCESetupGetDirectoryInfoPB  OCESetupGetDirectoryInfoPB
;****************************************************************************
;
;
; 		Catalog Manager operations
;
;
;****************************************************************************
; typedef union DirParamBlock  DirParamBlock
; typedef DirParamBlock 	*DirParamBlockPtr
; AddRecord 
DirAddRecordPB 			RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> CreationID returned here 
allowDuplicate			 ds.b   1		; offset: $42 (66)		;  --> 
filler1					 ds.b   1		; offset: $43 (67)
sizeof					 EQU *			; size:   $44 (68)
						ENDR

; typedef struct DirAddRecordPB  DirAddRecordPB
; DeleteRecord 
DirDeleteRecordPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> 
sizeof					 EQU *			; size:   $42 (66)
						ENDR

; typedef struct DirDeleteRecordPB  DirDeleteRecordPB
; aRecord must contain valid PackedRLI and a CreationID. 
;********************************************************************************
;
;DirEnumerate:
;This call can be used to enumerate both DNodes and records under a specified
;DNode. A DNode is specified by the PackedRLIPtr 'aRLI'.
;
;startingPoint indicates where to start the enumeration.  Initially,
;it should be set to a value of nil.  After some records are enumerated,
;the client can issue the call again with the same aRLI and recordName and
;typeList. The last received DirEnumSpec in the startingPoint field.  The server
;will continue the enumeration from that record on. if user wants to get back the
;value specified in the startingRecord also, the Boolean 'includeStartingPoint'
;must be set to 'true'. If this is set to 'false', records specified after the
;startingPoint record will be returned.
;
;sortBy indicates to the server to return the records that match in name-first
;or type-first order.  sortDirection indicates to the server to search in forward
;or backward sort order for RecordIDs Specified.
;
;RecordIDS and Enumeration Criteria:
;
;PackedRLIPtr parameter 'aRLI' will be accepted for DNode
;specification.
;
;One RStringPtr 'nameMatchString' is provided. User is allowed to
;specify a wild card in the name. WildCard specification is specified in 
;matchNameHow parameter and possible values are defined in DirMatchWith Enum.
;
;'typeCount' parameter indicate how many types are in the 'typeList'.
;
;'typeList' parmeter is a pointer to an RString array of size 'typeCount'.
;
;If 'typeCount' is exactly equal to one, a wild card can be specified
;for the entity type; otherwise types have to be completely specified.
;WildCard specification is specified in  matchNameHow parameter
; and possible values are defined in DirMatchWith Enum.
;
;
;A nil value for 'startingPoint' is allowed when sortDirection specified
;is 'kSortBackwards'. This was not allowed previously.
;
;'enumFlags' parameter is a bit field. The following bits can be set:
;	kEnumDistinguishedNameMask to get back records in the cluster data base.
;	kEnumAliasMask to get back record aliases
;	kEnumPseudonymMask to get back record pseudonyms
;	kEnumDNodeMask to get back any children dNodes for the DNode specified in the
;	'aRLI' parameter.
;	kEnumForeignDNodeMask to get back any children dNodes which have ForeignDnodes in the
;	dNode specified in the 'aRLI' parameter.
;
;	kEnumAll is combination of all five values and can be used to enumerate
;	everything under a specified DNode.
;
;
;
;The results returned for each element will consist of a DirEnumSpec.
;The DirEnumSpec contains 'enumFlag' which indicates the type of entity and a
;union which will have either DNodeID or LocalRecordID depending on the value of 'enumFlag'.
;The 'enumFlag'  will indicate whether the returned element is a
;record(kEnumDistinguishedNameMask bit) or a alias(kEnumAliasMask bit) or a
;Pseudonym(kEnumPseudonymMask) or a child DNode(kEnumDNodeMask bit).  If the 'enumFlag' value
;is kEnumDnodeMask, it indicates the value returned in the union is a DNodeID (i.e. 'dNodeNumber'
;is the 'dNodeNumber' of the child dnode(if the catalog supports dNodeNumbers, otherwise
;this will be set to zero). The name will be the child dnode name. For other values of the
;'enumFlag', the value in the union will be LocalRecordID. In addition to kEnumDnodeMask it is
;possible that kEnumForeignDNodeMask is also set. This is an advisory bit and application must make
;it's own decision before displaying these records. If catalog supports kSupportIndexRatioMask, it
;may also return the relative position of the record (percentile of total records) in the 
;indexRatio field in EnumSpec.
;
;
;responseSLRV will contain the script, language, region and version of the oce sorting software.
;The results will be collected in the 'getBuffer' supplied by the user.
;If buffer can not hold all the data returned 'kOCEMoreData' error will be returned.
;
;If user receives 'noErr' or 'kOCEMoreData', buffer will contain valid results. A user
;can extract the results in the 'getBuffer' by making DirEnumerateParse' call.
;
DirEnumerateGetPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRLI					 ds.l   1		; offset: $3E (62)		;  --> an RLI specifying the cluster to be enumerated 
startingPoint			 ds.l   1		; offset: $42 (66)		;  --> 
sortBy					 ds.w   1		; offset: $46 (70)		;  --> 
sortDirection			 ds.w   1		; offset: $48 (72)		;  --> 
dReserved				 ds.l   1		; offset: $4A (74)		;  --  
nameMatchString			 ds.l   1		; offset: $4E (78)		;  --> name from which enumeration should start 
typesList				 ds.l   1		; offset: $52 (82)		;  --> list of entity types to be enumerated 
typeCount				 ds.l   1		; offset: $56 (86)		;  --> number of types in the list 
enumFlags				 ds.l   1		; offset: $5A (90)		;  --> indicates what to enumerate 
includeStartingPoint	 ds.b   1		; offset: $5E (94)		;  --> if true return the record specified in starting point 
padByte					 ds.b   1		; offset: $5F (95)
matchNameHow			 ds.b   1		; offset: $60 (96)		;  --> Matching Criteria for nameMatchString 
matchTypeHow			 ds.b   1		; offset: $61 (97)		;  --> Matching Criteria for typeList 
getBuffer				 ds.l   1		; offset: $62 (98)		;  --> 
getBufferSize			 ds.l   1		; offset: $66 (102)		;  --> 
responseSLRV			 ds     SLRV	; offset: $6A (106)		;  <--  response SLRV 
sizeof					 EQU *			; size:   $72 (114)
						ENDR

; typedef struct DirEnumerateGetPB  DirEnumerateGetPB
; The EnumerateRecords call-back function is defined as follows: 
; typedef ForEachDirEnumSpecUPP  ForEachDirEnumSpec
;
;EnumerateParse:
;After an EnumerateGet call has completed, call EnumerateParse
;to parse through the buffer that was filled in EnumerateGet.
;
;'eachEnumSpec' will be called each time to return to the client a
;DirEnumSpec that matches the pattern for enumeration. 'enumFlag' indicates the type
;of information returned in the DirEnumSpec
;The clientData parameter that you pass in the parameter block will be passed
;to 'forEachEnumDSSpecFunc'.  You are free to put anything in clientData - it is intended
;to allow you some way to match the call-back to the original call (for
;example, you make more then one aysynchronous EnumerateGet calls and you want to
;associate returned results in some way).
;
;The client should return FALSE from 'eachEnumSpec' to continue
;processing of the EnumerateParse request.  Returning TRUE will
;terminate the EnumerateParse request.
;
;For synchronous calls, the call-back routine actually runs as part of the same thread
;of execution as the thread that made the EnumerateParse call.  That means that the
;same low-memory globals, A5, stack, etc. are in effect during the call-back
;that were in effect when the call was made.  Because of this, the call-back
;routine has the same restrictions as the caller of EnumerateParse:
;if EnumerateParse was not called from interrupt level, then the call-
;back routine can allocate memory. For asynchronous calls, call-back routine is
;like a ioCompletion except that A5 will be preserved for the application.
;
DirEnumerateParsePB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRLI					 ds.l   1		; offset: $3E (62)		;  --> an RLI specifying the cluster to be enumerated 
bReserved				 ds.l   1		; offset: $42 (66)		;  --  
cReserved				 ds.l   1		; offset: $46 (70)		;  --  
eachEnumSpec			 ds.l   1		; offset: $4A (74)		;  --> 
eReserved				 ds.l   1		; offset: $4E (78)		;  --  
fReserved				 ds.l   1		; offset: $52 (82)		;  --  
gReserved				 ds.l   1		; offset: $56 (86)		;  --  
hReserved				 ds.l   1		; offset: $5A (90)		;  --  
iReserved				 ds.l   1		; offset: $5E (94)		;  --  
getBuffer				 ds.l   1		; offset: $62 (98)		;  --> 
getBufferSize			 ds.l   1		; offset: $66 (102)		;  --> 
l1Reserved				 ds.w   1		; offset: $6A (106)		;  -- 
l2Reserved				 ds.w   1		; offset: $6C (108)		;  --  
l3Reserved				 ds.w   1		; offset: $6E (110)		;  -- 
l4Reserved				 ds.w   1		; offset: $70 (112)		;  --  
sizeof					 EQU *			; size:   $72 (114)
						ENDR

; typedef struct DirEnumerateParsePB  DirEnumerateParsePB
;
; * FindRecordGet operates similarly to DirEnumerate except it returns a list
; * of records instead of records local to a cluster.
;
DirFindRecordGetPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
startingPoint			 ds.l   1		; offset: $3E (62)
reservedA				 ds.l   2		; offset: $42 (66)
nameMatchString			 ds.l   1		; offset: $4A (74)
typesList				 ds.l   1		; offset: $4E (78)
typeCount				 ds.l   1		; offset: $52 (82)
reservedB				 ds.l   1		; offset: $56 (86)
reservedC				 ds.w   1		; offset: $5A (90)
matchNameHow			 ds.b   1		; offset: $5C (92)
matchTypeHow			 ds.b   1		; offset: $5D (93)
getBuffer				 ds.l   1		; offset: $5E (94)
getBufferSize			 ds.l   1		; offset: $62 (98)
directoryName			 ds.l   1		; offset: $66 (102)
discriminator			 ds.l   2		; offset: $6A (106)
sizeof					 EQU *			; size:   $72 (114)
						ENDR

; typedef struct DirFindRecordGetPB  DirFindRecordGetPB
; The FindRecordParse call-back function is defined as follows: 
; typedef ForEachRecordUPP 	ForEachRecord
;
; * This PB same as DirFindRecordGet except it includes the callback function
;
DirFindRecordParsePB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
startingPoint			 ds.l   1		; offset: $3E (62)
reservedA				 ds.l   2		; offset: $42 (66)
nameMatchString			 ds.l   1		; offset: $4A (74)
typesList				 ds.l   1		; offset: $4E (78)
typeCount				 ds.l   1		; offset: $52 (82)
reservedB				 ds.l   1		; offset: $56 (86)
reservedC				 ds.w   1		; offset: $5A (90)
matchNameHow			 ds.b   1		; offset: $5C (92)
matchTypeHow			 ds.b   1		; offset: $5D (93)
getBuffer				 ds.l   1		; offset: $5E (94)
getBufferSize			 ds.l   1		; offset: $62 (98)
directoryName			 ds.l   1		; offset: $66 (102)
discriminator			 ds.l   2		; offset: $6A (106)
forEachRecordFunc		 ds.l   1		; offset: $72 (114)
sizeof					 EQU *			; size:   $76 (118)
						ENDR

; typedef struct DirFindRecordParsePB  DirFindRecordParsePB
;
;LookupGet:
;
;aRecordList is an array of pointers to RecordIDs, each of which must
;contain valid PackedRLI and a CreationID.  recordIDCount is
;the size of this array.
;
;attrTypeList is an array of pointers to AttributeTypes.  attrTypeCount is
;the size of this array.
;
;staringRecordIndex is the record from which to continue the lookup.
;If you want to start from first record in the list, this must be 1 (not zero).
;This value must always be <= recordIDCount.
;
;startingAttributeIndex is the AttributeType from which we want to continue the lookup.
;If you want to start from first attribute in the list, this must be 1 (not zero).
;This value must always be <= attrTypeCount.
;
;startingAttribute is the value of the attribute value from which we want to
;continue lookup. In case of catalogs supporting creationIDs, startingAttribute
;may contain only a CID. Other catalogs may require the entire value.
;If a non-null cid is given and if an attribute value with that cid is not found, this
;call will terminate with kOCENoSuchAttribute error. A client should not make a LookupParse call
;after getting this error.
;
;'includeStartingPoint' boolean can be set to 'true' to receive the value specified in the
;startingPoint in the results returned. If this is set to 'false', the value
;specified in the startingAttribute will not be returned.
;
;When LookupGet call fails with kOCEMoreData, the client will be able to find out where the call ended
;with a subsequent LookupParse call. When the LookupParse call completes with kOCEMoreData,
;lastRecordIndex, lastAttributeIndex and lastValueCID will point to the corresponding
;recordID, attributeType and the CreationID of the last value returned successfully. These parameters
;are exactly the same ones for the startingRecordIndex, startingAttributeIndex, and startingAttrValueCID
;so they can be used in a subsequent LookupGet call to continue the lookup.
;
;In an extreme case, It is possible that we had an attribute value that is too large to fit
;in the client's buffer. In such cases, if it was the only thing that we tried to fit
;into the buffer, the client will not able to proceed further because he will not know the
;attributeCID of the attribute to continue with.  Also he does not know how big a buffer
;would be needed for the next call to get this 'mondo' attribute value successfully.
;
;to support this, LookupParse call will do the following:
;
;If LookupGet has failed with kOCEMoreData error, LookupParse will check to make sure that
;ForEachAttributeValueFunc has been called at least once. If so, the client has the option
;to continue from that attribute CreationID (for PAB/ADAP) in the next LookupGet call.
;However, if it was not even called once, then the attribute value may be too big to fit in the
;user's buffer. In this case, lastAttrValueCID (lastAttribute) and attrSize are returned in the
;parse buffer and the call will fail with kOCEMoreAttrValue. However, it is possible that
;ForEachAttributeValue was not called because the user does not have read access to some of
;the attributeTypes in the list, and the buffer was full before even reading the creationID of
;any of the attribute values.  A kOCEMoreData error is returned.
;
;The Toolbox will check for duplicate RecordIDs in the aRecordList. If found, it will return
;'daDuplicateRecordIDErr'.
;
;The Toolbox will check for duplicate AttributeTypes in the attrTypeList. If found it will
;return 'daDuplicateAttrTypeErr'.
;
DirLookupGetPB 			RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecordList				 ds.l   1		; offset: $3E (62)		;  --> an array of RecordID pointers 
attrTypeList			 ds.l   1		; offset: $42 (66)		;  --> an array of attribute types 
cReserved				 ds.l   1		; offset: $46 (70)		;  --  
dReserved				 ds.l   1		; offset: $4A (74)		;  --  
eReserved				 ds.l   1		; offset: $4E (78)		;  --  
fReserved				 ds.l   1		; offset: $52 (82)		;  --  
recordIDCount			 ds.l   1		; offset: $56 (86)		;  --> 
attrTypeCount			 ds.l   1		; offset: $5A (90)		;  --> 
includeStartingPoint	 ds.b   1		; offset: $5E (94)		;  --> if true return the value specified by the starting indices 
padByte					 ds.b   1		; offset: $5F (95)
i1Reserved				 ds.w   1		; offset: $60 (96)		;  --  
getBuffer				 ds.l   1		; offset: $62 (98)		;  --> 
getBufferSize			 ds.l   1		; offset: $66 (102)		;  --> 
startingRecordIndex		 ds.l   1		; offset: $6A (106)		;  --> start from this record 
startingAttrTypeIndex	 ds.l   1		; offset: $6E (110)		;  --> start from this attribute type 
startingAttribute		 ds.l   14		; offset: $72 (114)		;  --> start from this attribute value 
pReserved				 ds.l   1		; offset: $AA (170)		;  --  
sizeof					 EQU *			; size:   $AE (174)
						ENDR

; typedef struct DirLookupGetPB  DirLookupGetPB
; The Lookup call-back functions are defined as follows: 
; typedef ForEachLookupRecordIDUPP  ForEachLookupRecordID
; typedef ForEachAttrTypeLookupUPP  ForEachAttrTypeLookup
; typedef ForEachAttrValueUPP  ForEachAttrValue
;
;LookupParse:
;
;After a LookupGet call has completed, call LookupParse
;to parse through the buffer that was filled in LookupGet.  The
;toolbox will parse through the buffer and call the appropriate call-back routines
;for each item in the getBuffer.
;
;'eachRecordID' will be called each time to return to the client one of the
;RecordIDs from aRecordList.  The clientData parameter that you
;pass in the parameter block will be passed to eachRecordID.
;You are free to put anything in clientData - it is intended to allow
;you some way to match the call-back to the original call (in case, for
;example, you make simultaneous asynchronous LookupGet calls).  If you don't
;want to get a call-back for each RecordID (for example, if you're looking up
;attributes for only one RecordID), pass nil for eachRecordID.
;
;After forEachLocalRecordIDFunc is called, eachAttrType may be called to pass an
;attribute type (one from attrTypeList) that exists in the record specified
;in the last eachRecordID call.  If you don't want to get a call-back for
;each AttributeType (for example, if you're looking up only one attribute type,
;or you prefer to read the type from the Attribute struct during the eachAttrValue
;call-back routine), pass nil for eachAttrType. However access controls may
;prohibit you from reading some attribute types; in that case eachAttrValue
;may not be called even though the value exists. Hence the client should
;supply this call-back function to see the access controls for each attribute type.
;
;This will be followed by one or more calls to eachAttrValue, to pass the
;type, tag, and attribute value.  NOTE THIS CHANGE:  you are no longer expected to
;pass a pointer to a buffer in which to put the value.  Now you get a pointer to
;the value, and you can process it within the call-back routine.
;After one or more values are returned, eachAttrType may be called again to pass
;another attribute type that exists in the last-specified RecordID.
;
;The client should return FALSE from eachRecordID, eachAttrType, and
;eachAttrValue to continue processing of the LookupParse request.  Returning TRUE
;from any call-back will terminate the LookupParse request.
;
;If LookupGet has failed with kOCEMoreData error, LookupParse will check to make sure that
;ForEachAttributeValueFunc has been called at least once. If so, the client has the option
;to continue from that attribute CreationID (for PAB/ADAP) in the next LookupGet call.
;However, if it was not even called once, then the attribute value may be too big to fit in the
;user's buffer. In this case, lastAttrValueCID (lastAttribute) and attrSize are returned in the
;parse buffer and the call will fail with kOCEMoreAttrValue. However, it is possible that
;ForEachAttributeValue was not called because the user does not have read access to some of
;the attributeTypes in the list, and the buffer was full before even reading the creationID of
;any of the attribute values.  A kOCEMoreData error is returned.
;
;For synchronous calls, the call-back routine actually runs as part of the same thread
;of execution as the thread that made the LookupParse call.  That means that the
;same low-memory globals, A5, stack, etc. are in effect during the call-back
;that were in effect when the call was made.  Because of this, the call-back
;routine has the same restrictions as the caller of LookupParse:
;if LookupParse was not called from interrupt level, then the call-
;back routine can allocate memory. For asynchronous calls, call-back routine is
;like a ioCompletion except that A5 will be preserved for the application.
;
DirLookupParsePB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecordList				 ds.l   1		; offset: $3E (62)		;  --> must be same from the corresponding Get call 
attrTypeList			 ds.l   1		; offset: $42 (66)		;  --> must be same from the corresponding Get call 
cReserved				 ds.l   1		; offset: $46 (70)		;  --  
eachRecordID			 ds.l   1		; offset: $4A (74)		;  --> 
eachAttrType			 ds.l   1		; offset: $4E (78)		;  --> 
eachAttrValue			 ds.l   1		; offset: $52 (82)		;  --> 
recordIDCount			 ds.l   1		; offset: $56 (86)		;  --> must be same from the corresponding Get call 
attrTypeCount			 ds.l   1		; offset: $5A (90)		;  --> must be same from the corresponding Get call 
iReserved				 ds.l   1		; offset: $5E (94)		;  --  
getBuffer				 ds.l   1		; offset: $62 (98)		;  --> must be same from the corresponding Get call
getBufferSize			 ds.l   1		; offset: $66 (102)		;  --> must be same from the corresponding Get call
lastRecordIndex			 ds.l   1		; offset: $6A (106)		; <--  last RecordID processed when parse completed 
lastAttributeIndex		 ds.l   1		; offset: $6E (110)		; <--  last Attribute Type processed when parse completed 
lastAttribute			 ds.l   14		; offset: $72 (114)		; <--  last attribute value (with this CreationID) processed when parse completed 
attrSize				 ds.l   1		; offset: $AA (170)		; <--  length of the attribute we did not return 
sizeof					 EQU *			; size:   $AE (174)
						ENDR

; typedef struct DirLookupParsePB  DirLookupParsePB
; AddAttributeValue 
DirAddAttributeValuePB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> 
attr					 ds.l   1		; offset: $42 (66)		;  --> AttributeCreationID returned here 
sizeof					 EQU *			; size:   $46 (70)
						ENDR

; typedef struct DirAddAttributeValuePB  DirAddAttributeValuePB
;
;aRecord must contain valid PackedRLI and a CreationID.
;
;Instead of passing type, length, and value in three separate
;fields, we take a pointer to an Attribute structure that contains
;all three, and has room for the AttributeCreationNumber.
;The AttributeCreationID will be returned in the attr itself.
;
;The AttributeTag tells the catalog service that the attribute is an RString,
;binary, or a RecordID.
;
;
;DeleteAttributeType:
;This call is provided so that an existing AttributeType can be deleted.
;If any attribute values exist for this type, they will all be deleted
;(if the user has access rights to delete the values) and then the attribute type
;will be deleted. Otherwise dsAccessDenied error will be returned.
;
DirDeleteAttributeTypePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> 
attrType				 ds.l   1		; offset: $42 (66)		;  --> 
sizeof					 EQU *			; size:   $46 (70)
						ENDR

; typedef struct DirDeleteAttributeTypePB  DirDeleteAttributeTypePB
;
;	DeleteAttributeValue
;
DirDeleteAttributeValuePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  -> 
attr					 ds.l   1		; offset: $42 (66)		;  -> 
sizeof					 EQU *			; size:   $46 (70)
						ENDR

; typedef struct DirDeleteAttributeValuePB  DirDeleteAttributeValuePB
;
;	ChangeAttributeValue:
;	currentAttr ==> the attribute to be changed. For ADAS and PAB CreationID is
;	                sufficient
;	newAttr     ==> new value for the attribute. For ADAS and PAB 
;					CreationID field will be set when
;	                the call succeesfully completes
;	
;	aRecord     ==> must contain valid PackedRecordLocationInfo and a CreationID.
;
;
;	
;
DirChangeAttributeValuePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  -> 
currentAttr				 ds.l   1		; offset: $42 (66)		;  -> 
newAttr					 ds.l   1		; offset: $46 (70)		;  -> 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct DirChangeAttributeValuePB  DirChangeAttributeValuePB
; VerifyAttributeValue 
DirVerifyAttributeValuePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> 
attr					 ds.l   1		; offset: $42 (66)		;  --> 
sizeof					 EQU *			; size:   $46 (70)
						ENDR

; typedef struct DirVerifyAttributeValuePB  DirVerifyAttributeValuePB
;
;aRecord must contain valid PackedRLI and a CreationID.
;
;The attribute type and value are passed in the attribute structure.  If the
;attribute CreationID is non-zero, the server will verify that an attribute with
;the specified value and creation number exists in aRecord.  If the attribute
;CreationID is zero, the server will verify the attribute by type and value
;alone, and return the attribute CreationID in the Attribute struct if the
;attribute exists.
;
;
;EnumerateAttributeTypesGet:
;The following two calls can be used to enumerate the attribute types present in
;a specified RecordID.  The first, EnumerateAttributeTypesGet, processes the request
;and reads the response into getBuffer, as much as will fit.  A kOCEMoreData error will
;be returned if the buffer was not large enough.  After this call completes, the
;client can call EnumerateAttributeTypesParse (see below).
;
;The user will able to continue from a startingPoint by setting a startingAttrType.
;Typically, this should be the last value returned in EnumerateAttributeTypesParse call
;when 'kOCEMoreData' is returned.
;
;If 'includeStartingPoint' is true when a 'startingAttrType' is specified, the starting value
;will be included in the results, if it exists. If this is set to false, this value will not
;be included. AttributeTypes following this type will be returned.
;
DirEnumerateAttributeTypesGetPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> 
startingAttrType		 ds.l   1		; offset: $42 (66)		;  --> starting point 
cReserved				 ds.l   1		; offset: $46 (70)		;  --  
dReserved				 ds.l   1		; offset: $4A (74)		;  --  
eReserved				 ds.l   1		; offset: $4E (78)		;  --  
fReserved				 ds.l   1		; offset: $52 (82)		;  --  
gReserved				 ds.l   1		; offset: $56 (86)		;  --  
hReserved				 ds.l   1		; offset: $5A (90)		;  --  
includeStartingPoint	 ds.b   1		; offset: $5E (94)		;  --> if true return the attrType specified by starting point 
padByte					 ds.b   1		; offset: $5F (95)
i1Reserved				 ds.w   1		; offset: $60 (96)		;  --  
getBuffer				 ds.l   1		; offset: $62 (98)		;  --> 
getBufferSize			 ds.l   1		; offset: $66 (102)		;  --> 
sizeof					 EQU *			; size:   $6A (106)
						ENDR

; typedef struct DirEnumerateAttributeTypesGetPB  DirEnumerateAttributeTypesGetPB
; The call-back function is defined as follows: 
; typedef ForEachAttrTypeUPP  ForEachAttrType
;
;EnumerateAttributeTypesParse:
;After an EnumerateAttributeTypesGet call has completed, call EnumerateAttributeTypesParse
;to parse through the buffer that was filled in EnumerateAttributeTypesGet.  The
;toolbox will parse through the buffer and call the call-back routine for
;each attribute type in the getBuffer.
;
;The client should return false from eachAttrType to continue
;processing of the EnumerateAttributeTypesParse request.  Returning true will
;terminate the EnumerateAttributeTypesParse request.  The clientData parameter that
;you pass in the parameter block will be passed to eachAttrType.
;You are free to put anything in clientData - it is intended to allow
;you some way to match the call-back to the original call (in case, for
;example, you make simultaneous asynchronous calls).
;
;For synchronous calls, the call-back routine actually runs as part of the same thread
;of execution as the thread that made the EnumerateAttributeTypesParse call.  That means that the
;same low-memory globals, A5, stack, etc. are in effect during the call-back
;that were in effect when the call was made.  Because of this, the call-back
;routine has the same restrictions as the caller of EnumerateAttributeTypesParse.
;If EnumerateAttributeTypesParse was not called from interrupt level, then the call-
;back routine can allocate memory. For asynchronous calls, call-back routine is
;like a ioCompletion except that A5 will be preserved for the application.
;
DirEnumerateAttributeTypesParsePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> Same as DirEnumerateAttributeTypesGetPB 
bReserved				 ds.l   1		; offset: $42 (66)		;  --  
cReserved				 ds.l   1		; offset: $46 (70)		;  --  
dReserved				 ds.l   1		; offset: $4A (74)		;  --  
eachAttrType			 ds.l   1		; offset: $4E (78)		;  --> 
fReserved				 ds.l   1		; offset: $52 (82)		;  --  
gReserved				 ds.l   1		; offset: $56 (86)		;  --  
hReserved				 ds.l   1		; offset: $5A (90)		;  --  
iReserved				 ds.l   1		; offset: $5E (94)		;  --  
getBuffer				 ds.l   1		; offset: $62 (98)		;  --> 
getBufferSize			 ds.l   1		; offset: $66 (102)		;  --> 
sizeof					 EQU *			; size:   $6A (106)
						ENDR

; typedef struct DirEnumerateAttributeTypesParsePB  DirEnumerateAttributeTypesParsePB
;
;DirAbort:
;With this call a user will able to abort an outstanding catalog service call.
;A user must pass a pointer to the parameter block for the outstanding call.
;In the current version of the product, the toolbox will process this call
;for NetSearchADAPDirectoriesGet or FindADAPDirectoryByNetSearch calls and if possible
;it will abort. For other calls for ADAP and PAB this will return 'daAbortFailErr'.
;For CSAM catalogs, this call will be passed to the corresponding CSAM driver.
;The CSAM driver may process this call or may return 'daAbortFailErr'. This call can
;be called only in synchronous mode. Since the abort call makes references to fields in
;the pb associated with the original call, this pb must not be disposed or or altered if
;the original call completes before the abort call has completed.
;
DirAbortPB 				RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
pb						 ds.l   1		; offset: $3E (62)		;  --> pb for the call which must be aborted 
sizeof					 EQU *			; size:   $42 (66)
						ENDR

; typedef struct DirAbortPB  DirAbortPB
;
;AddPseudonym:
;An alternate name and type can be added to a given record. If allowDuplicate
;is set the name and type will be added even if the same name and type already
;exists.
;
DirAddPseudonymPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> RecordID to which pseudonym is to be added 
pseudonymName			 ds.l   1		; offset: $42 (66)		;  --> new name to be added as pseudonym 
pseudonymType			 ds.l   1		; offset: $46 (70)		;  --> new name to be added as pseudonym 
allowDuplicate			 ds.b   1		; offset: $4A (74)		;  --> 
filler1					 ds.b   1		; offset: $4B (75)
sizeof					 EQU *			; size:   $4C (76)
						ENDR

; typedef struct DirAddPseudonymPB  DirAddPseudonymPB
;
;DeletePseudonym:
;An alternate name and type for a given record can be deleted.
;
DirDeletePseudonymPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> RecordID to which pseudonym to be added 
pseudonymName			 ds.l   1		; offset: $42 (66)		;  --> pseudonymName to be deleted 
pseudonymType			 ds.l   1		; offset: $46 (70)		;  --> pseudonymType to be deleted 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct DirDeletePseudonymPB  DirDeletePseudonymPB
;
;	AddAlias:
;	This call can be used to create an alias  record. The alias
;	can be created either in the same or different cluster. ADAS will not support
;	this call for this release. A new catalog capability flag 'kSupportsAlias' will indicate
;	if the catalog supports this call. PAB's will support this call. For the PAB implementation,
;	this call will create a record with the name and type specified an aRecord.
;	This call works exactly like AddRecord.
;	If 'allowDuplicate' is false and another record with same name and type already exists
;	'daNoDupAllowed' error will be returned.
;
DirAddAliasPB 			RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  -> 
allowDuplicate			 ds.b   1		; offset: $42 (66)		;  -> 
filler1					 ds.b   1		; offset: $43 (67)
sizeof					 EQU *			; size:   $44 (68)
						ENDR

; typedef struct DirAddAliasPB  DirAddAliasPB
;
;DirFindValue:
;This call can be used to find the occurrence of a value. The value
;to be matched is passed in the buffer 'matchingData' field. The current
;ADAP/PAB implementation will match a maximum of 32 bytes of data.
;For attribute values in the PAB/ADAP implementation, only the first 32 bytes will
;be used for comparing the occurrence of data. Search can be restricted to
;a particular record and/or attribute type by specifying 'aRecord' or 'aType'.
;After finding one occurrence, 'startingRecord' and 'startingAttribute'
;can be specified to find the next occurrence of the same value.
;'sortDirection' can be specified with starting values to search forward or backward.
;When a matching value is found, the 'recordFound' indicates the reccordID in which the
;data occurrence was found, 'attributeFound' indicates the attribute with in which the
;matching data was found. ADAP/PAB implementation returns only the type and creationID of
;attributes. Catalogs which don't support creationIDs may return the
;complete value; hence this call may need a buffer to hold the data. For ADAP/PAB implementations
;the user has to make a DirLookup call to get the actual data. 'recordFound' and
;'attributeFound' can be used to initialize 'startingRecord' and 'startingAttribute' to
;find the next occurrence of the value.
;
DirFindValuePB 			RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRLI					 ds.l   1		; offset: $3E (62)		;  --> an RLI specifying the cluster to be enumerated 
aRecord					 ds.l   1		; offset: $42 (66)		;  --> if not nil, look only in this record 
attrType				 ds.l   1		; offset: $46 (70)		;  --> if not nil, look only in this attribute type 
startingRecord			 ds.l   1		; offset: $4A (74)		;  --> record in which to start searching 
startingAttribute		 ds.l   1		; offset: $4E (78)		;  --> attribute in which to start searching 
recordFound				 ds.l   1		; offset: $52 (82)		; <--  record in which data was found 
attributeFound			 ds.l   14		; offset: $56 (86)		; <--  attribute in which data was found 
matchSize				 ds.l   1		; offset: $8E (142)		;  --> length of matching bytes 
matchingData			 ds.l   1		; offset: $92 (146)		;  --> data bytes to be matched in search 
sortDirection			 ds.w   1		; offset: $96 (150)		;  --> sort direction (forwards or backwards) 
sizeof					 EQU *			; size:   $98 (152)
						ENDR

; typedef struct DirFindValuePB  DirFindValuePB
;
;EnumeratePseudonymGet:
;This call can be used to enumerate the existing pseudonyms for
;a given record specified in 'aRecord'. A starting point can be specified
;by 'startingName' and 'startingType'. If the 'includeStartingPoint' boolean
;is true and a starting point is specified, the name specified by startingName
;and startingType also is returned in the results, if it exists. If this is set to false,
;the pseudonym in startingName and Type is not included.
;Pseudonyms returned in the 'getBuffer' can be extracted by making an
;EnumeratePseudonymParse call. The results will consist of a RecordID with the
;name and type of the pseudonym. If the buffer could not hold all the results, then
;'kOCEMoreData' error will be returned. The user will be able to continue the call by
;using the last result returned as starting point for the next call.
;
DirEnumeratePseudonymGetPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> 
startingName			 ds.l   1		; offset: $42 (66)		;  --> 
startingType			 ds.l   1		; offset: $46 (70)		;  --> 
dReserved				 ds.l   1		; offset: $4A (74)		;  --  
eReserved				 ds.l   1		; offset: $4E (78)		;  --  
fReserved				 ds.l   1		; offset: $52 (82)		;  --  
gReserved				 ds.l   1		; offset: $56 (86)		;  --  
hReserved				 ds.l   1		; offset: $5A (90)		;  --  
includeStartingPoint	 ds.b   1		; offset: $5E (94)		;  --> if true return the Pseudonym specified by starting point will be included 
padByte					 ds.b   1		; offset: $5F (95)
i1Reserved				 ds.w   1		; offset: $60 (96)		;  --  
getBuffer				 ds.l   1		; offset: $62 (98)		;  --> 
getBufferSize			 ds.l   1		; offset: $66 (102)		;  --> 
sizeof					 EQU *			; size:   $6A (106)
						ENDR

; typedef struct DirEnumeratePseudonymGetPB  DirEnumeratePseudonymGetPB
; The call-back function is defined as follows: 
; typedef ForEachRecordIDUPP  ForEachRecordID
;
;EnumeratePseudonymParse:
;The pseudonyms returned in the 'getBuffer' from the EnumeratePseudonymGet call
;can be extracted by using the EnumeratePseudonymParse call. 'eachRecordID'
;will be called for each pseudonym.
;
;Returning true from any call-back will terminate the EnumeratePseudonymParse call.
;
;For synchronous calls, the call-back routine actually runs as part of the same thread
;of execution as the thread that made the EnumeratePseudonymParse call.  That means that the
;same low-memory globals, A5, stack, etc. are in effect during the call-back
;that were in effect when the call was made.  Because of this, the call-back
;routine has the same restrictions as the caller of EnumeratePseudonymParse:
;if EnumeratePseudonymParse was not called from interrupt level, then the call-
;back routine can allocate memory. For asynchronous calls, call-back routine is
;like a ioCompletion except that A5 will be preserved for the application.
;
DirEnumeratePseudonymParsePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> same as DirEnumerateAliasesGetPB 
bReserved				 ds.l   1		; offset: $42 (66)		;  --  
cReserved				 ds.l   1		; offset: $46 (70)		;  --  
eachRecordID			 ds.l   1		; offset: $4A (74)		;  --> 
eReserved				 ds.l   1		; offset: $4E (78)		;  --  
fReserved				 ds.l   1		; offset: $52 (82)		;  --  
gReserved				 ds.l   1		; offset: $56 (86)		;  --  
hReserved				 ds.l   1		; offset: $5A (90)		;  --  
iReserved				 ds.l   1		; offset: $5E (94)		;  --  
getBuffer				 ds.l   1		; offset: $62 (98)		;  --> 
getBufferSize			 ds.l   1		; offset: $66 (102)		;  --> 
sizeof					 EQU *			; size:   $6A (106)
						ENDR

; typedef struct DirEnumeratePseudonymParsePB  DirEnumeratePseudonymParsePB
; GetNameAndType 
DirGetNameAndTypePB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> 
sizeof					 EQU *			; size:   $42 (66)
						ENDR

; typedef struct DirGetNameAndTypePB  DirGetNameAndTypePB
;
;aRecord must contain valid RLI and a CreationID.  It
;must also contain pointers to maximum-length RStrings (name and type fields)
;in which will be returned the record's distinguished name and type.
;
;
;SetNameAndType:
;This call can be used to change a name and type for a record. The record
;to be renamed is specified using 'aRecord'.
;'newName' and 'newType' indicate the name and type to be set.
;'allowDuplicate' if true indicates that name is to be set even if another
;name and type exactly matches the newName and newType specified.
;
;'newName' and 'newType' are required since the catalogs not supporting
;CreationID require name and type fields in the recordID to identify a given
;record.
;
DirSetNameAndTypePB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> 
allowDuplicate			 ds.b   1		; offset: $42 (66)		;  --> 
padByte					 ds.b   1		; offset: $43 (67)
newName					 ds.l   1		; offset: $44 (68)		;  --> new name for the record 
newType					 ds.l   1		; offset: $48 (72)		;  --> new type for the record 
sizeof					 EQU *			; size:   $4C (76)
						ENDR

; typedef struct DirSetNameAndTypePB  DirSetNameAndTypePB
;
;DirGetMetaRecordInfo: This call can be made to obtain
;the MetaRecordInfo for a given record. Information returned
;is 16 bytes of OPAQUE information about the record.
;
DirGetRecordMetaInfoPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  --> 
metaInfo				 ds     DirMetaInfo ; offset: $42 (66)	; <--  
sizeof					 EQU *			; size:   $52 (82)
						ENDR

; typedef struct DirGetRecordMetaInfoPB  DirGetRecordMetaInfoPB
;
;DirGetDNodeMetaInfo: This call can be made to obtain
;the DNodeMetaInfo for a given Packed RLI. Information returned
;is 16 bytes of OPAQUE information about the DNode.
;
DirGetDNodeMetaInfoPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
pRLI					 ds.l   1		; offset: $3E (62)		;  --> 
metaInfo				 ds     DirMetaInfo ; offset: $42 (66)	; <--  
sizeof					 EQU *			; size:   $52 (82)
						ENDR

; typedef struct DirGetDNodeMetaInfoPB  DirGetDNodeMetaInfoPB
;
;EnumerateDirectoriesGet:
;A user can enumerate all the catalogs installed. This includes installed
;ADAP and CSAM catalogs. The user can specify a signature as input to restrict
;the results. kDirADAPKind will return only ADAP catalogs, kDirDSAMKind
;will return all CSAM catalogs. kDirAllKinds will get both ADAP & CSAM catalogs.
;A specific signature (e.g. X.500) may be used to get catalogs with an X.500 signature.
;The information for each catalog returned will have directoryName, discriminator and features.
;
;If the user receives 'noErr' or 'kOCEMoreData', the buffer will contain valid results. A user
;can extract the results in the 'getBuffer' by making an DirEnumerateDirectories call.
;
;If 'kOCEMoreData' is received, the user can continue enumeration by using the last catalog and
;discriminator as startingDirectoryName and staringDirDiscriminator in the next call.
;
;If 'includeStartingPoint' is true and a starting point is specified,
;the staring point will be returned in the result. If false, it is not included.
;
DirEnumerateDirectoriesGetPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
directoryKind			 ds.l   1		; offset: $3E (62)		;  --> enumerate catalogs bearing this signature 
startingDirectoryName	 ds.l   1		; offset: $42 (66)		;  --> staring catalog name 
startingDirDiscriminator ds.l   2		; offset: $46 (70)		;  --> staring catalog discriminator 
eReserved				 ds.l   1		; offset: $4E (78)		;  --  
fReserved				 ds.l   1		; offset: $52 (82)		;  --  
gReserved				 ds.l   1		; offset: $56 (86)		;  --  
hReserved				 ds.l   1		; offset: $5A (90)		;  --  
includeStartingPoint	 ds.b   1		; offset: $5E (94)		;  --> if true return the catalog specified by starting point 
padByte					 ds.b   1		; offset: $5F (95)
i1Reserved				 ds.w   1		; offset: $60 (96)		;  --  
getBuffer				 ds.l   1		; offset: $62 (98)		;  --> 
getBufferSize			 ds.l   1		; offset: $66 (102)		;  --> 
sizeof					 EQU *			; size:   $6A (106)
						ENDR

; typedef struct DirEnumerateDirectoriesGetPB  DirEnumerateDirectoriesGetPB
; typedef ForEachDirectoryUPP  ForEachDirectory
;
;EnumerateDirectoriesParse:
;The catalog info returned in 'getBuffer' from the EnumerateDirectoriesGet call
;can be extracted using the EnumerateDirectoriesParse call. 'eachDirectory' will
;be called for each catalog.
;
;Returning true from any call-back will terminate the EnumerateDirectoriesParse call.
;
;For synchronous calls, the call-back routine actually runs as part of the same thread
;of execution as the thread that made the EnumerateDirectoriesParse call.  That means that the
;same low-memory globals, A5, stack, etc. are in effect during the call-back
;that were in effect when the call was made.  Because of this, the call-back
;routine has the same restrictions as the caller of EnumerateDirectoriesParse:
;if EnumerateDirectoriesParse was not called from interrupt level, then the call-
;back routine can allocate memory. For asynchronous calls, call-back routine is
;like a ioCompletion except that A5 will be preserved for the application.
;
;eachDirectory will be called each time to return to the client a
;DirectoryName, DirDiscriminator, and features for that catalog.
;
DirEnumerateDirectoriesParsePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aReserved				 ds.l   1		; offset: $3E (62)		;  --  
bReserved				 ds.l   1		; offset: $42 (66)		;  --  
cReserved				 ds.l   1		; offset: $46 (70)		;  --  
dReserved				 ds.l   1		; offset: $4A (74)		;  --  
eachDirectory			 ds.l   1		; offset: $4E (78)		;  --> 
fReserved				 ds.l   1		; offset: $52 (82)		;  --  
gReserved				 ds.l   1		; offset: $56 (86)		;  --  
hReserved				 ds.l   1		; offset: $5A (90)		;  --  
iReserved				 ds.l   1		; offset: $5E (94)		;  --  
getBuffer				 ds.l   1		; offset: $62 (98)		;  --> 
getBufferSize			 ds.l   1		; offset: $66 (102)		;  --> 
sizeof					 EQU *			; size:   $6A (106)
						ENDR

; typedef struct DirEnumerateDirectoriesParsePB  DirEnumerateDirectoriesParsePB
;
;The Following five call are specific to ADAP Catalogs. Toolbox
;remembers a list of catalogs across boots. If any catalog service
;call is intended for a ADAP catalog, then it must be in the list.
;In order for managing this list, A client (Probably DE will use these
;calls.
;DirAddADAPDirectoryPB: Add a new ADAP catalog to the list.
;DirRemoveADAPDirectory: Remove a ADAP catalog from the list.
;DirNetSearchADAPDirectoriesGet:   search an internet for adas catalogs.
;DirNetSearchADAPDirectoriesParse: extract the results obtained NetSearchADAPDirectoriesGet.
;DirFindADAPDirectoryByNetSearch: Find a specified catalog through net search.
;
;
;NetSearchADAPDirectoriesGet:
;This call can be used to make a network wide search for finding ADAP catalogs.
;This call will be supported only by 'ADAP' and involve highly expensive
;network operations, so the user is advised to use utmost discretion before
;making this call. The results will be collected in the 'getbuffer' and can be
;extracted using NetSearchADAPDirectoriesParse call. The directoryName,
;the directoryDiscriminator, features and serverHint (AppleTalk address for
;a PathFinder serving that catalog) are collected for each catalog found
;on the network. If buffer is too small to hold all the catalogs found on
;the network, a 'kOCEMoreData' error will be returned.
;
DirNetSearchADAPDirectoriesGetPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
getBuffer				 ds.l   1		; offset: $3E (62)		;  --> 
getBufferSize			 ds.l   1		; offset: $42 (66)		;  --> 
cReserved				 ds.l   1		; offset: $46 (70)		;  --  
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct DirNetSearchADAPDirectoriesGetPB  DirNetSearchADAPDirectoriesGetPB
; typedef ForEachADAPDirectoryUPP  ForEachADAPDirectory
;
;DirNetSearchADAPDirectoriesParse:
;This call can be used to extract the results obtained in the 'getBuffer'.
;The directoryName, directoryDiscriminator, features and
;serverHint (AppleTalk address for a PathFinder serving that catalog) are
;returned in each call-back. These values may be used to make an
;AddADAPDirectory call.
;
;Returning TRUE from any call-back will terminate the NetSearchADAPDirectoriesParse request.
;
;For synchronous calls, the call-back routine actually runs as part of the same thread
;of execution as the thread that made the DirNetSearchADAPDirectoriesParse call. That means that the
;same low-memory globals, A5, stack, etc. are in effect during the call-back
;that were in effect when the call was made.  Because of this, the call-back
;routine has the same restrictions as the caller of DirNetSearchADAPDirectoriesParse:
;if DirNetSearchADAPDirectoriesParse was not called from interrupt level, then the call-
;back routine can allocate memory. For asynchronous calls, call-back routine is
;like a ioCompletion except that A5 will be preserved for the application.
;
DirNetSearchADAPDirectoriesParsePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
getBuffer				 ds.l   1		; offset: $3E (62)		;  --> 
getBufferSize			 ds.l   1		; offset: $42 (66)		;  --> 
eachADAPDirectory		 ds.l   1		; offset: $46 (70)		;  --> 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct DirNetSearchADAPDirectoriesParsePB  DirNetSearchADAPDirectoriesParsePB
;
;DirFindADAPDirectoryByNetSearch:
;This call can be used to make a network wide search to find an ADAP catalog.
;This call will be supported only by 'ADAP' and involves highly expensive
;network operations, so the user is advised to use utmost discretion before
;making this call. The catalog is specified using directoryName and discriminator.
;If 'addToOCESetup' is true, the catalog will be automatically added to the setup
;list and will be visible through the EnumerateDirectories call and also
;also a creationID to the directoryRecord will be returned.
;If this parameter is set to 'false', the catalog will be added to temporary list
;and will be available for making other catalog service calls. The catalogs
;which are not in the preference catalog list will not be visible through the
;EnumerateDirectories call.
;
DirFindADAPDirectoryByNetSearchPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
directoryName			 ds.l   1		; offset: $3E (62)		;  --> catalog name 
discriminator			 ds.l   2		; offset: $42 (66)		;  --> discriminate between dup catalog names 
addToOCESetup			 ds.b   1		; offset: $4A (74)		;  --> add this catalog to OCE Setup List 
padByte					 ds.b   1		; offset: $4B (75)
directoryRecordCID		 ds.l   2		; offset: $4C (76)		; <--  creationID for the catalog record 
sizeof					 EQU *			; size:   $54 (84)
						ENDR

; typedef struct DirFindADAPDirectoryByNetSearchPB  DirFindADAPDirectoryByNetSearchPB
;
;DirAddADAPDirectory:
;The catalog specified by 'directoryName' and 'discriminator' will be
;added to the list of catalogs maintained by the Toolbox. Once added,
;the catalog is available across boots, until the catalog is removed
;explicitly through a DirRemoveADAPDirectory call.
;If 'serverHint' is not nil, the address provided will be used
;to contact a PathFinder for the catalog specified.
;If 'serverHint' is nil or does not point to a valid PathFinder server
;for that catalog, this call will fail.
;If 'addToOCESetup' is true, the catalog will be automatically added to the setup
;catalog list and will be visible through EnumerateDirectories calls and
;also a creationID to the directoryRecord will be returned.
;If this parameter is set to 'false', catalog will be added to temprary list
;and will be available for making other catalog service calls. The catalogs
;which are not in the setup  list will not be visible through
;EnumerateDirectories call.
;
DirAddADAPDirectoryPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
directoryName			 ds.l   1		; offset: $3E (62)		;  --> catalog name 
discriminator			 ds.l   2		; offset: $42 (66)		;  --> discriminate between dup catalog names 
addToOCESetup			 ds.b   1		; offset: $4A (74)		;  --> add this catalog to OCE Setup 
padByte					 ds.b   1		; offset: $4B (75)
directoryRecordCID		 ds.l   2		; offset: $4C (76)		; <--  creationID for the catalog record 
sizeof					 EQU *			; size:   $54 (84)
						ENDR

; typedef struct DirAddADAPDirectoryPB  DirAddADAPDirectoryPB
;
;GetDirectoryInfo:
;DirGetDirectoryInfo will do:
;
;If a 'dsRefNum' is non-Zero, the catalog information for
;	the corresponding  PAB will be  returned.
; If 'dsRefNum' is zero and 'serverHint' is non-zero, If the
; 'serverHint' points to a valid ADAP Catalog Server(Path Finder),
; the catalog information (i.e. directoryName, discriminator, features)
; for that catalog will be returned.
;	If a  valid catalog name and discriminator are provided
;	features (Set of capability flags) for that catalog will be returned.
;
DirGetDirectoryInfoPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
directoryName			 ds.l   1		; offset: $3E (62)		;  --> catalog name 
discriminator			 ds.l   2		; offset: $42 (66)		; <--> descriminate between dup catalog names 
features				 ds.l   1		; offset: $4A (74)		; <--  capability bit flags 
sizeof					 EQU *			; size:   $4E (78)
						ENDR

; typedef struct DirGetDirectoryInfoPB  DirGetDirectoryInfoPB
;
; * Note on Access Controls:
; * Access control is based on a list model.
; * You can get access controls list which gives dsObject and accMask for each dsObject.
; * GetAccessControl can be limited to currently supplied identity by setting forCurrentUserOnly.
; * There are special DSObjects are defined in ADASTypes.h for each of the category
; * supported in ADAS Catalogs. (kOwner, kFriends, kAuthenticatedToCluster, 
; * kAuthenticatedToDirectory, kGuest) and DUGetActlDSSpec call can be used
; * to obtain appropraiate DSSpec before making set calls to ADAS catalogs.
; *
; 
;
;	GetDNodeAccessControlGet:
;	This call can be done to get back access control list for a DNode.
;	pRLI -> RLI of the DNode whose access control list is sought
;	curUserAccMask -> If this is 'true', Access controls for the user specified by
;	                  the identity parameter will be returned other wise entire list
;					  will be returned.
;	startingDsObj  -> If this is not nil, list should be started after this object.
;	startingPointInclusive -> If staringDsObj is specified, include that in the returned
;	                          results.
;							  
;	The results will be collected in the 'getBuffer' supplied by the user.
;	If buffer can not hold all the data returned 'daMoreData' error will be returned.
;	 
;	If user receives 'noErr' or 'daMoreData', buffer will contain valid results. A user
;	can extract the results in the 'getBuffer' by making 'DsGetDNodeAccessControlParse' call.
;	
;	Results returned for each DSObject will contain DSSpecPtr and three sets of access mask. 
;
;
DirGetDNodeAccessControlGetPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
pRLI					 ds.l   1		; offset: $3E (62)		;  -> RLI of the cluster whose access control list is sought  
bReserved				 ds.l   1		; offset: $42 (66)		;  -- unused 
cReserved				 ds.l   1		; offset: $46 (70)		;  -- unused 
dReserved				 ds.l   1		; offset: $4A (74)		;  -- unused 
eResreved				 ds.l   1		; offset: $4E (78)		; --> 
forCurrentUserOnly		 ds.b   1		; offset: $52 (82)		; -->  
filler1					 ds.b   1		; offset: $53 (83)
startingPoint			 ds.l   1		; offset: $54 (84)		; --> starting Point 
includeStartingPoint	 ds.b   1		; offset: $58 (88)		;  -> if true return the DsObject 
;																specified in starting point 
filler2					 ds.b   1		; offset: $59 (89)
getBuffer				 ds.l   1		; offset: $5A (90)		;	-> 
getBufferSize			 ds.l   1		; offset: $5E (94)		;  -> 
sizeof					 EQU *			; size:   $62 (98)
						ENDR

; typedef struct DirGetDNodeAccessControlGetPB  DirGetDNodeAccessControlGetPB
; The Access Control call-back function is defined as follows: 
; typedef ForEachDNodeAccessControlUPP  ForEachDNodeAccessControl
;
;	GetDNodeAccessControlParse:
;	After an GetDNodeAccessControlGet call has completed, 
;	call GetDNodeAccessControlParse to parse through the buffer that
;	that was filled in GetDNodeAccessControlGet.
;	
;	'eachObject' will be called each time to return to the client a
;	DsObject and a set of three accMasks (three long words) for that object.
;	Acceesmasks returned apply to the dsObject in the callback :
;	1. Currently Active Access mask for the specified DNode.
;	2. Default Access mask for any Record in the DNode
;	3. Default Access mask for any Attribute in the DNode
;	The clientData parameter that you pass in the parameter block will be passed
;	to 'eachObject'.  You are free to put anything in clientData - it is intended
;	to allow you some way to match the call-back to the original call (for
;	example, you make more then one aysynchronous GetDNodeAccessControlGet calls and you want to
;	associate returned results in some way).
;	
;	The client should return FALSE from 'eachObject' to continue
;	processing of the GetDNodeAccessControlParse request.  Returning TRUE will
;	terminate the GetDNodeAccessControlParse request.
;
;	For synchronous calls, the call-back routine actually runs as part of the same thread 
;	of execution as the thread that made the GetDNodeAccessControlParse call.  That means that the
;	same low-memory globals, A5, stack, etc. are in effect during the call-back
;	that were in effect when the call was made.  Because of this, the call-back
;	routine has the same restrictions as the caller of GetDNodeAccessControlParse:
;	if GetDNodeAccessControlParse was not called from interrupt level, then the call-
;	back routine can allocate memory. For asynchronous calls, call-back routine is
;	like a ioCompletion except that A5 will be preserved for the application.
;
;
;
DirGetDNodeAccessControlParsePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
pRLI					 ds.l   1		; offset: $3E (62)		;  -> RLI of the cluster  
bReserved				 ds.l   1		; offset: $42 (66)		;  -- unused 
cReserved				 ds.l   1		; offset: $46 (70)		;  -- unused 
dReserved				 ds.l   1		; offset: $4A (74)		;  -- unused 
eachObject				 ds.l   1		; offset: $4E (78)		; --> 
forCurrentUserOnly		 ds.b   1		; offset: $52 (82)		; -->  
filler1					 ds.b   1		; offset: $53 (83)
startingPoint			 ds.l   1		; offset: $54 (84)		; --> starting Point 
includeStartingPoint	 ds.b   1		; offset: $58 (88)		;  -> if true return the record 
;														specified in starting point 
filler2					 ds.b   1		; offset: $59 (89)
getBuffer				 ds.l   1		; offset: $5A (90)		;	-> 
getBufferSize			 ds.l   1		; offset: $5E (94)		;  -> 
sizeof					 EQU *			; size:   $62 (98)
						ENDR

; typedef struct DirGetDNodeAccessControlParsePB  DirGetDNodeAccessControlParsePB
;
;	GetRecordAccessControlGet:
;	This call can be done to get back access control list for a RecordID.
;	aRecord -> RecordID to which access control list is sought
;	curUserAccMask -> If this is 'true', Access controls for the user specified by
;	                  the identity parameter will be returned other wise entire list
;					  will be returned.
;	startingDsObj  -> If this is not nil, list should be started after this object.
;	startingPointInclusive -> If staringDsObj is specified, include that in the returned
;	                          results.
;							  
;	The results will be collected in the 'getBuffer' supplied by the user.
;	If buffer can not hold all the data returned 'daMoreData' error will be returned.
;	 
;	If user receives 'noErr' or 'daMoreData', buffer will contain valid results. A user
;	can extract the results in the 'getBuffer' by making 'DsGetDNodeAccessControlParse' call.
;	
;	Results returned for each DSObject will contain DSSpecPtr and accMask. 
;
;
DirGetRecordAccessControlGetPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  -> RecordID to which access control list is sought list is sought  
bReserved				 ds.l   1		; offset: $42 (66)		;  -- unused 
cReserved				 ds.l   1		; offset: $46 (70)		;  -- unused 
dReserved				 ds.l   1		; offset: $4A (74)		;  -- unused 
eResreved				 ds.l   1		; offset: $4E (78)		; --> 
forCurrentUserOnly		 ds.b   1		; offset: $52 (82)		; -->  
filler1					 ds.b   1		; offset: $53 (83)
startingPoint			 ds.l   1		; offset: $54 (84)		; --> starting Point 
includeStartingPoint	 ds.b   1		; offset: $58 (88)		;  -> if true return the DsObject 
;																specified in starting point 
filler2					 ds.b   1		; offset: $59 (89)
getBuffer				 ds.l   1		; offset: $5A (90)		;	-> 
getBufferSize			 ds.l   1		; offset: $5E (94)		;  -> 
sizeof					 EQU *			; size:   $62 (98)
						ENDR

; typedef struct DirGetRecordAccessControlGetPB  DirGetRecordAccessControlGetPB
; The Access Control call-back function is defined as follows: 
; typedef ForEachRecordAccessControlUPP  ForEachRecordAccessControl
;
;	GetRecordAccessControlParse:
;	After an GetRecordAccessControlGet call has completed, 
;	call GetRecordAccessControlParse to parse through the buffer that
;	that was filled in GetRecordAccessControlGet.
;	
;	'eachObject' will be called each time to return to the client a
;	DsObject and a set of three accMasks (three long words) for that object.
;	Acceesmasks returned apply to the dsObject in the callback :
;	1. Active Access mask for the DNode Containing the Record.
;	2. Active Access mask for the Record specified.
;	3. Defualt Access mask for Attributes in the record.
;	The clientData parameter that you pass in the parameter block will be passed
;	to 'eachObject'.  You are free to put anything in clientData - it is intended
;	to allow you some way to match the call-back to the original call (for
;	example, you make more then one aysynchronous GetRecordAccessControlGet calls and you want to
;	associate returned results in some way).
;	
;	The client should return FALSE from 'eachObject' to continue
;	processing of the GetRecordAccessControlParse request.  Returning TRUE will
;	terminate the GetRecordAccessControlParse request.
;
;	For synchronous calls, the call-back routine actually runs as part of the same thread 
;	of execution as the thread that made the GetRecordAccessControlParse call.  That means that the
;	same low-memory globals, A5, stack, etc. are in effect during the call-back
;	that were in effect when the call was made.  Because of this, the call-back
;	routine has the same restrictions as the caller of GetRecordAccessControlParse:
;	if GetRecordAccessControlParse was not called from interrupt level, then the call-
;	back routine can allocate memory. For asynchronous calls, call-back routine is
;	like a ioCompletion except that A5 will be preserved for the application.
;
;
;
DirGetRecordAccessControlParsePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  -> RecordID to which access control list is sought list is sought  
bReserved				 ds.l   1		; offset: $42 (66)		;  -- unused 
cReserved				 ds.l   1		; offset: $46 (70)		;  -- unused 
dReserved				 ds.l   1		; offset: $4A (74)		;  -- unused 
eachObject				 ds.l   1		; offset: $4E (78)		; --> 
forCurrentUserOnly		 ds.b   1		; offset: $52 (82)		; -->  
filler1					 ds.b   1		; offset: $53 (83)
startingPoint			 ds.l   1		; offset: $54 (84)		; --> starting Point 
includeStartingPoint	 ds.b   1		; offset: $58 (88)		;  -> if true return the record 
;														specified in starting point 
filler2					 ds.b   1		; offset: $59 (89)
getBuffer				 ds.l   1		; offset: $5A (90)		;	-> 
getBufferSize			 ds.l   1		; offset: $5E (94)		;  -> 
sizeof					 EQU *			; size:   $62 (98)
						ENDR

; typedef struct DirGetRecordAccessControlParsePB  DirGetRecordAccessControlParsePB
;
;	GetAttributeAccessControlGet:
;	This call can be done to get back access control list for a attributeType with in a RecordID.
;	aRecord -> RecordID to which access control list is sought
;	aType	-> Attribute Type to which access controls are sought
;	curUserAccMask -> If this is 'true', Access controls for the user specified by
;	                  the identity parameter will be returned other wise entire list
;					  will be returned.
;	startingDsObj  -> If this is not nil, list should be started after this object.
;	startingPointInclusive -> If staringDsObj is specified, include that in the returned
;	                          results.
;							  
;	The results will be collected in the 'getBuffer' supplied by the user.
;	If buffer can not hold all the data returned 'daMoreData' error will be returned.
;	 
;	If user receives 'noErr' or 'daMoreData', buffer will contain valid results. A user
;	can extract the results in the 'getBuffer' by making 'DsGetDNodeAccessControlParse' call.
;	
;	Results returned for each DSObject will contain DSSpecPtr and accMask. 
;
;
DirGetAttributeAccessControlGetPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  -> RecordID to which access control list is sought list is sought  
aType					 ds.l   1		; offset: $42 (66)		;  -> Attribute Type to which access controls are sought          
cReserved				 ds.l   1		; offset: $46 (70)		;  -- unused 
dReserved				 ds.l   1		; offset: $4A (74)		;  -- unused 
eResreved				 ds.l   1		; offset: $4E (78)		; --> 
forCurrentUserOnly		 ds.b   1		; offset: $52 (82)		; -->  
filler1					 ds.b   1		; offset: $53 (83)
startingPoint			 ds.l   1		; offset: $54 (84)		; --> starting Point 
includeStartingPoint	 ds.b   1		; offset: $58 (88)		;  -> if true return the DsObject 
;																specified in starting point 
filler2					 ds.b   1		; offset: $59 (89)
getBuffer				 ds.l   1		; offset: $5A (90)		;	-> 
getBufferSize			 ds.l   1		; offset: $5E (94)		;  -> 
sizeof					 EQU *			; size:   $62 (98)
						ENDR

; typedef struct DirGetAttributeAccessControlGetPB  DirGetAttributeAccessControlGetPB
; The Access Control call-back function is defined as follows: 
; typedef ForEachAttributeAccessControlUPP  ForEachAttributeAccessControl
;
;	GetAttributeAccessControlParse:
;	After an GetAttributeAccessControlGet call has completed, 
;	call GetAttributeAccessControlParse to parse through the buffer that
;	that was filled in GetAttributeAccessControlGet.
;	
;	'eachObject' will be called each time to return to the client a
;	DsObject and a set of three accMasks (three long words) for that object.
;	Acceesmasks returned apply to the dsObject in the callback :
;	1. Active Access mask for the DNode Containing the Attribute.
;	2. Active Access mask for the Record in the Containing the Attribute.
;	3. Active Access mask for the specified Attribute.
;	The clientData parameter that you pass in the parameter block will be passed
;	to 'eachObject'.  You are free to put anything in clientData - it is intended
;	to allow you some way to match the call-back to the original call (for
;	example, you make more then one aysynchronous GetAttributeAccessControlGet calls and you want to
;	associate returned results in some way).
;	
;	The client should return FALSE from 'eachObject' to continue
;	processing of the GetAttributeAccessControlParse request.  Returning TRUE will
;	terminate the GetAttributeAccessControlParse request.
;
;	For synchronous calls, the call-back routine actually runs as part of the same thread 
;	of execution as the thread that made the GetAttributeAccessControlParse call.  That means that the
;	same low-memory globals, A5, stack, etc. are in effect during the call-back
;	that were in effect when the call was made.  Because of this, the call-back
;	routine has the same restrictions as the caller of GetAttributeAccessControlParse:
;	if GetAttributeAccessControlParse was not called from interrupt level, then the call-
;	back routine can allocate memory. For asynchronous calls, call-back routine is
;	like a ioCompletion except that A5 will be preserved for the application.
;
;
;
DirGetAttributeAccessControlParsePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
aRecord					 ds.l   1		; offset: $3E (62)		;  -> RecordID to which access control list is sought list is sought  
aType					 ds.l   1		; offset: $42 (66)		;  -> Attribute Type to which access controls are sought          
cReserved				 ds.l   1		; offset: $46 (70)		;  -- unused 
dReserved				 ds.l   1		; offset: $4A (74)		;  -- unused 
eachObject				 ds.l   1		; offset: $4E (78)		; --> 
forCurrentUserOnly		 ds.b   1		; offset: $52 (82)		; -->  
filler1					 ds.b   1		; offset: $53 (83)
startingPoint			 ds.l   1		; offset: $54 (84)		; --> starting Point 
includeStartingPoint	 ds.b   1		; offset: $58 (88)		;  -> if true return the record 
;														specified in starting point 
filler2					 ds.b   1		; offset: $59 (89)
getBuffer				 ds.l   1		; offset: $5A (90)		;	-> 
getBufferSize			 ds.l   1		; offset: $5E (94)		;  -> 
sizeof					 EQU *			; size:   $62 (98)
						ENDR

; typedef struct DirGetAttributeAccessControlParsePB  DirGetAttributeAccessControlParsePB
;
;MapPathNameToDNodeNumber:
;This call maps a given PathName within a catalog to its DNodeNumber.
;
DirMapPathNameToDNodeNumberPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
directoryName			 ds.l   1		; offset: $3E (62)		;  --> catalog name 
discriminator			 ds.l   2		; offset: $42 (66)		;  --> discriminator 
dNodeNumber				 ds.l   1		; offset: $4A (74)		; <--  dNodenumber to the path 
path					 ds.l   1		; offset: $4E (78)		;  --> Path Name to be mapped 
sizeof					 EQU *			; size:   $52 (82)
						ENDR

; typedef struct DirMapPathNameToDNodeNumberPB  DirMapPathNameToDNodeNumberPB
;
;PathName in the path field will be mapped to the cooresponding dNodeNumber and
;returned in the DNodeNumber field. directoryName and descriminator Fields are
;ignored. DSRefNum is used to identify the catalog.
;
;
;MapDNodeNumberToPathName:
;This call will map a given DNodeNumber with in a catalog to the
;corresponding PathName.
;
DirMapDNodeNumberToPathNamePB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
directoryName			 ds.l   1		; offset: $3E (62)		;  --> catalog name 
discriminator			 ds.l   2		; offset: $42 (66)		;  --> discriminator 
dNodeNumber				 ds.l   1		; offset: $4A (74)		;  --> dNodenumber to be mapped 
path					 ds.l   1		; offset: $4E (78)		; <--  Packed Path Name returned 
lengthOfPathName		 ds.w   1		; offset: $52 (82)		;  --> length of packed pathName structure
sizeof					 EQU *			; size:   $54 (84)
						ENDR

; typedef struct DirMapDNodeNumberToPathNamePB  DirMapDNodeNumberToPathNamePB
;
;dNodeNumber in the DNodeNumber field will be mapped to the cooresponding
;pathName and returned in the PackedPathName field.
;lengthOfPathName is to be set the length of pathName structure.
;If length of PackedPathName is larger then the lengthOfPathName, kOCEMoreData
;OSErr will be returned.
;
;
;GetLocalNetworkSpec:
;This call will return the Local NetworkSpec. Client should supply
;an RString big enough to hold the NetworkSpec.
;
DirGetLocalNetworkSpecPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
directoryName			 ds.l   1		; offset: $3E (62)		;  --> catalog name 
discriminator			 ds.l   2		; offset: $42 (66)		;  --> discriminator 
networkSpec				 ds.l   1		; offset: $4A (74)		; <--  NetworkSpec 
sizeof					 EQU *			; size:   $4E (78)
						ENDR

; typedef struct DirGetLocalNetworkSpecPB  DirGetLocalNetworkSpecPB
;
;PathName in the path field must be set to nil. internetName should be large
;enough to hold the internetName. InterNetname returned indicates path finder's
;local internet (configured by administrator).
;
;
;GetDNodeInfo:
;This call will return the information (internetName and descriptor)
;for the given RLI of a DNode.
;
DirGetDNodeInfoPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
pRLI					 ds.l   1		; offset: $3E (62)		;  --> packed RLI whose info is requested 
descriptor				 ds.l   1		; offset: $42 (66)		; <--  dNode descriptor 
networkSpec				 ds.l   1		; offset: $46 (70)		; <--  cluster's networkSpec if kIsCluster 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct DirGetDNodeInfoPB  DirGetDNodeInfoPB
;
;If DnodeNumber is set to a non zero value, path should be set to nil.
;if DnodeNumber is set to zero, pathName should point to a packed path name.
;internetName should be large enough to hold
;the internetName. (If the internetName is same as the one got by
;GetLocalInternetName call, it indicates cluster is reachable  without
;forwarders, --> Tell me if I am wrong)
;
;
;DirCreatePersonalDirectory:
;A new  personal catalog can be created by specifying an FSSpec for
;the file. If a file already exists dupFNErr will be returned. This call is
;supported 'synchronous' mode only.
;
DirCreatePersonalDirectoryPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
fsSpec					 ds.l   1		; offset: $3E (62)		;  --> FSSpec for the Personal Catalog 
fdType					 ds.l   1		; offset: $42 (66)		;  --> file type for the Personal Catalog 
fdCreator				 ds.l   1		; offset: $46 (70)		;  --> file creator for the Personal Catalog 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct DirCreatePersonalDirectoryPB  DirCreatePersonalDirectoryPB
;
;DirOpenPersonalDirectory:
;An existing personal catalog can be opened using this call.
;User can specify the personal catalog by FSSpec for the AddressBook file.
;'accessRequested' field specifies open permissions. 'fsRdPerm'  & 'fsRdWrPerm'
;are the only accepted open modes for the address book.
;When the call completes successfully, a dsRefNum will be returned. The 'dsRefNum'
;field is in the DSParamBlockHeader. In addittion 'accessGranted' indicates
;actual permission with personal catalog is opened and 'features' indicate the capabilty flags
;associated with the personal catalog.
;This call is supported 'synchronous' mode only.
;
DirOpenPersonalDirectoryPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
fsSpec					 ds.l   1		; offset: $3E (62)		;  --> Open an existing Personal Catalog 
accessRequested			 ds.b   1		; offset: $42 (66)		;  --> Open: permissions Requested(byte)
accessGranted			 ds.b   1		; offset: $43 (67)		;  <-- Open: permissions (byte) (Granted)
features				 ds.l   1		; offset: $44 (68)		; <--  features for Personal Catalog 
sizeof					 EQU *			; size:   $48 (72)
						ENDR

; typedef struct DirOpenPersonalDirectoryPB  DirOpenPersonalDirectoryPB
;
;DirClosePersonalDirectory: This call lets a client close AddressBook opened by DirOpenPersonalDirectory.
;The Personal Catalog specified by the 'dsRefNum' will be closed.
;This call is supported 'synchronous' mode only.
;
DirClosePersonalDirectoryPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
sizeof					 EQU *			; size:   $3E (62)
						ENDR

; typedef struct DirClosePersonalDirectoryPB  DirClosePersonalDirectoryPB
;
;DirMakePersonalDirectoryRLI: With this call a client can make an RLI
;for a Personal Catalog opened by DirOpenPersonalDirectory Call.
;A packed RLI is created for the Personal Catalog specified by the 'dsRefNum'.
;If a client has a need to make the AddressBook reference to persistent
;acrross boots it should make use of this call. In the current implementaion
;PackedRLI has an embeeded System7.0 'alias'. If in later time
;If client has a need to make reference to the AddressBook, it must use
;ADAPLibrary call 'DUExtractAlias' and resole the 'alias' to 'FSSpec' and
;make DirOpenPersonalDirectory call to get a 'dsRefNum'.
;  'fromFSSpec'			FSPecPtr from which relative alias to be created. If nil,
;						absolute alias is created.
; 'pRLIBufferSize' indicates the size of buffer pointed by 'pRLI'
; 'pRLISize'	indicates the actual length of 'pRLI'. If the call
;						fails with 'kOCEMoreData' error a client can reissue
;					this call with a larger buffer of this length.
;  'pRLI' is pointer to the buffer in which 'PackedRLI' is
;  returned.
;This call is supported in 'synchronous' mode only.
;
DirMakePersonalDirectoryRLIPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
fromFSSpec				 ds.l   1		; offset: $3E (62)		;  --> FSSpec for creating relative alia 
pRLIBufferSize			 ds.w   1		; offset: $42 (66)		;  --> Length of 'pRLI' buffer 
pRLISize				 ds.w   1		; offset: $44 (68)		; <--  Length of actual 'pRLI' 
pRLI					 ds.l   1		; offset: $46 (70)		; <--  pRLI for the specified AddressBook 
sizeof					 EQU *			; size:   $4A (74)
						ENDR

; typedef struct DirMakePersonalDirectoryRLIPB  DirMakePersonalDirectoryRLIPB
;****************************************************************************
;The calls described below apply only for CSAM Drivers:
;
;The following three calls provide capability to Install/Remove a CSAM at RunTime.
;	DirAddDSAM
;	DirRemoveDSAM
;	DirInstantiateDSAM
;
;The following two calls provide capability to Install/Remove a CSAM Catalog at RunTime.
;	DirAddDSAMDirectory
;	DirRemoveDirectory
;
;DirGetDirectoryIcon call is used by clients to get any special icon associated
;with a CSAM catalog.
;
;****************************************************************************
;
;DirAddDSAM: This call can be used to inorm the availability of a CSAM file
;after discovering the CSAM file.
;	dsamName -> is generic CSAM name e.g. Untitled X.500 directory
;	dsamSignature -> could be generic CSAM kind e.g. 'X500'.
;	fsSpec -> is the FileSpec for the file containing CSAM resources.
;If the call is successfull 'DSAMRecordCID' will be returned. If the
;call returns 'daDSAMRecordCIDExists', record was already there and
;'dsamRecordCID' will be returned.
;This call can be done only in synchronous mode.
;
DirAddDSAMPB 			RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
dsamRecordCID			 ds.l   2		; offset: $3E (62)		; <--  CreationID for the CSAM record 
dsamName				 ds.l   1		; offset: $46 (70)		;  --> CSAM name 
dsamKind				 ds.l   1		; offset: $4A (74)		;  --> CSAM kind 
fsSpec					 ds.l   1		; offset: $4E (78)		;  --> FSSpec for the file containing CSAM 
sizeof					 EQU *			; size:   $52 (82)
						ENDR

; typedef struct DirAddDSAMPB  DirAddDSAMPB
;
;DirInstantiateDSAM: This call should be used by the CSAM driver in response
;Driver Open call to indicate the toolbox about the availability of the CSAM.
;	dsamName -> is generic CSAM name e.g. Untitled X.500 directory
;	dsamKind -> could be generic CSAM kind e.g. 'X500'.
;	dsamData -> pointer to private DSAMData. This will be paased back to the CSAM
;	when the CSAM functions (DSAMDirProc,DSAMDirParseProc, DSAMAuthProc) are called.
;	CSAM should already be setup using DirAddDSAM call.
;	DSAMDirProc -> This procedure will be called when  any catalog service
;	call intended for the CSAM (other then parse calls)
;	DSAMDirParseProc -> This procedure will be called when any of the parse calls
;	are called.
;	DSAMAuthProc -> This procedure will be called when any of the Authentication Calls
;	are made to the CSAM. If the CSAM does not support authentication, this can be nil.
;This call can be done only in synchronous mode.
;
; typedef DSAMDirUPP 		DSAMDirProc
; typedef DSAMDirParseUPP 	DSAMDirParseProc
; typedef DSAMAuthUPP 		DSAMAuthProc
DirInstantiateDSAMPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
dsamName				 ds.l   1		; offset: $3E (62)		;  --> dsamName name 
dsamKind				 ds.l   1		; offset: $42 (66)		;  --> DSAMKind 
dsamData				 ds.l   1		; offset: $46 (70)		;  --> dsamData  
dsamDirProc				 ds.l   1		; offset: $4A (74)		;  --> of type DSAMDirProc: for catalog service calls 
dsamDirParseProc		 ds.l   1		; offset: $4E (78)		;  --> of type DSAMDirParseProc: for catalog service parse calls 
dsamAuthProc			 ds.l   1		; offset: $52 (82)		;  --> of type DSAMAuthProc: for authetication service calls 
sizeof					 EQU *			; size:   $56 (86)
						ENDR

; typedef struct DirInstantiateDSAMPB  DirInstantiateDSAMPB
;
;DirRemoveDSAM: This call can be used to remove  a CSAM file from the OCE Setup.
;	dsamRecordCID -> is the creationID of the CSAM record.
;This call can be made only in synchronous mode.
;
DirRemoveDSAMPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
dsamRecordCID			 ds.l   2		; offset: $3E (62)		; <--  CreationID for the CSAM record 
sizeof					 EQU *			; size:   $46 (70)
						ENDR

; typedef struct DirRemoveDSAMPB  DirRemoveDSAMPB
;
;DirAddDSAMDirectory: This call can be used to inorm the availability of a CSAM catalog.
;	dsamRecordCID ->  recordID for the CSAM serving this catalog
;	directoryName ->  name of the catalog
;	discriminator -> discriminator for the catalog
;	directoryRecordCID -> If the call is successful, creationID for the record will
;							be returned.
;
DirAddDSAMDirectoryPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
dsamRecordCID			 ds.l   2		; offset: $3E (62)		;  --> CreationID for the CSAM record 
directoryName			 ds.l   1		; offset: $46 (70)		;  --> catalog name 
discriminator			 ds.l   2		; offset: $4A (74)		;  --> catalog discriminator 
features				 ds.l   1		; offset: $52 (82)		;  --> capabilty flags for the catalog 
directoryRecordCID		 ds.l   2		; offset: $56 (86)		; <--  creationID for the catalog record 
sizeof					 EQU *			; size:   $5E (94)
						ENDR

; typedef struct DirAddDSAMDirectoryPB  DirAddDSAMDirectoryPB
;
;DirRemoveDirectory: This call can be used to inform the toolbox that
;catalog specified by 'directoryRecordCID'
;
DirRemoveDirectoryPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
directoryRecordCID		 ds.l   2		; offset: $3E (62)		;  --> creationID for the catalog record 
sizeof					 EQU *			; size:   $46 (70)
						ENDR

; typedef struct DirRemoveDirectoryPB  DirRemoveDirectoryPB
;
; * DSGetExtendedDirectoriesInfo::  This call can be used to get
; * the information of various foreign catalogs supported.
; * Typically a DE Template  may make this call to create a
; * Address template or a Gateway may make this call to findout
; * catalog name space in which MSAM may would support. 
; * Client will supply a buffer pointed by 'bufferPtr' of size 'bufferLength'. 
; * When the call completes with 'daMoreData' error, client can examine 'totalEntries'
; * returned and reissue the call with increaing buffer.
; * Toolbox will findout the private information of each of the Foreign Catalogs
; * by polling CSAM's, Gateways, and MnMServers. The Information returned
; * for each catalog will be packed in the format: 
; * typedef struct EachDirectoryData {
; *  PackedRLI						pRLI;	       //  packed RLI for the catalog
; *  OSType							entnType; 	   //  Entn Type
; *  long							hasMailSlot;   //  If this catalog has mail slot this will be 1 otherwise zero
; *	ProtoRString					RealName;      //  Packed RString for Real Name (padded to even boundary) 
; *	ProtoRString					comment;       //  Packed RString holding any comment for Display (padded to even boundary)
; *	long                			length;        //  data length
; *	char                			data[length];  //  data padded to even boundary
; * };
; *
; *
; *
; * typedef struct myData {
; *      EachDirectoryData	data[numberOfEntries];    // data packed in the above format
; *	};
; *
; 
DirGetExtendedDirectoriesInfoPB RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
buffer					 ds.l   1		; offset: $3E (62)		;  --> Pointer to a buufer where data will be returned 
bufferSize				 ds.l   1		; offset: $42 (66)		;  --> Length of the buffer, Length of actual data will be returned here 
totalEntries			 ds.l   1		; offset: $46 (70)		; <--  Total Number of Catalogs found 
actualEntries			 ds.l   1		; offset: $4A (74)		; <--  Total Number of Catalogs entries returned 
sizeof					 EQU *			; size:   $4E (78)
						ENDR

; typedef struct DirGetExtendedDirectoriesInfoPB  DirGetExtendedDirectoriesInfoPB
;
;DirGetDirectoryIconPB: With this call a client can find out about
;the icons supported by the Catalog.
;Both ADAP and Personal Catalog will not support this call for now.
;A CSAM can support a call so that DE Extension can use this
;call to find appropriate Icons.
;
;Returns kOCEBufferTooSmall if icon is too small, but will update iconSize.
;
DirGetDirectoryIconPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
pRLI					 ds.l   1		; offset: $3E (62)		;  --> packed RLI for the catalog 
iconType				 ds.l   1		; offset: $42 (66)		;  --> Type of Icon requested 
iconBuffer				 ds.l   1		; offset: $46 (70)		;  --> Buffer to hold Icon Data 
bufferSize				 ds.l   1		; offset: $4A (74)		;  <-> size of buffer to hold icon data 
sizeof					 EQU *			; size:   $4E (78)
						ENDR

; typedef struct DirGetDirectoryIconPB  DirGetDirectoryIconPB
;
;DirGetOCESetupRefNum: This call will return 'dsRefnum' for the OCE Setup Personal Catalog
;and oceSetupRecordCID for the oceSetup Record.
;Clients interested in manipulating OCE Setup Personal Catalog directly should
;make this call to get 'dsRefNum'.
;'dsRefNum' will be returned in the standard field in the DirParamHeader.
;
DirGetOCESetupRefNumPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
oceSetupRecordCID		 ds.l   2		; offset: $3E (62)		; --> creationID for the catalog record 
sizeof					 EQU *			; size:   $46 (70)
						ENDR

; typedef struct DirGetOCESetupRefNumPB  DirGetOCESetupRefNumPB
;***************************************************************************
; Catalog and Authentication control blocks and operation definitions 
AuthParamBlock 			RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
						 ORG 0
bindIdentityPB			 ds     AuthBindSpecificIdentityPB ; offset: $0 (0)
						 ORG 0
unbindIdentityPB		 ds     AuthUnbindSpecificIdentityPB ; offset: $0 (0)
						 ORG 0
resolveCreationIDPB		 ds     AuthResolveCreationIDPB ; offset: $0 (0)
						 ORG 0
getIdentityInfoPB		 ds     AuthGetSpecificIdentityInfoPB ; offset: $0 (0)
						 ORG 0
addKeyPB				 ds     AuthAddKeyPB ; offset: $0 (0)
						 ORG 0
changeKeyPB				 ds     AuthChangeKeyPB ; offset: $0 (0)
						 ORG 0
deleteKeyPB				 ds     AuthDeleteKeyPB ; offset: $0 (0)
						 ORG 0
passwordToKeyPB			 ds     AuthPasswordToKeyPB ; offset: $0 (0)
						 ORG 0
getCredentialsPB		 ds     AuthGetCredentialsPB ; offset: $0 (0)
						 ORG 0
decryptCredentialsPB	 ds     AuthDecryptCredentialsPB ; offset: $0 (0)
						 ORG 0
makeChallengePB			 ds     AuthMakeChallengePB ; offset: $0 (0)
						 ORG 0
makeReplyPB				 ds     AuthMakeReplyPB ; offset: $0 (0)
						 ORG 0
verifyReplyPB			 ds     AuthVerifyReplyPB ; offset: $0 (0)
						 ORG 0
getUTCTimePB			 ds     AuthGetUTCTimePB ; offset: $0 (0)
						 ORG 0
makeProxyPB				 ds     AuthMakeProxyPB ; offset: $0 (0)
						 ORG 0
tradeProxyForCredentialsPB ds     AuthTradeProxyForCredentialsPB ; offset: $0 (0)
						 ORG 0
getLocalIdentityPB		 ds     AuthGetLocalIdentityPB ; offset: $0 (0)
						 ORG 0
unLockLocalIdentityPB	 ds     AuthUnlockLocalIdentityPB ; offset: $0 (0)
						 ORG 0
lockLocalIdentityPB		 ds     AuthLockLocalIdentityPB ; offset: $0 (0)
						 ORG 0
localIdentityQInstallPB	 ds     AuthAddToLocalIdentityQueuePB ; offset: $0 (0)
						 ORG 0
localIdentityQRemovePB	 ds     AuthRemoveFromLocalIdentityQueuePB ; offset: $0 (0)
						 ORG 0
setupLocalIdentityPB	 ds     AuthSetupLocalIdentityPB ; offset: $0 (0)
						 ORG 0
changeLocalIdentityPB	 ds     AuthChangeLocalIdentityPB ; offset: $0 (0)
						 ORG 0
removeLocalIdentityPB	 ds     AuthRemoveLocalIdentityPB ; offset: $0 (0)
						 ORG 0
setupDirectoryIdentityPB ds     OCESetupAddDirectoryInfoPB ; offset: $0 (0)
						 ORG 0
changeDirectoryIdentityPB ds     OCESetupChangeDirectoryInfoPB ; offset: $0 (0)
						 ORG 0
removeDirectoryIdentityPB ds     OCESetupRemoveDirectoryInfoPB ; offset: $0 (0)
						 ORG 0
getDirectoryIdentityInfoPB ds     OCESetupGetDirectoryInfoPB ; offset: $0 (0)
						 ORG 98
sizeof					 EQU *			; size:   $62 (98)
						ENDR

DirParamBlock 			RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
reserved1				 ds.l   1		; offset: $4 (4)
reserved2				 ds.l   1		; offset: $8 (8)
ioCompletion			 ds.l   1		; offset: $C (12)
ioResult				 ds.w   1		; offset: $10 (16)
saveA5					 ds.l   1		; offset: $12 (18)
reqCode					 ds.w   1		; offset: $16 (22)
reserved				 ds.l   2		; offset: $18 (24)
serverHint				 ds     AddrBlock ; offset: $20 (32)
dsRefNum				 ds.w   1		; offset: $24 (36)
callID					 ds.l   1		; offset: $26 (38)
identity				 ds.l   1		; offset: $2A (42)
gReserved1				 ds.l   1		; offset: $2E (46)
gReserved2				 ds.l   1		; offset: $32 (50)
gReserved3				 ds.l   1		; offset: $36 (54)
clientData				 ds.l   1		; offset: $3A (58)
						 ORG 0
addRecordPB				 ds     DirAddRecordPB ; offset: $0 (0)
						 ORG 0
deleteRecordPB			 ds     DirDeleteRecordPB ; offset: $0 (0)
						 ORG 0
enumerateGetPB			 ds     DirEnumerateGetPB ; offset: $0 (0)
						 ORG 0
enumerateParsePB		 ds     DirEnumerateParsePB ; offset: $0 (0)
						 ORG 0
findRecordGetPB			 ds     DirFindRecordGetPB ; offset: $0 (0)
						 ORG 0
findRecordParsePB		 ds     DirFindRecordParsePB ; offset: $0 (0)
						 ORG 0
lookupGetPB				 ds     DirLookupGetPB ; offset: $0 (0)
						 ORG 0
lookupParsePB			 ds     DirLookupParsePB ; offset: $0 (0)
						 ORG 0
addAttributeValuePB		 ds     DirAddAttributeValuePB ; offset: $0 (0)
						 ORG 0
deleteAttributeTypePB	 ds     DirDeleteAttributeTypePB ; offset: $0 (0)
						 ORG 0
deleteAttributeValuePB	 ds     DirDeleteAttributeValuePB ; offset: $0 (0)
						 ORG 0
changeAttributeValuePB	 ds     DirChangeAttributeValuePB ; offset: $0 (0)
						 ORG 0
verifyAttributeValuePB	 ds     DirVerifyAttributeValuePB ; offset: $0 (0)
						 ORG 0
findValuePB				 ds     DirFindValuePB ; offset: $0 (0)
						 ORG 0
enumeratePseudonymGetPB	 ds     DirEnumeratePseudonymGetPB ; offset: $0 (0)
						 ORG 0
enumeratePseudonymParsePB ds     DirEnumeratePseudonymParsePB ; offset: $0 (0)
						 ORG 0
addPseudonymPB			 ds     DirAddPseudonymPB ; offset: $0 (0)
						 ORG 0
deletePseudonymPB		 ds     DirDeletePseudonymPB ; offset: $0 (0)
						 ORG 0
addAliasPB				 ds     DirAddAliasPB ; offset: $0 (0)
						 ORG 0
enumerateAttributeTypesGetPB ds     DirEnumerateAttributeTypesGetPB ; offset: $0 (0)
						 ORG 0
enumerateAttributeTypesParsePB ds     DirEnumerateAttributeTypesParsePB ; offset: $0 (0)
						 ORG 0
getNameAndTypePB		 ds     DirGetNameAndTypePB ; offset: $0 (0)
						 ORG 0
setNameAndTypePB		 ds     DirSetNameAndTypePB ; offset: $0 (0)
						 ORG 0
getRecordMetaInfoPB		 ds     DirGetRecordMetaInfoPB ; offset: $0 (0)
						 ORG 0
getDNodeMetaInfoPB		 ds     DirGetDNodeMetaInfoPB ; offset: $0 (0)
						 ORG 0
getDirectoryInfoPB		 ds     DirGetDirectoryInfoPB ; offset: $0 (0)
						 ORG 0
getDNodeAccessControlGetPB ds     DirGetDNodeAccessControlGetPB ; offset: $0 (0)
						 ORG 0
getDNodeAccessControlParsePB ds     DirGetDNodeAccessControlParsePB ; offset: $0 (0)
						 ORG 0
getRecordAccessControlGetPB ds     DirGetRecordAccessControlGetPB ; offset: $0 (0)
						 ORG 0
getRecordAccessControlParsePB ds     DirGetRecordAccessControlParsePB ; offset: $0 (0)
						 ORG 0
getAttributeAccessControlGetPB ds     DirGetAttributeAccessControlGetPB ; offset: $0 (0)
						 ORG 0
getAttributeAccessControlParsePB ds     DirGetAttributeAccessControlParsePB ; offset: $0 (0)
						 ORG 0
enumerateDirectoriesGetPB ds     DirEnumerateDirectoriesGetPB ; offset: $0 (0)
						 ORG 0
enumerateDirectoriesParsePB ds     DirEnumerateDirectoriesParsePB ; offset: $0 (0)
						 ORG 0
addADAPDirectoryPB		 ds     DirAddADAPDirectoryPB ; offset: $0 (0)
						 ORG 0
removeDirectoryPB		 ds     DirRemoveDirectoryPB ; offset: $0 (0)
						 ORG 0
netSearchADAPDirectoriesGetPB ds     DirNetSearchADAPDirectoriesGetPB ; offset: $0 (0)
						 ORG 0
netSearchADAPDirectoriesParsePB ds     DirNetSearchADAPDirectoriesParsePB ; offset: $0 (0)
						 ORG 0
findADAPDirectoryByNetSearchPB ds     DirFindADAPDirectoryByNetSearchPB ; offset: $0 (0)
						 ORG 0
mapDNodeNumberToPathNamePB ds     DirMapDNodeNumberToPathNamePB ; offset: $0 (0)
						 ORG 0
mapPathNameToDNodeNumberPB ds     DirMapPathNameToDNodeNumberPB ; offset: $0 (0)
						 ORG 0
getLocalNetworkSpecPB	 ds     DirGetLocalNetworkSpecPB ; offset: $0 (0)
						 ORG 0
getDNodeInfoPB			 ds     DirGetDNodeInfoPB ; offset: $0 (0)
						 ORG 0
createPersonalDirectoryPB ds     DirCreatePersonalDirectoryPB ; offset: $0 (0)
						 ORG 0
openPersonalDirectoryPB	 ds     DirOpenPersonalDirectoryPB ; offset: $0 (0)
						 ORG 0
closePersonalDirectoryPB ds     DirClosePersonalDirectoryPB ; offset: $0 (0)
						 ORG 0
makePersonalDirectoryRLIPB ds     DirMakePersonalDirectoryRLIPB ; offset: $0 (0)
						 ORG 0
addDSAMPB				 ds     DirAddDSAMPB ; offset: $0 (0)
						 ORG 0
instantiateDSAMPB		 ds     DirInstantiateDSAMPB ; offset: $0 (0)
						 ORG 0
removeDSAMPB			 ds     DirRemoveDSAMPB ; offset: $0 (0)
						 ORG 0
addDSAMDirectoryPB		 ds     DirAddDSAMDirectoryPB ; offset: $0 (0)
						 ORG 0
getExtendedDirectoriesInfoPB ds     DirGetExtendedDirectoriesInfoPB ; offset: $0 (0)
						 ORG 0
getDirectoryIconPB		 ds     DirGetDirectoryIconPB ; offset: $0 (0)
						 ORG 0
dirGetOCESetupRefNumPB	 ds     DirGetOCESetupRefNumPB ; offset: $0 (0)
						 ORG 0
abortPB					 ds     DirAbortPB ; offset: $0 (0)
						 ORG 174
sizeof					 EQU *			; size:   $AE (174)
						ENDR

;
; pascal OSErr AuthBindSpecificIdentity(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthBindSpecificIdentity
			move.w	#$200,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthBindSpecificIdentity
	ENDIF

;
; pascal OSErr AuthUnbindSpecificIdentity(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthUnbindSpecificIdentity
			move.w	#$201,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthUnbindSpecificIdentity
	ENDIF

;
; pascal OSErr AuthResolveCreationID(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthResolveCreationID
			move.w	#$202,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthResolveCreationID
	ENDIF

;
; pascal OSErr AuthGetSpecificIdentityInfo(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthGetSpecificIdentityInfo
			move.w	#$203,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthGetSpecificIdentityInfo
	ENDIF

;
; pascal OSErr AuthAddKey(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthAddKey
			move.w	#$207,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthAddKey
	ENDIF

;
; pascal OSErr AuthChangeKey(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthChangeKey
			move.w	#$208,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthChangeKey
	ENDIF

;
; pascal OSErr AuthDeleteKey(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthDeleteKey
			move.w	#$209,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthDeleteKey
	ENDIF

;
; pascal OSErr AuthPasswordToKey(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthPasswordToKey
			move.w	#$20A,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthPasswordToKey
	ENDIF

;
; pascal OSErr AuthGetCredentials(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthGetCredentials
			move.w	#$20B,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthGetCredentials
	ENDIF

;
; pascal OSErr AuthDecryptCredentials(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthDecryptCredentials
			move.w	#$20C,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthDecryptCredentials
	ENDIF

;
; pascal OSErr AuthMakeChallenge(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthMakeChallenge
			move.w	#$20F,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthMakeChallenge
	ENDIF

;
; pascal OSErr AuthMakeReply(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthMakeReply
			move.w	#$210,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthMakeReply
	ENDIF

;
; pascal OSErr AuthVerifyReply(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthVerifyReply
			move.w	#$211,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthVerifyReply
	ENDIF

;
; pascal OSErr AuthGetUTCTime(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthGetUTCTime
			move.w	#$21A,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthGetUTCTime
	ENDIF

;
; pascal OSErr AuthMakeProxy(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthMakeProxy
			move.w	#$212,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthMakeProxy
	ENDIF

;
; pascal OSErr AuthTradeProxyForCredentials(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthTradeProxyForCredentials
			move.w	#$213,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthTradeProxyForCredentials
	ENDIF

; Local Identity API 
;
; pascal OSErr AuthGetLocalIdentity(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthGetLocalIdentity
			move.w	#$204,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthGetLocalIdentity
	ENDIF

;
; pascal OSErr AuthUnlockLocalIdentity(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthUnlockLocalIdentity
			move.w	#$214,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthUnlockLocalIdentity
	ENDIF

;
; pascal OSErr AuthLockLocalIdentity(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthLockLocalIdentity
			move.w	#$215,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthLockLocalIdentity
	ENDIF

;
; pascal OSErr AuthAddToLocalIdentityQueue(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthAddToLocalIdentityQueue
			move.w	#$205,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthAddToLocalIdentityQueue
	ENDIF

;
; pascal OSErr AuthRemoveFromLocalIdentityQueue(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthRemoveFromLocalIdentityQueue
			move.w	#$206,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthRemoveFromLocalIdentityQueue
	ENDIF

;
; pascal OSErr AuthSetupLocalIdentity(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthSetupLocalIdentity
			move.w	#$216,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthSetupLocalIdentity
	ENDIF

;
; pascal OSErr AuthChangeLocalIdentity(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthChangeLocalIdentity
			move.w	#$217,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthChangeLocalIdentity
	ENDIF

;
; pascal OSErr AuthRemoveLocalIdentity(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AuthRemoveLocalIdentity
			move.w	#$218,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AuthRemoveLocalIdentity
	ENDIF

;
; pascal OSErr DirAddRecord(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirAddRecord
			move.w	#$109,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirAddRecord
	ENDIF

;
; pascal OSErr DirDeleteRecord(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirDeleteRecord
			move.w	#$10A,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirDeleteRecord
	ENDIF

;
; pascal OSErr DirEnumerateGet(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirEnumerateGet
			move.w	#$111,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirEnumerateGet
	ENDIF

;
; pascal OSErr DirEnumerateParse(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirEnumerateParse
			move.w	#$101,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirEnumerateParse
	ENDIF

;
; pascal OSErr DirFindRecordGet(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirFindRecordGet
			move.w	#$140,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirFindRecordGet
	ENDIF

;
; pascal OSErr DirFindRecordParse(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirFindRecordParse
			move.w	#$141,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirFindRecordParse
	ENDIF

;
; pascal OSErr DirLookupGet(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirLookupGet
			move.w	#$117,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirLookupGet
	ENDIF

;
; pascal OSErr DirLookupParse(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirLookupParse
			move.w	#$102,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirLookupParse
	ENDIF

;
; pascal OSErr DirAddAttributeValue(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirAddAttributeValue
			move.w	#$10B,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirAddAttributeValue
	ENDIF

;
; pascal OSErr DirDeleteAttributeValue(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirDeleteAttributeValue
			move.w	#$10C,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirDeleteAttributeValue
	ENDIF

;
; pascal OSErr DirDeleteAttributeType(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirDeleteAttributeType
			move.w	#$130,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirDeleteAttributeType
	ENDIF

;
; pascal OSErr DirChangeAttributeValue(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirChangeAttributeValue
			move.w	#$10D,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirChangeAttributeValue
	ENDIF

;
; pascal OSErr DirVerifyAttributeValue(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirVerifyAttributeValue
			move.w	#$10E,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirVerifyAttributeValue
	ENDIF

;
; pascal OSErr DirFindValue(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirFindValue
			move.w	#$126,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirFindValue
	ENDIF

;
; pascal OSErr DirEnumerateAttributeTypesGet(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirEnumerateAttributeTypesGet
			move.w	#$112,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirEnumerateAttributeTypesGet
	ENDIF

;
; pascal OSErr DirEnumerateAttributeTypesParse(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirEnumerateAttributeTypesParse
			move.w	#$103,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirEnumerateAttributeTypesParse
	ENDIF

;
; pascal OSErr DirAddPseudonym(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirAddPseudonym
			move.w	#$10F,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirAddPseudonym
	ENDIF

;
; pascal OSErr DirDeletePseudonym(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirDeletePseudonym
			move.w	#$110,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirDeletePseudonym
	ENDIF

;
; pascal OSErr DirAddAlias(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirAddAlias
			move.w	#$11C,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirAddAlias
	ENDIF

;
; pascal OSErr DirEnumeratePseudonymGet(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirEnumeratePseudonymGet
			move.w	#$113,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirEnumeratePseudonymGet
	ENDIF

;
; pascal OSErr DirEnumeratePseudonymParse(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirEnumeratePseudonymParse
			move.w	#$104,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirEnumeratePseudonymParse
	ENDIF

;
; pascal OSErr DirGetNameAndType(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetNameAndType
			move.w	#$114,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetNameAndType
	ENDIF

;
; pascal OSErr DirSetNameAndType(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirSetNameAndType
			move.w	#$115,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirSetNameAndType
	ENDIF

;
; pascal OSErr DirGetRecordMetaInfo(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetRecordMetaInfo
			move.w	#$116,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetRecordMetaInfo
	ENDIF

;
; pascal OSErr DirGetDNodeMetaInfo(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetDNodeMetaInfo
			move.w	#$118,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetDNodeMetaInfo
	ENDIF

;
; pascal OSErr DirGetDirectoryInfo(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetDirectoryInfo
			move.w	#$119,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetDirectoryInfo
	ENDIF

;
; pascal OSErr DirGetDNodeAccessControlGet(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetDNodeAccessControlGet
			move.w	#$12A,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetDNodeAccessControlGet
	ENDIF

;
; pascal OSErr DirGetDNodeAccessControlParse(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetDNodeAccessControlParse
			move.w	#$12F,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetDNodeAccessControlParse
	ENDIF

;
; pascal OSErr DirGetRecordAccessControlGet(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetRecordAccessControlGet
			move.w	#$12C,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetRecordAccessControlGet
	ENDIF

;
; pascal OSErr DirGetRecordAccessControlParse(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetRecordAccessControlParse
			move.w	#$134,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetRecordAccessControlParse
	ENDIF

;
; pascal OSErr DirGetAttributeAccessControlGet(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetAttributeAccessControlGet
			move.w	#$12E,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetAttributeAccessControlGet
	ENDIF

;
; pascal OSErr DirGetAttributeAccessControlParse(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetAttributeAccessControlParse
			move.w	#$138,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetAttributeAccessControlParse
	ENDIF

;
; pascal OSErr DirEnumerateDirectoriesGet(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirEnumerateDirectoriesGet
			move.w	#$11A,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirEnumerateDirectoriesGet
	ENDIF

;
; pascal OSErr DirEnumerateDirectoriesParse(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirEnumerateDirectoriesParse
			move.w	#$106,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirEnumerateDirectoriesParse
	ENDIF

;
; pascal OSErr DirMapPathNameToDNodeNumber(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirMapPathNameToDNodeNumber
			move.w	#$122,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirMapPathNameToDNodeNumber
	ENDIF

;
; pascal OSErr DirMapDNodeNumberToPathName(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirMapDNodeNumberToPathName
			move.w	#$123,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirMapDNodeNumberToPathName
	ENDIF

;
; pascal OSErr DirGetLocalNetworkSpec(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetLocalNetworkSpec
			move.w	#$124,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetLocalNetworkSpec
	ENDIF

;
; pascal OSErr DirGetDNodeInfo(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetDNodeInfo
			move.w	#$125,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetDNodeInfo
	ENDIF

;  Trap Dispatchers for Personal Catalog and CSAM Extensions 
;
; pascal OSErr DirCreatePersonalDirectory(DirParamBlockPtr paramBlock)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirCreatePersonalDirectory
			moveq	#0,d0
			dc.w 	$1F00
			move.w	#$11F,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirCreatePersonalDirectory
	ENDIF

;
; pascal OSErr DirOpenPersonalDirectory(DirParamBlockPtr paramBlock)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirOpenPersonalDirectory
			moveq	#0,d0
			dc.w 	$1F00
			move.w	#$11E,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirOpenPersonalDirectory
	ENDIF

;
; pascal OSErr DirClosePersonalDirectory(DirParamBlockPtr paramBlock)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirClosePersonalDirectory
			moveq	#0,d0
			dc.w 	$1F00
			move.w	#$131,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirClosePersonalDirectory
	ENDIF

;
; pascal OSErr DirMakePersonalDirectoryRLI(DirParamBlockPtr paramBlock)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirMakePersonalDirectoryRLI
			moveq	#0,d0
			dc.w 	$1F00
			move.w	#$132,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirMakePersonalDirectoryRLI
	ENDIF

;
; pascal OSErr DirAddDSAM(DirParamBlockPtr paramBlock)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirAddDSAM
			moveq	#0,d0
			dc.w 	$1F00
			move.w	#$11D,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirAddDSAM
	ENDIF

;
; pascal OSErr DirInstantiateDSAM(DirParamBlockPtr paramBlock)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirInstantiateDSAM
			moveq	#0,d0
			dc.w 	$1F00
			move.w	#$127,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirInstantiateDSAM
	ENDIF

;
; pascal OSErr DirRemoveDSAM(DirParamBlockPtr paramBlock)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirRemoveDSAM
			moveq	#0,d0
			dc.w 	$1F00
			move.w	#$120,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirRemoveDSAM
	ENDIF

;
; pascal OSErr DirAddDSAMDirectory(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirAddDSAMDirectory
			move.w	#$133,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirAddDSAMDirectory
	ENDIF

;
; pascal OSErr DirGetExtendedDirectoriesInfo(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetExtendedDirectoriesInfo
			move.w	#$136,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetExtendedDirectoriesInfo
	ENDIF

;
; pascal OSErr DirGetDirectoryIcon(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetDirectoryIcon
			move.w	#$121,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetDirectoryIcon
	ENDIF

;
; pascal OSErr DirAddADAPDirectory(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirAddADAPDirectory
			move.w	#$137,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirAddADAPDirectory
	ENDIF

;
; pascal OSErr DirRemoveDirectory(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirRemoveDirectory
			move.w	#$135,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirRemoveDirectory
	ENDIF

;
; pascal OSErr DirNetSearchADAPDirectoriesGet(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirNetSearchADAPDirectoriesGet
			move.w	#$108,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirNetSearchADAPDirectoriesGet
	ENDIF

;
; pascal OSErr DirNetSearchADAPDirectoriesParse(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirNetSearchADAPDirectoriesParse
			move.w	#$105,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirNetSearchADAPDirectoriesParse
	ENDIF

;
; pascal OSErr DirFindADAPDirectoryByNetSearch(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirFindADAPDirectoryByNetSearch
			move.w	#$107,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirFindADAPDirectoryByNetSearch
	ENDIF

;
; pascal OSErr DirGetOCESetupRefNum(DirParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirGetOCESetupRefNum
			move.w	#$128,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirGetOCESetupRefNum
	ENDIF

;
; pascal OSErr DirAbort(DirParamBlockPtr paramBlock)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DirAbort
			moveq	#0,d0
			dc.w 	$1F00
			move.w	#$11B,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DirAbort
	ENDIF

;
; pascal OSErr OCESetupAddDirectoryInfo(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_OCESetupAddDirectoryInfo
			move.w	#$219,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	OCESetupAddDirectoryInfo
	ENDIF

;
; pascal OSErr OCESetupChangeDirectoryInfo(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_OCESetupChangeDirectoryInfo
			move.w	#$21B,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	OCESetupChangeDirectoryInfo
	ENDIF

;
; pascal OSErr OCESetupRemoveDirectoryInfo(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_OCESetupRemoveDirectoryInfo
			move.w	#$20D,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	OCESetupRemoveDirectoryInfo
	ENDIF

;
; pascal OSErr OCESetupGetDirectoryInfo(AuthParamBlockPtr paramBlock, Boolean async)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_OCESetupGetDirectoryInfo
			move.w	#$20E,-(sp)
			dc.w 	$AA5E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	OCESetupGetDirectoryInfo
	ENDIF

	ENDIF ; __OCEAUTHDIR__

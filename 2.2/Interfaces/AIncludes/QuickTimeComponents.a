;
;	File:		QuickTimeComponents.a
;
;	Contains:	QuickTime Interfaces.
;
;	Version:	Technology:	QuickTime 2.0
;				Package:	Universal Interfaces 2.2 in “MPW” on ETO #20
;
;	Copyright:	© 1984-1995 by Apple Computer, Inc.
;				All rights reserved.
;
;	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter
;				stack.  Include the file and version information (from above)
;				in the problem description and send to:
;					Internet:	apple.bugs@applelink.apple.com
;					AppleLink:	APPLE.BUGS
;
;

	IF &TYPE('__QUICKTIMECOMPONENTS__') = 'UNDEFINED' THEN
__QUICKTIMECOMPONENTS__ SET 1


	IF &TYPE('__COMPONENTS__') = 'UNDEFINED' THEN
	include 'Components.a'
	ENDIF
;		include 'Types.a'											;
;			include 'ConditionalMacros.a'							;
;		include 'MixedMode.a'										;

	IF &TYPE('__IMAGECOMPRESSION__') = 'UNDEFINED' THEN
	include 'ImageCompression.a'
	ENDIF
;		include 'Quickdraw.a'										;
;			include 'QuickdrawText.a'								;
;		include 'QDOffscreen.a'									;
;			include 'Errors.a'										;
;		include 'Windows.a'										;
;			include 'Memory.a'										;
;			include 'Events.a'										;
;				include 'OSUtils.a'								;
;			include 'Controls.a'									;
;				include 'Menus.a'									;
;		include 'StandardFile.a'									;
;			include 'Dialogs.a'									;
;				include 'TextEdit.a'								;
;			include 'Files.a'										;
;				include 'Finder.a'									;

	IF &TYPE('__MOVIES__') = 'UNDEFINED' THEN
	include 'Movies.a'
	ENDIF
;		include 'Aliases.a'										;
;			include 'AppleTalk.a'									;

	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF

	IF &TYPE('__VIDEO__') = 'UNDEFINED' THEN
	include 'Video.a'
	ENDIF

	IF &TYPE('__MEMORY__') = 'UNDEFINED' THEN
	include 'Memory.a'
	ENDIF

clockComponentType				EQU		'clok'
systemTickClock					EQU		'tick'				; subtype: 60ths since boot		
systemSecondClock				EQU		'seco'				; subtype: seconds since 1904		
systemMillisecondClock			EQU		'mill'				; subtype: 1000ths since boot		
systemMicrosecondClock			EQU		'micr'

kClockRateIsLinear				EQU		1
kClockImplementsCallBacks		EQU		2

;* These are Clock procedures *
;
; pascal ComponentResult ClockGetTime(ComponentInstance aClock, TimeRecord *out)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_ClockGetTime
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0001
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	ClockGetTime
	ENDIF

;
; pascal QTCallBack ClockNewCallBack(ComponentInstance aClock, TimeBase tb, short callBackType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_ClockNewCallBack
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$0002
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	ClockNewCallBack
	ENDIF

;
; pascal ComponentResult ClockDisposeCallBack(ComponentInstance aClock, QTCallBack cb)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_ClockDisposeCallBack
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0003
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	ClockDisposeCallBack
	ENDIF

;
; pascal ComponentResult ClockCallMeWhen(ComponentInstance aClock, QTCallBack cb, long param1, long param2, long param3)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_ClockCallMeWhen
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$0004
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	ClockCallMeWhen
	ENDIF

;
; pascal ComponentResult ClockCancelCallBack(ComponentInstance aClock, QTCallBack cb)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_ClockCancelCallBack
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0005
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	ClockCancelCallBack
	ENDIF

;
; pascal ComponentResult ClockRateChanged(ComponentInstance aClock, QTCallBack cb)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_ClockRateChanged
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0006
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	ClockRateChanged
	ENDIF

;
; pascal ComponentResult ClockTimeChanged(ComponentInstance aClock, QTCallBack cb)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_ClockTimeChanged
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0007
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	ClockTimeChanged
	ENDIF

;
; pascal ComponentResult ClockSetTimeBase(ComponentInstance aClock, TimeBase tb)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_ClockSetTimeBase
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0008
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	ClockSetTimeBase
	ENDIF

;
; pascal ComponentResult ClockStartStopChanged(ComponentInstance aClock, QTCallBack cb, Boolean startChanged, Boolean stopChanged)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_ClockStartStopChanged
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0009
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	ClockStartStopChanged
	ENDIF

;
; pascal ComponentResult ClockGetRate(ComponentInstance aClock, Fixed *rate)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_ClockGetRate
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	ClockGetRate
	ENDIF

kClockGetTimeSelect				EQU		$1
kClockNewCallBackSelect			EQU		$2
kClockDisposeCallBackSelect		EQU		$3
kClockCallMeWhenSelect			EQU		$4
kClockCancelCallBackSelect		EQU		$5
kClockRateChangedSelect			EQU		$6
kClockTimeChangedSelect			EQU		$7
kClockSetTimeBaseSelect			EQU		$8
kClockStartStopChangedSelect	EQU		$9
kClockGetRateSelect				EQU		$A

;
;	General Sequence Grab stuff
;
; typedef ComponentInstance  SeqGrabComponent
; typedef ComponentInstance  SGChannel

SeqGrabComponentType			EQU		'barg'
SeqGrabChannelType				EQU		'sgch'
SeqGrabPanelType				EQU		'sgpn'
SeqGrabCompressionPanelType		EQU		'comp'
SeqGrabSourcePanelType			EQU		'sour'

seqGrabToDisk					EQU		1
seqGrabToMemory					EQU		2
seqGrabDontUseTempMemory		EQU		4
seqGrabAppendToFile				EQU		8
seqGrabDontAddMovieResource		EQU		16
seqGrabDontMakeMovie			EQU		32
seqGrabPreExtendFile			EQU		64
seqGrabDataProcIsInterruptSafe	EQU		128
seqGrabDataProcDoesOverlappingReads EQU		256

; typedef unsigned long 	SeqGrabDataOutputEnum

seqGrabRecord					EQU		1
seqGrabPreview					EQU		2
seqGrabPlayDuringRecord			EQU		4

; typedef unsigned long 	SeqGrabUsageEnum

seqGrabHasBounds				EQU		1
seqGrabHasVolume				EQU		2
seqGrabHasDiscreteSamples		EQU		4

; typedef unsigned long 	SeqGrabChannelInfoEnum
SeqGrabFrameInfo 		RECORD	0
frameOffset				 ds.l   1		; offset: $0 (0)
frameTime				 ds.l   1		; offset: $4 (4)
frameSize				 ds.l   1		; offset: $8 (8)
frameChannel			 ds.l   1		; offset: $C (12)
frameRefCon				 ds.l   1		; offset: $10 (16)
sizeof					 EQU *			; size:   $14 (20)
						ENDR

; typedef struct SeqGrabFrameInfo  SeqGrabFrameInfo, *SeqGrabFrameInfoPtr

grabPictOffScreen				EQU		1
grabPictIgnoreClip				EQU		2
grabPictCurrentImage			EQU		4

sgFlagControlledGrab			EQU		(1 << 0)

SGDeviceName 			RECORD	0
name					 ds.l   16		; offset: $0 (0)
icon					 ds.l   1		; offset: $40 (64)
flags					 ds.l   1		; offset: $44 (68)
refCon					 ds.l   1		; offset: $48 (72)
reserved				 ds.l   1		; offset: $4C (76)		; zero
sizeof					 EQU *			; size:   $50 (80)
						ENDR

; typedef struct SGDeviceName  SGDeviceName

sgDeviceNameFlagDeviceUnavailable EQU		(1 << 0)

SGDeviceListRecord 		RECORD	0
count					 ds.w   1		; offset: $0 (0)
selectedIndex			 ds.w   1		; offset: $2 (2)
reserved				 ds.l   1		; offset: $4 (4)		; zero
entry					 ds     SGDeviceName ; offset: $8 (8)
sizeof					 EQU *			; size:   $58 (88)
						ENDR

; typedef struct SGDeviceListRecord  SGDeviceListRecord, *SGDeviceListPtr, **SGDeviceList

sgDeviceListWithIcons			EQU		(1 << 0)
sgDeviceListDontCheckAvailability EQU		(1 << 1)

seqGrabWriteAppend				EQU		0
seqGrabWriteReserve				EQU		1
seqGrabWriteFill				EQU		2

seqGrabUnpause					EQU		0
seqGrabPause					EQU		1
seqGrabPauseForMenu				EQU		3

channelFlagDontOpenResFile		EQU		2
channelFlagHasDependency		EQU		4

sgPanelFlagForPanel				EQU		1

SGOutputRecord 			RECORD	0
data					 ds.l   1		; offset: $0 (0)
sizeof					 EQU *			; size:   $4 (4)
						ENDR

; typedef struct SGOutputRecord  SGOutputRecord, *SGOutput

channelPlayNormal				EQU		0
channelPlayFast					EQU		1
channelPlayHighQuality			EQU		2
channelPlayAllData				EQU		4

;
; pascal ComponentResult SGInitialize(SeqGrabComponent s)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGInitialize
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0001
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGInitialize
	ENDIF

;
; pascal ComponentResult SGSetDataOutput(SeqGrabComponent s, const FSSpec *movieFile, long whereFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetDataOutput
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0002
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetDataOutput
	ENDIF

;
; pascal ComponentResult SGGetDataOutput(SeqGrabComponent s, FSSpec *movieFile, long *whereFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetDataOutput
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0003
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetDataOutput
	ENDIF

;
; pascal ComponentResult SGSetGWorld(SeqGrabComponent s, CGrafPtr gp, GDHandle gd)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetGWorld
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0004
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetGWorld
	ENDIF

;
; pascal ComponentResult SGGetGWorld(SeqGrabComponent s, CGrafPtr *gp, GDHandle *gd)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetGWorld
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0005
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetGWorld
	ENDIF

;
; pascal ComponentResult SGNewChannel(SeqGrabComponent s, OSType channelType, SGChannel *ref)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGNewChannel
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0006
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGNewChannel
	ENDIF

;
; pascal ComponentResult SGDisposeChannel(SeqGrabComponent s, SGChannel c)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGDisposeChannel
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0007
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGDisposeChannel
	ENDIF

;
; pascal ComponentResult SGStartPreview(SeqGrabComponent s)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGStartPreview
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0010
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGStartPreview
	ENDIF

;
; pascal ComponentResult SGStartRecord(SeqGrabComponent s)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGStartRecord
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0011
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGStartRecord
	ENDIF

;
; pascal ComponentResult SGIdle(SeqGrabComponent s)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGIdle
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0012
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGIdle
	ENDIF

;
; pascal ComponentResult SGStop(SeqGrabComponent s)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGStop
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0013
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGStop
	ENDIF

;
; pascal ComponentResult SGPause(SeqGrabComponent s, Byte pause)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPause
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$0014
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPause
	ENDIF

;
; pascal ComponentResult SGPrepare(SeqGrabComponent s, Boolean prepareForPreview, Boolean prepareForRecord)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPrepare
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0015
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPrepare
	ENDIF

;
; pascal ComponentResult SGRelease(SeqGrabComponent s)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGRelease
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0016
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGRelease
	ENDIF

;
; pascal Movie SGGetMovie(SeqGrabComponent s)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetMovie
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0017
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetMovie
	ENDIF

;
; pascal ComponentResult SGSetMaximumRecordTime(SeqGrabComponent s, unsigned long ticks)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetMaximumRecordTime
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0018
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetMaximumRecordTime
	ENDIF

;
; pascal ComponentResult SGGetMaximumRecordTime(SeqGrabComponent s, unsigned long *ticks)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetMaximumRecordTime
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0019
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetMaximumRecordTime
	ENDIF

;
; pascal ComponentResult SGGetStorageSpaceRemaining(SeqGrabComponent s, unsigned long *bytes)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetStorageSpaceRemaining
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetStorageSpaceRemaining
	ENDIF

;
; pascal ComponentResult SGGetTimeRemaining(SeqGrabComponent s, long *ticksLeft)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetTimeRemaining
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetTimeRemaining
	ENDIF

;
; pascal ComponentResult SGGrabPict(SeqGrabComponent s, PicHandle *p, const Rect *bounds, short offscreenDepth, long grabPictFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGrabPict
			dc.w 	$2F3C
			dc.w 	$000E
			dc.w 	$001C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGrabPict
	ENDIF

;
; pascal ComponentResult SGGetLastMovieResID(SeqGrabComponent s, short *resID)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetLastMovieResID
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetLastMovieResID
	ENDIF

;
; pascal ComponentResult SGSetFlags(SeqGrabComponent s, long sgFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetFlags
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetFlags
	ENDIF

;
; pascal ComponentResult SGGetFlags(SeqGrabComponent s, long *sgFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetFlags
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetFlags
	ENDIF

;
; pascal ComponentResult SGSetDataProc(SeqGrabComponent s, SGDataUPP proc, long refCon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetDataProc
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0020
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetDataProc
	ENDIF

;
; pascal ComponentResult SGNewChannelFromComponent(SeqGrabComponent s, SGChannel *newChannel, Component sgChannelComponent)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGNewChannelFromComponent
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0021
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGNewChannelFromComponent
	ENDIF

;
; pascal ComponentResult SGDisposeDeviceList(SeqGrabComponent s, SGDeviceList list)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGDisposeDeviceList
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0022
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGDisposeDeviceList
	ENDIF

;
; pascal ComponentResult SGAppendDeviceListToMenu(SeqGrabComponent s, SGDeviceList list, MenuHandle mh)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGAppendDeviceListToMenu
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0023
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGAppendDeviceListToMenu
	ENDIF

;
; pascal ComponentResult SGSetSettings(SeqGrabComponent s, UserData ud, long flags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetSettings
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0024
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetSettings
	ENDIF

;
; pascal ComponentResult SGGetSettings(SeqGrabComponent s, UserData *ud, long flags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetSettings
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0025
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetSettings
	ENDIF

;
; pascal ComponentResult SGGetIndChannel(SeqGrabComponent s, short index, SGChannel *ref, OSType *chanType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetIndChannel
			dc.w 	$2F3C
			dc.w 	$000A
			dc.w 	$0026
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetIndChannel
	ENDIF

;
; pascal ComponentResult SGUpdate(SeqGrabComponent s, RgnHandle updateRgn)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGUpdate
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0027
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGUpdate
	ENDIF

;
; pascal ComponentResult SGGetPause(SeqGrabComponent s, Byte *paused)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetPause
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0028
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetPause
	ENDIF

;
; pascal ComponentResult SGSettingsDialog(SeqGrabComponent s, SGChannel c, short numPanels, Component *panelList, long flags, SGModalFilterUPP proc, long procRefNum)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSettingsDialog
			dc.w 	$2F3C
			dc.w 	$0016
			dc.w 	$0029
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSettingsDialog
	ENDIF

;
; pascal ComponentResult SGGetAlignmentProc(SeqGrabComponent s, ICMAlignmentProcRecordPtr alignmentProc)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetAlignmentProc
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$002A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetAlignmentProc
	ENDIF

;
; pascal ComponentResult SGSetChannelSettings(SeqGrabComponent s, SGChannel c, UserData ud, long flags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetChannelSettings
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$002B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetChannelSettings
	ENDIF

;
; pascal ComponentResult SGGetChannelSettings(SeqGrabComponent s, SGChannel c, UserData *ud, long flags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetChannelSettings
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$002C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetChannelSettings
	ENDIF

;
; pascal ComponentResult SGGetMode(SeqGrabComponent s, Boolean *previewMode, Boolean *recordMode)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetMode
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$002D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetMode
	ENDIF

;
; pascal ComponentResult SGSetDataRef(SeqGrabComponent s, Handle dataRef, OSType dataRefType, long whereFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetDataRef
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$002E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetDataRef
	ENDIF

;
; pascal ComponentResult SGGetDataRef(SeqGrabComponent s, Handle *dataRef, OSType *dataRefType, long *whereFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetDataRef
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$002F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetDataRef
	ENDIF

;
; pascal ComponentResult SGNewOutput(SeqGrabComponent s, Handle dataRef, OSType dataRefType, long whereFlags, SGOutput *output)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGNewOutput
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$0030
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGNewOutput
	ENDIF

;
; pascal ComponentResult SGDisposeOutput(SeqGrabComponent s, SGOutput output)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGDisposeOutput
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0031
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGDisposeOutput
	ENDIF

;
; pascal ComponentResult SGSetOutputFlags(SeqGrabComponent s, SGOutput output, long whereFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetOutputFlags
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0032
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetOutputFlags
	ENDIF

;
; pascal ComponentResult SGSetChannelOutput(SeqGrabComponent s, SGChannel c, SGOutput output)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetChannelOutput
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0033
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetChannelOutput
	ENDIF

;
; pascal ComponentResult SGGetDataOutputStorageSpaceRemaining(SeqGrabComponent s, SGOutput output, unsigned long *space)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetDataOutputStorageSpaceRemaining
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0034
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetDataOutputStorageSpaceRemaining
	ENDIF

;
;	calls from Channel to seqGrab
;
;
; pascal ComponentResult SGWriteMovieData(SeqGrabComponent s, SGChannel c, Ptr p, long len, long *offset)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGWriteMovieData
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$0100
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGWriteMovieData
	ENDIF

;
; pascal ComponentResult SGAddFrameReference(SeqGrabComponent s, SeqGrabFrameInfoPtr frameInfo)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGAddFrameReference
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0101
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGAddFrameReference
	ENDIF

;
; pascal ComponentResult SGGetNextFrameReference(SeqGrabComponent s, SeqGrabFrameInfoPtr frameInfo, TimeValue *frameDuration, long *frameNumber)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetNextFrameReference
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0102
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetNextFrameReference
	ENDIF

;
; pascal ComponentResult SGGetTimeBase(SeqGrabComponent s, TimeBase *tb)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetTimeBase
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0103
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetTimeBase
	ENDIF

;
; pascal ComponentResult SGSortDeviceList(SeqGrabComponent s, SGDeviceList list)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSortDeviceList
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0104
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSortDeviceList
	ENDIF

;
; pascal ComponentResult SGAddMovieData(SeqGrabComponent s, SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGAddMovieData
			dc.w 	$2F3C
			dc.w 	$001A
			dc.w 	$0105
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGAddMovieData
	ENDIF

;
; pascal ComponentResult SGChangedSource(SeqGrabComponent s, SGChannel c)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGChangedSource
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0106
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGChangedSource
	ENDIF

;** Sequence Grab CHANNEL Component Stuff **
;
; pascal ComponentResult SGSetChannelUsage(SGChannel c, long usage)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetChannelUsage
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0080
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetChannelUsage
	ENDIF

;
; pascal ComponentResult SGGetChannelUsage(SGChannel c, long *usage)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetChannelUsage
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0081
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetChannelUsage
	ENDIF

;
; pascal ComponentResult SGSetChannelBounds(SGChannel c, const Rect *bounds)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetChannelBounds
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0082
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetChannelBounds
	ENDIF

;
; pascal ComponentResult SGGetChannelBounds(SGChannel c, Rect *bounds)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetChannelBounds
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0083
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetChannelBounds
	ENDIF

;
; pascal ComponentResult SGSetChannelVolume(SGChannel c, short volume)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetChannelVolume
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$0084
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetChannelVolume
	ENDIF

;
; pascal ComponentResult SGGetChannelVolume(SGChannel c, short *volume)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetChannelVolume
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0085
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetChannelVolume
	ENDIF

;
; pascal ComponentResult SGGetChannelInfo(SGChannel c, long *channelInfo)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetChannelInfo
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0086
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetChannelInfo
	ENDIF

;
; pascal ComponentResult SGSetChannelPlayFlags(SGChannel c, long playFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetChannelPlayFlags
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0087
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetChannelPlayFlags
	ENDIF

;
; pascal ComponentResult SGGetChannelPlayFlags(SGChannel c, long *playFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetChannelPlayFlags
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0088
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetChannelPlayFlags
	ENDIF

;
; pascal ComponentResult SGSetChannelMaxFrames(SGChannel c, long frameCount)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetChannelMaxFrames
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0089
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetChannelMaxFrames
	ENDIF

;
; pascal ComponentResult SGGetChannelMaxFrames(SGChannel c, long *frameCount)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetChannelMaxFrames
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$008A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetChannelMaxFrames
	ENDIF

;
; pascal ComponentResult SGSetChannelRefCon(SGChannel c, long refCon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetChannelRefCon
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$008B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetChannelRefCon
	ENDIF

;
; pascal ComponentResult SGSetChannelClip(SGChannel c, RgnHandle theClip)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetChannelClip
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$008C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetChannelClip
	ENDIF

;
; pascal ComponentResult SGGetChannelClip(SGChannel c, RgnHandle *theClip)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetChannelClip
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$008D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetChannelClip
	ENDIF

;
; pascal ComponentResult SGGetChannelSampleDescription(SGChannel c, Handle sampleDesc)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetChannelSampleDescription
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$008E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetChannelSampleDescription
	ENDIF

;
; pascal ComponentResult SGGetChannelDeviceList(SGChannel c, long selectionFlags, SGDeviceList *list)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetChannelDeviceList
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$008F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetChannelDeviceList
	ENDIF

;
; pascal ComponentResult SGSetChannelDevice(SGChannel c, StringPtr name)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetChannelDevice
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0090
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetChannelDevice
	ENDIF

;
; pascal ComponentResult SGSetChannelMatrix(SGChannel c, const MatrixRecord *m)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetChannelMatrix
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0091
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetChannelMatrix
	ENDIF

;
; pascal ComponentResult SGGetChannelMatrix(SGChannel c, MatrixRecord *m)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetChannelMatrix
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0092
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetChannelMatrix
	ENDIF

;
; pascal ComponentResult SGGetChannelTimeScale(SGChannel c, TimeScale *scale)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetChannelTimeScale
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0093
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetChannelTimeScale
	ENDIF

;
; pascal ComponentResult SGChannelPutPicture(SGChannel c)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGChannelPutPicture
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0094
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGChannelPutPicture
	ENDIF

;
; pascal ComponentResult SGChannelSetRequestedDataRate(SGChannel c, long bytesPerSecond)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGChannelSetRequestedDataRate
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0095
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGChannelSetRequestedDataRate
	ENDIF

;
; pascal ComponentResult SGChannelGetRequestedDataRate(SGChannel c, long *bytesPerSecond)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGChannelGetRequestedDataRate
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0096
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGChannelGetRequestedDataRate
	ENDIF

;
; pascal ComponentResult SGChannelSetDataSourceName(SGChannel c, ConstStr255Param name, ScriptCode scriptTag)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGChannelSetDataSourceName
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$0097
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGChannelSetDataSourceName
	ENDIF

;
; pascal ComponentResult SGChannelGetDataSourceName(SGChannel c, Str255 name, ScriptCode *scriptTag)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGChannelGetDataSourceName
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0098
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGChannelGetDataSourceName
	ENDIF

;
;	calls from seqGrab to Channel
;
;
; pascal ComponentResult SGInitChannel(SGChannel c, SeqGrabComponent owner)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGInitChannel
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0180
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGInitChannel
	ENDIF

;
; pascal ComponentResult SGWriteSamples(SGChannel c, Movie m, AliasHandle theFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGWriteSamples
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0181
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGWriteSamples
	ENDIF

;
; pascal ComponentResult SGGetDataRate(SGChannel c, long *bytesPerSecond)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetDataRate
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0182
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetDataRate
	ENDIF

;
; pascal ComponentResult SGAlignChannelRect(SGChannel c, Rect *r)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGAlignChannelRect
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0183
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGAlignChannelRect
	ENDIF

;
;	Dorky dialog panel calls
;
;
; pascal ComponentResult SGPanelGetDitl(SeqGrabComponent s, Handle *ditl)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelGetDitl
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0200
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelGetDitl
	ENDIF

;
; pascal ComponentResult SGPanelGetTitle(SeqGrabComponent s, Str255 title)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelGetTitle
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0201
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelGetTitle
	ENDIF

;
; pascal ComponentResult SGPanelCanRun(SeqGrabComponent s, SGChannel c)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelCanRun
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0202
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelCanRun
	ENDIF

;
; pascal ComponentResult SGPanelInstall(SeqGrabComponent s, SGChannel c, DialogPtr d, short itemOffset)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelInstall
			dc.w 	$2F3C
			dc.w 	$000A
			dc.w 	$0203
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelInstall
	ENDIF

;
; pascal ComponentResult SGPanelEvent(SeqGrabComponent s, SGChannel c, DialogPtr d, short itemOffset, EventRecord *theEvent, short *itemHit, Boolean *handled)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelEvent
			dc.w 	$2F3C
			dc.w 	$0016
			dc.w 	$0204
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelEvent
	ENDIF

;
; pascal ComponentResult SGPanelItem(SeqGrabComponent s, SGChannel c, DialogPtr d, short itemOffset, short itemNum)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelItem
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0205
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelItem
	ENDIF

;
; pascal ComponentResult SGPanelRemove(SeqGrabComponent s, SGChannel c, DialogPtr d, short itemOffset)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelRemove
			dc.w 	$2F3C
			dc.w 	$000A
			dc.w 	$0206
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelRemove
	ENDIF

;
; pascal ComponentResult SGPanelSetGrabber(SeqGrabComponent s, SeqGrabComponent sg)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelSetGrabber
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0207
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelSetGrabber
	ENDIF

;
; pascal ComponentResult SGPanelSetResFile(SeqGrabComponent s, short resRef)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelSetResFile
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$0208
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelSetResFile
	ENDIF

;
; pascal ComponentResult SGPanelGetSettings(SeqGrabComponent s, SGChannel c, UserData *ud, long flags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelGetSettings
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0209
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelGetSettings
	ENDIF

;
; pascal ComponentResult SGPanelSetSettings(SeqGrabComponent s, SGChannel c, UserData ud, long flags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelSetSettings
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$020A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelSetSettings
	ENDIF

;
; pascal ComponentResult SGPanelValidateInput(SeqGrabComponent s, Boolean *ok)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelValidateInput
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$020B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelValidateInput
	ENDIF

;
; pascal ComponentResult SGPanelSetEventFilter(SeqGrabComponent s, SGModalFilterUPP proc, long refCon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGPanelSetEventFilter
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$020C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGPanelSetEventFilter
	ENDIF

;** Sequence Grab VIDEO CHANNEL Component Stuff **
;
;	Video stuff
;
SGCompressInfo 			RECORD	0
buffer					 ds.l   1		; offset: $0 (0)
bufferSize				 ds.l   1		; offset: $4 (4)
similarity				 ds.b   1		; offset: $8 (8)
reserved				 ds.b   1		; offset: $9 (9)
sizeof					 EQU *			; size:   $A (10)
						ENDR

; typedef struct SGCompressInfo  SGCompressInfo
VideoBottles 			RECORD	0
procCount				 ds.w   1		; offset: $0 (0)
grabProc				 ds.l   1		; offset: $2 (2)
grabCompleteProc		 ds.l   1		; offset: $6 (6)
displayProc				 ds.l   1		; offset: $A (10)
compressProc			 ds.l   1		; offset: $E (14)
compressCompleteProc	 ds.l   1		; offset: $12 (18)
addFrameProc			 ds.l   1		; offset: $16 (22)
transferFrameProc		 ds.l   1		; offset: $1A (26)
grabCompressCompleteProc ds.l   1		; offset: $1E (30)
displayCompressProc		 ds.l   1		; offset: $22 (34)
sizeof					 EQU *			; size:   $26 (38)
						ENDR

; typedef struct VideoBottles  VideoBottles
;
; pascal ComponentResult SGGetSrcVideoBounds(SGChannel c, Rect *r)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetSrcVideoBounds
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0100
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetSrcVideoBounds
	ENDIF

;
; pascal ComponentResult SGSetVideoRect(SGChannel c, const Rect *r)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetVideoRect
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0101
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetVideoRect
	ENDIF

;
; pascal ComponentResult SGGetVideoRect(SGChannel c, Rect *r)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetVideoRect
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0102
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetVideoRect
	ENDIF

;
; pascal ComponentResult SGGetVideoCompressorType(SGChannel c, OSType *compressorType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetVideoCompressorType
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0103
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetVideoCompressorType
	ENDIF

;
; pascal ComponentResult SGSetVideoCompressorType(SGChannel c, OSType compressorType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetVideoCompressorType
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0104
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetVideoCompressorType
	ENDIF

;
; pascal ComponentResult SGSetVideoCompressor(SGChannel c, short depth, CompressorComponent compressor, CodecQ spatialQuality, CodecQ temporalQuality, long keyFrameRate)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetVideoCompressor
			dc.w 	$2F3C
			dc.w 	$0012
			dc.w 	$0105
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetVideoCompressor
	ENDIF

;
; pascal ComponentResult SGGetVideoCompressor(SGChannel c, short *depth, CompressorComponent *compressor, CodecQ *spatialQuality, CodecQ *temporalQuality, long *keyFrameRate)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetVideoCompressor
			dc.w 	$2F3C
			dc.w 	$0014
			dc.w 	$0106
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetVideoCompressor
	ENDIF

;
; pascal ComponentInstance SGGetVideoDigitizerComponent(SGChannel c)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetVideoDigitizerComponent
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0107
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetVideoDigitizerComponent
	ENDIF

;
; pascal ComponentResult SGSetVideoDigitizerComponent(SGChannel c, ComponentInstance vdig)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetVideoDigitizerComponent
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0108
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetVideoDigitizerComponent
	ENDIF

;
; pascal ComponentResult SGVideoDigitizerChanged(SGChannel c)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGVideoDigitizerChanged
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0109
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGVideoDigitizerChanged
	ENDIF

;
; pascal ComponentResult SGSetVideoBottlenecks(SGChannel c, VideoBottles *vb)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetVideoBottlenecks
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$010A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetVideoBottlenecks
	ENDIF

;
; pascal ComponentResult SGGetVideoBottlenecks(SGChannel c, VideoBottles *vb)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetVideoBottlenecks
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$010B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetVideoBottlenecks
	ENDIF

;
; pascal ComponentResult SGGrabFrame(SGChannel c, short bufferNum)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGrabFrame
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$010C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGrabFrame
	ENDIF

;
; pascal ComponentResult SGGrabFrameComplete(SGChannel c, short bufferNum, Boolean *done)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGrabFrameComplete
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$010D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGrabFrameComplete
	ENDIF

;
; pascal ComponentResult SGDisplayFrame(SGChannel c, short bufferNum, const MatrixRecord *mp, RgnHandle clipRgn)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGDisplayFrame
			dc.w 	$2F3C
			dc.w 	$000A
			dc.w 	$010E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGDisplayFrame
	ENDIF

;
; pascal ComponentResult SGCompressFrame(SGChannel c, short bufferNum)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGCompressFrame
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$010F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGCompressFrame
	ENDIF

;
; pascal ComponentResult SGCompressFrameComplete(SGChannel c, short bufferNum, Boolean *done, SGCompressInfo *ci)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGCompressFrameComplete
			dc.w 	$2F3C
			dc.w 	$000A
			dc.w 	$0110
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGCompressFrameComplete
	ENDIF

;
; pascal ComponentResult SGAddFrame(SGChannel c, short bufferNum, TimeValue atTime, TimeScale scale, const SGCompressInfo *ci)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGAddFrame
			dc.w 	$2F3C
			dc.w 	$000E
			dc.w 	$0111
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGAddFrame
	ENDIF

;
; pascal ComponentResult SGTransferFrameForCompress(SGChannel c, short bufferNum, const MatrixRecord *mp, RgnHandle clipRgn)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGTransferFrameForCompress
			dc.w 	$2F3C
			dc.w 	$000A
			dc.w 	$0112
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGTransferFrameForCompress
	ENDIF

;
; pascal ComponentResult SGSetCompressBuffer(SGChannel c, short depth, const Rect *compressSize)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetCompressBuffer
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$0113
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetCompressBuffer
	ENDIF

;
; pascal ComponentResult SGGetCompressBuffer(SGChannel c, short *depth, Rect *compressSize)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetCompressBuffer
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0114
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetCompressBuffer
	ENDIF

;
; pascal ComponentResult SGGetBufferInfo(SGChannel c, short bufferNum, PixMapHandle *bufferPM, Rect *bufferRect, GWorldPtr *compressBuffer, Rect *compressBufferRect)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetBufferInfo
			dc.w 	$2F3C
			dc.w 	$0012
			dc.w 	$0115
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetBufferInfo
	ENDIF

;
; pascal ComponentResult SGSetUseScreenBuffer(SGChannel c, Boolean useScreenBuffer)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetUseScreenBuffer
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$0116
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetUseScreenBuffer
	ENDIF

;
; pascal ComponentResult SGGetUseScreenBuffer(SGChannel c, Boolean *useScreenBuffer)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetUseScreenBuffer
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0117
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetUseScreenBuffer
	ENDIF

;
; pascal ComponentResult SGGrabCompressComplete(SGChannel c, Boolean *done, SGCompressInfo *ci, TimeRecord *tr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGrabCompressComplete
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0118
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGrabCompressComplete
	ENDIF

;
; pascal ComponentResult SGDisplayCompress(SGChannel c, Ptr dataPtr, ImageDescriptionHandle desc, MatrixRecord *mp, RgnHandle clipRgn)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGDisplayCompress
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$0119
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGDisplayCompress
	ENDIF

;
; pascal ComponentResult SGSetFrameRate(SGChannel c, Fixed frameRate)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetFrameRate
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$011A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetFrameRate
	ENDIF

;
; pascal ComponentResult SGGetFrameRate(SGChannel c, Fixed *frameRate)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetFrameRate
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$011B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetFrameRate
	ENDIF

;** Sequence Grab SOUND CHANNEL Component Stuff **
;
;	Sound stuff
;
;
; pascal ComponentResult SGSetSoundInputDriver(SGChannel c, ConstStr255Param driverName)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetSoundInputDriver
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0100
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetSoundInputDriver
	ENDIF

;
; pascal long SGGetSoundInputDriver(SGChannel c)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetSoundInputDriver
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0101
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetSoundInputDriver
	ENDIF

;
; pascal ComponentResult SGSoundInputDriverChanged(SGChannel c)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSoundInputDriverChanged
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0102
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSoundInputDriverChanged
	ENDIF

;
; pascal ComponentResult SGSetSoundRecordChunkSize(SGChannel c, long seconds)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetSoundRecordChunkSize
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0103
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetSoundRecordChunkSize
	ENDIF

;
; pascal long SGGetSoundRecordChunkSize(SGChannel c)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetSoundRecordChunkSize
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0104
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetSoundRecordChunkSize
	ENDIF

;
; pascal ComponentResult SGSetSoundInputRate(SGChannel c, Fixed rate)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetSoundInputRate
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0105
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetSoundInputRate
	ENDIF

;
; pascal Fixed SGGetSoundInputRate(SGChannel c)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetSoundInputRate
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0106
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetSoundInputRate
	ENDIF

;
; pascal ComponentResult SGSetSoundInputParameters(SGChannel c, short sampleSize, short numChannels, OSType compressionType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGSetSoundInputParameters
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0107
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGSetSoundInputParameters
	ENDIF

;
; pascal ComponentResult SGGetSoundInputParameters(SGChannel c, short *sampleSize, short *numChannels, OSType *compressionType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SGGetSoundInputParameters
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0108
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGGetSoundInputParameters
	ENDIF


sgChannelAtom					EQU		'chan'
sgChannelSettingsAtom			EQU		'ctom'
sgChannelDescription			EQU		'cdsc'
sgChannelSettings				EQU		'cset'

sgDeviceNameType				EQU		'name'
sgUsageType						EQU		'use '
sgPlayFlagsType					EQU		'plyf'
sgClipType						EQU		'clip'
sgMatrixType					EQU		'mtrx'
sgVolumeType					EQU		'volu'

sgPanelSettingsAtom				EQU		'ptom'
sgPanelDescription				EQU		'pdsc'
sgPanelSettings					EQU		'pset'

sgcSoundCompressionType			EQU		'scmp'
sgcSoundSampleRateType			EQU		'srat'
sgcSoundChannelCountType		EQU		'schn'
sgcSoundSampleSizeType			EQU		'ssiz'
sgcSoundInputType				EQU		'sinp'
sgcSoundGainType				EQU		'gain'

sgcVideoHueType					EQU		'hue '
sgcVideoSaturationType			EQU		'satr'
sgcVideoContrastType			EQU		'trst'
sgcVideoSharpnessType			EQU		'shrp'
sgcVideoBrigtnessType			EQU		'brit'
sgcVideoBlackLevelType			EQU		'blkl'
sgcVideoWhiteLevelType			EQU		'whtl'
sgcVideoInputType				EQU		'vinp'
sgcVideoFormatType				EQU		'vstd'
sgcVideoFilterType				EQU		'vflt'
sgcVideoRectType				EQU		'vrct'
sgVideoDigitizerType			EQU		'vdig'

kSGInitializeSelect				EQU		$1
kSGSetDataOutputSelect			EQU		$2
kSGGetDataOutputSelect			EQU		$3
kSGSetGWorldSelect				EQU		$4
kSGGetGWorldSelect				EQU		$5
kSGNewChannelSelect				EQU		$6
kSGDisposeChannelSelect			EQU		$7
kSGStartPreviewSelect			EQU		$10
kSGStartRecordSelect			EQU		$11
kSGIdleSelect					EQU		$12
kSGStopSelect					EQU		$13
kSGPauseSelect					EQU		$14
kSGPrepareSelect				EQU		$15
kSGReleaseSelect				EQU		$16
kSGGetMovieSelect				EQU		$17
kSGSetMaximumRecordTimeSelect	EQU		$18
kSGGetMaximumRecordTimeSelect	EQU		$19
kSGGetStorageSpaceRemainingSelect EQU		$1A
kSGGetTimeRemainingSelect		EQU		$1B
kSGGrabPictSelect				EQU		$1C
kSGGetLastMovieResIDSelect		EQU		$1D
kSGSetFlagsSelect				EQU		$1E
kSGGetFlagsSelect				EQU		$1F
kSGSetDataProcSelect			EQU		$20
kSGNewChannelFromComponentSelect EQU		$21
kSGDisposeDeviceListSelect		EQU		$22
kSGAppendDeviceListToMenuSelect	EQU		$23
kSGSetSettingsSelect			EQU		$24
kSGGetSettingsSelect			EQU		$25
kSGGetIndChannelSelect			EQU		$26
kSGUpdateSelect					EQU		$27
kSGGetPauseSelect				EQU		$28
kSGSettingsDialogSelect			EQU		$29
kSGGetAlignmentProcSelect		EQU		$2A
kSGSetChannelSettingsSelect		EQU		$2B
kSGGetChannelSettingsSelect		EQU		$2C
kSGGetModeSelect				EQU		$2D
kSGSetDataRefSelect				EQU		$2E
kSGGetDataRefSelect				EQU		$2F
kSGNewOutputSelect				EQU		$30
kSGDisposeOutputSelect			EQU		$31
kSGSetOutputFlagsSelect			EQU		$32
kSGSetChannelOutputSelect		EQU		$33
kSGGetDataOutputStorageSpaceRemainingSelect EQU		$34
kSGWriteMovieDataSelect			EQU		$100
kSGAddFrameReferenceSelect		EQU		$101
kSGGetNextFrameReferenceSelect	EQU		$102
kSGGetTimeBaseSelect			EQU		$103
kSGSortDeviceListSelect			EQU		$104
kSGAddMovieDataSelect			EQU		$105
kSGChangedSourceSelect			EQU		$106
kSGCSetChannelUsageSelect		EQU		$80
kSGCGetChannelUsageSelect		EQU		$81
kSGCSetChannelBoundsSelect		EQU		$82
kSGCGetChannelBoundsSelect		EQU		$83
kSGCSetChannelVolumeSelect		EQU		$84
kSGCGetChannelVolumeSelect		EQU		$85
kSGCGetChannelInfoSelect		EQU		$86
kSGCSetChannelPlayFlagsSelect	EQU		$87
kSGCGetChannelPlayFlagsSelect	EQU		$88
kSGCSetChannelMaxFramesSelect	EQU		$89
kSGCGetChannelMaxFramesSelect	EQU		$8A
kSGCSetChannelRefConSelect		EQU		$8B
kSGCSetChannelClipSelect		EQU		$8C
kSGCGetChannelClipSelect		EQU		$8D
kSGCGetChannelSampleDescriptionSelect EQU		$8E
kSGCGetChannelDeviceListSelect	EQU		$8F
kSGCSetChannelDeviceSelect		EQU		$90
kSGCSetChannelMatrixSelect		EQU		$91
kSGCGetChannelMatrixSelect		EQU		$92
kSGCGetChannelTimeScaleSelect	EQU		$93
kSGCChannelPutPictureSelect		EQU		$94
kSGCChannelSetRequestedDataRateSelect EQU		$95
kSGCChannelGetRequestedDataRateSelect EQU		$96
kSGCChannelSetDataSourceNameSelect EQU		$97
kSGCChannelGetDataSourceNameSelect EQU		$98
kSGCInitChannelSelect			EQU		$180
kSGCWriteSamplesSelect			EQU		$181
kSGCGetDataRateSelect			EQU		$182
kSGCAlignChannelRectSelect		EQU		$183
kSGCPanelGetDitlSelect			EQU		$200
kSGCPanelGetTitleSelect			EQU		$201
kSGCPanelCanRunSelect			EQU		$202
kSGCPanelInstallSelect			EQU		$203
kSGCPanelEventSelect			EQU		$204
kSGCPanelItemSelect				EQU		$205
kSGCPanelRemoveSelect			EQU		$206
kSGCPanelSetGrabberSelect		EQU		$207
kSGCPanelSetResFileSelect		EQU		$208
kSGCPanelGetSettingsSelect		EQU		$209
kSGCPanelSetSettingsSelect		EQU		$20A
kSGCPanelValidateInputSelect	EQU		$20B
kSGCPanelSetEventFilterSelect	EQU		$20C
kSGCGetSrcVideoBoundsSelect		EQU		$100
kSGCSetVideoRectSelect			EQU		$101
kSGCGetVideoRectSelect			EQU		$102
kSGCGetVideoCompressorTypeSelect EQU		$103
kSGCSetVideoCompressorTypeSelect EQU		$104
kSGCSetVideoCompressorSelect	EQU		$105
kSGCGetVideoCompressorSelect	EQU		$106
kSGCGetVideoDigitizerComponentSelect EQU		$107
kSGCSetVideoDigitizerComponentSelect EQU		$108
kSGCVideoDigitizerChangedSelect	EQU		$109
kSGCSetVideoBottlenecksSelect	EQU		$10A
kSGCGetVideoBottlenecksSelect	EQU		$10B
kSGCGrabFrameSelect				EQU		$10C
kSGCGrabFrameCompleteSelect		EQU		$10D
kSGCDisplayFrameSelect			EQU		$10E
kSGCCompressFrameSelect			EQU		$10F
kSGCCompressFrameCompleteSelect	EQU		$110
kSGCAddFrameSelect				EQU		$111
kSGCTransferFrameForCompressSelect EQU		$112
kSGCSetCompressBufferSelect		EQU		$113
kSGCGetCompressBufferSelect		EQU		$114
kSGCGetBufferInfoSelect			EQU		$115
kSGCSetUseScreenBufferSelect	EQU		$116
kSGCGetUseScreenBufferSelect	EQU		$117
kSGCGrabCompressCompleteSelect	EQU		$118
kSGCDisplayCompressSelect		EQU		$119
kSGCSetFrameRateSelect			EQU		$11A
kSGCGetFrameRateSelect			EQU		$11B
kSGCSetSoundInputDriverSelect	EQU		$100
kSGCGetSoundInputDriverSelect	EQU		$101
kSGCSoundInputDriverChangedSelect EQU		$102
kSGCSetSoundRecordChunkSizeSelect EQU		$103
kSGCGetSoundRecordChunkSizeSelect EQU		$104
kSGCSetSoundInputRateSelect		EQU		$105
kSGCGetSoundInputRateSelect		EQU		$106
kSGCSetSoundInputParametersSelect EQU		$107
kSGCGetSoundInputParametersSelect EQU		$108

; Standard type for video digitizers 
videoDigitizerComponentType		EQU		'vdig'
vdigInterfaceRev				EQU		2

; Input Format Standards 
ntscIn							EQU		0					; current input format 
currentIn						EQU		0					; ntsc input format 
palIn							EQU		1					; pal input format 
secamIn							EQU		2					; secam input format 
ntscReallyIn					EQU		3					; ntsc input format 

; Input Formats 
compositeIn						EQU		0					; input is composite format 
sVideoIn						EQU		1					; input is sVideo format 
rgbComponentIn					EQU		2					; input is rgb component format 
rgbComponentSyncIn				EQU		3					; input is rgb component format (sync on green?)
yuvComponentIn					EQU		4					; input is yuv component format 
yuvComponentSyncIn				EQU		5					; input is yuv component format (sync on green?) 

; Video Digitizer PlayThru States 
vdPlayThruOff					EQU		0
vdPlayThruOn					EQU		1

; Input Color Space Modes 
vdDigitizerBW					EQU		0					; black and white 
vdDigitizerRGB					EQU		1					; rgb color 

; Phase Lock Loop Modes 
vdBroadcastMode					EQU		0					; Broadcast / Laser Disk video mode 
vdVTRMode						EQU		1					; VCR / Magnetic media mode 

; Field Select Options 
vdUseAnyField					EQU		0					; Digitizers choice on field use 
vdUseOddField					EQU		1					; Use odd field for half size vert and smaller 
vdUseEvenField					EQU		2					; Use even field for half size vert and smaller 

; vdig types 
vdTypeBasic						EQU		0					; basic, no clipping 
vdTypeAlpha						EQU		1					; supports clipping with alpha channel 
vdTypeMask						EQU		2					; supports clipping with mask plane 
vdTypeKey						EQU		3					; supports clipping with key color(s) 

; Digitizer Input Capability/Current Flags	
digiInDoesNTSC					EQU		1 << 0				; digitizer supports NTSC input format 
digiInDoesPAL					EQU		1 << 1				; digitizer supports PAL input format 
digiInDoesSECAM					EQU		1 << 2				; digitizer supports SECAM input format 
digiInDoesGenLock				EQU		1 << 7				; digitizer does genlock 
digiInDoesComposite				EQU		1 << 8				; digitizer supports composite input type 
digiInDoesSVideo				EQU		1 << 9				; digitizer supports S-Video input type 
digiInDoesComponent				EQU		1 << 10				; digitizer supports component = rgb, input type 
digiInVTR_Broadcast				EQU		1 << 11				; digitizer can differentiate between the two 
digiInDoesColor					EQU		1 << 12				; digitizer supports color 
digiInDoesBW					EQU		1 << 13				; digitizer supports black & white 
; Digitizer Input Current Flags = these are valid only during active operating conditions,	
digiInSignalLock				EQU		1 << 31				; digitizer detects input signal is locked, this bit = horiz lock || vertical lock 

; Digitizer Output Capability/Current Flags 
digiOutDoes1					EQU		1 << 0				; digitizer supports 1 bit pixels 
digiOutDoes2					EQU		1 << 1				; digitizer supports 2 bit pixels 
digiOutDoes4					EQU		1 << 2				; digitizer supports 4 bit pixels 
digiOutDoes8					EQU		1 << 3				; digitizer supports 8 bit pixels 
digiOutDoes16					EQU		1 << 4				; digitizer supports 16 bit pixels 
digiOutDoes32					EQU		1 << 5				; digitizer supports 32 bit pixels 
digiOutDoesDither				EQU		1 << 6				; digitizer dithers in indexed modes 
digiOutDoesStretch				EQU		1 << 7				; digitizer can arbitrarily stretch 
digiOutDoesShrink				EQU		1 << 8				; digitizer can arbitrarily shrink 
digiOutDoesMask					EQU		1 << 9				; digitizer can mask to clipping regions 
digiOutDoesDouble				EQU		1 << 11				; digitizer can stretch to exactly double size 
digiOutDoesQuad					EQU		1 << 12				; digitizer can stretch exactly quadruple size 
digiOutDoesQuarter				EQU		1 << 13				; digitizer can shrink to exactly quarter size 
digiOutDoesSixteenth			EQU		1 << 14				; digitizer can shrink to exactly sixteenth size 
digiOutDoesRotate				EQU		1 << 15				; digitizer supports rotate transformations 
digiOutDoesHorizFlip			EQU		1 << 16				; digitizer supports horizontal flips Sx < 0 
digiOutDoesVertFlip				EQU		1 << 17				; digitizer supports vertical flips Sy < 0 
digiOutDoesSkew					EQU		1 << 18				; digitizer supports skew = shear,twist, 
digiOutDoesBlend				EQU		1 << 19
digiOutDoesWarp					EQU		1 << 20
digiOutDoesHW_DMA				EQU		1 << 21				; digitizer not constrained to local device 
digiOutDoesHWPlayThru			EQU		1 << 22				; digitizer doesn't need time to play thru 
digiOutDoesILUT					EQU		1 << 23				; digitizer does inverse LUT for index modes 
digiOutDoesKeyColor				EQU		1 << 24				; digitizer does key color functions too 
digiOutDoesAsyncGrabs			EQU		1 << 25				; digitizer supports async grabs 
digiOutDoesUnreadableScreenBits	EQU		1 << 26				; playthru doesn't generate readable bits on screen
digiOutDoesCompress				EQU		1 << 27				; supports alternate output data types 
digiOutDoesCompressOnly			EQU		1 << 28				; can't provide raw frames anywhere 
digiOutDoesPlayThruDuringCompress EQU		1 << 29			; digi can do playthru while providing compressed data 

; Types 
; typedef ComponentInstance  VideoDigitizerComponent
; typedef ComponentResult 	VideoDigitizerError
DigitizerInfo 			RECORD	0
vdigType				 ds.w   1		; offset: $0 (0)
inputCapabilityFlags	 ds.l   1		; offset: $2 (2)
outputCapabilityFlags	 ds.l   1		; offset: $6 (6)
inputCurrentFlags		 ds.l   1		; offset: $A (10)
outputCurrentFlags		 ds.l   1		; offset: $E (14)
slot					 ds.w   1		; offset: $12 (18)		; temporary for connection purposes 
gdh						 ds.l   1		; offset: $14 (20)		; temporary for digitizers that have preferred screen 
maskgdh					 ds.l   1		; offset: $18 (24)		; temporary for digitizers that have mask planes 
minDestHeight			 ds.w   1		; offset: $1C (28)		; Smallest resizable height 
minDestWidth			 ds.w   1		; offset: $1E (30)		; Smallest resizable width 
maxDestHeight			 ds.w   1		; offset: $20 (32)		; Largest resizable height 
maxDestWidth			 ds.w   1		; offset: $22 (34)		; Largest resizable height 
blendLevels				 ds.w   1		; offset: $24 (36)		; Number of blend levels supported (2 if 1 bit mask) 
reserved				 ds.l   1		; offset: $26 (38)		; reserved 
sizeof					 EQU *			; size:   $2A (42)
						ENDR

; typedef struct DigitizerInfo  DigitizerInfo
VdigType 				RECORD	0
digType					 ds.l   1		; offset: $0 (0)
reserved				 ds.l   1		; offset: $4 (4)
sizeof					 EQU *			; size:   $8 (8)
						ENDR

; typedef struct VdigType 	VdigType
VdigTypeList 			RECORD	0
count					 ds.w   1		; offset: $0 (0)
list					 ds     VdigType ; offset: $2 (2)
sizeof					 EQU *			; size:   $A (10)
						ENDR

; typedef struct VdigTypeList  VdigTypeList
VdigBufferRec 			RECORD	0
dest					 ds.l   1		; offset: $0 (0)
location				 ds     Point	; offset: $4 (4)
reserved				 ds.l   1		; offset: $8 (8)
sizeof					 EQU *			; size:   $C (12)
						ENDR

; typedef struct VdigBufferRec  VdigBufferRec
VdigBufferRecList 		RECORD	0
count					 ds.w   1		; offset: $0 (0)
matrix					 ds.l   1		; offset: $2 (2)
mask					 ds.l   1		; offset: $6 (6)
list					 ds     VdigBufferRec ; offset: $A (10)
sizeof					 EQU *			; size:   $16 (22)
						ENDR

; typedef struct VdigBufferRecList  VdigBufferRecList, *VdigBufferRecListPtr, **VdigBufferRecListHandle
VDCompressionList 		RECORD	0
codec					 ds.l   1		; offset: $0 (0)
cType					 ds.l   1		; offset: $4 (4)
typeName				 ds.l   16		; offset: $8 (8)
name					 ds.l   16		; offset: $48 (72)
formatFlags				 ds.l   1		; offset: $88 (136)
compressFlags			 ds.l   1		; offset: $8C (140)
reserved				 ds.l   1		; offset: $90 (144)
sizeof					 EQU *			; size:   $94 (148)
						ENDR

; typedef struct VDCompressionList  VDCompressionList, *VDCompressionListPtr, **VDCompressionListHandle

dmaDepth1						EQU		1
dmaDepth2						EQU		2
dmaDepth4						EQU		4
dmaDepth8						EQU		8
dmaDepth16						EQU		16
dmaDepth32						EQU		32
dmaDepth2Gray					EQU		64
dmaDepth4Gray					EQU		128
dmaDepth8Gray					EQU		256

kVDIGControlledFrameRate		EQU		-1

; number of vdig calls
kvdigSelectors					EQU		86

;
; pascal VideoDigitizerError VDGetMaxSrcRect(VideoDigitizerComponent ci, short inputStd, Rect *maxSrcRect)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetMaxSrcRect
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$0001
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetMaxSrcRect
	ENDIF

;
; pascal VideoDigitizerError VDGetActiveSrcRect(VideoDigitizerComponent ci, short inputStd, Rect *activeSrcRect)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetActiveSrcRect
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$0002
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetActiveSrcRect
	ENDIF

;
; pascal VideoDigitizerError VDSetDigitizerRect(VideoDigitizerComponent ci, Rect *digitizerRect)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetDigitizerRect
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0003
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetDigitizerRect
	ENDIF

;
; pascal VideoDigitizerError VDGetDigitizerRect(VideoDigitizerComponent ci, Rect *digitizerRect)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetDigitizerRect
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0004
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetDigitizerRect
	ENDIF

;
; pascal VideoDigitizerError VDGetVBlankRect(VideoDigitizerComponent ci, short inputStd, Rect *vBlankRect)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetVBlankRect
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$0005
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetVBlankRect
	ENDIF

;
; pascal VideoDigitizerError VDGetMaskPixMap(VideoDigitizerComponent ci, PixMapHandle maskPixMap)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetMaskPixMap
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0006
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetMaskPixMap
	ENDIF

;
; pascal VideoDigitizerError VDGetPlayThruDestination(VideoDigitizerComponent ci, PixMapHandle *dest, Rect *destRect, MatrixRecord *m, RgnHandle *mask)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetPlayThruDestination
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$0008
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetPlayThruDestination
	ENDIF

;
; pascal VideoDigitizerError VDUseThisCLUT(VideoDigitizerComponent ci, CTabHandle colorTableHandle)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDUseThisCLUT
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0009
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDUseThisCLUT
	ENDIF

;
; pascal VideoDigitizerError VDSetInputGammaValue(VideoDigitizerComponent ci, Fixed channel1, Fixed channel2, Fixed channel3)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetInputGammaValue
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$000A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetInputGammaValue
	ENDIF

;
; pascal VideoDigitizerError VDGetInputGammaValue(VideoDigitizerComponent ci, Fixed *channel1, Fixed *channel2, Fixed *channel3)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetInputGammaValue
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$000B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetInputGammaValue
	ENDIF

;
; pascal VideoDigitizerError VDSetBrightness(VideoDigitizerComponent ci, unsigned short *brightness)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetBrightness
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetBrightness
	ENDIF

;
; pascal VideoDigitizerError VDGetBrightness(VideoDigitizerComponent ci, unsigned short *brightness)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetBrightness
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetBrightness
	ENDIF

;
; pascal VideoDigitizerError VDSetContrast(VideoDigitizerComponent ci, unsigned short *contrast)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetContrast
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetContrast
	ENDIF

;
; pascal VideoDigitizerError VDSetHue(VideoDigitizerComponent ci, unsigned short *hue)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetHue
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetHue
	ENDIF

;
; pascal VideoDigitizerError VDSetSharpness(VideoDigitizerComponent ci, unsigned short *sharpness)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetSharpness
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0010
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetSharpness
	ENDIF

;
; pascal VideoDigitizerError VDSetSaturation(VideoDigitizerComponent ci, unsigned short *saturation)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetSaturation
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0011
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetSaturation
	ENDIF

;
; pascal VideoDigitizerError VDGetContrast(VideoDigitizerComponent ci, unsigned short *contrast)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetContrast
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0012
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetContrast
	ENDIF

;
; pascal VideoDigitizerError VDGetHue(VideoDigitizerComponent ci, unsigned short *hue)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetHue
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0013
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetHue
	ENDIF

;
; pascal VideoDigitizerError VDGetSharpness(VideoDigitizerComponent ci, unsigned short *sharpness)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetSharpness
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0014
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetSharpness
	ENDIF

;
; pascal VideoDigitizerError VDGetSaturation(VideoDigitizerComponent ci, unsigned short *saturation)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetSaturation
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0015
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetSaturation
	ENDIF

;
; pascal VideoDigitizerError VDGrabOneFrame(VideoDigitizerComponent ci)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGrabOneFrame
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0016
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGrabOneFrame
	ENDIF

;
; pascal VideoDigitizerError VDGetMaxAuxBuffer(VideoDigitizerComponent ci, PixMapHandle *pm, Rect *r)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetMaxAuxBuffer
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0017
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetMaxAuxBuffer
	ENDIF

;
; pascal VideoDigitizerError VDGetDigitizerInfo(VideoDigitizerComponent ci, DigitizerInfo *info)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetDigitizerInfo
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0019
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetDigitizerInfo
	ENDIF

;
; pascal VideoDigitizerError VDGetCurrentFlags(VideoDigitizerComponent ci, long *inputCurrentFlag, long *outputCurrentFlag)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetCurrentFlags
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$001A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetCurrentFlags
	ENDIF

;
; pascal VideoDigitizerError VDSetKeyColor(VideoDigitizerComponent ci, long index)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetKeyColor
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetKeyColor
	ENDIF

;
; pascal VideoDigitizerError VDGetKeyColor(VideoDigitizerComponent ci, long *index)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetKeyColor
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetKeyColor
	ENDIF

;
; pascal VideoDigitizerError VDAddKeyColor(VideoDigitizerComponent ci, long *index)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDAddKeyColor
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDAddKeyColor
	ENDIF

;
; pascal VideoDigitizerError VDGetNextKeyColor(VideoDigitizerComponent ci, long index)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetNextKeyColor
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetNextKeyColor
	ENDIF

;
; pascal VideoDigitizerError VDSetKeyColorRange(VideoDigitizerComponent ci, RGBColor *minRGB, RGBColor *maxRGB)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetKeyColorRange
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$001F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetKeyColorRange
	ENDIF

;
; pascal VideoDigitizerError VDGetKeyColorRange(VideoDigitizerComponent ci, RGBColor *minRGB, RGBColor *maxRGB)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetKeyColorRange
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0020
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetKeyColorRange
	ENDIF

;
; pascal VideoDigitizerError VDSetDigitizerUserInterrupt(VideoDigitizerComponent ci, long flags, VdigIntUPP userInterruptProc, long refcon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetDigitizerUserInterrupt
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0021
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetDigitizerUserInterrupt
	ENDIF

;
; pascal VideoDigitizerError VDSetInputColorSpaceMode(VideoDigitizerComponent ci, short colorSpaceMode)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetInputColorSpaceMode
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$0022
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetInputColorSpaceMode
	ENDIF

;
; pascal VideoDigitizerError VDGetInputColorSpaceMode(VideoDigitizerComponent ci, short *colorSpaceMode)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetInputColorSpaceMode
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0023
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetInputColorSpaceMode
	ENDIF

;
; pascal VideoDigitizerError VDSetClipState(VideoDigitizerComponent ci, short clipEnable)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetClipState
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$0024
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetClipState
	ENDIF

;
; pascal VideoDigitizerError VDGetClipState(VideoDigitizerComponent ci, short *clipEnable)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetClipState
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0025
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetClipState
	ENDIF

;
; pascal VideoDigitizerError VDSetClipRgn(VideoDigitizerComponent ci, RgnHandle clipRegion)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetClipRgn
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0026
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetClipRgn
	ENDIF

;
; pascal VideoDigitizerError VDClearClipRgn(VideoDigitizerComponent ci, RgnHandle clipRegion)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDClearClipRgn
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0027
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDClearClipRgn
	ENDIF

;
; pascal VideoDigitizerError VDGetCLUTInUse(VideoDigitizerComponent ci, CTabHandle *colorTableHandle)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetCLUTInUse
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0028
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetCLUTInUse
	ENDIF

;
; pascal VideoDigitizerError VDSetPLLFilterType(VideoDigitizerComponent ci, short pllType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetPLLFilterType
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$0029
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetPLLFilterType
	ENDIF

;
; pascal VideoDigitizerError VDGetPLLFilterType(VideoDigitizerComponent ci, short *pllType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetPLLFilterType
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$002A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetPLLFilterType
	ENDIF

;
; pascal VideoDigitizerError VDGetMaskandValue(VideoDigitizerComponent ci, unsigned short blendLevel, long *mask, long *value)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetMaskandValue
			dc.w 	$2F3C
			dc.w 	$000A
			dc.w 	$002B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetMaskandValue
	ENDIF

;
; pascal VideoDigitizerError VDSetMasterBlendLevel(VideoDigitizerComponent ci, unsigned short *blendLevel)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetMasterBlendLevel
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$002C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetMasterBlendLevel
	ENDIF

;
; pascal VideoDigitizerError VDSetPlayThruDestination(VideoDigitizerComponent ci, PixMapHandle dest, Rect *destRect, MatrixRecord *m, RgnHandle mask)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetPlayThruDestination
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$002D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetPlayThruDestination
	ENDIF

;
; pascal VideoDigitizerError VDSetPlayThruOnOff(VideoDigitizerComponent ci, short state)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetPlayThruOnOff
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$002E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetPlayThruOnOff
	ENDIF

;
; pascal VideoDigitizerError VDSetFieldPreference(VideoDigitizerComponent ci, short fieldFlag)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetFieldPreference
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$002F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetFieldPreference
	ENDIF

;
; pascal VideoDigitizerError VDGetFieldPreference(VideoDigitizerComponent ci, short *fieldFlag)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetFieldPreference
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0030
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetFieldPreference
	ENDIF

;
; pascal VideoDigitizerError VDPreflightDestination(VideoDigitizerComponent ci, Rect *digitizerRect, PixMap **dest, Rect *destRect, MatrixRecord *m)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDPreflightDestination
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$0032
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDPreflightDestination
	ENDIF

;
; pascal VideoDigitizerError VDPreflightGlobalRect(VideoDigitizerComponent ci, GrafPtr theWindow, Rect *globalRect)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDPreflightGlobalRect
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0033
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDPreflightGlobalRect
	ENDIF

;
; pascal VideoDigitizerError VDSetPlayThruGlobalRect(VideoDigitizerComponent ci, GrafPtr theWindow, Rect *globalRect)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetPlayThruGlobalRect
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0034
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetPlayThruGlobalRect
	ENDIF

;
; pascal VideoDigitizerError VDSetInputGammaRecord(VideoDigitizerComponent ci, VDGamRecPtr inputGammaPtr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetInputGammaRecord
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0035
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetInputGammaRecord
	ENDIF

;
; pascal VideoDigitizerError VDGetInputGammaRecord(VideoDigitizerComponent ci, VDGamRecPtr *inputGammaPtr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetInputGammaRecord
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0036
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetInputGammaRecord
	ENDIF

;
; pascal VideoDigitizerError VDSetBlackLevelValue(VideoDigitizerComponent ci, unsigned short *blackLevel)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetBlackLevelValue
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0037
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetBlackLevelValue
	ENDIF

;
; pascal VideoDigitizerError VDGetBlackLevelValue(VideoDigitizerComponent ci, unsigned short *blackLevel)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetBlackLevelValue
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0038
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetBlackLevelValue
	ENDIF

;
; pascal VideoDigitizerError VDSetWhiteLevelValue(VideoDigitizerComponent ci, unsigned short *whiteLevel)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetWhiteLevelValue
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0039
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetWhiteLevelValue
	ENDIF

;
; pascal VideoDigitizerError VDGetWhiteLevelValue(VideoDigitizerComponent ci, unsigned short *whiteLevel)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetWhiteLevelValue
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$003A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetWhiteLevelValue
	ENDIF

;
; pascal VideoDigitizerError VDGetVideoDefaults(VideoDigitizerComponent ci, unsigned short *blackLevel, unsigned short *whiteLevel, unsigned short *brightness, unsigned short *hue, unsigned short *saturation, unsigned short *contrast, unsigned short *sharpness)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetVideoDefaults
			dc.w 	$2F3C
			dc.w 	$001C
			dc.w 	$003B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetVideoDefaults
	ENDIF

;
; pascal VideoDigitizerError VDGetNumberOfInputs(VideoDigitizerComponent ci, short *inputs)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetNumberOfInputs
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$003C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetNumberOfInputs
	ENDIF

;
; pascal VideoDigitizerError VDGetInputFormat(VideoDigitizerComponent ci, short input, short *format)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetInputFormat
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$003D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetInputFormat
	ENDIF

;
; pascal VideoDigitizerError VDSetInput(VideoDigitizerComponent ci, short input)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetInput
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$003E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetInput
	ENDIF

;
; pascal VideoDigitizerError VDGetInput(VideoDigitizerComponent ci, short *input)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetInput
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$003F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetInput
	ENDIF

;
; pascal VideoDigitizerError VDSetInputStandard(VideoDigitizerComponent ci, short inputStandard)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetInputStandard
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$0040
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetInputStandard
	ENDIF

;
; pascal VideoDigitizerError VDSetupBuffers(VideoDigitizerComponent ci, VdigBufferRecListHandle bufferList)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetupBuffers
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0041
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetupBuffers
	ENDIF

;
; pascal VideoDigitizerError VDGrabOneFrameAsync(VideoDigitizerComponent ci, short buffer)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGrabOneFrameAsync
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$0042
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGrabOneFrameAsync
	ENDIF

;
; pascal VideoDigitizerError VDDone(VideoDigitizerComponent ci, short buffer)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDDone
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$0043
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDDone
	ENDIF

;
; pascal VideoDigitizerError VDSetCompression(VideoDigitizerComponent ci, OSType compressType, short depth, Rect *bounds, CodecQ spatialQuality, CodecQ temporalQuality, long keyFrameRate)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetCompression
			dc.w 	$2F3C
			dc.w 	$0016
			dc.w 	$0044
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetCompression
	ENDIF

;
; pascal VideoDigitizerError VDCompressOneFrameAsync(VideoDigitizerComponent ci)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDCompressOneFrameAsync
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0045
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDCompressOneFrameAsync
	ENDIF

;
; pascal VideoDigitizerError VDCompressDone(VideoDigitizerComponent ci, Boolean *done, Ptr *theData, long *dataSize, UInt8 *similarity, TimeRecord *t)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDCompressDone
			dc.w 	$2F3C
			dc.w 	$0014
			dc.w 	$0046
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDCompressDone
	ENDIF

;
; pascal VideoDigitizerError VDReleaseCompressBuffer(VideoDigitizerComponent ci, Ptr bufferAddr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDReleaseCompressBuffer
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0047
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDReleaseCompressBuffer
	ENDIF

;
; pascal VideoDigitizerError VDGetImageDescription(VideoDigitizerComponent ci, ImageDescriptionHandle desc)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetImageDescription
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0048
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetImageDescription
	ENDIF

;
; pascal VideoDigitizerError VDResetCompressSequence(VideoDigitizerComponent ci)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDResetCompressSequence
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0049
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDResetCompressSequence
	ENDIF

;
; pascal VideoDigitizerError VDSetCompressionOnOff(VideoDigitizerComponent ci, Boolean state)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetCompressionOnOff
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$004A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetCompressionOnOff
	ENDIF

;
; pascal VideoDigitizerError VDGetCompressionTypes(VideoDigitizerComponent ci, VDCompressionListHandle h)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetCompressionTypes
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$004B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetCompressionTypes
	ENDIF

;
; pascal VideoDigitizerError VDSetTimeBase(VideoDigitizerComponent ci, TimeBase t)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetTimeBase
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$004C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetTimeBase
	ENDIF

;
; pascal VideoDigitizerError VDSetFrameRate(VideoDigitizerComponent ci, Fixed framesPerSecond)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetFrameRate
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$004D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetFrameRate
	ENDIF

;
; pascal VideoDigitizerError VDGetDataRate(VideoDigitizerComponent ci, long *milliSecPerFrame, Fixed *framesPerSecond, long *bytesPerSecond)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetDataRate
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$004E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetDataRate
	ENDIF

;
; pascal VideoDigitizerError VDGetSoundInputDriver(VideoDigitizerComponent ci, Str255 soundDriverName)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetSoundInputDriver
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$004F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetSoundInputDriver
	ENDIF

;
; pascal VideoDigitizerError VDGetDMADepths(VideoDigitizerComponent ci, long *depthArray, long *preferredDepth)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetDMADepths
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0050
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetDMADepths
	ENDIF

;
; pascal VideoDigitizerError VDGetPreferredTimeScale(VideoDigitizerComponent ci, TimeScale *preferred)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetPreferredTimeScale
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0051
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetPreferredTimeScale
	ENDIF

;
; pascal VideoDigitizerError VDReleaseAsyncBuffers(VideoDigitizerComponent ci)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDReleaseAsyncBuffers
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0052
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDReleaseAsyncBuffers
	ENDIF

; 83 is reserved for compatibility reasons 
;
; pascal VideoDigitizerError VDSetDataRate(VideoDigitizerComponent ci, long bytesPerSecond)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDSetDataRate
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0054
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDSetDataRate
	ENDIF

;
; pascal VideoDigitizerError VDGetTimeCode(VideoDigitizerComponent ci, TimeRecord *atTime, void *timeCodeFormat, void *timeCodeTime)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDGetTimeCode
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0055
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDGetTimeCode
	ENDIF

;
; pascal VideoDigitizerError VDUseSafeBuffers(VideoDigitizerComponent ci, Boolean useSafeBuffers)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_VDUseSafeBuffers
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$0056
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	VDUseSafeBuffers
	ENDIF

kSelectVDGetMaxSrcRect			EQU		$1
kSelectVDGetActiveSrcRect		EQU		$2
kSelectVDSetDigitizerRect		EQU		$3
kSelectVDGetDigitizerRect		EQU		$4
kSelectVDGetVBlankRect			EQU		$5
kSelectVDGetMaskPixMap			EQU		$6
kSelectVDGetPlayThruDestination	EQU		$8
kSelectVDUseThisCLUT			EQU		$9
kSelectVDSetInputGammaValue		EQU		$A
kSelectVDGetInputGammaValue		EQU		$B
kSelectVDSetBrightness			EQU		$C
kSelectVDGetBrightness			EQU		$D
kSelectVDSetContrast			EQU		$E
kSelectVDSetHue					EQU		$F
kSelectVDSetSharpness			EQU		$10
kSelectVDSetSaturation			EQU		$11
kSelectVDGetContrast			EQU		$12
kSelectVDGetHue					EQU		$13
kSelectVDGetSharpness			EQU		$14
kSelectVDGetSaturation			EQU		$15
kSelectVDGrabOneFrame			EQU		$16
kSelectVDGetMaxAuxBuffer		EQU		$17
kSelectVDGetDigitizerInfo		EQU		$19
kSelectVDGetCurrentFlags		EQU		$1A
kSelectVDSetKeyColor			EQU		$1B
kSelectVDGetKeyColor			EQU		$1C
kSelectVDAddKeyColor			EQU		$1D
kSelectVDGetNextKeyColor		EQU		$1E
kSelectVDSetKeyColorRange		EQU		$1F
kSelectVDGetKeyColorRange		EQU		$20
kSelectVDSetDigitizerUserInterrupt EQU		$21
kSelectVDSetInputColorSpaceMode	EQU		$22
kSelectVDGetInputColorSpaceMode	EQU		$23
kSelectVDSetClipState			EQU		$24
kSelectVDGetClipState			EQU		$25
kSelectVDSetClipRgn				EQU		$26
kSelectVDClearClipRgn			EQU		$27
kSelectVDGetCLUTInUse			EQU		$28
kSelectVDSetPLLFilterType		EQU		$29
kSelectVDGetPLLFilterType		EQU		$2A
kSelectVDGetMaskandValue		EQU		$2B
kSelectVDSetMasterBlendLevel	EQU		$2C
kSelectVDSetPlayThruDestination	EQU		$2D
kSelectVDSetPlayThruOnOff		EQU		$2E
kSelectVDSetFieldPreference		EQU		$2F
kSelectVDGetFieldPreference		EQU		$30
kSelectVDPreflightDestination	EQU		$32
kSelectVDPreflightGlobalRect	EQU		$33
kSelectVDSetPlayThruGlobalRect	EQU		$34
kSelectVDSetInputGammaRecord	EQU		$35
kSelectVDGetInputGammaRecord	EQU		$36
kSelectVDSetBlackLevelValue		EQU		$37
kSelectVDGetBlackLevelValue		EQU		$38
kSelectVDSetWhiteLevelValue		EQU		$39
kSelectVDGetWhiteLevelValue		EQU		$3A
kSelectVDGetVideoDefaults		EQU		$3B
kSelectVDGetNumberOfInputs		EQU		$3C
kSelectVDGetInputFormat			EQU		$3D
kSelectVDSetInput				EQU		$3E
kSelectVDGetInput				EQU		$3F
kSelectVDSetInputStandard		EQU		$40
kSelectVDSetupBuffers			EQU		$41
kSelectVDGrabOneFrameAsync		EQU		$42
kSelectVDDone					EQU		$43
kSelectVDSetCompression			EQU		$44
kSelectVDCompressOneFrameAsync	EQU		$45
kSelectVDCompressDone			EQU		$46
kSelectVDReleaseCompressBuffer	EQU		$47
kSelectVDGetImageDescription	EQU		$48
kSelectVDResetCompressSequence	EQU		$49
kSelectVDSetCompressionOnOff	EQU		$4A
kSelectVDGetCompressionTypes	EQU		$4B
kSelectVDSetTimeBase			EQU		$4C
kSelectVDSetFrameRate			EQU		$4D
kSelectVDGetDataRate			EQU		$4E
kSelectVDGetSoundInputDriver	EQU		$4F
kSelectVDGetDMADepths			EQU		$50
kSelectVDGetPreferredTimeScale	EQU		$51
kSelectVDReleaseAsyncBuffers	EQU		$52
kSelectVDSetDataRate			EQU		$54
kSelectVDGetTimeCode			EQU		$55
kSelectVDUseSafeBuffers			EQU		$56

StandardCompressionType			EQU		'scdi'
StandardCompressionSubType		EQU		'imag'

scListEveryCodec				EQU		1 << 1
scAllowZeroFrameRate			EQU		1 << 2
scAllowZeroKeyFrameRate			EQU		1 << 3
scShowBestDepth					EQU		1 << 4
scUseMovableModal				EQU		1 << 5

;	Possible test flags for setting test image.
scPreferCropping				EQU		1 << 0
scPreferScaling					EQU		1 << 1
scPreferScalingAndCropping		EQU		scPreferScaling | scPreferCropping

;	Dimensions of the image preview box.
scTestImageWidth				EQU		80
scTestImageHeight				EQU		80

;	Possible items returned by hookProc.
scOKItem						EQU		1
scCancelItem					EQU		2
scCustomItem					EQU		3

;	Result returned when user cancelled.
scUserCancelled					EQU		1

SCSpatialSettings 		RECORD	0
codecType				 ds.l   1		; offset: $0 (0)
codec					 ds.l   1		; offset: $4 (4)
depth					 ds.w   1		; offset: $8 (8)
spatialQuality			 ds.l   1		; offset: $A (10)
sizeof					 EQU *			; size:   $E (14)
						ENDR

; typedef struct SCSpatialSettings  SCSpatialSettings
SCTemporalSettings 		RECORD	0
temporalQuality			 ds.l   1		; offset: $0 (0)
frameRate				 ds.l   1		; offset: $4 (4)
keyFrameRate			 ds.l   1		; offset: $8 (8)
sizeof					 EQU *			; size:   $C (12)
						ENDR

; typedef struct SCTemporalSettings  SCTemporalSettings
SCDataRateSettings 		RECORD	0
dataRate				 ds.l   1		; offset: $0 (0)
frameDuration			 ds.l   1		; offset: $4 (4)
minSpatialQuality		 ds.l   1		; offset: $8 (8)
minTemporalQuality		 ds.l   1		; offset: $C (12)
sizeof					 EQU *			; size:   $10 (16)
						ENDR

; typedef struct SCDataRateSettings  SCDataRateSettings
SCExtendedProcs 		RECORD	0
filterProc				 ds.l   1		; offset: $0 (0)
hookProc				 ds.l   1		; offset: $4 (4)
refcon					 ds.l   1		; offset: $8 (8)
customName				 ds.l   8		; offset: $C (12)
sizeof					 EQU *			; size:   $2C (44)
						ENDR

; typedef struct SCExtendedProcs  SCExtendedProcs
;	Get/SetInfo selectors

scSpatialSettingsType			EQU		'sptl'				; pointer to SCSpatialSettings struct
scTemporalSettingsType			EQU		'tprl'				; pointer to SCTemporalSettings struct
scDataRateSettingsType			EQU		'drat'				; pointer to SCDataRateSettings struct
scColorTableType				EQU		'clut'				; pointer to CTabHandle
scProgressProcType				EQU		'prog'				; pointer to ProgressRecord struct
scExtendedProcsType				EQU		'xprc'				; pointer to SCExtendedProcs struct
scPreferenceFlagsType			EQU		'pref'				; pointer to long
scSettingsStateType				EQU		'ssta'				; pointer to Handle
scSequenceIDType				EQU		'sequ'				; pointer to ImageSequence
scWindowPositionType			EQU		'wndw'				; pointer to Point
scCodecFlagsType				EQU		'cflg'				; pointer to CodecFlags
scCodecSettingsType				EQU		'cdec'				; pointer to Handle
scForceKeyValueType				EQU		'ksim'

;	scTypeNotFoundErr returned by Get/SetInfo when type cannot be found.
;* These are Progress procedures *
;
; pascal ComponentResult SCPositionRect(ComponentInstance ci, Rect *rp, Point *where)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCPositionRect
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0002
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCPositionRect
	ENDIF

;
; pascal ComponentResult SCPositionDialog(ComponentInstance ci, short id, Point *where)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCPositionDialog
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$0003
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCPositionDialog
	ENDIF

;
; pascal ComponentResult SCSetTestImagePictHandle(ComponentInstance ci, PicHandle testPict, Rect *testRect, short testFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSetTestImagePictHandle
			dc.w 	$2F3C
			dc.w 	$000A
			dc.w 	$0004
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSetTestImagePictHandle
	ENDIF

;
; pascal ComponentResult SCSetTestImagePictFile(ComponentInstance ci, short testFileRef, Rect *testRect, short testFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSetTestImagePictFile
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0005
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSetTestImagePictFile
	ENDIF

;
; pascal ComponentResult SCSetTestImagePixMap(ComponentInstance ci, PixMapHandle testPixMap, Rect *testRect, short testFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSetTestImagePixMap
			dc.w 	$2F3C
			dc.w 	$000A
			dc.w 	$0006
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSetTestImagePixMap
	ENDIF

;
; pascal ComponentResult SCGetBestDeviceRect(ComponentInstance ci, Rect *r)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCGetBestDeviceRect
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0007
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCGetBestDeviceRect
	ENDIF

;
; pascal ComponentResult SCRequestImageSettings(ComponentInstance ci)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCRequestImageSettings
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$000A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCRequestImageSettings
	ENDIF

;
; pascal ComponentResult SCCompressImage(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, ImageDescriptionHandle *desc, Handle *data)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCCompressImage
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$000B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCCompressImage
	ENDIF

;
; pascal ComponentResult SCCompressPicture(ComponentInstance ci, PicHandle srcPicture, PicHandle dstPicture)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCCompressPicture
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$000C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCCompressPicture
	ENDIF

;
; pascal ComponentResult SCCompressPictureFile(ComponentInstance ci, short srcRefNum, short dstRefNum)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCCompressPictureFile
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCCompressPictureFile
	ENDIF

;
; pascal ComponentResult SCRequestSequenceSettings(ComponentInstance ci)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCRequestSequenceSettings
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$000E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCRequestSequenceSettings
	ENDIF

;
; pascal ComponentResult SCCompressSequenceBegin(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, ImageDescriptionHandle *desc)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCCompressSequenceBegin
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$000F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCCompressSequenceBegin
	ENDIF

;
; pascal ComponentResult SCCompressSequenceFrame(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, Handle *data, long *dataSize, short *notSyncFlag)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCCompressSequenceFrame
			dc.w 	$2F3C
			dc.w 	$0014
			dc.w 	$0010
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCCompressSequenceFrame
	ENDIF

;
; pascal ComponentResult SCCompressSequenceEnd(ComponentInstance ci)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCCompressSequenceEnd
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0011
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCCompressSequenceEnd
	ENDIF

;
; pascal ComponentResult SCDefaultPictHandleSettings(ComponentInstance ci, PicHandle srcPicture, short motion)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCDefaultPictHandleSettings
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$0012
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCDefaultPictHandleSettings
	ENDIF

;
; pascal ComponentResult SCDefaultPictFileSettings(ComponentInstance ci, short srcRef, short motion)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCDefaultPictFileSettings
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0013
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCDefaultPictFileSettings
	ENDIF

;
; pascal ComponentResult SCDefaultPixMapSettings(ComponentInstance ci, PixMapHandle src, short motion)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCDefaultPixMapSettings
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$0014
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCDefaultPixMapSettings
	ENDIF

;
; pascal ComponentResult SCGetInfo(ComponentInstance ci, OSType infoType, void *info)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCGetInfo
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0015
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCGetInfo
	ENDIF

;
; pascal ComponentResult SCSetInfo(ComponentInstance ci, OSType infoType, void *info)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSetInfo
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0016
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSetInfo
	ENDIF

;
; pascal ComponentResult SCNewGWorld(ComponentInstance ci, GWorldPtr *gwp, Rect *rp, GWorldFlags flags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCNewGWorld
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0017
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCNewGWorld
	ENDIF

;
; pascal ComponentResult SCSetCompressFlags(ComponentInstance ci, long flags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSetCompressFlags
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0018
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSetCompressFlags
	ENDIF

;
; pascal ComponentResult SCGetCompressFlags(ComponentInstance ci, long *flags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCGetCompressFlags
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0019
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCGetCompressFlags
	ENDIF

SCParams 				RECORD	0
flags					 ds.l   1		; offset: $0 (0)
theCodecType			 ds.l   1		; offset: $4 (4)
theCodec				 ds.l   1		; offset: $8 (8)
spatialQuality			 ds.l   1		; offset: $C (12)
temporalQuality			 ds.l   1		; offset: $10 (16)
depth					 ds.w   1		; offset: $14 (20)
frameRate				 ds.l   1		; offset: $16 (22)
keyFrameRate			 ds.l   1		; offset: $1A (26)
reserved1				 ds.l   1		; offset: $1E (30)
reserved2				 ds.l   1		; offset: $22 (34)
sizeof					 EQU *			; size:   $26 (38)
						ENDR

; typedef struct SCParams 	SCParams

scGetCompression				EQU		1
scShowMotionSettings			EQU		1 << 0
scSettingsChangedItem			EQU		-1

scCompressFlagIgnoreIdenticalFrames EQU		1

;
; pascal ComponentResult SCGetCompressionExtended(ComponentInstance ci, SCParams *params, Point where, SCModalFilterUPP filterProc, SCModalHookUPP hookProc, long refcon, StringPtr customName)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCGetCompressionExtended
			dc.w 	$2F3C
			dc.w 	$0018
			dc.w 	$0001
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCGetCompressionExtended
	ENDIF

kSCPositionRectSelect			EQU		$2
kSCPositionDialogSelect			EQU		$3
kSCSetTestImagePictHandleSelect	EQU		$4
kSCSetTestImagePictFileSelect	EQU		$5
kSCSetTestImagePixMapSelect		EQU		$6
kSCGetBestDeviceRectSelect		EQU		$7
kSCRequestImageSettingsSelect	EQU		$A
kSCCompressImageSelect			EQU		$B
kSCCompressPictureSelect		EQU		$C
kSCCompressPictureFileSelect	EQU		$D
kSCRequestSequenceSettingsSelect EQU		$E
kSCCompressSequenceBeginSelect	EQU		$F
kSCCompressSequenceFrameSelect	EQU		$10
kSCCompressSequenceEndSelect	EQU		$11
kSCDefaultPictHandleSettingsSelect EQU		$12
kSCDefaultPictFileSettingsSelect EQU		$13
kSCDefaultPixMapSettingsSelect	EQU		$14
kSCGetInfoSelect				EQU		$15
kSCSetInfoSelect				EQU		$16
kSCNewGWorldSelect				EQU		$17
kSCSetCompressFlagsSelect		EQU		$18
kSCGetCompressFlagsSelect		EQU		$19
kSCGetCompressionExtendedSelect	EQU		$1

; typedef ComponentInstance  MovieImportComponent, MovieExportComponent

MovieImportType					EQU		'eat '
MovieExportType					EQU		'spit'

canMovieImportHandles			EQU		1 << 0
canMovieImportFiles				EQU		1 << 1
hasMovieImportUserInterface		EQU		1 << 2
canMovieExportHandles			EQU		1 << 3
canMovieExportFiles				EQU		1 << 4
hasMovieExportUserInterface		EQU		1 << 5
dontAutoFileMovieImport			EQU		1 << 6
canMovieExportAuxDataHandle		EQU		1 << 7
canMovieImportValidateHandles	EQU		1 << 8
canMovieImportValidateFile		EQU		1 << 9
dontRegisterWithEasyOpen		EQU		1 << 10
canMovieImportInPlace			EQU		1 << 11
movieImportSubTypeIsFileExtension EQU		1 << 12

kMovieImportExportOpenSelect	EQU		kComponentOpenSelect
kMovieImportExportCloseSelect	EQU		kComponentCloseSelect
kMovieImportExportCanDoSelect	EQU		kComponentCanDoSelect
kMovieImportExportVersionSelect	EQU		kComponentVersionSelect
kMovieImportHandleSelect		EQU		1
kMovieImportFileSelect			EQU		2
kMovieImportSetSampleDurationSelect EQU		3
kMovieImportSetSampleDescriptionSelect EQU		4
kMovieImportSetMediaFileSelect	EQU		5
kMovieImportSetDimensionsSelect	EQU		6
kMovieImportSetChunkSizeSelect	EQU		7
kMovieImportSetProgressProcSelect EQU		8
kMovieImportSetAuxiliaryDataSelect EQU		9
kMovieImportSetFromScrapSelect	EQU		10
kMovieImportDoUserDialogSelect	EQU		11
kMovieImportSetDurationSelect	EQU		12
kMovieImportGetAuxiliaryDataTypeSelect EQU		13
kMovieImportValidateSelect		EQU		14
kMovieImportGetFileTypeSelect	EQU		15
kMovieExportToHandleSelect		EQU		128
kMovieExportToFileSelect		EQU		129
kMovieExportDoUserDialogSelectOBSOLETE EQU		130
kMovieExportGetAuxiliaryDataSelect EQU		131
kMovieExportSetProgressProcSelect EQU		132
kMovieExportSetSampleDescriptionSelect EQU		133
kMovieExportDoUserDialogSelect	EQU		134
kMovieExportGetCreatorTypeSelect EQU		135

movieImportCreateTrack			EQU		1
movieImportInParallel			EQU		2
movieImportMustUseTrack			EQU		4

movieImportResultUsedMultipleTracks EQU		8

;
; pascal ComponentResult MovieImportHandle(MovieImportComponent ci, Handle dataH, Movie theMovie, Track targetTrack, Track *usedTrack, TimeValue atTime, TimeValue *addedDuration, long inFlags, long *outFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportHandle
			dc.w 	$2F3C
			dc.w 	$0020
			dc.w 	$0001
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportHandle
	ENDIF

;
; pascal ComponentResult MovieImportFile(MovieImportComponent ci, const FSSpec *theFile, Movie theMovie, Track targetTrack, Track *usedTrack, TimeValue atTime, TimeValue *addedDuration, long inFlags, long *outFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportFile
			dc.w 	$2F3C
			dc.w 	$0020
			dc.w 	$0002
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportFile
	ENDIF

;
; pascal ComponentResult MovieImportSetSampleDuration(MovieImportComponent ci, TimeValue duration, TimeScale scale)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportSetSampleDuration
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0003
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportSetSampleDuration
	ENDIF

;
; pascal ComponentResult MovieImportSetSampleDescription(MovieImportComponent ci, SampleDescriptionHandle desc, OSType mediaType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportSetSampleDescription
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0004
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportSetSampleDescription
	ENDIF

;
; pascal ComponentResult MovieImportSetMediaFile(MovieImportComponent ci, AliasHandle alias)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportSetMediaFile
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0005
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportSetMediaFile
	ENDIF

;
; pascal ComponentResult MovieImportSetDimensions(MovieImportComponent ci, Fixed width, Fixed height)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportSetDimensions
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0006
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportSetDimensions
	ENDIF

;
; pascal ComponentResult MovieImportSetChunkSize(MovieImportComponent ci, long chunkSize)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportSetChunkSize
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0007
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportSetChunkSize
	ENDIF

;
; pascal ComponentResult MovieImportSetProgressProc(MovieImportComponent ci, MovieProgressUPP proc, long refcon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportSetProgressProc
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0008
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportSetProgressProc
	ENDIF

;
; pascal ComponentResult MovieImportSetAuxiliaryData(MovieImportComponent ci, Handle data, OSType handleType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportSetAuxiliaryData
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0009
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportSetAuxiliaryData
	ENDIF

;
; pascal ComponentResult MovieImportSetFromScrap(MovieImportComponent ci, Boolean fromScrap)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportSetFromScrap
			dc.w 	$2F3C
			dc.w 	$0002
			dc.w 	$000A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportSetFromScrap
	ENDIF

;
; pascal ComponentResult MovieImportDoUserDialog(MovieImportComponent ci, const FSSpec *theFile, Handle theData, Boolean *canceled)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportDoUserDialog
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$000B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportDoUserDialog
	ENDIF

;
; pascal ComponentResult MovieImportSetDuration(MovieImportComponent ci, TimeValue duration)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportSetDuration
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportSetDuration
	ENDIF

;
; pascal ComponentResult MovieImportGetAuxiliaryDataType(MovieImportComponent ci, OSType *auxType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportGetAuxiliaryDataType
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportGetAuxiliaryDataType
	ENDIF

;
; pascal ComponentResult MovieImportValidate(MovieImportComponent ci, const FSSpec *theFile, Handle theData, Boolean *valid)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportValidate
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$000E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportValidate
	ENDIF

;
; pascal ComponentResult MovieImportGetFileType(MovieImportComponent ci, OSType *fileType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieImportGetFileType
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieImportGetFileType
	ENDIF

;
; pascal ComponentResult MovieExportToHandle(MovieExportComponent ci, Handle dataH, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieExportToHandle
			dc.w 	$2F3C
			dc.w 	$0014
			dc.w 	$0080
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieExportToHandle
	ENDIF

;
; pascal ComponentResult MovieExportToFile(MovieExportComponent ci, const FSSpec *theFile, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieExportToFile
			dc.w 	$2F3C
			dc.w 	$0014
			dc.w 	$0081
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieExportToFile
	ENDIF

;
; pascal ComponentResult MovieExportGetAuxiliaryData(MovieExportComponent ci, Handle dataH, OSType *handleType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieExportGetAuxiliaryData
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0083
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieExportGetAuxiliaryData
	ENDIF

;
; pascal ComponentResult MovieExportSetProgressProc(MovieExportComponent ci, MovieProgressUPP proc, long refcon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieExportSetProgressProc
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0084
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieExportSetProgressProc
	ENDIF

;
; pascal ComponentResult MovieExportSetSampleDescription(MovieExportComponent ci, SampleDescriptionHandle desc, OSType mediaType)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieExportSetSampleDescription
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0085
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieExportSetSampleDescription
	ENDIF

;
; pascal ComponentResult MovieExportDoUserDialog(MovieExportComponent ci, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration, Boolean *canceled)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieExportDoUserDialog
			dc.w 	$2F3C
			dc.w 	$0014
			dc.w 	$0086
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieExportDoUserDialog
	ENDIF

;
; pascal ComponentResult MovieExportGetCreatorType(MovieExportComponent ci, OSType *creator)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MovieExportGetCreatorType
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0087
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MovieExportGetCreatorType
	ENDIF

	 IF ¬ GENERATINGPOWERPC THEN 
; Text Export Display Info data structure
TextDisplayData 		RECORD	0
displayFlags			 ds.l   1		; offset: $0 (0)
textJustification		 ds.l   1		; offset: $4 (4)
bgColor					 ds     RGBColor ; offset: $8 (8)
textBox					 ds     Rect	; offset: $E (14)
beginHilite				 ds.w   1		; offset: $16 (22)
endHilite				 ds.w   1		; offset: $18 (24)
hiliteColor				 ds     RGBColor ; offset: $1A (26)
doHiliteColor			 ds.b   1		; offset: $20 (32)
filler					 ds.b   1		; offset: $21 (33)
scrollDelayDur			 ds.l   1		; offset: $22 (34)
dropShadowOffset		 ds     Point	; offset: $26 (38)
dropShadowTransparency	 ds.w   1		; offset: $2A (42)
sizeof					 EQU *			; size:   $2C (44)
						ENDR

; typedef struct TextDisplayData  TextDisplayData
	ENDIF
; typedef ComponentInstance  TextExportComponent
;
; pascal ComponentResult TextExportGetDisplayData(TextExportComponent ci, TextDisplayData *textDisplay)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TextExportGetDisplayData
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0100
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TextExportGetDisplayData
	ENDIF

;**************
;
;	File Preview Components
;
;**************
; typedef ComponentInstance  pnotComponent

pnotComponentWantsEvents		EQU		1
pnotComponentNeedsNoCache		EQU		2

kPreviewOpenSelector			EQU		0
kPreviewCloseSelector			EQU		-1
kPreviewCanDoSelector			EQU		-2
kPreviewVersionSelector			EQU		-3
kPreviewShowDataSelector		EQU		1
kPreviewMakePreviewSelector		EQU		2
kPreviewMakePreviewReferenceSelector EQU		3
kPreviewEventSelector			EQU		4

ShowFilePreviewComponentType	EQU		'pnot'
CreateFilePreviewComponentType	EQU		'pmak'

;
; pascal ComponentResult PreviewShowData(pnotComponent p, OSType dataType, Handle data, const Rect *inHere)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_PreviewShowData
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0001
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	PreviewShowData
	ENDIF

;
; pascal ComponentResult PreviewMakePreview(pnotComponent p, OSType *previewType, Handle *previewResult, const FSSpec *sourceFile, ICMProgressProcRecordPtr progress)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_PreviewMakePreview
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$0002
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	PreviewMakePreview
	ENDIF

;
; pascal ComponentResult PreviewMakePreviewReference(pnotComponent p, OSType *previewType, short *resID, const FSSpec *sourceFile)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_PreviewMakePreviewReference
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0003
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	PreviewMakePreviewReference
	ENDIF

;
; pascal ComponentResult PreviewEvent(pnotComponent p, EventRecord *e, Boolean *handledEvent)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_PreviewEvent
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0004
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	PreviewEvent
	ENDIF

kDataHCanRead					EQU		1 << 0
kDataHSpecialRead				EQU		1 << 1
kDataHSpecialReadFile			EQU		1 << 2
kDataHCanWrite					EQU		1 << 3
kDataHSpecialWrite				EQU		1 << 4
kDataHSpecialWriteFile			EQU		1 << 5
kDataHCanStreamingWrite			EQU		1 << 6
kDataHMustCheckDataRef			EQU		1 << 7

DataHVolumeListRecord 	RECORD	0
vRefNum					 ds.w   1		; offset: $0 (0)
flags					 ds.l   1		; offset: $2 (2)
sizeof					 EQU *			; size:   $6 (6)
						ENDR

; typedef struct DataHVolumeListRecord  DataHVolumeListRecord
; typedef DataHVolumeListRecord  *DataHVolumeListPtr
; typedef DataHVolumeListPtr  *DataHVolumeList

kDataHExtendedSchedule			EQU		'xtnd'

DataHScheduleRecord 	RECORD	0
timeNeededBy			 ds     TimeRecord ; offset: $0 (0)
extendedID				 ds.l   1		; offset: $10 (16)		; always is kDataHExtendedSchedule
extendedVers			 ds.l   1		; offset: $14 (20)		; always set to 0
priority				 ds.l   1		; offset: $18 (24)		; 100.0 or more means must have. lower numbers…
sizeof					 EQU *			; size:   $1C (28)
						ENDR

; typedef struct DataHScheduleRecord  DataHScheduleRecord
; typedef DataHScheduleRecord  *DataHSchedulePtr
;
; pascal ComponentResult DataHGetData(DataHandler dh, Handle h, long hOffset, long offset, long size)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHGetData
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$0002
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHGetData
	ENDIF

;
; pascal ComponentResult DataHPutData(DataHandler dh, Handle h, long hOffset, long *offset, long size)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHPutData
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$0003
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHPutData
	ENDIF

;
; pascal ComponentResult DataHFlushData(DataHandler dh)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHFlushData
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0004
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHFlushData
	ENDIF

;
; pascal ComponentResult DataHOpenForWrite(DataHandler dh)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHOpenForWrite
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0005
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHOpenForWrite
	ENDIF

;
; pascal ComponentResult DataHCloseForWrite(DataHandler dh)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHCloseForWrite
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0006
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHCloseForWrite
	ENDIF

;
; pascal ComponentResult DataHOpenForRead(DataHandler dh)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHOpenForRead
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0008
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHOpenForRead
	ENDIF

;
; pascal ComponentResult DataHCloseForRead(DataHandler dh)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHCloseForRead
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0009
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHCloseForRead
	ENDIF

;
; pascal ComponentResult DataHSetDataRef(DataHandler dh, Handle dataRef)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHSetDataRef
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHSetDataRef
	ENDIF

;
; pascal ComponentResult DataHGetDataRef(DataHandler dh, Handle *dataRef)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHGetDataRef
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHGetDataRef
	ENDIF

;
; pascal ComponentResult DataHCompareDataRef(DataHandler dh, Handle dataRef, Boolean *equal)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHCompareDataRef
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$000C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHCompareDataRef
	ENDIF

;
; pascal ComponentResult DataHTask(DataHandler dh)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHTask
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$000D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHTask
	ENDIF

;
; pascal ComponentResult DataHScheduleData(DataHandler dh, Ptr PlaceToPutDataPtr, long FileOffset, long DataSize, long RefCon, DataHSchedulePtr scheduleRec, DataHCompletionUPP CompletionRtn)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHScheduleData
			dc.w 	$2F3C
			dc.w 	$0018
			dc.w 	$000E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHScheduleData
	ENDIF

;
; pascal ComponentResult DataHFinishData(DataHandler dh, Ptr PlaceToPutDataPtr, Boolean Cancel)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHFinishData
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$000F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHFinishData
	ENDIF

;
; pascal ComponentResult DataHFlushCache(DataHandler dh)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHFlushCache
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0010
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHFlushCache
	ENDIF

;
; pascal ComponentResult DataHResolveDataRef(DataHandler dh, Handle theDataRef, Boolean *wasChanged, Boolean userInterfaceAllowed)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHResolveDataRef
			dc.w 	$2F3C
			dc.w 	$000A
			dc.w 	$0011
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHResolveDataRef
	ENDIF

;
; pascal ComponentResult DataHGetFileSize(DataHandler dh, long *fileSize)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHGetFileSize
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0012
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHGetFileSize
	ENDIF

;
; pascal ComponentResult DataHCanUseDataRef(DataHandler dh, Handle dataRef, long *useFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHCanUseDataRef
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0013
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHCanUseDataRef
	ENDIF

;
; pascal ComponentResult DataHGetVolumeList(DataHandler dh, DataHVolumeList *volumeList)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHGetVolumeList
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0014
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHGetVolumeList
	ENDIF

;
; pascal ComponentResult DataHWrite(DataHandler dh, Ptr data, long offset, long size, DataHCompletionUPP completion, long refCon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHWrite
			dc.w 	$2F3C
			dc.w 	$0014
			dc.w 	$0015
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHWrite
	ENDIF

;
; pascal ComponentResult DataHPreextend(DataHandler dh, long maxToAdd, long *spaceAdded)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHPreextend
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0016
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHPreextend
	ENDIF

;
; pascal ComponentResult DataHSetFileSize(DataHandler dh, long fileSize)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHSetFileSize
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0017
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHSetFileSize
	ENDIF

;
; pascal ComponentResult DataHGetFreeSpace(DataHandler dh, unsigned long *freeSize)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHGetFreeSpace
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0018
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHGetFreeSpace
	ENDIF

;
; pascal ComponentResult DataHCreateFile(DataHandler dh, OSType creator, Boolean deleteExisting)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHCreateFile
			dc.w 	$2F3C
			dc.w 	$0006
			dc.w 	$0019
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHCreateFile
	ENDIF

;
; pascal ComponentResult DataHGetPreferredBlockSize(DataHandler dh, long *blockSize)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHGetPreferredBlockSize
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHGetPreferredBlockSize
	ENDIF

;
; pascal ComponentResult DataHGetDeviceIndex(DataHandler dh, long *deviceIndex)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHGetDeviceIndex
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHGetDeviceIndex
	ENDIF

;
; pascal ComponentResult DataHIsStreamingDataHandler(DataHandler dh, Boolean *yes)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHIsStreamingDataHandler
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHIsStreamingDataHandler
	ENDIF

;
; pascal ComponentResult DataHGetDataInBuffer(DataHandler dh, long startOffset, long *size)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHGetDataInBuffer
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$001D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHGetDataInBuffer
	ENDIF

;
; pascal ComponentResult DataHGetScheduleAheadTime(DataHandler dh, long *millisecs)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHGetScheduleAheadTime
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHGetScheduleAheadTime
	ENDIF

;
; pascal ComponentResult DataHSetCacheSizeLimit(DataHandler dh, Size cacheSizeLimit)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHSetCacheSizeLimit
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$001F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHSetCacheSizeLimit
	ENDIF

;
; pascal ComponentResult DataHGetCacheSizeLimit(DataHandler dh, Size *cacheSizeLimit)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHGetCacheSizeLimit
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0020
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHGetCacheSizeLimit
	ENDIF

;
; pascal ComponentResult DataHPlaybackHints(DataHandler dh, long flags, unsigned long minFileOffset, unsigned long maxFileOffset, long bytesPerSecond)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_DataHPlaybackHints
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$0103
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	DataHPlaybackHints
	ENDIF


kDataHGetDataSelect				EQU		$2
kDataHPutDataSelect				EQU		$3
kDataHFlushDataSelect			EQU		$4
kDataHOpenForWriteSelect		EQU		$5
kDataHCloseForWriteSelect		EQU		$6
kDataHOpenForReadSelect			EQU		$8
kDataHCloseForReadSelect		EQU		$9
kDataHSetDataRefSelect			EQU		$A
kDataHGetDataRefSelect			EQU		$B
kDataHCompareDataRefSelect		EQU		$C
kDataHTaskSelect				EQU		$D
kDataHScheduleDataSelect		EQU		$E
kDataHFinishDataSelect			EQU		$F
kDataHFlushCacheSelect			EQU		$10
kDataHResolveDataRefSelect		EQU		$11
kDataHGetFileSizeSelect			EQU		$12
kDataHCanUseDataRefSelect		EQU		$13
kDataHGetVolumeListSelect		EQU		$14
kDataHWriteSelect				EQU		$15
kDataHPreextendSelect			EQU		$16
kDataHSetFileSizeSelect			EQU		$17
kDataHGetFreeSpaceSelect		EQU		$18
kDataHCreateFileSelect			EQU		$19
kDataHGetPreferredBlockSizeSelect EQU		$1A
kDataHGetDeviceIndexSelect		EQU		$1B
kDataHIsStreamingDataHandlerSelect EQU		$1C
kDataHGetDataInBufferSelect		EQU		$1D
kDataHGetScheduleAheadTimeSelect EQU		$1E
kDataHSetCacheSizeLimitSelect	EQU		$1F
kDataHGetCacheSizeLimitSelect	EQU		$20
kDataHPlaybackHintsSelect		EQU		$103

kMusicComponentType				EQU		'musi'

; typedef ComponentInstance  MusicComponent
; MusicSynthesizerFlags

kSynthesizerDynamicVoice		EQU		1					; can reassign voices/channels (else, hogs all channels in mask 
kSynthesizerUsesMIDIPort		EQU		2					; must be patched through MIDI Manager 
kSynthesizerMicrotone			EQU		4					; can play microtonal scales 
kSynthesizerLimitedMicrotone	EQU		8					; can play microtones, but only on 1-voice parts 
kSynthesizerMixedDrums			EQU		16					; any part can play drum parts, total = instrument parts 
kSynthesizerSoftware			EQU		32					; implemented in main CPU software == uses cpu cycles 
kSynthesizerGMSuperset			EQU		8192
kSynthesizerGM					EQU		16384				; synth is a GM device 

;
; * Note that these controller numbers
; * are _not_ identical to the MIDI controller numbers.
; * These are _signed_ 8.8 values, and the LSB's are
; * always sent to a MIDI device. Controllers 32-63 are
; * reserved (for MIDI, they are LSB's for 0-31, but we
; * always send both).
; *
; * The full range, therefore, is -128.00 to 127.7f.
; *
; * _Excepting_ _volume_, all controls default to zero.
; *
; * Pitch bend is specified in fractional semitones! No
; * more "pitch bend range" nonsense. You can bend as far
; * as you want, any time you want.
; 
kControllerModulationWheel		EQU		1
kControllerBreath				EQU		2
kControllerFoot					EQU		4
kControllerPortamentoTime		EQU		5
kControllerVolume				EQU		7
kControllerBalance				EQU		8
kControllerPan					EQU		10					; 0 - "default", 1 - n: positioned in output 1-n (incl fractions) 
kControllerExpression			EQU		11
kControllerPitchBend			EQU		32					; positive & negative semitones, with 7 bits fraction 
kControllerAfterTouch			EQU		33
kControllerSustain				EQU		64					; boolean - positive for on, 0 or negative off 
kControllerPortamento			EQU		65					; boolean 
kControllerSostenuto			EQU		66					; boolean 
kControllerSoftPedal			EQU		67					; boolean 
kControllerReverb				EQU		91
kControllerTremolo				EQU		92
kControllerChorus				EQU		93
kControllerCeleste				EQU		94
kControllerPhaser				EQU		95

kControllerMaximum				EQU		$7FFF				; +01111111.11111111 
kControllerMinimum				EQU		$8000				; -10000000.00000000 

SynthesizerDescription 	RECORD	0
synthesizerType			 ds.l   1		; offset: $0 (0)		; synthesizer type (must be same as component subtype) 
name					 ds.l   8		; offset: $4 (4)		; text name of synthesizer type 
flags					 ds.l   1		; offset: $24 (36)		; from the above enum 
voiceCount				 ds.l   1		; offset: $28 (40)		; maximum polyphony 
partCount				 ds.l   1		; offset: $2C (44)		; maximum multi-timbrality (and midi channels) 
instrumentCount			 ds.l   1		; offset: $30 (48)		; non gm, built in (rom) instruments only 
modifiableInstrumentCount ds.l   1		; offset: $34 (52)		; plus n-more are user modifiable 
channelMask				 ds.l   1		; offset: $38 (56)		; (midi device only) which channels device always uses 
drumPartCount			 ds.l   1		; offset: $3C (60)		; maximum multi-timbrality of drum parts 
drumCount				 ds.l   1		; offset: $40 (64)		; non gm, built in (rom) drumkits only 
modifiableDrumCount		 ds.l   1		; offset: $44 (68)		; plus n-more are user modifiable 
drumChannelMask			 ds.l   1		; offset: $48 (72)		; (midi device only) which channels device always uses 
outputCount				 ds.l   1		; offset: $4C (76)		; number of audio outputs (usually two) 
latency					 ds.l   1		; offset: $50 (80)		; response time in µSec 
controllers				 ds.l   4		; offset: $54 (84)		; array of 128 bits 
gmInstruments			 ds.l   4		; offset: $64 (100)		; array of 128 bits 
gmDrums					 ds.l   4		; offset: $74 (116)		; array of 128 bits 
sizeof					 EQU *			; size:   $84 (132)
						ENDR

; typedef struct SynthesizerDescription  SynthesizerDescription

kVoiceCountDynamic				EQU		-1					; constant to use to specify dynamic voicing 

ToneDescription 		RECORD	0
synthesizerType			 ds.l   1		; offset: $0 (0)		; synthesizer type 
synthesizerName			 ds.l   8		; offset: $4 (4)		; name of instantiation of synth 
instrumentName			 ds.l   8		; offset: $24 (36)		; preferred name for human use 
instrumentNumber		 ds.l   1		; offset: $44 (68)		; inst-number used if synth-name matches 
gmNumber				 ds.l   1		; offset: $48 (72)		; Best matching general MIDI number 
sizeof					 EQU *			; size:   $4C (76)
						ENDR

; typedef struct ToneDescription  ToneDescription

kFirstDrumkit					EQU		16384				; (first value is "no drum". instrument numbers from 16384->16384+128 are drumkits, and for GM they are _defined_ drumkits! 
kLastDrumkit					EQU		(kFirstDrumkit + 128)

; InstrumentMatch
kInstrumentMatchSynthesizerType	EQU		1
kInstrumentMatchSynthesizerName	EQU		2
kInstrumentMatchName			EQU		4
kInstrumentMatchNumber			EQU		8
kInstrumentMatchGMNumber		EQU		16

; KnobFlags
kKnobRealtime					EQU		1					; Knob can be changed interactively as part of a sequence (ie knob can be changed at interrupt time) 
kKnobNextNote					EQU		2					; Knob only takes effect on the next note played 
kKnobAction						EQU		4					; setting the knob does something immediate 
kKnobNotInstrument				EQU		8					; indicates that the knob isn't in the instrument handle 
kKnobAffectsOthers				EQU		16					; other knobs will change value from this one 
kKnobMinorGroupStart			EQU		64					; knob is first in some logical subgroup of knobs 
kKnobGroupStart					EQU		128					; knob is first in some logical group of knobs 
; One of these may be used at a time. 
kKnobTypeNumber					EQU		0 << 12
kKnobTypeBoolean				EQU		1 << 12
kKnobTypeNote					EQU		2 << 12
kKnobTypePan					EQU		3 << 12
kKnobTypeInstrument				EQU		4 << 12				; knob value = reference to another instrument number 
kKnobTypeSetting				EQU		5 << 12				; knob value is 1 of n different things (eg, fm algorithms) 

kUnknownKnobValue				EQU		$7FFFFFFF			; a knob with this value means, we don't know it. 

KnobDescription 		RECORD	0
name					 ds.l   8		; offset: $0 (0)
lowValue				 ds.l   1		; offset: $20 (32)
highValue				 ds.l   1		; offset: $24 (36)
defaultValue			 ds.l   1		; offset: $28 (40)		; a default instrument is made of all default values 
flags					 ds.l   1		; offset: $2C (44)
sizeof					 EQU *			; size:   $30 (48)
						ENDR

; typedef struct KnobDescription  KnobDescription
InstrumentData 			RECORD	0
tone					 ds     ToneDescription ; offset: $0 (0)
knobCount				 ds.l   1		; offset: $4C (76)
knob					 ds.l   1		; offset: $50 (80)
sizeof					 EQU *			; size:   $54 (84)
						ENDR

; typedef struct InstrumentData  InstrumentData, **InstrumentDataHandle
FlatInstrument 			RECORD	0
tone					 ds     ToneDescription ; offset: $0 (0)
size					 ds.l   1		; offset: $4C (76)		; size in bytes of the following data, including size field (excluding tonedescription) 
data					 ds.b   4		; offset: $50 (80)
sizeof					 EQU *			; size:   $54 (84)
						ENDR

; typedef struct FlatInstrument  FlatInstrument
InstrumentAboutInfo 	RECORD	0
p						 ds.l   1		; offset: $0 (0)
author					 ds.l   64		; offset: $4 (4)
copyright				 ds.l   64		; offset: $104 (260)
other					 ds.l   64		; offset: $204 (516)
sizeof					 EQU *			; size:   $304 (772)
						ENDR

; typedef struct InstrumentAboutInfo  InstrumentAboutInfo
MusicMIDIPacket 		RECORD	0
length					 ds.w   1		; offset: $0 (0)
reserved				 ds.l   1		; offset: $2 (2)
data					 ds.b   249		; offset: $6 (6)
						 ORG 256
sizeof					 EQU *			; size:   $100 (256)
						ENDR

; typedef struct MusicMIDIPacket  MusicMIDIPacket

kMusicFirstSelect				EQU		0
kMusicGetDescriptionSelect		EQU		1
kMusicGetPartSelect				EQU		2
kMusicSetPartSelect				EQU		3
kMusicSetInstrumentNumberSelect	EQU		4
kMusicGetInstrumentNumberSelect	EQU		5
kMusicStoreInstrumentSelect		EQU		6
kMusicGetInstrumentSelect		EQU		7
kMusicSetInstrumentSelect		EQU		8
kMusicDummyOne					EQU		9
kMusicDummyTwo					EQU		10
kMusicDummyThree				EQU		11
kMusicDummyFour					EQU		12
kMusicGetInstrumentKnobDescriptionSelect EQU		13
kMusicGetDrumKnobDescriptionSelect EQU		14
kMusicGetKnobDescriptionSelect	EQU		15
kMusicGetPartKnobSelect			EQU		16
kMusicSetPartKnobSelect			EQU		17
kMusicGetKnobSelect				EQU		18
kMusicSetKnobSelect				EQU		19
kMusicGetPartNameSelect			EQU		20
kMusicSetPartNameSelect			EQU		21
kMusicFindToneSelect			EQU		22
kMusicPlayNoteSelect			EQU		23
kMusicResetPartSelect			EQU		24
kMusicSetControllerSelect		EQU		25
kMusicGetControllerSelect		EQU		26
kMusicGetMIDIProcSelect			EQU		27
kMusicSetMIDIProcSelect			EQU		28
kMusicGetInstrumentNamesSelect	EQU		29
kMusicGetDrumNamesSelect		EQU		30
kMusicGetMasterTuneSelect		EQU		31
kMusicSetMasterTuneSelect		EQU		32
kMusicSetFlatInstrumentSelect	EQU		33
kMusicGetInstrumentAboutInfoSelect EQU		34

notImplementedMusicErr			EQU		($80000000 | ((-2100 - 1)))
cantSendToSynthesizerErr		EQU		($80000000 | ((-2100 - 2)))
cantReceiveFromSynthesizerErr	EQU		($80000000 | ((-2100 - 3)))
illegalVoiceAllocationErr		EQU		($80000000 | ((-2100 - 4)))
illegalPartErr					EQU		($80000000 | ((-2100 - 5)))
illegalChannelErr				EQU		($80000000 | ((-2100 - 6)))
illegalKnobErr					EQU		($80000000 | ((-2100 - 7)))
illegalKnobValueErr				EQU		($80000000 | ((-2100 - 8)))
illegalInstrumentErr			EQU		($80000000 | ((-2100 - 9)))
illegalControllerErr			EQU		($80000000 | ((-2100 - 10)))
midiManagerAbsentErr			EQU		($80000000 | ((-2100 - 11)))
synthesizerNotRespondingErr		EQU		($80000000 | ((-2100 - 12)))
synthesizerErr					EQU		($80000000 | ((-2100 - 13)))
illegalNoteChannelErr			EQU		($80000000 | ((-2100 - 14)))
noteChannelNotAllocatedErr		EQU		($80000000 | ((-2100 - 15)))
tunePlayerFullErr				EQU		($80000000 | ((-2100 - 16)))
tuneParseErr					EQU		($80000000 | ((-2100 - 17)))

kGMType							EQU		'gm  '

;-----------------------------------------
;	Capabilities and Voice Allocation
;-----------------------------------------
;
; pascal ComponentResult MusicGetPart(MusicComponent mc, long part, long *midiChannel, long *polyphony)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetPart
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0002
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetPart
	ENDIF

;
; pascal ComponentResult MusicSetPart(MusicComponent mc, long part, long midiChannel, long polyphony)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicSetPart
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0003
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicSetPart
	ENDIF

;
; pascal ComponentResult MusicGetDescription(MusicComponent mc, SynthesizerDescription *sd)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetDescription
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0001
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetDescription
	ENDIF

;
; pascal ComponentResult MusicGetInstrumentAboutInfo(MusicComponent mc, long part, InstrumentAboutInfo *iai)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetInstrumentAboutInfo
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0022
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetInstrumentAboutInfo
	ENDIF

;-----------------------------------------
;	Instrument Loading and Storing
;-----------------------------------------
;
; pascal ComponentResult MusicSetInstrumentNumber(MusicComponent mc, long part, long instrumentNumber)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicSetInstrumentNumber
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0004
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicSetInstrumentNumber
	ENDIF

;
; pascal ComponentResult MusicGetInstrumentNumber(MusicComponent mc, long part)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetInstrumentNumber
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0005
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetInstrumentNumber
	ENDIF

;
; pascal ComponentResult MusicStoreInstrument(MusicComponent mc, long part, long instrumentNumber)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicStoreInstrument
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0006
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicStoreInstrument
	ENDIF

;
; pascal ComponentResult MusicGetInstrument(MusicComponent mc, long part, InstrumentDataHandle *iH)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetInstrument
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0007
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetInstrument
	ENDIF

;
; pascal ComponentResult MusicSetInstrument(MusicComponent mc, long part, InstrumentDataHandle iH)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicSetInstrument
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0008
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicSetInstrument
	ENDIF

;
; pascal ComponentResult MusicSetFlatInstrument(MusicComponent mc, long part, FlatInstrument *flatInstrument)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicSetFlatInstrument
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0021
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicSetFlatInstrument
	ENDIF

;-----------------------------------------
;	Instrument Knobs
;-----------------------------------------
;
; pascal ComponentResult MusicGetInstrumentKnobDescription(MusicComponent mc, long knobNumber, KnobDescription *mkd)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetInstrumentKnobDescription
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$000D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetInstrumentKnobDescription
	ENDIF

;
; pascal ComponentResult MusicGetDrumKnobDescription(MusicComponent mc, long knobNumber, KnobDescription *mkd)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetDrumKnobDescription
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$000E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetDrumKnobDescription
	ENDIF

;
; pascal ComponentResult MusicGetPartKnob(MusicComponent mc, long part, long knobNumber)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetPartKnob
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0010
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetPartKnob
	ENDIF

;
; pascal ComponentResult MusicSetPartKnob(MusicComponent mc, long part, long knobNumber, long knobValue)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicSetPartKnob
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0011
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicSetPartKnob
	ENDIF

;-----------------------------------------
;	Synthesizer Knobs
;-----------------------------------------
;
; pascal ComponentResult MusicGetKnobDescription(MusicComponent mc, long knobNumber, KnobDescription *mkd)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetKnobDescription
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$000F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetKnobDescription
	ENDIF

;
; pascal ComponentResult MusicGetKnob(MusicComponent mc, long knobNumber)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetKnob
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0012
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetKnob
	ENDIF

;
; pascal ComponentResult MusicSetKnob(MusicComponent mc, long knobNumber, long knobValue)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicSetKnob
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0013
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicSetKnob
	ENDIF

;
; pascal ComponentResult MusicSetMasterTune(MusicComponent mc, Fixed masterTune)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicSetMasterTune
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0020
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicSetMasterTune
	ENDIF

;
; pascal ComponentResult MusicGetMasterTune(MusicComponent mc)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetMasterTune
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$001F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetMasterTune
	ENDIF

;-----------------------------------------
;	Names of Instruments
;-----------------------------------------
;
; pascal ComponentResult MusicGetPartName(MusicComponent mc, long part, Str31 name)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetPartName
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0014
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetPartName
	ENDIF

;
; pascal ComponentResult MusicSetPartName(MusicComponent mc, long part, Str31 name)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicSetPartName
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0015
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicSetPartName
	ENDIF

;
; pascal ComponentResult MusicFindTone(MusicComponent mc, ToneDescription *td, long *instrumentNumber, unsigned long *fit)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicFindTone
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0016
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicFindTone
	ENDIF

;
; pascal ComponentResult MusicGetInstrumentNames(MusicComponent mc, long modifiableInstruments, Handle *instrumentNames, Handle *instrumentCategoryLasts, Handle *instrumentCategoryNames)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetInstrumentNames
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$001D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetInstrumentNames
	ENDIF

;
; pascal ComponentResult MusicGetDrumNames(MusicComponent mc, long modifiableInstruments, Handle *instrumentNumbers, Handle *instrumentNames)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetDrumNames
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$001E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetDrumNames
	ENDIF

;-----------------------------------------
;	Realtime Actions
;-----------------------------------------
;
; pascal ComponentResult MusicPlayNote(MusicComponent mc, long part, long pitch, long velocity)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicPlayNote
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0017
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicPlayNote
	ENDIF

;
; pascal ComponentResult MusicResetPart(MusicComponent mc, long part)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicResetPart
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0018
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicResetPart
	ENDIF

;
; pascal ComponentResult MusicSetController(MusicComponent mc, long part, long controllerNumber, long controllerValue)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicSetController
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0019
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicSetController
	ENDIF

;
; pascal ComponentResult MusicGetController(MusicComponent mc, long part, long controllerNumber)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetController
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$001A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetController
	ENDIF

;-----------------------------------------
;	Finding the Hardware
;-----------------------------------------
;
; pascal ComponentResult MusicGetMIDIProc(MusicComponent mc, MusicMIDISendUPP *midiSendProc, long *refCon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicGetMIDIProc
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$001B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicGetMIDIProc
	ENDIF

;
; pascal ComponentResult MusicSetMIDIProc(MusicComponent mc, MusicMIDISendUPP midiSendProc, long refCon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_MusicSetMIDIProc
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$001C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	MusicSetMIDIProc
	ENDIF

;--------------------------
;	Types
;--------------------------
; typedef void 				*NoteChannel
SynthesizerConnections 	RECORD	0
clientID				 ds.l   1		; offset: $0 (0)
inputPortID				 ds.l   1		; offset: $4 (4)
outputPortID			 ds.l   1		; offset: $8 (8)
midiChannel				 ds.l   1		; offset: $C (12)		; The system channel; others are configurable (or the nubus slot number) 
flags					 ds.l   1		; offset: $10 (16)
reserved				 ds.l   3		; offset: $14 (20)		; should be zero 
sizeof					 EQU *			; size:   $20 (32)
						ENDR

; typedef struct SynthesizerConnections  SynthesizerConnections
NoteRequest 			RECORD	0
polyphony				 ds.l   1		; offset: $0 (0)		; Maximum number of voices 
typicalPolyphony		 ds.l   1		; offset: $4 (4)		; Hint for level mixing 
tone					 ds     ToneDescription ; offset: $8 (8)
sizeof					 EQU *			; size:   $54 (84)
						ENDR

; typedef struct NoteRequest  NoteRequest

kNAFirstSelector				EQU		-7
kNATargetSelect					EQU		-6
kNARegisterSelect				EQU		-5
kNAVersionSelect				EQU		-4
kNACanDoSelect					EQU		-3
kNACloseSelect					EQU		-2
kNAOpenSelect					EQU		-1
kNARegisterMusicDeviceSelect	EQU		0
kNAUnregisterMusicDeviceSelect	EQU		1
kNAGetRegisteredMusicDeviceSelect EQU		2
kNASaveMusicConfigurationSelect	EQU		3
kNANewNoteChannelSelect			EQU		4
kNADisposeNoteChannelSelect		EQU		5
kNAGetNoteChannelInfoSelect		EQU		6
kNAPrerollNoteChannelSelect		EQU		7
kNAUnrollNoteChannelSelect		EQU		8
kNAEngageNoteChannelSelect		EQU		9
kNADisengageNoteChannelSelect	EQU		10
kNASetNoteChannelVolumeSelect	EQU		11
kNAResetNoteChannelSelect		EQU		12
kNAPlayNoteSelect				EQU		13
kNASetControllerSelect			EQU		14
kNASetKnobSelect				EQU		15
kNAFindNoteChannelToneSelect	EQU		16
kNASetNoteChannelInstrumentSelect EQU		17
kNAPickInstrumentSelect			EQU		18
kNAPickArrangementSelect		EQU		19
kNAGetStatusBlockSelect			EQU		20
kNASetDefaultMIDIInputSelect	EQU		21
kNAGetDefaultMIDIInputSelect	EQU		22
kNAGetNoteChannelStateSelect	EQU		23
kNASetNoteChannelStateSelect	EQU		24
kNAUseDefaultMIDIInputSelect	EQU		25
kNALoseDefaultMIDIInputSelect	EQU		26
kNAStuffToneDescriptionSelect	EQU		27
kNACopyrightDialogSelect		EQU		28
kNASetFlatInstrumentSelect		EQU		29
kNASetInstrumentSelect			EQU		30
kNALastSelector					EQU		31

; typedef ComponentInstance  NoteAllocator

kPickDontMix					EQU		1					; dont mix instruments with drum sounds 
kPickSameSynth					EQU		2					; only allow the same device that went in, to come out 

kNoteAllocatorType				EQU		'nota'

;--------------------------------
;	Note Allocator Prototypes
;--------------------------------
;
; * System Configuration
; 
;
; pascal ComponentResult NARegisterMusicDevice(NoteAllocator na, OSType synthType, Str31 name, SynthesizerConnections *connections)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NARegisterMusicDevice
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0000
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NARegisterMusicDevice
	ENDIF

;
; pascal ComponentResult NAUnregisterMusicDevice(NoteAllocator na, long index)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAUnregisterMusicDevice
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0001
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAUnregisterMusicDevice
	ENDIF

;
; pascal ComponentResult NAGetRegisteredMusicDevice(NoteAllocator na, long index, OSType *synthType, Str31 name, SynthesizerConnections *connections, MusicComponent *mc)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAGetRegisteredMusicDevice
			dc.w 	$2F3C
			dc.w 	$0014
			dc.w 	$0002
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAGetRegisteredMusicDevice
	ENDIF

;
; pascal ComponentResult NASetDefaultMIDIInput(NoteAllocator na, SynthesizerConnections *sc)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NASetDefaultMIDIInput
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0015
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NASetDefaultMIDIInput
	ENDIF

;
; pascal ComponentResult NAGetDefaultMIDIInput(NoteAllocator na, SynthesizerConnections *sc)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAGetDefaultMIDIInput
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0016
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAGetDefaultMIDIInput
	ENDIF

;
; pascal ComponentResult NASaveMusicConfiguration(NoteAllocator na)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NASaveMusicConfiguration
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0003
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NASaveMusicConfiguration
	ENDIF

;
; * Allocation
; 
;
; pascal ComponentResult NANewNoteChannel(NoteAllocator na, NoteRequest *noteRequest, NoteChannel *outChannel)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NANewNoteChannel
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0004
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NANewNoteChannel
	ENDIF

;
; pascal ComponentResult NADisposeNoteChannel(NoteAllocator na, NoteChannel noteChannel)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NADisposeNoteChannel
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0005
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NADisposeNoteChannel
	ENDIF

;
; pascal ComponentResult NAGetNoteChannelInfo(NoteAllocator na, NoteChannel noteChannel, long *index, long *part)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAGetNoteChannelInfo
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0006
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAGetNoteChannelInfo
	ENDIF

;
; pascal ComponentResult NAUseDefaultMIDIInput(NoteAllocator na, MusicMIDIReadHookUPP readHook, long refCon, unsigned long flags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAUseDefaultMIDIInput
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0019
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAUseDefaultMIDIInput
	ENDIF

;
; pascal ComponentResult NALoseDefaultMIDIInput(NoteAllocator na)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NALoseDefaultMIDIInput
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$001A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NALoseDefaultMIDIInput
	ENDIF

;
; * Setup
; 
;
; pascal ComponentResult NAPrerollNoteChannel(NoteAllocator na, NoteChannel noteChannel)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAPrerollNoteChannel
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0007
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAPrerollNoteChannel
	ENDIF

;
; pascal ComponentResult NAUnrollNoteChannel(NoteAllocator na, NoteChannel noteChannel)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAUnrollNoteChannel
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0008
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAUnrollNoteChannel
	ENDIF

;
; pascal ComponentResult NAEngageNoteChannel(NoteAllocator na, NoteChannel noteChannel)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAEngageNoteChannel
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0009
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAEngageNoteChannel
	ENDIF

;
; pascal ComponentResult NADisengageNoteChannel(NoteAllocator na, NoteChannel noteChannel, long silenceNotes)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NADisengageNoteChannel
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$000A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NADisengageNoteChannel
	ENDIF

;
; pascal ComponentResult NAGetNoteChannelState(NoteAllocator na, NoteChannel noteChannel, long instrumentNumber, Handle *state)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAGetNoteChannelState
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0017
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAGetNoteChannelState
	ENDIF

;
; pascal ComponentResult NASetNoteChannelState(NoteAllocator na, NoteChannel noteChannel, long instrumentNumber, Handle state)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NASetNoteChannelState
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0018
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NASetNoteChannelState
	ENDIF

;
; pascal ComponentResult NAResetNoteChannel(NoteAllocator na, NoteChannel noteChannel)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAResetNoteChannel
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAResetNoteChannel
	ENDIF

;
; pascal ComponentResult NASetNoteChannelVolume(NoteAllocator na, NoteChannel noteChannel, Fixed volume)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NASetNoteChannelVolume
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$000B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NASetNoteChannelVolume
	ENDIF

;
; pascal ComponentResult NASetInstrument(NoteAllocator na, NoteChannel noteChannel, InstrumentData *instrumentData)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NASetInstrument
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$001E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NASetInstrument
	ENDIF

;
; pascal ComponentResult NASetFlatInstrument(NoteAllocator na, NoteChannel noteChannel, FlatInstrument *flatInstrument)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NASetFlatInstrument
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$001D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NASetFlatInstrument
	ENDIF

;
; * Control
; 
;
; pascal ComponentResult NAPlayNote(NoteAllocator na, NoteChannel noteChannel, long pitch, long velocity)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAPlayNote
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$000D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAPlayNote
	ENDIF

;
; pascal ComponentResult NASetController(NoteAllocator na, NoteChannel noteChannel, long controllerNumber, long controllerValue)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NASetController
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$000E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NASetController
	ENDIF

;
; pascal ComponentResult NASetKnob(NoteAllocator na, NoteChannel noteChannel, long knobNumber, long knobValue)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NASetKnob
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$000F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NASetKnob
	ENDIF

;
; pascal ComponentResult NAFindNoteChannelTone(NoteAllocator na, NoteChannel noteChannel, ToneDescription *td, long *instrumentNumber)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAFindNoteChannelTone
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0010
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAFindNoteChannelTone
	ENDIF

;
; pascal ComponentResult NASetNoteChannelInstrument(NoteAllocator na, NoteChannel noteChannel, long instrumentNumber)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NASetNoteChannelInstrument
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0011
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NASetNoteChannelInstrument
	ENDIF

;
; * User Interface
; 
;
; pascal ComponentResult NAPickInstrument(NoteAllocator na, ModalFilterUPP filterProc, StringPtr prompt, ToneDescription *sd, unsigned long flags, long refCon, Ptr *flatList, long *flatChoiceIndex)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAPickInstrument
			dc.w 	$2F3C
			dc.w 	$001C
			dc.w 	$0012
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAPickInstrument
	ENDIF

;
; pascal ComponentResult NAStuffToneDescription(NoteAllocator na, long gmNumber, ToneDescription *td)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAStuffToneDescription
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$001B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAStuffToneDescription
	ENDIF

;
; pascal ComponentResult NAPickArrangement(NoteAllocator na, ModalFilterUPP filterProc, StringPtr prompt, long partCount, NoteRequest *noteRequestList, Track t, StringPtr songName)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAPickArrangement
			dc.w 	$2F3C
			dc.w 	$0018
			dc.w 	$0013
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAPickArrangement
	ENDIF

;
; pascal ComponentResult NACopyrightDialog(NoteAllocator na, PicHandle p, StringPtr author, StringPtr copyright, StringPtr other, StringPtr title, ModalFilterUPP filterProc, long refCon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NACopyrightDialog
			dc.w 	$2F3C
			dc.w 	$001C
			dc.w 	$001C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NACopyrightDialog
	ENDIF

;
; * Note Allocator interior views
; 
NAStatPiece 			RECORD	0
clientName				 ds.l   8		; offset: $0 (0)
synthesizerName			 ds.l   8		; offset: $20 (32)
part					 ds.l   1		; offset: $40 (64)
midiChannel				 ds.l   1		; offset: $44 (68)
polyphony				 ds.l   1		; offset: $48 (72)
valid					 ds.l   1		; offset: $4C (76)
sizeof					 EQU *			; size:   $50 (80)
						ENDR

; typedef struct NAStatPiece  NAStatPiece
NAStat 					RECORD	0
pieceCount				 ds.l   1		; offset: $0 (0)
piece					 ds.b   64 * NAStatPiece.sizeof ; offset: $4 (4)
sizeof					 EQU *			; size:   $1404 (5124)
						ENDR

; typedef struct NAStat 	NAStat
;
; pascal ComponentResult NAGetStatusBlock(NoteAllocator na, NAStat *stat)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_NAGetStatusBlock
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0014
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	NAGetStatusBlock
	ENDIF

;--------------------------
;	Types
;--------------------------

kTuneQueueDepth					EQU		8					; Deepest you can queue tune segments 

TuneStatus 				RECORD	0
tune					 ds.l   1		; offset: $0 (0)		; currently playing tune 
tunePtr					 ds.l   1		; offset: $4 (4)		; position within currently playing piece 
time					 ds.l   1		; offset: $8 (8)		; current tune time 
queueCount				 ds.w   1		; offset: $C (12)		; how many pieces queued up? 
queueSpots				 ds.w   1		; offset: $E (14)		; How many more tunepieces can be queued 
queueTime				 ds.l   1		; offset: $10 (16)		; How much time is queued up? (can be very inaccurate) 
reserved				 ds.l   3		; offset: $14 (20)
sizeof					 EQU *			; size:   $20 (32)
						ENDR

; typedef struct TuneStatus  TuneStatus

kStopTuneFade					EQU		1					; do a quick, synchronous fadeout 
kStopTuneSustain				EQU		2					; don't silece notes 
kStopTuneInstant				EQU		4					; silence notes fast (else, decay them) 
kStopTuneReleaseChannels		EQU		8					; afterwards, let the channels go 

kTuneSelect						EQU		3
kTuneSetHeaderSelect			EQU		4
kTuneGetTimeBaseSelect			EQU		5
kTuneSetTimeScaleSelect			EQU		6
kTuneGetTimeScaleSelect			EQU		7
kTuneGetIndexedNoteChannelSelect EQU		8
kTuneDummy						EQU		9
kTuneQueueSelect				EQU		10
kTuneInstantSelect				EQU		11
kTuneGetStatusSelect			EQU		12
kTuneStopSelect					EQU		13
kTuneResumeSelect				EQU		14
kTuneFlushSelect				EQU		15
kTuneSetVolumeSelect			EQU		16
kTuneGetVolumeSelect			EQU		17
kTunePrerollSelect				EQU		18
kTuneUnrollSelect				EQU		19
kTuneLastSelector				EQU		20

; typedef ComponentInstance  TunePlayer

kMaxTunePlayerParts				EQU		32
kTunePlayerType					EQU		'tune'

;--------------------------
;	Prototypes
;--------------------------
;
; pascal ComponentResult TuneSetHeader(TunePlayer tp, unsigned long *header)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneSetHeader
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0004
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneSetHeader
	ENDIF

;
; pascal ComponentResult TuneGetTimeBase(TunePlayer tp, TimeBase *tb)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneGetTimeBase
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0005
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneGetTimeBase
	ENDIF

;
; pascal ComponentResult TuneSetTimeScale(TunePlayer tp, TimeScale scale)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneSetTimeScale
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0006
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneSetTimeScale
	ENDIF

;
; pascal ComponentResult TuneGetTimeScale(TunePlayer tp, TimeScale *scale)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneGetTimeScale
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0007
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneGetTimeScale
	ENDIF

;
; pascal ComponentResult TuneGetIndexedNoteChannel(TunePlayer tp, long i, NoteChannel *nc)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneGetIndexedNoteChannel
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0008
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneGetIndexedNoteChannel
	ENDIF

; Values for when to start. 
kTuneStartNow					EQU		1					; start after buffer is implied 
kTuneDontClipNotes				EQU		2					; allow notes to finish their durations outside sample 
kTuneExcludeEdgeNotes			EQU		4					; dont play notes that start at end of tune 
kTuneStartNewMaster				EQU		16384

;
; pascal ComponentResult TuneQueue(TunePlayer tp, unsigned long *tune, Fixed tuneRate, unsigned long tuneStartPosition, unsigned long tuneStopPosition, unsigned long queueFlags, TuneCallBackUPP callBackProc, long refCon)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneQueue
			dc.w 	$2F3C
			dc.w 	$001C
			dc.w 	$000A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneQueue
	ENDIF

;
; pascal ComponentResult TuneInstant(TunePlayer tp, unsigned long *tune, long tunePosition)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneInstant
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$000B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneInstant
	ENDIF

;
; pascal ComponentResult TuneGetStatus(TunePlayer tp, TuneStatus *status)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneGetStatus
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000C
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneGetStatus
	ENDIF

; Values for when to start. 
kStopSustain					EQU		1					; Leaves notes playing, not silent 
kStopFadeout					EQU		2					; Does a synchronous fade-out 

;
; pascal ComponentResult TuneStop(TunePlayer tp, long stopFlags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneStop
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$000D
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneStop
	ENDIF

;
; pascal ComponentResult TuneResume(TunePlayer tp)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneResume
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$000E
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneResume
	ENDIF

;
; pascal ComponentResult TuneFlush(TunePlayer tp)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneFlush
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$000F
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneFlush
	ENDIF

;
; pascal ComponentResult TuneSetVolume(TunePlayer tp, Fixed volume)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneSetVolume
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0010
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneSetVolume
	ENDIF

;
; pascal ComponentResult TuneGetVolume(TunePlayer tp)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneGetVolume
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0011
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneGetVolume
	ENDIF

;
; pascal ComponentResult TunePreroll(TunePlayer tp)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TunePreroll
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0012
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TunePreroll
	ENDIF

;
; pascal ComponentResult TuneUnroll(TunePlayer tp)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TuneUnroll
			dc.w 	$2F3C
			dc.w 	$0000
			dc.w 	$0013
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TuneUnroll
	ENDIF

; typedef unsigned long 	MusicOpWord, *MusicOpWordPtr
; 	QuickTime Music Track Event Formats:
;
;	At this time, QuickTime music tracks support 5 different event types -- REST events,
;	short NOTE events, short CONTROL events, short GENERAL events, Long NOTE events, 
;	long CONTROL events, and variable GENERAL events.
; 
;		• REST Event (4 bytes/event):
;	
;			(0 0 0) (5-bit UNUSED) (24-bit Rest Duration)
;		
;		• Short NOTE Events (4 bytes/event):
;	
;			(0 0 1) (5-bit Instrument) (6-bit Pitch) (7-bit Volume) (11-bit Duration)
;		
;			where:	Pitch is offset by 32 (Actual pitch = pitch field + 32)
;
;		• Short CONTROL Events (4 bytes/event):
;	
;			(0 1 0) (5-bit Instrument) (8-bit Controller) (1-bit UNUSED) (1-bit Sign) (7-bit MSB) (7-bit LSB)
;																		 ( or 15-bit Signed Value)
;		• Short GENERAL Event (4 bytes/event):
;	
;			(0 1 1) (1-bit UNUSED) (12-bit Sub-Type) (16-bit Value)
;	
;		• Long NOTE Events (8 bytes/event):
;	
;			(1 0 0 1) (12-bit Instrument) (1-bit UNUSED) (7-bit Pitch) (1-bit UNUSED) (7-bit Volume)
;			(1 0) (8-bit UNUSED) (22-bit Duration)
;		
;		• Long CONTROL Event (8 bytes/event):
;		
;			(1 0 1 0) (12-bit Instrument) (16-bit Value MSB) 
;			(1 0) (14-bit Controller) (16-bit Value LSB)
;	
;		• Long KNOB Event (8 bytes/event):
;	
;			(1 0 1 1) (12-bit Sub-Type) (16-bit Value MSB)
;			(1 0) (14-bit KNOB) (16-bit Value LSB)
;	
;		• Variable GENERAL Length Events (N bytes/event):
;	
;			(1 1 1 1) (12-bit Sub-Type) (16-bit Length)
;				:
;			(32-bit Data values)
;				:
;			(1 1) (14-bit UNUSED) (16-bit Length)
;	
;			where:	Length field is the number of LONG words in the record.
;					Lengths include the first and last long words (Minimum length = 2)
;				
;	The following event type values have not been used yet and are reserved for 
;	future expansion:
;		
;		• (1 0 0 0)		(8 bytes/event)
;		• (1 1 0 0)		(N bytes/event)
;		• (1 1 0 1)		(N bytes/event)
;		• (1 1 1 0)		(N bytes/event)
;		
;	For all events, the following generalizations apply:
;	
;		-	All duration values are specified in Millisecond units.
;		- 	Pitch values are intended to map directly to the MIDI key numbers.
;		-	Controllers from 0 to 127 correspond to the standard MIDI controllers.
;			Controllers greater than 127 correspond to other controls (i.e., Pitch Bend, 
;			Key Pressure, and Channel Pressure).	
;
; Defines for the implemented music event data fields

kRestEventType					EQU		$0					; lower 3-bits 
kNoteEventType					EQU		$1					; lower 3-bits 
kControlEventType				EQU		$2					; lower 3-bits 
kMarkerEventType				EQU		$3					; lower 3-bits 
kUndefined1EventType			EQU		$8					; 4-bits 
kXNoteEventType					EQU		$9					; 4-bits 
kXControlEventType				EQU		$A					; 4-bits 
kKnobEventType					EQU		$B					; 4-bits 
kUndefined2EventType			EQU		$C					; 4-bits 
kUndefined3EventType			EQU		$D					; 4-bits 
kUndefined4EventType			EQU		$E					; 4-bits 
kGeneralEventType				EQU		$F					; 4-bits 
kXEventLengthBits				EQU		$2					; 2 bits: indicates 8-byte event record 
kGeneralEventLengthBits			EQU		$3					; 2 bits: indicates variable length event record 
kEventLen						EQU		1					; length of events in long words 
kXEventLen						EQU		2
kRestEventLen					EQU		kEventLen			; length of events in long words 
kNoteEventLen					EQU		kEventLen
kControlEventLen				EQU		kEventLen
kMarkerEventLen					EQU		kEventLen
kXNoteEventLen					EQU		kXEventLen
kXControlEventLen				EQU		kXEventLen
kGeneralEventLen				EQU		kXEventLen			; 2 or more, however 
; Universal Event Defines
kEventLengthFieldPos			EQU		30					; by looking at these two bits of the 1st or last word 			 
kEventLengthFieldWidth			EQU		2					; of an event you can determine the event length 					 
; length field: 0 & 1 => 1 long; 2 => 2 longs; 3 => variable length 
kEventTypeFieldPos				EQU		29					; event type field for short events 
kEventTypeFieldWidth			EQU		3					; short type is 3 bits 
kXEventTypeFieldPos				EQU		28					; event type field for extended events 
kXEventTypeFieldWidth			EQU		4					; extended type is 4 bits 
kEventInstrumentFieldPos		EQU		24
kEventInstrumentFieldWidth		EQU		5
kXEventInstrumentFieldPos		EQU		16					; in the 1st long word 
kXEventInstrumentFieldWidth		EQU		12
; Rest Events
kRestEventDurationFieldPos		EQU		0
kRestEventDurationFieldWidth	EQU		24
kRestEventDurationMax			EQU		((1 << kRestEventDurationFieldWidth) - 1)
; Note Events
kNoteEventPitchFieldPos			EQU		18
kNoteEventPitchFieldWidth		EQU		6
kNoteEventPitchOffset			EQU		32					; add to value in pitch field to get actual pitch 
kNoteEventVolumeFieldPos		EQU		11
kNoteEventVolumeFieldWidth		EQU		7
kNoteEventVolumeOffset			EQU		0					; add to value in volume field to get actual volume 
kNoteEventDurationFieldPos		EQU		0
kNoteEventDurationFieldWidth	EQU		11
kNoteEventDurationMax			EQU		((1 << kNoteEventDurationFieldWidth) - 1)
kXNoteEventPitchFieldPos		EQU		0					; in the 1st long word 
kXNoteEventPitchFieldWidth		EQU		16
kXNoteEventDurationFieldPos		EQU		0					; in the 2nd long word 
kXNoteEventDurationFieldWidth	EQU		22
kXNoteEventDurationMax			EQU		((1 << kXNoteEventDurationFieldWidth) - 1)
kXNoteEventVolumeFieldPos		EQU		22					; in the 2nd long word 
kXNoteEventVolumeFieldWidth		EQU		7
; Control Events
kControlEventControllerFieldPos	EQU		16
kControlEventControllerFieldWidth EQU		8
kControlEventValueFieldPos		EQU		0
kControlEventValueFieldWidth	EQU		16
kXControlEventControllerFieldPos EQU		0					; in the 2nd long word 
kXControlEventControllerFieldWidth EQU		16
kXControlEventValueFieldPos		EQU		0					; in the 1st long word 
kXControlEventValueFieldWidth	EQU		16
; Knob Events
kKnobEventValueHighFieldPos		EQU		0					; 1st long word 
kKnobEventValueHighFieldWidth	EQU		16
kKnobEventKnobFieldPos			EQU		16					; 2nd long word 
kKnobEventKnobFieldWidth		EQU		14
kKnobEventValueLowFieldPos		EQU		0					; 2nd long word 
kKnobEventValueLowFieldWidth	EQU		16
; Marker Events
kMarkerEventSubtypeFieldPos		EQU		16
kMarkerEventSubtypeFieldWidth	EQU		8
kMarkerEventValueFieldPos		EQU		0
kMarkerEventValueFieldWidth		EQU		16
; General Events
kGeneralEventSubtypeFieldPos	EQU		16					; in the last long word 
kGeneralEventSubtypeFieldWidth	EQU		14
kGeneralEventLengthFieldPos		EQU		0					; in the 1st & last long words 
kGeneralEventLengthFieldWidth	EQU		16

kGeneralEventNoteRequest		EQU		1					; Encapsulates NoteRequest data structure 
kGeneralEventInstrument			EQU		2					; Encapsulates poly, typical poly, followed by InstrumentData record 
kGeneralEventFlatInstrument		EQU		3					; Encapsulates poly, typical poly, followed by FlatInstrument record 
kGeneralEventPartName			EQU		4					; Brackets 2 longs follwed by a pascal string (padded to long alignment) 
kGeneralEventPartKey			EQU		5					; Brackets 2 longs 

TCSourceRefNameType				EQU		'name'

tcDropFrame						EQU		1 << 0
tc24HourMax						EQU		1 << 1
tcNegTimesOK					EQU		1 << 2
tcCounter						EQU		1 << 3

TimeCodeDef 			RECORD	0
flags					 ds.l   1		; offset: $0 (0)		; drop-frame, etc.
fTimeScale				 ds.l   1		; offset: $4 (4)		; time scale of frameDuration (eg. 2997)
frameDuration			 ds.l   1		; offset: $8 (8)		; duration of each frame (eg. 100)
numFrames				 ds.b   1		; offset: $C (12)		; number of frames per second for timecode (eg. 30)
; number of frames per tick for counter mode
padding					 ds.b   1		; offset: $D (13)		; unused padding byte 
sizeof					 EQU *			; size:   $E (14)
						ENDR

; typedef struct TimeCodeDef  TimeCodeDef

tctNegFlag						EQU		$80					; negative bit is in minutes

TimeCodeTime 			RECORD	0
hours					 ds.b   1		; offset: $0 (0)
minutes					 ds.b   1		; offset: $1 (1)
seconds					 ds.b   1		; offset: $2 (2)
frames					 ds.b   1		; offset: $3 (3)
sizeof					 EQU *			; size:   $4 (4)
						ENDR

; typedef struct TimeCodeTime  TimeCodeTime
TimeCodeCounter 		RECORD	0
counter					 ds.l   1		; offset: $0 (0)
sizeof					 EQU *			; size:   $4 (4)
						ENDR

; typedef struct TimeCodeCounter  TimeCodeCounter
TimeCodeDescription 	RECORD	0
; standard sample description header
descSize				 ds.l   1		; offset: $0 (0)
dataFormat				 ds.l   1		; offset: $4 (4)
resvd1					 ds.l   1		; offset: $8 (8)
resvd2					 ds.w   1		; offset: $C (12)
dataRefIndex			 ds.w   1		; offset: $E (14)
; timecode specific stuff
flags					 ds.l   1		; offset: $10 (16)
timeCodeDef				 ds     TimeCodeDef ; offset: $14 (20)
srcRef					 ds.l   1		; offset: $22 (34)
sizeof					 EQU *			; size:   $26 (38)
						ENDR

; typedef struct TimeCodeDescription  TimeCodeDescription
; typedef TimeCodeDescription  *TimeCodeDescriptionPtr
; typedef TimeCodeDescriptionPtr  *TimeCodeDescriptionHandle

tcdfShowTimeCode				EQU		1 << 0

kTCGetCurrentTimeCodeSelect		EQU		257
kTCGetTimeCodeAtTimeSelect		EQU		258
kTCTimeCodeToStringSelect		EQU		259
kTCTimeCodeToFrameNumberSelect	EQU		260
kTCFrameNumberToTimeCodeSelect	EQU		261
kTCGetSourceRefSelect			EQU		262
kTCSetSourceRefSelect			EQU		263
kTCSetTimeCodeFlagsSelect		EQU		264
kTCGetTimeCodeFlagsSelect		EQU		265
kTCSetDisplayOptionsSelect		EQU		266
kTCGetDisplayOptionsSelect		EQU		267

;
; pascal HandlerError TCGetCurrentTimeCode(MediaHandler mh, long *frameNum, TimeCodeDef *tcdef, TimeCodeRecord *tcrec, UserData *srcRefH)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TCGetCurrentTimeCode
			dc.w 	$2F3C
			dc.w 	$0010
			dc.w 	$0101
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TCGetCurrentTimeCode
	ENDIF

;
; pascal HandlerError TCGetTimeCodeAtTime(MediaHandler mh, TimeValue mediaTime, long *frameNum, TimeCodeDef *tcdef, TimeCodeRecord *tcdata, UserData *srcRefH)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TCGetTimeCodeAtTime
			dc.w 	$2F3C
			dc.w 	$0014
			dc.w 	$0102
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TCGetTimeCodeAtTime
	ENDIF

;
; pascal HandlerError TCTimeCodeToFrameNumber(MediaHandler mh, TimeCodeDef *tcdef, TimeCodeRecord *tcrec, long *frameNumber)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TCTimeCodeToFrameNumber
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0104
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TCTimeCodeToFrameNumber
	ENDIF

;
; pascal HandlerError TCFrameNumberToTimeCode(MediaHandler mh, long frameNumber, TimeCodeDef *tcdef, TimeCodeRecord *tcrec)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TCFrameNumberToTimeCode
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0105
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TCFrameNumberToTimeCode
	ENDIF

;
; pascal HandlerError TCTimeCodeToString(MediaHandler mh, TimeCodeDef *tcdef, TimeCodeRecord *tcrec, StringPtr tcStr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TCTimeCodeToString
			dc.w 	$2F3C
			dc.w 	$000C
			dc.w 	$0103
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TCTimeCodeToString
	ENDIF

;
; pascal HandlerError TCGetSourceRef(MediaHandler mh, TimeCodeDescriptionHandle tcdH, UserData *srefH)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TCGetSourceRef
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0106
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TCGetSourceRef
	ENDIF

;
; pascal HandlerError TCSetSourceRef(MediaHandler mh, TimeCodeDescriptionHandle tcdH, UserData srefH)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TCSetSourceRef
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0107
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TCSetSourceRef
	ENDIF

;
; pascal HandlerError TCSetTimeCodeFlags(MediaHandler mh, long flags, long flagsMask)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TCSetTimeCodeFlags
			dc.w 	$2F3C
			dc.w 	$0008
			dc.w 	$0108
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TCSetTimeCodeFlags
	ENDIF

;
; pascal HandlerError TCGetTimeCodeFlags(MediaHandler mh, long *flags)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TCGetTimeCodeFlags
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$0109
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TCGetTimeCodeFlags
	ENDIF

;
; pascal HandlerError TCSetDisplayOptions(MediaHandler mh, TCTextOptionsPtr textOptions)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TCSetDisplayOptions
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$010A
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TCSetDisplayOptions
	ENDIF

;
; pascal HandlerError TCGetDisplayOptions(MediaHandler mh, TCTextOptionsPtr textOptions)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_TCGetDisplayOptions
			dc.w 	$2F3C
			dc.w 	$0004
			dc.w 	$010B
			moveq	#0,d0
			dc.w 	$A82A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	TCGetDisplayOptions
	ENDIF

; UPP call backs 
	ENDIF ; __QUICKTIMECOMPONENTS__

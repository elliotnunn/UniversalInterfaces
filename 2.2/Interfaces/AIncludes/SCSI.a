;
;	File:		SCSI.a
;
;	Contains:	SCSI Manager Interfaces.
;
;	Version:	Technology:	System 7.5
;				Package:	Universal Interfaces 2.2.1
;
;	Copyright:	© 1984-1996 by Apple Computer, Inc.
;				All rights reserved.
;
;	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter
;				stack.  Include the file and version information (from above)
;				in the problem description and send to:
;					Internet:	apple.bugs@applelink.apple.com
;					AppleLink:	APPLE.BUGS
;
;

	IF &TYPE('__SCSI__') = 'UNDEFINED' THEN
__SCSI__ SET 1


	IF &TYPE('__TYPES__') = 'UNDEFINED' THEN
	include 'Types.a'
	ENDIF
;		include 'ConditionalMacros.a'								;

	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF

scInc							EQU		1
scNoInc							EQU		2
scAdd							EQU		3
scMove							EQU		4
scLoop							EQU		5
scNop							EQU		6
scStop							EQU		7
scComp							EQU		8

; SCSI Manager errors 
scCommErr						EQU		2					; communications error, operation timeout 
scArbNBErr						EQU		3					; arbitration timeout waiting for not BSY 
scBadParmsErr					EQU		4					; bad parameter or TIB opcode 
scPhaseErr						EQU		5					; SCSI bus not in correct phase for attempted operation 
scCompareErr					EQU		6					; data compare error 
scMgrBusyErr					EQU		7					; SCSI Manager busy  
scSequenceErr					EQU		8					; attempted operation is out of sequence 
scBusTOErr						EQU		9					; CPU bus timeout 
scComplPhaseErr					EQU		10					; SCSI bus wasn't in Status phase 

; Signatures 
sbSIGWord						EQU		$4552				; signature word for Block 0 ('ER') 
sbMac							EQU		1					; system type for Mac 
pMapSIG							EQU		$504D				; partition map signature ('PM') 
pdSigWord						EQU		$5453

oldPMSigWord					EQU		pdSigWord
newPMSigWord					EQU		pMapSIG

; Driver Descriptor Map 
Block0 					RECORD	0
sbSig					 ds.w   1		; offset: $0 (0)		; unique value for SCSI block 0 
sbBlkSize				 ds.w   1		; offset: $2 (2)		; block size of device 
sbBlkCount				 ds.l   1		; offset: $4 (4)		; number of blocks on device 
sbDevType				 ds.w   1		; offset: $8 (8)		; device type 
sbDevId					 ds.w   1		; offset: $A (10)		; device id 
sbData					 ds.l   1		; offset: $C (12)		; not used 
sbDrvrCount				 ds.w   1		; offset: $10 (16)		; driver descriptor count 
ddBlock					 ds.l   1		; offset: $12 (18)		; 1st driver's starting block 
ddSize					 ds.w   1		; offset: $16 (22)		; size of 1st driver (512-byte blks) 
ddType					 ds.w   1		; offset: $18 (24)		; system type (1 for Mac+) 
ddPad					 ds.w   243		; offset: $1A (26)		; ARRAY[0..242] OF INTEGER; not used 
sizeof					 EQU *			; size:   $200 (512)
						ENDR

; typedef struct Block0 	Block0
;Driver descriptor
DDMap 					RECORD	0
ddBlock					 ds.l   1		; offset: $0 (0)		; 1st driver's starting block 
ddSize					 ds.w   1		; offset: $4 (4)		; size of 1st driver (512-byte blks) 
ddType					 ds.w   1		; offset: $6 (6)		; system type (1 for Mac+) 
sizeof					 EQU *			; size:   $8 (8)
						ENDR

; typedef struct DDMap 		DDMap
; Partition Map Entry 
Partition 				RECORD	0
pmSig					 ds.w   1		; offset: $0 (0)		; unique value for map entry blk 
pmSigPad				 ds.w   1		; offset: $2 (2)		; currently unused 
pmMapBlkCnt				 ds.l   1		; offset: $4 (4)		; # of blks in partition map 
pmPyPartStart			 ds.l   1		; offset: $8 (8)		; physical start blk of partition 
pmPartBlkCnt			 ds.l   1		; offset: $C (12)		; # of blks in this partition 
pmPartName				 ds.b   32		; offset: $10 (16)		; ASCII partition name 
pmParType				 ds.b   32		; offset: $30 (48)		; ASCII partition type 
pmLgDataStart			 ds.l   1		; offset: $50 (80)		; log. # of partition's 1st data blk 
pmDataCnt				 ds.l   1		; offset: $54 (84)		; # of blks in partition's data area 
pmPartStatus			 ds.l   1		; offset: $58 (88)		; bit field for partition status 
pmLgBootStart			 ds.l   1		; offset: $5C (92)		; log. blk of partition's boot code 
pmBootSize				 ds.l   1		; offset: $60 (96)		; number of bytes in boot code 
pmBootAddr				 ds.l   1		; offset: $64 (100)		; memory load address of boot code 
pmBootAddr2				 ds.l   1		; offset: $68 (104)		; currently unused 
pmBootEntry				 ds.l   1		; offset: $6C (108)		; entry point of boot code 
pmBootEntry2			 ds.l   1		; offset: $70 (112)		; currently unused 
pmBootCksum				 ds.l   1		; offset: $74 (116)		; checksum of boot code 
pmProcessor				 ds.b   16		; offset: $78 (120)		; ASCII for the processor type 
pmPad					 ds.w   188		; offset: $88 (136)		; ARRAY[0..187] OF INTEGER; not used 
sizeof					 EQU *			; size:   $200 (512)
						ENDR

; typedef struct Partition 	Partition
; TIB instruction 
SCSIInstr 				RECORD	0
scOpcode				 ds.w   1		; offset: $0 (0)
scParam1				 ds.l   1		; offset: $2 (2)
scParam2				 ds.l   1		; offset: $6 (6)
sizeof					 EQU *			; size:   $A (10)
						ENDR

; typedef struct SCSIInstr 	SCSIInstr
;
; pascal OSErr SCSIReset(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSIReset
			dc.w 	$4267
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIReset
	ENDIF

;
; pascal OSErr SCSIGet(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSIGet
			move.w	#$0001,-(sp)
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIGet
	ENDIF

;
; pascal OSErr SCSISelect(short targetID)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSISelect
			move.w	#$0002,-(sp)
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSISelect
	ENDIF

;
; pascal OSErr SCSICmd(Ptr buffer, short count)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSICmd
			move.w	#$0003,-(sp)
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSICmd
	ENDIF

;
; pascal OSErr SCSIRead(Ptr tibPtr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSIRead
			move.w	#$0005,-(sp)
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIRead
	ENDIF

;
; pascal OSErr SCSIRBlind(Ptr tibPtr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSIRBlind
			move.w	#$0008,-(sp)
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIRBlind
	ENDIF

;
; pascal OSErr SCSIWrite(Ptr tibPtr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSIWrite
			move.w	#$0006,-(sp)
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIWrite
	ENDIF

;
; pascal OSErr SCSIWBlind(Ptr tibPtr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSIWBlind
			move.w	#$0009,-(sp)
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIWBlind
	ENDIF

;
; pascal OSErr SCSIComplete(short *stat, short *message, unsigned long wait)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSIComplete
			move.w	#$0004,-(sp)
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIComplete
	ENDIF

;
; pascal short SCSIStat(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSIStat
			move.w	#$000A,-(sp)
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIStat
	ENDIF

;
; pascal OSErr SCSISelAtn(short targetID)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSISelAtn
			move.w	#$000B,-(sp)
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSISelAtn
	ENDIF

;
; pascal OSErr SCSIMsgIn(short *message)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSIMsgIn
			move.w	#$000C,-(sp)
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIMsgIn
	ENDIF

;
; pascal OSErr SCSIMsgOut(short message)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SCSIMsgOut
			move.w	#$000D,-(sp)
			dc.w 	$A815
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIMsgOut
	ENDIF

;——————————————————————— New SCSI Manager Interface ———————————————————————

scsiVERSION						EQU		43

; SCSI Manager function codes 
SCSINop							EQU		$00					; Execute nothing 										
SCSIExecIO						EQU		$01					; Execute the specified IO 							
SCSIBusInquiry					EQU		$03					; Get parameters for entire path of HBAs 				
SCSIReleaseQ					EQU		$04					; Release the frozen SIM queue for particular LUN 		
SCSIAbortCommand				EQU		$10					; Abort the selected Control Block  					
SCSIResetBus					EQU		$11					; Reset the SCSI bus  									
SCSIResetDevice					EQU		$12					; Reset the SCSI device  								
SCSITerminateIO					EQU		$13					; Terminate any pending IO  							
SCSIGetVirtualIDInfo			EQU		$80					; Find out which bus old ID is on 						
SCSILoadDriver					EQU		$82					; Load a driver for a device ident 					
SCSIOldCall						EQU		$84					; XPT->SIM private call for old-API 					
SCSICreateRefNumXref			EQU		$85					; Register a DeviceIdent to drvr RefNum xref 			
SCSILookupRefNumXref			EQU		$86					; Get DeviceIdent to drvr RefNum xref 					
SCSIRemoveRefNumXref			EQU		$87					; Remove a DeviceIdent to drvr RefNum xref 			
SCSIRegisterWithNewXPT			EQU		$88					; XPT has changed - SIM needs to re-register itself 	
vendorUnique					EQU		$C0					; 0xC0 thru 0xFF 

; SCSI Callback Procedure Prototypes 
; SCSIInterruptPollProcPtr is obsolete (use SCSIInterruptProcPtr) but still here for compatibility 
handshakeDataLength				EQU		8					; Handshake data length 
maxCDBLength					EQU		16					; Space for the CDB bytes/pointer 
vendorIDLength					EQU		16					; ASCII string len for Vendor ID  

; Define DeviceIdent structure 
DeviceIdent 			RECORD	0
diReserved				 ds.b   1		; offset: $0 (0)		; reserved 				
bus						 ds.b   1		; offset: $1 (1)		; SCSI - Bus Number		
targetID				 ds.b   1		; offset: $2 (2)		; SCSI - Target SCSI ID	
LUN						 ds.b   1		; offset: $3 (3)		; SCSI - LUN  				
sizeof					 EQU *			; size:   $4 (4)
						ENDR

; typedef struct DeviceIdent  DeviceIdent
; Command Descriptor Block structure 
CDB 					RECORD	0
cdbPtr					 ds.l   1		; offset: $0 (0)		; pointer to the CDB, or 
						 ORG 0
cdbBytes				 ds.b   16		; offset: $0 (0)		; the actual CDB to send 
						 ORG 16
sizeof					 EQU *			; size:   $10 (16)
						ENDR

; typedef union CDB 		CDB, *CDBPtr
; Scatter/gather list element 
SGRecord 				RECORD	0
SGAddr					 ds.l   1		; offset: $0 (0)
SGCount					 ds.l   1		; offset: $4 (4)
sizeof					 EQU *			; size:   $8 (8)
						ENDR

; typedef struct SGRecord 	SGRecord
; SCSI Phases (used by SIMs to support the Original SCSI Manager 

kDataOutPhase					EQU		0					; Encoded MSG, C/D, I/O bits 
kDataInPhase					EQU		1
kCommandPhase					EQU		2
kStatusPhase					EQU		3
kPhaseIllegal0					EQU		4
kPhaseIllegal1					EQU		5
kMessageOutPhase				EQU		6
kMessageInPhase					EQU		7
kBusFreePhase					EQU		8					; Additional Phases 
kArbitratePhase					EQU		9
kSelectPhase					EQU		10
kMessageInPhaseNACK				EQU		11					; Message In Phase with ACK hanging on the bus 

SCSIHdr 				RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
scsiReserved1			 ds.w   1		; offset: $4 (4)
scsiPBLength			 ds.w   1		; offset: $6 (6)
scsiFunctionCode		 ds.b   1		; offset: $8 (8)
scsiReserved2			 ds.b   1		; offset: $9 (9)
scsiResult				 ds.w   1		; offset: $A (10)
scsiDevice				 ds     DeviceIdent ; offset: $C (12)
scsiCompletion			 ds.l   1		; offset: $10 (16)
scsiFlags				 ds.l   1		; offset: $14 (20)
scsiDriverStorage		 ds.l   1		; offset: $18 (24)
scsiXPTprivate			 ds.l   1		; offset: $1C (28)
scsiReserved3			 ds.l   1		; offset: $20 (32)
sizeof					 EQU *			; size:   $24 (36)
						ENDR

; typedef struct SCSIHdr 	SCSIHdr
SCSI_PB 				RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
scsiReserved1			 ds.w   1		; offset: $4 (4)
scsiPBLength			 ds.w   1		; offset: $6 (6)
scsiFunctionCode		 ds.b   1		; offset: $8 (8)
scsiReserved2			 ds.b   1		; offset: $9 (9)
scsiResult				 ds.w   1		; offset: $A (10)
scsiDevice				 ds     DeviceIdent ; offset: $C (12)
scsiCompletion			 ds.l   1		; offset: $10 (16)
scsiFlags				 ds.l   1		; offset: $14 (20)
scsiDriverStorage		 ds.l   1		; offset: $18 (24)
scsiXPTprivate			 ds.l   1		; offset: $1C (28)
scsiReserved3			 ds.l   1		; offset: $20 (32)
sizeof					 EQU *			; size:   $24 (36)
						ENDR

; typedef struct SCSI_PB 	SCSI_PB
SCSI_IO 				RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
scsiReserved1			 ds.w   1		; offset: $4 (4)
scsiPBLength			 ds.w   1		; offset: $6 (6)
scsiFunctionCode		 ds.b   1		; offset: $8 (8)
scsiReserved2			 ds.b   1		; offset: $9 (9)
scsiResult				 ds.w   1		; offset: $A (10)
scsiDevice				 ds     DeviceIdent ; offset: $C (12)
scsiCompletion			 ds.l   1		; offset: $10 (16)
scsiFlags				 ds.l   1		; offset: $14 (20)
scsiDriverStorage		 ds.l   1		; offset: $18 (24)
scsiXPTprivate			 ds.l   1		; offset: $1C (28)
scsiReserved3			 ds.l   1		; offset: $20 (32)
scsiResultFlags			 ds.w   1		; offset: $24 (36)
scsiReserved3pt5		 ds.w   1		; offset: $26 (38)
scsiDataPtr				 ds.l   1		; offset: $28 (40)
scsiDataLength			 ds.l   1		; offset: $2C (44)
scsiSensePtr			 ds.l   1		; offset: $30 (48)
scsiSenseLength			 ds.b   1		; offset: $34 (52)
scsiCDBLength			 ds.b   1		; offset: $35 (53)
scsiSGListCount			 ds.w   1		; offset: $36 (54)
scsiReserved4			 ds.l   1		; offset: $38 (56)
scsiSCSIstatus			 ds.b   1		; offset: $3C (60)
scsiSenseResidual		 ds.b   1		; offset: $3D (61)
scsiReserved5			 ds.w   1		; offset: $3E (62)
scsiDataResidual		 ds.l   1		; offset: $40 (64)
scsiCDB					 ds.l   4		; offset: $44 (68)
scsiTimeout				 ds.l   1		; offset: $54 (84)
scsiReserved5pt5		 ds.l   1		; offset: $58 (88)
scsiReserved5pt6		 ds.w   1		; offset: $5C (92)
scsiIOFlags				 ds.w   1		; offset: $5E (94)
scsiTagAction			 ds.b   1		; offset: $60 (96)
scsiReserved6			 ds.b   1		; offset: $61 (97)
scsiReserved7			 ds.w   1		; offset: $62 (98)
scsiSelectTimeout		 ds.w   1		; offset: $64 (100)
scsiDataType			 ds.b   1		; offset: $66 (102)
scsiTransferType		 ds.b   1		; offset: $67 (103)
scsiReserved8			 ds.l   1		; offset: $68 (104)
scsiReserved9			 ds.l   1		; offset: $6C (108)
scsiHandshake			 ds.w   8		; offset: $70 (112)
scsiReserved10			 ds.l   1		; offset: $80 (128)
scsiReserved11			 ds.l   1		; offset: $84 (132)
scsiCommandLink			 ds.l   1		; offset: $88 (136)
scsiSIMpublics			 ds.b   8		; offset: $8C (140)
scsiAppleReserved6		 ds.b   8		; offset: $94 (148)
scsiCurrentPhase		 ds.w   1		; offset: $9C (156)
scsiSelector			 ds.w   1		; offset: $9E (158)
scsiOldCallResult		 ds.w   1		; offset: $A0 (160)
scsiSCSImessage			 ds.b   1		; offset: $A2 (162)
XPTprivateFlags			 ds.b   1		; offset: $A3 (163)
XPTextras				 ds.b   12		; offset: $A4 (164)
sizeof					 EQU *			; size:   $B0 (176)
						ENDR

; typedef struct SCSI_IO 	SCSI_IO
; typedef SCSI_IO 			SCSIExecIOPB
; Bus inquiry PB 
SCSIBusInquiryPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
scsiReserved1			 ds.w   1		; offset: $4 (4)
scsiPBLength			 ds.w   1		; offset: $6 (6)
scsiFunctionCode		 ds.b   1		; offset: $8 (8)
scsiReserved2			 ds.b   1		; offset: $9 (9)
scsiResult				 ds.w   1		; offset: $A (10)
scsiDevice				 ds     DeviceIdent ; offset: $C (12)
scsiCompletion			 ds.l   1		; offset: $10 (16)
scsiFlags				 ds.l   1		; offset: $14 (20)
scsiDriverStorage		 ds.l   1		; offset: $18 (24)
scsiXPTprivate			 ds.l   1		; offset: $1C (28)
scsiReserved3			 ds.l   1		; offset: $20 (32)
scsiEngineCount			 ds.w   1		; offset: $24 (36)		; <- Number of engines on HBA 						
scsiMaxTransferType		 ds.w   1		; offset: $26 (38)		; <- Number of transfer types for this HBA			
scsiDataTypes			 ds.l   1		; offset: $28 (40)		; <- which data types are supported by this SIM 	
scsiIOpbSize			 ds.w   1		; offset: $2C (44)		; <- Size of SCSI_IO PB for this SIM/HBA 			
scsiMaxIOpbSize			 ds.w   1		; offset: $2E (46)		; <- Size of max SCSI_IO PB for all SIM/HBAs 		
scsiFeatureFlags		 ds.l   1		; offset: $30 (48)		; <- Supported features flags field 				
scsiVersionNumber		 ds.b   1		; offset: $34 (52)		; <- Version number for the SIM/HBA 				
scsiHBAInquiry			 ds.b   1		; offset: $35 (53)		; <- Mimic of INQ byte 7 for the HBA 				
scsiTargetModeFlags		 ds.b   1		; offset: $36 (54)		; <- Flags for target mode support 				
scsiScanFlags			 ds.b   1		; offset: $37 (55)		; <- Scan related feature flags 					
scsiSIMPrivatesPtr		 ds.l   1		; offset: $38 (56)		; <- Ptr to SIM private data area 					
scsiSIMPrivatesSize		 ds.l   1		; offset: $3C (60)		; <- Size of SIM private data area 				
scsiAsyncFlags			 ds.l   1		; offset: $40 (64)		; <- Event cap. for Async Callback 				
scsiHiBusID				 ds.b   1		; offset: $44 (68)		; <- Highest path ID in the subsystem  			
scsiInitiatorID			 ds.b   1		; offset: $45 (69)		; <- ID of the HBA on the SCSI bus 				
scsiBIReserved0			 ds.w   1		; offset: $46 (70)		;													
scsiBIReserved1			 ds.l   1		; offset: $48 (72)		; <-  												
scsiFlagsSupported		 ds.l   1		; offset: $4C (76)		; <- which scsiFlags are supported 				
scsiIOFlagsSupported	 ds.w   1		; offset: $50 (80)		; <- which scsiIOFlags are supported 				
scsiWeirdStuff			 ds.w   1		; offset: $52 (82)		; <- 												
scsiMaxTarget			 ds.w   1		; offset: $54 (84)		; <- maximum Target number supported 				
scsiMaxLUN				 ds.w   1		; offset: $56 (86)		; <- maximum Logical Unit number supported 		
scsiSIMVendor			 ds.b   16		; offset: $58 (88)		; <- Vendor ID of SIM (or XPT if bus<FF) 		
scsiHBAVendor			 ds.b   16		; offset: $68 (104)		; <- Vendor ID of the HBA 						
scsiControllerFamily	 ds.b   16		; offset: $78 (120)		; <- Family of SCSI Controller 				
scsiControllerType		 ds.b   16		; offset: $88 (136)		; <- Specific Model of SCSI Controller used 	
scsiXPTversion			 ds.b   4		; offset: $98 (152)		; <- version number of XPT 						
scsiSIMversion			 ds.b   4		; offset: $9C (156)		; <- version number of SIM 						
scsiHBAversion			 ds.b   4		; offset: $A0 (160)		; <- version number of HBA 						
scsiHBAslotType			 ds.b   1		; offset: $A4 (164)		; <- type of "slot" that this HBA is in			
scsiHBAslotNumber		 ds.b   1		; offset: $A5 (165)		; <- slot number of this HBA 						
scsiSIMsRsrcID			 ds.w   1		; offset: $A6 (166)		; <- resource ID of this SIM 						
scsiBIReserved3			 ds.w   1		; offset: $A8 (168)		; <- 												
scsiAdditionalLength	 ds.w   1		; offset: $AA (170)		; <- additional BusInquiry PB len					
sizeof					 EQU *			; size:   $AC (172)
						ENDR

; typedef struct SCSIBusInquiryPB  SCSIBusInquiryPB
; Abort SIM Request PB 
SCSIAbortCommandPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
scsiReserved1			 ds.w   1		; offset: $4 (4)
scsiPBLength			 ds.w   1		; offset: $6 (6)
scsiFunctionCode		 ds.b   1		; offset: $8 (8)
scsiReserved2			 ds.b   1		; offset: $9 (9)
scsiResult				 ds.w   1		; offset: $A (10)
scsiDevice				 ds     DeviceIdent ; offset: $C (12)
scsiCompletion			 ds.l   1		; offset: $10 (16)
scsiFlags				 ds.l   1		; offset: $14 (20)
scsiDriverStorage		 ds.l   1		; offset: $18 (24)
scsiXPTprivate			 ds.l   1		; offset: $1C (28)
scsiReserved3			 ds.l   1		; offset: $20 (32)
scsiIOptr				 ds.l   1		; offset: $24 (36)		; Pointer to the PB to abort						
sizeof					 EQU *			; size:   $28 (40)
						ENDR

; typedef struct SCSIAbortCommandPB  SCSIAbortCommandPB
; Terminate I/O Process Request PB 
SCSITerminateIOPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
scsiReserved1			 ds.w   1		; offset: $4 (4)
scsiPBLength			 ds.w   1		; offset: $6 (6)
scsiFunctionCode		 ds.b   1		; offset: $8 (8)
scsiReserved2			 ds.b   1		; offset: $9 (9)
scsiResult				 ds.w   1		; offset: $A (10)
scsiDevice				 ds     DeviceIdent ; offset: $C (12)
scsiCompletion			 ds.l   1		; offset: $10 (16)
scsiFlags				 ds.l   1		; offset: $14 (20)
scsiDriverStorage		 ds.l   1		; offset: $18 (24)
scsiXPTprivate			 ds.l   1		; offset: $1C (28)
scsiReserved3			 ds.l   1		; offset: $20 (32)
scsiIOptr				 ds.l   1		; offset: $24 (36)		; Pointer to the PB to terminate 					
sizeof					 EQU *			; size:   $28 (40)
						ENDR

; typedef struct SCSITerminateIOPB  SCSITerminateIOPB
; Reset SCSI Bus PB 
SCSIResetBusPB 			RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
scsiReserved1			 ds.w   1		; offset: $4 (4)
scsiPBLength			 ds.w   1		; offset: $6 (6)
scsiFunctionCode		 ds.b   1		; offset: $8 (8)
scsiReserved2			 ds.b   1		; offset: $9 (9)
scsiResult				 ds.w   1		; offset: $A (10)
scsiDevice				 ds     DeviceIdent ; offset: $C (12)
scsiCompletion			 ds.l   1		; offset: $10 (16)
scsiFlags				 ds.l   1		; offset: $14 (20)
scsiDriverStorage		 ds.l   1		; offset: $18 (24)
scsiXPTprivate			 ds.l   1		; offset: $1C (28)
scsiReserved3			 ds.l   1		; offset: $20 (32)
sizeof					 EQU *			; size:   $24 (36)
						ENDR

; typedef struct SCSIResetBusPB  SCSIResetBusPB
; Reset SCSI Device PB 
SCSIResetDevicePB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
scsiReserved1			 ds.w   1		; offset: $4 (4)
scsiPBLength			 ds.w   1		; offset: $6 (6)
scsiFunctionCode		 ds.b   1		; offset: $8 (8)
scsiReserved2			 ds.b   1		; offset: $9 (9)
scsiResult				 ds.w   1		; offset: $A (10)
scsiDevice				 ds     DeviceIdent ; offset: $C (12)
scsiCompletion			 ds.l   1		; offset: $10 (16)
scsiFlags				 ds.l   1		; offset: $14 (20)
scsiDriverStorage		 ds.l   1		; offset: $18 (24)
scsiXPTprivate			 ds.l   1		; offset: $1C (28)
scsiReserved3			 ds.l   1		; offset: $20 (32)
sizeof					 EQU *			; size:   $24 (36)
						ENDR

; typedef struct SCSIResetDevicePB  SCSIResetDevicePB
; Release SIM Queue PB 
SCSIReleaseQPB 			RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
scsiReserved1			 ds.w   1		; offset: $4 (4)
scsiPBLength			 ds.w   1		; offset: $6 (6)
scsiFunctionCode		 ds.b   1		; offset: $8 (8)
scsiReserved2			 ds.b   1		; offset: $9 (9)
scsiResult				 ds.w   1		; offset: $A (10)
scsiDevice				 ds     DeviceIdent ; offset: $C (12)
scsiCompletion			 ds.l   1		; offset: $10 (16)
scsiFlags				 ds.l   1		; offset: $14 (20)
scsiDriverStorage		 ds.l   1		; offset: $18 (24)
scsiXPTprivate			 ds.l   1		; offset: $1C (28)
scsiReserved3			 ds.l   1		; offset: $20 (32)
sizeof					 EQU *			; size:   $24 (36)
						ENDR

; typedef struct SCSIReleaseQPB  SCSIReleaseQPB
; SCSI Get Virtual ID Info PB 
SCSIGetVirtualIDInfoPB 	RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
scsiReserved1			 ds.w   1		; offset: $4 (4)
scsiPBLength			 ds.w   1		; offset: $6 (6)
scsiFunctionCode		 ds.b   1		; offset: $8 (8)
scsiReserved2			 ds.b   1		; offset: $9 (9)
scsiResult				 ds.w   1		; offset: $A (10)
scsiDevice				 ds     DeviceIdent ; offset: $C (12)
scsiCompletion			 ds.l   1		; offset: $10 (16)
scsiFlags				 ds.l   1		; offset: $14 (20)
scsiDriverStorage		 ds.l   1		; offset: $18 (24)
scsiXPTprivate			 ds.l   1		; offset: $1C (28)
scsiReserved3			 ds.l   1		; offset: $20 (32)
scsiOldCallID			 ds.w   1		; offset: $24 (36)		; -> SCSI ID of device in question 			
scsiExists				 ds.b   1		; offset: $26 (38)		; <- true if device exists 					
filler					 ds.b   1		; offset: $27 (39)
sizeof					 EQU *			; size:   $28 (40)
						ENDR

; typedef struct SCSIGetVirtualIDInfoPB  SCSIGetVirtualIDInfoPB
; Create/Lookup/Remove RefNum for Device PB 
SCSIDriverPB 			RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
scsiReserved1			 ds.w   1		; offset: $4 (4)
scsiPBLength			 ds.w   1		; offset: $6 (6)
scsiFunctionCode		 ds.b   1		; offset: $8 (8)
scsiReserved2			 ds.b   1		; offset: $9 (9)
scsiResult				 ds.w   1		; offset: $A (10)
scsiDevice				 ds     DeviceIdent ; offset: $C (12)
scsiCompletion			 ds.l   1		; offset: $10 (16)
scsiFlags				 ds.l   1		; offset: $14 (20)
scsiDriverStorage		 ds.l   1		; offset: $18 (24)
scsiXPTprivate			 ds.l   1		; offset: $1C (28)
scsiReserved3			 ds.l   1		; offset: $20 (32)
scsiDriver				 ds.w   1		; offset: $24 (36)		; -> DriverRefNum, For SetDriver, <- For GetNextDriver 
scsiDriverFlags			 ds.w   1		; offset: $26 (38)		; <> Details of driver/device 					
scsiNextDevice			 ds     DeviceIdent ; offset: $28 (40)	; <- DeviceIdent of the NEXT Item in the list  
sizeof					 EQU *			; size:   $2C (44)
						ENDR

; typedef struct SCSIDriverPB  SCSIDriverPB
; Load Driver PB 
SCSILoadDriverPB 		RECORD	0
qLink					 ds.l   1		; offset: $0 (0)
scsiReserved1			 ds.w   1		; offset: $4 (4)
scsiPBLength			 ds.w   1		; offset: $6 (6)
scsiFunctionCode		 ds.b   1		; offset: $8 (8)
scsiReserved2			 ds.b   1		; offset: $9 (9)
scsiResult				 ds.w   1		; offset: $A (10)
scsiDevice				 ds     DeviceIdent ; offset: $C (12)
scsiCompletion			 ds.l   1		; offset: $10 (16)
scsiFlags				 ds.l   1		; offset: $14 (20)
scsiDriverStorage		 ds.l   1		; offset: $18 (24)
scsiXPTprivate			 ds.l   1		; offset: $1C (28)
scsiReserved3			 ds.l   1		; offset: $20 (32)
scsiLoadedRefNum		 ds.w   1		; offset: $24 (36)		; <- SIM returns refnum of driver 					
scsiDiskLoadFailed		 ds.b   1		; offset: $26 (38)		; -> if true, indicates call after failure to load 
filler					 ds.b   1		; offset: $27 (39)
sizeof					 EQU *			; size:   $28 (40)
						ENDR

; typedef struct SCSILoadDriverPB  SCSILoadDriverPB
; Defines for the scsiTransferType field 

scsiTransferBlind				EQU		0
scsiTransferPolled				EQU		1

; Defines for the scsiDataType field 
scsiDataBuffer					EQU		0					; single contiguous buffer supplied  				
scsiDataTIB						EQU		1					; TIB supplied (ptr in scsiDataPtr) 				
scsiDataSG						EQU		2					; scatter/gather list supplied  					

; Defines for the SCSIMgr scsiResult field in the PB header. 
;  $E100 thru  E1FF 
; -$1EFF thru -1E00 
; -#7935 thru -7681  
; = 0xE100 
scsiErrorBase					EQU		-7936

scsiRequestInProgress			EQU		1					; 1	 = PB request is in progress 			
; Execution failed  00-2F 
scsiRequestAborted				EQU		scsiErrorBase + 2	; -7934 = PB request aborted by the host 		
scsiUnableToAbort				EQU		scsiErrorBase + 3	; -7933 = Unable to Abort PB request 			
scsiNonZeroStatus				EQU		scsiErrorBase + 4	; -7932 = PB request completed with an err 	
scsiUnused05					EQU		scsiErrorBase + 5	; -7931 =  									
scsiUnused06					EQU		scsiErrorBase + 6	; -7930 =  									
scsiUnused07					EQU		scsiErrorBase + 7	; -7929 =  									
scsiUnused08					EQU		scsiErrorBase + 8	; -7928 =  									
scsiUnableToTerminate			EQU		scsiErrorBase + 9	; -7927 = Unable to Terminate I/O PB req 		
scsiSelectTimeout				EQU		scsiErrorBase + 10	; -7926 = Target selection timeout 			
scsiCommandTimeout				EQU		scsiErrorBase + 11	; -7925 = Command timeout  					
scsiIdentifyMessageRejected		EQU		scsiErrorBase + 12	; -7924 =  									
scsiMessageRejectReceived		EQU		scsiErrorBase + 13	; -7923 = Message reject received 				
scsiSCSIBusReset				EQU		scsiErrorBase + 14	; -7922 = SCSI bus reset sent/received 		
scsiParityError					EQU		scsiErrorBase + 15	; -7921 = Uncorrectable parity error occured 	
scsiAutosenseFailed				EQU		scsiErrorBase + 16	; -7920 = Autosense: Request sense cmd fail 	
scsiUnused11					EQU		scsiErrorBase + 17	; -7919 =  									
scsiDataRunError				EQU		scsiErrorBase + 18	; -7918 = Data overrun/underrun error  		
scsiUnexpectedBusFree			EQU		scsiErrorBase + 19	; -7917 = Unexpected BUS free 					
scsiSequenceFailed				EQU		scsiErrorBase + 20	; -7916 = Target bus phase sequence failure 	
scsiWrongDirection				EQU		scsiErrorBase + 21	; -7915 = Data phase was in wrong direction 	
scsiUnused16					EQU		scsiErrorBase + 22	; -7914 =  									
scsiBDRsent						EQU		scsiErrorBase + 23	; -7913 = A SCSI BDR msg was sent to target 	
scsiTerminated					EQU		scsiErrorBase + 24	; -7912 = PB request terminated by the host 	
scsiNoNexus						EQU		scsiErrorBase + 25	; -7911 = Nexus is not established 			
scsiCDBReceived					EQU		scsiErrorBase + 26	; -7910 = The SCSI CDB has been received 		
; Couldn't begin execution  30-3F 
scsiTooManyBuses				EQU		scsiErrorBase + 48	; -7888 = Register failed because we're full	
scsiBusy						EQU		scsiErrorBase + 49	; -7887 = SCSI subsystem is busy 				
scsiProvideFail					EQU		scsiErrorBase + 50	; -7886 = Unable to provide requ. capability	
scsiDeviceNotThere				EQU		scsiErrorBase + 51	; -7885 = SCSI device not installed/there  	
scsiNoHBA						EQU		scsiErrorBase + 52	; -7884 = No HBA detected Error 				
scsiDeviceConflict				EQU		scsiErrorBase + 53	; -7883 = sorry, max 1 refNum per DeviceIdent 	
scsiNoSuchXref					EQU		scsiErrorBase + 54	; -7882 = no such RefNum xref 					
scsiQLinkInvalid				EQU		scsiErrorBase + 55	; -7881 = pre-linked PBs not supported			
;																   (The QLink field was nonzero)		
; Parameter errors  40-7F 
scsiPBLengthError				EQU		scsiErrorBase + 64	; -7872 = (scsiPBLength is insuf'ct/invalid 	
scsiFunctionNotAvailable		EQU		scsiErrorBase + 65	; -7871 = The requ. func is not available  	
scsiRequestInvalid				EQU		scsiErrorBase + 66	; -7870 = PB request is invalid 				
scsiBusInvalid					EQU		scsiErrorBase + 67	; -7869 = Bus ID supplied is invalid  			
scsiTIDInvalid					EQU		scsiErrorBase + 68	; -7868 = Target ID supplied is invalid 		
scsiLUNInvalid					EQU		scsiErrorBase + 69	; -7867 = LUN supplied is invalid  			
scsiIDInvalid					EQU		scsiErrorBase + 70	; -7866 = The initiator ID is invalid  		
scsiDataTypeInvalid				EQU		scsiErrorBase + 71	; -7865 = scsiDataType requested not supported 
scsiTransferTypeInvalid			EQU		scsiErrorBase + 72	; -7864 = scsiTransferType field is too high 	
scsiCDBLengthInvalid			EQU		scsiErrorBase + 73	; -7863 = scsiCDBLength field is too big 		

scsiExecutionErrors				EQU		scsiErrorBase
scsiNotExecutedErrors			EQU		scsiTooManyBuses
scsiParameterErrors				EQU		scsiPBLengthError

; Defines for the scsiResultFlags field 
scsiSIMQFrozen					EQU		$0001				; The SIM queue is frozen w/this err			
scsiAutosenseValid				EQU		$0002				; Autosense data valid for target  			
scsiBusNotFree					EQU		$0004				; At time of callback, SCSI bus is not free	

; Defines for the bit numbers of the scsiFlags field in the PB header for the SCSIExecIO function 
kbSCSIDisableAutosense			EQU		29					; Disable auto sense feature 					
kbSCSIFlagReservedA				EQU		28					;  											
kbSCSIFlagReserved0				EQU		27					;  											
kbSCSICDBLinked					EQU		26					; The PB contains a linked CDB					
kbSCSIQEnable					EQU		25					; Target queue actions are enabled				
kbSCSICDBIsPointer				EQU		24					; The CDB field contains a pointer				
kbSCSIFlagReserved1				EQU		23					; 												
kbSCSIInitiateSyncData			EQU		22					; Attempt Sync data xfer and SDTR				
kbSCSIDisableSyncData			EQU		21					; Disable sync, go to async					
kbSCSISIMQHead					EQU		20					; Place PB at the head of SIM Q				
kbSCSISIMQFreeze				EQU		19					; Return the SIM Q to frozen state				
kbSCSISIMQNoFreeze				EQU		18					; Disallow SIM Q freezing						
kbSCSIDoDisconnect				EQU		17					; Definitely do disconnect						
kbSCSIDontDisconnect			EQU		16					; Definitely don't disconnect					
kbSCSIDataReadyForDMA			EQU		15					; Data buffer(s) are ready for DMA				
kbSCSIFlagReserved3				EQU		14					; 												
kbSCSIDataPhysical				EQU		13					; SG/Buffer data ptrs are physical				
kbSCSISensePhysical				EQU		12					; Autosense buffer ptr is physical				
kbSCSIFlagReserved5				EQU		11					; 												
kbSCSIFlagReserved6				EQU		10					; 												
kbSCSIFlagReserved7				EQU		9					; 												
kbSCSIFlagReserved8				EQU		8					; 												
kbSCSIDataBufferValid			EQU		7					; Data buffer valid							
kbSCSIStatusBufferValid			EQU		6					; Status buffer valid 							
kbSCSIMessageBufferValid		EQU		5					; Message buffer valid							
kbSCSIFlagReserved9				EQU		4					;  											

; Defines for the bit masks of the scsiFlags field 
scsiDirectionMask				EQU		$C0000000			; Data direction mask						
scsiDirectionNone				EQU		$C0000000			; Data direction (11: no data)				
scsiDirectionReserved			EQU		$00000000			; Data direction (00: reserved)			
scsiDirectionOut				EQU		$80000000			; Data direction (10: DATA OUT)			
scsiDirectionIn					EQU		$40000000			; Data direction (01: DATA IN)				
scsiDisableAutosense			EQU		$20000000			; Disable auto sense feature				
scsiFlagReservedA				EQU		$10000000			; 											
scsiFlagReserved0				EQU		$08000000			; 											
scsiCDBLinked					EQU		$04000000			; The PB contains a linked CDB				
scsiQEnable						EQU		$02000000			; Target queue actions are enabled			
scsiCDBIsPointer				EQU		$01000000			; The CDB field contains a pointer			
scsiFlagReserved1				EQU		$00800000			; 											
scsiInitiateSyncData			EQU		$00400000			; Attempt Sync data xfer and SDTR			
scsiDisableSyncData				EQU		$00200000			; Disable sync, go to async				
scsiSIMQHead					EQU		$00100000			; Place PB at the head of SIM Q			
scsiSIMQFreeze					EQU		$00080000			; Return the SIM Q to frozen state			
scsiSIMQNoFreeze				EQU		$00040000			; Disallow SIM Q freezing					
scsiDoDisconnect				EQU		$00020000			; Definitely do disconnect					
scsiDontDisconnect				EQU		$00010000			; Definitely don't disconnect				
scsiDataReadyForDMA				EQU		$00008000			; Data buffer(s) are ready for DMA			
scsiFlagReserved3				EQU		$00004000			;  
scsiDataPhysical				EQU		$00002000			; SG/Buffer data ptrs are physical			
scsiSensePhysical				EQU		$00001000			; Autosense buffer ptr is physical			
scsiFlagReserved5				EQU		$00000800			;  										
scsiFlagReserved6				EQU		$00000400			; 											
scsiFlagReserved7				EQU		$00000200			; 											
scsiFlagReserved8				EQU		$00000100			; 											

; bit masks for the scsiIOFlags field in SCSIExecIOPB 
scsiNoParityCheck				EQU		$0002				; disable parity checking 							
scsiDisableSelectWAtn			EQU		$0004				; disable select w/Atn  							
scsiSavePtrOnDisconnect			EQU		$0008				; do SaveDataPointer upon Disconnect msg 			
scsiNoBucketIn					EQU		$0010				; don’t bit bucket in during this I/O 				
scsiNoBucketOut					EQU		$0020				; don’t bit bucket out during this I/O 			
scsiDisableWide					EQU		$0040				; disable wide transfer negotiation 				
scsiInitiateWide				EQU		$0080				; initiate wide transfer negotiation 				
scsiRenegotiateSense			EQU		$0100				; renegotiate sync/wide before issuing autosense 	
scsiDisableDiscipline			EQU		$0200				; disable parameter checking on SCSIExecIO calls	
scsiIOFlagReserved0080			EQU		$0080				;  												
scsiIOFlagReserved8000			EQU		$8000				; 													

; Defines for the SIM/HBA queue actions.  These values are used in the 
; SCSIExecIOPB, for the queue action field. [These values should match the 
; defines from some other include file for the SCSI message phases.  We may 
; not need these definitions here. ] 
scsiSimpleQTag					EQU		$20					; Tag for a simple queue 								
scsiHeadQTag					EQU		$21					; Tag for head of queue  								
scsiOrderedQTag					EQU		$22					; Tag for ordered queue 								

; Defines for the Bus Inquiry PB fields. 
; scsiHBAInquiry field bits 
scsiBusMDP						EQU		$80					; Supports Modify Data Pointer message						
scsiBusWide32					EQU		$40					; Supports 32 bit wide SCSI								
scsiBusWide16					EQU		$20					; Supports 16 bit wide SCSI								
scsiBusSDTR						EQU		$10					; Supports Sync Data Transfer Req message					
scsiBusLinkedCDB				EQU		$08					; Supports linked CDBs										
scsiBusTagQ						EQU		$02					; Supports tag queue message								
scsiBusSoftReset				EQU		$01					; Supports soft reset										

; scsiDataTypes field bits  
;	bits 0->15 Apple-defined, 16->30 3rd-party unique, 31 = reserved 
scsiBusDataTIB					EQU		(1 << scsiDataTIB)	; TIB supplied (ptr in scsiDataPtr)		
scsiBusDataBuffer				EQU		(1 << scsiDataBuffer) ; single contiguous buffer supplied 		
scsiBusDataSG					EQU		(1 << scsiDataSG)	; scatter/gather list supplied 			
scsiBusDataReserved				EQU		$80000000			;   										

; scsiScanFlags field bits 
scsiBusScansDevices				EQU		$80					; Bus scans for and maintains device list			
scsiBusScansOnInit				EQU		$40					; Bus scans performed at power-up/reboot			
scsiBusLoadsROMDrivers			EQU		$20					; may load ROM drivers to support targets 			

; scsiFeatureFlags field bits 
scsiBusInternalExternalMask		EQU		$000000C0			; bus internal/external mask					
scsiBusInternalExternalUnknown	EQU		$00000000			; not known whether bus is inside or outside 	
scsiBusInternalExternal			EQU		$000000C0			; bus goes inside and outside the box 			
scsiBusInternal					EQU		$00000080			; bus goes inside the box 						
scsiBusExternal					EQU		$00000040			; bus goes outside the box 					
scsiBusCacheCoherentDMA			EQU		$00000020			; DMA is cache coherent 						
scsiBusOldCallCapable			EQU		$00000010			; SIM is old call capable 						
scsiBusDifferential				EQU		$00000004			; Single Ended (0) or Differential (1) 		
scsiBusFastSCSI					EQU		$00000002			; HBA supports fast SCSI 						
scsiBusDMAavailable				EQU		$00000001			; DMA is available 							

; scsiWeirdStuff field bits 
scsiOddDisconnectUnsafeRead1	EQU		$0001				; Disconnects on odd byte boundries are unsafe with DMA and/or blind reads 
scsiOddDisconnectUnsafeWrite1	EQU		$0002				; Disconnects on odd byte boundries are unsafe with DMA and/or blind writes 
scsiBusErrorsUnsafe				EQU		$0004				; Non-handshaked delays or disconnects during blind transfers may cause a crash 
scsiRequiresHandshake			EQU		$0008				; Non-handshaked delays or disconnects during blind transfers may cause data corruption 
scsiTargetDrivenSDTRSafe		EQU		$0010				; Targets which initiate synchronous negotiations are supported 
scsiOddCountForPhysicalUnsafe	EQU		$0020				; If using physical addrs all counts must be even, and disconnects must be on even boundries 

; scsiHBAslotType values 
scsiMotherboardBus				EQU		$00					; A built in Apple supplied bus 					
scsiNuBus						EQU		$01					; A SIM on a NuBus card 							
scsiPDSBus						EQU		$03					;    "  on a PDS card								
scsiPCIBus						EQU		$04					;    "  on a PCI bus card							
scsiPCMCIABus					EQU		$05					;    "  on a PCMCIA card							
scsiFireWireBridgeBus			EQU		$06					;    "  connected through a FireWire bridge		

; Defines for the scsiDriverFlags field (in SCSIDriverPB) 
scsiDeviceSensitive				EQU		$0001				; Only driver should access this device				
scsiDeviceNoOldCallAccess		EQU		$0002				; no old call access to this device 					

;  SIMInitInfo PB 
; directions are for SCSIRegisterBus call ( -> parm, <- result) 			
SIMInitInfo 			RECORD	0
SIMstaticPtr			 ds.l   1		; offset: $0 (0)		; <- alloc. ptr to the SIM's static vars 				
staticSize				 ds.l   1		; offset: $4 (4)		; -> num bytes SIM needs for static vars 				
SIMInit					 ds.l   1		; offset: $8 (8)		; -> pointer to the SIM init routine 					
SIMAction				 ds.l   1		; offset: $C (12)		; -> pointer to the SIM action routine 				
SIM_ISR					 ds.l   1		; offset: $10 (16)		; 	  reserved 											
SIMInterruptPoll		 ds.l   1		; offset: $14 (20)		; -> pointer to the SIM interrupt poll routine			
NewOldCall				 ds.l   1		; offset: $18 (24)		; -> pointer to the SIM NewOldCall routine				
ioPBSize				 ds.w   1		; offset: $1C (28)		; -> size of SCSI_IO_PBs required for this SIM			
oldCallCapable			 ds.b   1		; offset: $1E (30)		; -> true if this SIM can handle old-API calls			
simInfoUnused1			 ds.b   1		; offset: $1F (31)		; 	  reserved											
simInternalUse			 ds.l   1		; offset: $20 (32)		; xx not affected or viewed by XPT						
XPT_ISR					 ds.l   1		; offset: $24 (36)		;    reserved											
EnteringSIM				 ds.l   1		; offset: $28 (40)		; <- ptr to the EnteringSIM routine					
ExitingSIM				 ds.l   1		; offset: $2C (44)		; <- ptr to the ExitingSIM routine						
MakeCallback			 ds.l   1		; offset: $30 (48)		; <- the XPT layer’s SCSIMakeCallback routine	        
busID					 ds.w   1		; offset: $34 (52)		; <- bus number for the registered bus					
simSlotNumber			 ds.b   1		; offset: $36 (54)		; <- Magic cookie to place in scsiHBASlotNumber (PCI)	
simSRsrcID				 ds.b   1		; offset: $37 (55)		; <- Magic cookie to place in scsiSIMsRsrcID	 (PCI)	
simRegEntry				 ds.l   1		; offset: $38 (56)		; -> The SIM's RegEntryIDPtr					 (PCI)	
sizeof					 EQU *			; size:   $3C (60)
						ENDR

; typedef struct SIMInitInfo  SIMInitInfo
; Glue between SCSI calls and SCSITrap format 

xptSCSIAction					EQU		$0001
xptSCSIRegisterBus				EQU		$0002
xptSCSIDeregisterBus			EQU		$0003
xptSCSIReregisterBus			EQU		$0004
xptSCSIKillXPT					EQU		$0005				; kills Mini-XPT after transition 
xptSCSIInitialize				EQU		$000A				; Initialize the SCSI manager 

; SCSI status
scsiStatGood					EQU		$00					; Good Status
scsiStatCheckCondition			EQU		$02					; Check Condition
scsiStatConditionMet			EQU		$04					; Condition Met
scsiStatBusy					EQU		$08					; Busy
scsiStatIntermediate			EQU		$10					; Intermediate
scsiStatIntermedMet				EQU		$14					; Intermediate - Condition Met
scsiStatResvConflict			EQU		$18					; Reservation conflict
scsiStatTerminated				EQU		$20					; Command terminated
scsiStatQFull					EQU		$28					; Queue full

; SCSI messages
kCmdCompleteMsg					EQU		0
kExtendedMsg					EQU		1					; 0x01
kSaveDataPointerMsg				EQU		2					; 0x02
kRestorePointersMsg				EQU		3					; 0x03
kDisconnectMsg					EQU		4					; 0x04
kInitiatorDetectedErrorMsg		EQU		5					; 0x05
kAbortMsg						EQU		6					; 0x06
kMsgRejectMsg					EQU		7					; 0x07
kNoOperationMsg					EQU		8					; 0x08
kMsgParityErrorMsg				EQU		9					; 0x09
kLinkedCmdCompleteMsg			EQU		10					; 0x0a
kLinkedCmdCompleteWithFlagMsg	EQU		11					; 0x0b
kBusDeviceResetMsg				EQU		12					; 0x0c
kAbortTagMsg					EQU		13					; 0x0d
kClearQueueMsg					EQU		14					; 0x0e
kInitiateRecoveryMsg			EQU		15					; 0x0f
kReleaseRecoveryMsg				EQU		16					; 0x10
kTerminateIOProcessMsg			EQU		17					; 0x11
kSimpleQueueTag					EQU		$20					; 0x20
kHeadOfQueueTagMsg				EQU		33					; 0x21
kOrderedQueueTagMsg				EQU		34					; 0x22
kIgnoreWideResidueMsg			EQU		35					; 0x23

; moveq #kSCSIx, D0;  _SCSIAtomic 
;
; pascal OSErr SCSIAction(SCSI_PB *parameterBlock)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 parameterBlock	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SCSIAction
			moveq	#1,d0
			dc.w 	$A089
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIAction
	ENDIF

;
; pascal OSErr SCSIRegisterBus(SIMInitInfo *parameterBlock)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 parameterBlock	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SCSIRegisterBus
			moveq	#2,d0
			dc.w 	$A089
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIRegisterBus
	ENDIF

;
; pascal OSErr SCSIDeregisterBus(SCSI_PB *parameterBlock)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 parameterBlock	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SCSIDeregisterBus
			moveq	#3,d0
			dc.w 	$A089
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIDeregisterBus
	ENDIF

;
; pascal OSErr SCSIReregisterBus(SIMInitInfo *parameterBlock)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 parameterBlock	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SCSIReregisterBus
			moveq	#4,d0
			dc.w 	$A089
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIReregisterBus
	ENDIF

;
; pascal OSErr SCSIKillXPT(SIMInitInfo *parameterBlock)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 parameterBlock	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SCSIKillXPT
			moveq	#5,d0
			dc.w 	$A089
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCSIKillXPT
	ENDIF

	ENDIF ; __SCSI__

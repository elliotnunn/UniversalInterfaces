;
;	File:		Slots.a
;
;	Contains:	Slot Manager Interfaces.
;
;	Version:	Technology:	System 7.5
;				Package:	Universal Interfaces 2.2 in “MPW” on ETO #20
;
;	Copyright:	© 1984-1995 by Apple Computer, Inc.
;				All rights reserved.
;
;	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter
;				stack.  Include the file and version information (from above)
;				in the problem description and send to:
;					Internet:	apple.bugs@applelink.apple.com
;					AppleLink:	APPLE.BUGS
;
;

	IF &TYPE('__SLOTS__') = 'UNDEFINED' THEN
__SLOTS__ SET 1


	IF &TYPE('__TYPES__') = 'UNDEFINED' THEN
	include 'Types.a'
	ENDIF
;		include 'ConditionalMacros.a'								;

	IF &TYPE('__EVENTS__') = 'UNDEFINED' THEN
	include 'Events.a'
	ENDIF
;		include 'Quickdraw.a'										;
;			include 'MixedMode.a'									;
;			include 'QuickdrawText.a'								;
;		include 'OSUtils.a'										;
;			include 'Memory.a'										;

	IF &TYPE('__OSUTILS__') = 'UNDEFINED' THEN
	include 'OSUtils.a'
	ENDIF

	IF &TYPE('__FILES__') = 'UNDEFINED' THEN
	include 'Files.a'
	ENDIF
;		include 'Finder.a'											;

fDontUse						EQU		0					;old slotmgr put fcardIsChanged here
fCardIsChanged					EQU		1					;card is Changed field in StatusFlags field of sInfoArray
fTempEnabled					EQU		2					;slot is temporarily enabled
fCkForNext						EQU		0					;check for NEXT sRsrc in SRT			(SearchSRT)
fCkReserved						EQU		1					;check reserved field for zero 		(ReadPBSize)
fWarmStart						EQU		2					;warm start, else cold start			(PrimaryInit)
fClear							EQU		3					;clear the memory						(sNewPtr)
fSys							EQU		4					;alloc  on system heap 				(sNewPtr)
fConsecBytes					EQU		5					;calc step value for consecutive bytes (CalcStep)

stateNil						EQU		0					;State
stateSDMInit					EQU		1					;:Slot declaration manager Init
statePRAMInit					EQU		2					;:sPRAM record init
statePInit						EQU		3					;:Primary init
stateSInit						EQU		4					;:Secondary init
; flags for spParamData 
fall							EQU		0					; bit 0: set=search enabled/disabled sRsrc's 
foneslot						EQU		1					;    1: set=search sRsrc's in given slot only 
fnext							EQU		2					;    2: set=search for next sRsrc 
; Misc masks 
catMask							EQU		$08					; sets spCategory field of spTBMask (bit 3) 
cTypeMask						EQU		$04					; sets spCType    field of spTBMask (bit 2) 
drvrSWMask						EQU		$02					; sets spDrvrSW   field of spTBMask (bit 1) 
drvrHWMask						EQU		$01					; sets spDrvrHW	  field of spTBMask (bit 0) 

SlotIntQElement 		RECORD	0
sqLink					 ds.l   1		; offset: $0 (0)		;ptr to next element
sqType					 ds.w   1		; offset: $4 (4)		;queue type ID for validity
sqPrio					 ds.w   1		; offset: $6 (6)		;priority
sqAddr					 ds.l   1		; offset: $8 (8)		;interrupt service routine
sqParm					 ds.l   1		; offset: $C (12)		;optional A1 parameter
sizeof					 EQU *			; size:   $10 (16)
						ENDR

; typedef struct SlotIntQElement  SlotIntQElement
; typedef SlotIntQElement 	*SQElemPtr
SpBlock 				RECORD	0
spResult				 ds.l   1		; offset: $0 (0)		;FUNCTION Result
spsPointer				 ds.l   1		; offset: $4 (4)		;structure pointer
spSize					 ds.l   1		; offset: $8 (8)		;size of structure
spOffsetData			 ds.l   1		; offset: $C (12)		;offset/data field used by sOffsetData
spIOFileName			 ds.l   1		; offset: $10 (16)		;ptr to IOFile name for sDisDrvrName
spsExecPBlk				 ds.l   1		; offset: $14 (20)		;pointer to sExec parameter block.
spParamData				 ds.l   1		; offset: $18 (24)		;misc parameter data (formerly spStackPtr).
spMisc					 ds.l   1		; offset: $1C (28)		;misc field for SDM.
spReserved				 ds.l   1		; offset: $20 (32)		;reserved for future expansion
spIOReserved			 ds.w   1		; offset: $24 (36)		;Reserved field of Slot Resource Table
spRefNum				 ds.w   1		; offset: $26 (38)		;RefNum
spCategory				 ds.w   1		; offset: $28 (40)		;sType: Category
spCType					 ds.w   1		; offset: $2A (42)		;Type
spDrvrSW				 ds.w   1		; offset: $2C (44)		;DrvrSW
spDrvrHW				 ds.w   1		; offset: $2E (46)		;DrvrHW
spTBMask				 ds.b   1		; offset: $30 (48)		;type bit mask bits 0..3 mask words 0..3
spSlot					 ds.b   1		; offset: $31 (49)		;slot number
spID					 ds.b   1		; offset: $32 (50)		;structure ID
spExtDev				 ds.b   1		; offset: $33 (51)		;ID of the external device
spHwDev					 ds.b   1		; offset: $34 (52)		;Id of the hardware device.
spByteLanes				 ds.b   1		; offset: $35 (53)		;bytelanes from card ROM format block
spFlags					 ds.b   1		; offset: $36 (54)		;standard flags
spKey					 ds.b   1		; offset: $37 (55)		;Internal use only
sizeof					 EQU *			; size:   $38 (56)
						ENDR

; typedef struct SpBlock 	SpBlock
; typedef SpBlock 			*SpBlockPtr
SInfoRecord 			RECORD	0
siDirPtr				 ds.l   1		; offset: $0 (0)		;Pointer to directory
siInitStatusA			 ds.w   1		; offset: $4 (4)		;initialization E
siInitStatusV			 ds.w   1		; offset: $6 (6)		;status returned by vendor init code
siState					 ds.b   1		; offset: $8 (8)		;initialization state
siCPUByteLanes			 ds.b   1		; offset: $9 (9)		;0=[d0..d7] 1=[d8..d15]
siTopOfROM				 ds.b   1		; offset: $A (10)		;Top of ROM= $FssFFFFx: x is TopOfROM
siStatusFlags			 ds.b   1		; offset: $B (11)		;bit 0 - card is changed
siTOConst				 ds.w   1		; offset: $C (12)		;Time Out C for BusErr
siReserved				 ds.b   2		; offset: $E (14)		;reserved
siROMAddr				 ds.l   1		; offset: $10 (16)		; addr of top of ROM 
siSlot					 ds.b   1		; offset: $14 (20)		; slot number 
siPadding				 ds.b   3		; offset: $15 (21)		; reserved 
sizeof					 EQU *			; size:   $18 (24)
						ENDR

; typedef struct SInfoRecord  SInfoRecord
; typedef SInfoRecord 		*SInfoRecPtr
SDMRecord 				RECORD	0
sdBEVSave				 ds.l   1		; offset: $0 (0)		;Save old BusErr vector
sdBusErrProc			 ds.l   1		; offset: $4 (4)		;Go here to determine if it is a BusErr
sdErrorEntry			 ds.l   1		; offset: $8 (8)		;Go here if BusErrProc finds real BusErr
sdReserved				 ds.l   1		; offset: $C (12)		;Reserved
sizeof					 EQU *			; size:   $10 (16)
						ENDR

; typedef struct SDMRecord 	SDMRecord
FHeaderRec 				RECORD	0
fhDirOffset				 ds.l   1		; offset: $0 (0)		;offset to directory
fhLength				 ds.l   1		; offset: $4 (4)		;length of ROM
fhCRC					 ds.l   1		; offset: $8 (8)		;CRC
fhROMRev				 ds.b   1		; offset: $C (12)		;revision of ROM
fhFormat				 ds.b   1		; offset: $D (13)		;format - 2
fhTstPat				 ds.l   1		; offset: $E (14)		;test pattern
fhReserved				 ds.b   1		; offset: $12 (18)		;reserved
fhByteLanes				 ds.b   1		; offset: $13 (19)		;ByteLanes
sizeof					 EQU *			; size:   $14 (20)
						ENDR

; typedef struct FHeaderRec  FHeaderRec
; typedef FHeaderRec 		*FHeaderRecPtr
OffsetToDir		EQU			FHeaderRec.fhDirOffset-FHeaderRec.sizeof+1	; offset to dir ptr	<1.8>
; 
; 	Extended Format header block  -  extended declaration ROM format header for super sRsrc directories.	<H2><SM0>
; 
XFHeaderRec 			RECORD	0
fhXSuperInit			 ds.l   1		; offset: $0 (0)		;Offset to SuperInit SExecBlock	<fhFormat,offset>
fhXSDirOffset			 ds.l   1		; offset: $4 (4)		;Offset to SuperDirectory			<$FE,offset>
fhXEOL					 ds.l   1		; offset: $8 (8)		;Psuedo end-of-list				<$FF,nil>
fhXSTstPat				 ds.l   1		; offset: $C (12)		;TestPattern
fhXDirOffset			 ds.l   1		; offset: $10 (16)		;Offset to (minimal) directory
fhXLength				 ds.l   1		; offset: $14 (20)		;Length of ROM
fhXCRC					 ds.l   1		; offset: $18 (24)		;CRC
fhXROMRev				 ds.b   1		; offset: $1C (28)		;Revision of ROM
fhXFormat				 ds.b   1		; offset: $1D (29)		;Format-2
fhXTstPat				 ds.l   1		; offset: $1E (30)		;TestPattern
fhXReserved				 ds.b   1		; offset: $22 (34)		;Reserved
fhXByteLanes			 ds.b   1		; offset: $23 (35)		;ByteLanes
sizeof					 EQU *			; size:   $24 (36)
						ENDR

; typedef struct XFHeaderRec  XFHeaderRec
; typedef XFHeaderRec 		*XFHeaderRecPtr
XFHdrExtraSize	Equ			XFHeaderRec.sizeof-FHeaderRec.sizeof		; (extended - standard) delta
XOffsetToDir	Equ			XFHeaderRec.fhXSDirOffset-XFHeaderRec.sizeof+1	; offset to super dir ptr
XOffsetToSInit	Equ			XFHeaderRec.fhXSuperInit-XFHeaderRec.sizeof+1	; offset to super dir ptr
SEBlock 				RECORD	0
seSlot					 ds.b   1		; offset: $0 (0)		;Slot number.
sesRsrcId				 ds.b   1		; offset: $1 (1)		;sResource Id.
seStatus				 ds.w   1		; offset: $2 (2)		;Status of code executed by sExec.
seFlags					 ds.b   1		; offset: $4 (4)		;Flags
seFiller0				 ds.b   1		; offset: $5 (5)		;Filler, must be SignedByte to align on odd boundry
seFiller1				 ds.b   1		; offset: $6 (6)		;Filler
seFiller2				 ds.b   1		; offset: $7 (7)		;Filler
seResult				 ds.l   1		; offset: $8 (8)		;Result of sLoad.
seIOFileName			 ds.l   1		; offset: $C (12)		;Pointer to IOFile name.
seDevice				 ds.b   1		; offset: $10 (16)		;Which device to read from.
sePartition				 ds.b   1		; offset: $11 (17)		;The partition.
seOSType				 ds.b   1		; offset: $12 (18)		;Type of OS.
seReserved				 ds.b   1		; offset: $13 (19)		;Reserved field.
seRefNum				 ds.b   1		; offset: $14 (20)		;RefNum of the driver.
seNumDevices			 ds.b   1		; offset: $15 (21)		; Number of devices to load.
seBootState				 ds.b   1		; offset: $16 (22)		;State of StartBoot code.
filler					 ds.b   1		; offset: $17 (23)
sizeof					 EQU *			; size:   $18 (24)
						ENDR

; typedef struct SEBlock 	SEBlock
;  Principle  
;
; pascal OSErr SReadByte(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SReadByte
			moveq	#0,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SReadByte
	ENDIF

;
; pascal OSErr SReadWord(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SReadWord
			moveq	#1,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SReadWord
	ENDIF

;
; pascal OSErr SReadLong(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SReadLong
			moveq	#2,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SReadLong
	ENDIF

;
; pascal OSErr SGetCString(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SGetCString
			moveq	#3,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGetCString
	ENDIF

;
; pascal OSErr SGetBlock(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SGetBlock
			moveq	#5,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGetBlock
	ENDIF

;
; pascal OSErr SFindStruct(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SFindStruct
			moveq	#6,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SFindStruct
	ENDIF

;
; pascal OSErr SReadStruct(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SReadStruct
			moveq	#7,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SReadStruct
	ENDIF

;  Special  
;
; pascal OSErr SReadInfo(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SReadInfo
			moveq	#16,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SReadInfo
	ENDIF

;
; pascal OSErr SReadPRAMRec(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SReadPRAMRec
			moveq	#17,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SReadPRAMRec
	ENDIF

;
; pascal OSErr SPutPRAMRec(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SPutPRAMRec
			moveq	#18,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SPutPRAMRec
	ENDIF

;
; pascal OSErr SReadFHeader(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SReadFHeader
			moveq	#19,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SReadFHeader
	ENDIF

;
; pascal OSErr SNextSRsrc(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SNextSRsrc
			moveq	#20,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SNextSRsrc
	ENDIF

;
; pascal OSErr SNextTypeSRsrc(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SNextTypeSRsrc
			moveq	#21,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SNextTypeSRsrc
	ENDIF

;
; pascal OSErr SRsrcInfo(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SRsrcInfo
			moveq	#22,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SRsrcInfo
	ENDIF

;
; pascal OSErr SDisposePtr(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SDisposePtr
			moveq	#23,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SDisposePtr
	ENDIF

;
; pascal OSErr SCkCardStat(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SCkCardStat
			moveq	#24,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCkCardStat
	ENDIF

;
; pascal OSErr SReadDrvrName(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SReadDrvrName
			moveq	#25,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SReadDrvrName
	ENDIF

;
; pascal OSErr SFindSRTRec(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SFindSRTRec
			moveq	#26,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SFindSRTRec
	ENDIF

;
; pascal OSErr SFindDevBase(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SFindDevBase
			moveq	#27,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SFindDevBase
	ENDIF

;
; pascal OSErr SFindBigDevBase(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SFindBigDevBase
			moveq	#28,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SFindBigDevBase
	ENDIF

;  Advanced  
;
; pascal OSErr InitSDeclMgr(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_InitSDeclMgr
			moveq	#32,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	InitSDeclMgr
	ENDIF

;
; pascal OSErr SPrimaryInit(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SPrimaryInit
			moveq	#33,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SPrimaryInit
	ENDIF

;
; pascal OSErr SCardChanged(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SCardChanged
			moveq	#34,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCardChanged
	ENDIF

;
; pascal OSErr SExec(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SExec
			moveq	#35,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SExec
	ENDIF

;
; pascal OSErr SOffsetData(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SOffsetData
			moveq	#36,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SOffsetData
	ENDIF

;
; pascal OSErr SInitPRAMRecs(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SInitPRAMRecs
			moveq	#37,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SInitPRAMRecs
	ENDIF

;
; pascal OSErr SReadPBSize(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SReadPBSize
			moveq	#38,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SReadPBSize
	ENDIF

;
; pascal OSErr SCalcStep(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SCalcStep
			moveq	#40,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCalcStep
	ENDIF

;
; pascal OSErr SInitSRsrcTable(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SInitSRsrcTable
			moveq	#41,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SInitSRsrcTable
	ENDIF

;
; pascal OSErr SSearchSRT(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SSearchSRT
			moveq	#42,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SSearchSRT
	ENDIF

;
; pascal OSErr SUpdateSRT(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SUpdateSRT
			moveq	#43,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SUpdateSRT
	ENDIF

;
; pascal OSErr SCalcSPointer(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SCalcSPointer
			moveq	#44,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SCalcSPointer
	ENDIF

;
; pascal OSErr SGetDriver(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SGetDriver
			moveq	#45,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGetDriver
	ENDIF

;
; pascal OSErr SPtrToSlot(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SPtrToSlot
			moveq	#46,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SPtrToSlot
	ENDIF

;
; pascal OSErr SFindSInfoRecPtr(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SFindSInfoRecPtr
			moveq	#47,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SFindSInfoRecPtr
	ENDIF

;
; pascal OSErr SFindSRsrcPtr(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SFindSRsrcPtr
			moveq	#48,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SFindSRsrcPtr
	ENDIF

;
; pascal OSErr SDeleteSRTRec(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SDeleteSRTRec
			moveq	#49,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SDeleteSRTRec
	ENDIF

;
; pascal OSErr SSecondaryInit(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SSecondaryInit
			moveq	#50,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SSecondaryInit
	ENDIF

;
; pascal OSErr SInitSlotPRAM(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SInitSlotPRAM
			moveq	#51,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SInitSlotPRAM
	ENDIF

;
; pascal OSErr OpenSlot(ParmBlkPtr paramBlock, Boolean async)
;
	IF GENERATINGCFM THEN
		IMPORT_CFM_FUNCTION	OpenSlot
	ENDIF

;
; pascal OSErr OpenSlotSync(ParmBlkPtr paramBlock)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 paramBlock    	=> A0
		; returns: 
		;	 OSErr         	<= D0
		_OpenSlotSync:	OPWORD	$A200
	ELSE
		IMPORT_CFM_FUNCTION	OpenSlotSync
	ENDIF

;
; pascal OSErr OpenSlotAsync(ParmBlkPtr paramBlock)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 paramBlock    	=> A0
		; returns: 
		;	 OSErr         	<= D0
		_OpenSlotAsync:	OPWORD	$A600
	ELSE
		IMPORT_CFM_FUNCTION	OpenSlotAsync
	ENDIF

;  Device Manager Slot Support  
;
; pascal OSErr SIntInstall(SQElemPtr sIntQElemPtr, short theSlot)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 sIntQElemPtr  	=> A0
		;	 theSlot       	=> D0
		; returns: 
		;	 OSErr         	<= D0
		_SIntInstall:	OPWORD	$A075
	ELSE
		IMPORT_CFM_FUNCTION	SIntInstall
	ENDIF

;
; pascal OSErr SIntRemove(SQElemPtr sIntQElemPtr, short theSlot)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 sIntQElemPtr  	=> A0
		;	 theSlot       	=> D0
		; returns: 
		;	 OSErr         	<= D0
		_SIntRemove:	OPWORD	$A076
	ELSE
		IMPORT_CFM_FUNCTION	SIntRemove
	ENDIF

;
; pascal OSErr SVersion(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SVersion
			moveq	#8,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SVersion
	ENDIF

;
; pascal OSErr SetSRsrcState(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SetSRsrcState
			moveq	#9,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SetSRsrcState
	ENDIF

;
; pascal OSErr InsertSRTRec(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_InsertSRTRec
			moveq	#10,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	InsertSRTRec
	ENDIF

;
; pascal OSErr SGetSRsrc(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SGetSRsrc
			moveq	#11,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGetSRsrc
	ENDIF

;
; pascal OSErr SGetTypeSRsrc(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SGetTypeSRsrc
			moveq	#12,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGetTypeSRsrc
	ENDIF

;
; pascal OSErr SGetSRsrcPtr(SpBlockPtr spBlkPtr)
;
	IF ¬ GENERATINGCFM THEN
		; parameters: 
		;	 spBlkPtr      	=> A0
		; returns: 
		;	 OSErr         	<= D0
		Macro
		_SGetSRsrcPtr
			moveq	#29,d0
			dc.w 	$A06E
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SGetSRsrcPtr
	ENDIF

	ENDIF ; __SLOTS__

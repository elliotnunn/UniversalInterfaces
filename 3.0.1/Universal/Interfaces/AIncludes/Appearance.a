;
;	File:		Appearance.a
;
;	Contains:	Appearance Manager & SDK Interfaces.
;
;	Version:	Technology:	Appearance 1.0
;				Release:	Universal Interfaces 3.0.1
;
;	Copyright:	© 1994-1997 by Apple Computer, Inc., all rights reserved
;
;	Bugs?:		Please include the the file and version information (from above) with
;				the problem description.  Developers belonging to one of the Apple
;				developer programs can submit bug reports to:
;
;					devsupport@apple.com
;
;
	IF &TYPE('__APPEARANCE__') = 'UNDEFINED' THEN
__APPEARANCE__ SET 1

	IF &TYPE('__TYPES__') = 'UNDEFINED' THEN
	include 'Types.a'
	ENDIF
	IF &TYPE('__MACWINDOWS__') = 'UNDEFINED' THEN
	include 'MacWindows.a'
	ENDIF
	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF
	IF &TYPE('__DIALOGS__') = 'UNDEFINED' THEN
	include 'Dialogs.a'
	ENDIF
	IF &TYPE('__FILES__') = 'UNDEFINED' THEN
	include 'Files.a'
	ENDIF
	IF &TYPE('__ICONS__') = 'UNDEFINED' THEN
	include 'Icons.a'
	ENDIF
	IF &TYPE('__CONTROLS__') = 'UNDEFINED' THEN
	include 'Controls.a'
	ENDIF
	IF &TYPE('__TEXTEDIT__') = 'UNDEFINED' THEN
	include 'TextEdit.a'
	ENDIF
	IF &TYPE('__QDOFFSCREEN__') = 'UNDEFINED' THEN
	include 'QDOffscreen.a'
	ENDIF
	IF &TYPE('__TEXTCOMMON__') = 'UNDEFINED' THEN
	include 'TextCommon.a'
	ENDIF

; ——————————————————————————————————————————————————————————————————————————————————
;  Appearance Manager constants, etc.												
; ——————————————————————————————————————————————————————————————————————————————————

															; Appearance Trap Number 
_AppearanceDispatch				EQU		$AA74
;  Gestalt selector and values for the Appearance Manager 

gestaltAppearanceAttr			EQU		'appr'
gestaltAppearanceExists			EQU		0
gestaltAppearanceCompatMode		EQU		1
;  Appearance Manager Error Codes 

appearanceBadBrushIndexErr		EQU		-30560				; pattern index invalid 
appearanceProcessRegisteredErr	EQU		-30561
appearanceProcessNotRegisteredErr EQU	-30562
appearanceBadTextColorIndexErr	EQU		-30563

kThemeActiveDialogBackgroundBrush EQU	1					; Dialogs 
kThemeInactiveDialogBackgroundBrush EQU	2					; Dialogs 
kThemeActiveAlertBackgroundBrush EQU	3
kThemeInactiveAlertBackgroundBrush EQU	4
kThemeActiveModelessDialogBackgroundBrush EQU 5
kThemeInactiveModelessDialogBackgroundBrush EQU 6
kThemeActiveUtilityWindowBackgroundBrush EQU 7				; Miscellaneous 
kThemeInactiveUtilityWindowBackgroundBrush EQU 8			; Miscellaneous 
kThemeListViewSortColumnBackgroundBrush EQU 9				; Finder 
kThemeListViewBackgroundBrush	EQU		10
kThemeIconLabelBackgroundBrush	EQU		11
kThemeListViewSeparatorBrush	EQU		12
kThemeChasingArrowsBrush		EQU		13
kThemeDragHiliteBrush			EQU		14
kThemeDocumentWindowBackgroundBrush EQU	15
kThemeFinderWindowBackgroundBrush EQU	16
; typedef SInt16 						ThemeBrush


kThemeActiveDialogTextColor		EQU		1					; Dialogs 
kThemeInactiveDialogTextColor	EQU		2
kThemeActiveAlertTextColor		EQU		3
kThemeInactiveAlertTextColor	EQU		4
kThemeActiveModelessDialogTextColor EQU	5
kThemeInactiveModelessDialogTextColor EQU 6
kThemeActiveWindowHeaderTextColor EQU	7					; Primitives 
kThemeInactiveWindowHeaderTextColor EQU	8
kThemeActivePlacardTextColor	EQU		9					; Primitives 
kThemeInactivePlacardTextColor	EQU		10
kThemePressedPlacardTextColor	EQU		11
kThemeActivePushButtonTextColor	EQU		12					; Primitives 
kThemeInactivePushButtonTextColor EQU	13
kThemePressedPushButtonTextColor EQU	14
kThemeActiveBevelButtonTextColor EQU	15					; Primitives 
kThemeInactiveBevelButtonTextColor EQU	16
kThemePressedBevelButtonTextColor EQU	17
kThemeActivePopupButtonTextColor EQU	18					; Primitives 
kThemeInactivePopupButtonTextColor EQU	19
kThemePressedPopupButtonTextColor EQU	20
kThemeIconLabelTextColor		EQU		21					; Finder 
kThemeListViewTextColor			EQU		22
; typedef SInt16 						ThemeTextColor

;  States to draw primitives: disabled, active, and pressed (hilited) 

kThemeStateDisabled				EQU		0
kThemeStateActive				EQU		1
kThemeStatePressed				EQU		2
; typedef UInt32 						ThemeDrawState

; ——————————————————————————————————————————————————————————————————————————————————
;  Window Manager constants, etc.													
; ——————————————————————————————————————————————————————————————————————————————————

															; Resource IDs for new window defprocs 
kWindowDocumentDefProcResID		EQU		64
kWindowDialogDefProcResID		EQU		65
kWindowUtilityDefProcResID		EQU		66
kWindowUtilitySideTitleDefProcResID EQU	67

															; Proc IDs for theme-savvy windows 
kWindowDocumentProc				EQU		1024
kWindowGrowDocumentProc			EQU		1025
kWindowHorizZoomDocumentProc	EQU		1026
kWindowHorizZoomGrowDocumentProc EQU	1027
kWindowVertZoomDocumentProc		EQU		1028
kWindowVertZoomGrowDocumentProc	EQU		1029
kWindowFullZoomDocumentProc		EQU		1030
kWindowFullZoomGrowDocumentProc	EQU		1031

															; Proc IDs for theme-savvy dialogs 
kWindowPlainDialogProc			EQU		1040
kWindowShadowDialogProc			EQU		1041
kWindowModalDialogProc			EQU		1042
kWindowMovableModalDialogProc	EQU		1043
kWindowAlertProc				EQU		1044
kWindowMovableAlertProc			EQU		1045

															; Proc IDs for top title bar theme-savvy floating windows 
kWindowFloatProc				EQU		1057
kWindowFloatGrowProc			EQU		1059
kWindowFloatHorizZoomProc		EQU		1061
kWindowFloatHorizZoomGrowProc	EQU		1063
kWindowFloatVertZoomProc		EQU		1065
kWindowFloatVertZoomGrowProc	EQU		1067
kWindowFloatFullZoomProc		EQU		1069
kWindowFloatFullZoomGrowProc	EQU		1071

															; Proc IDs for side title bar theme-savvy floating windows 
kWindowFloatSideProc			EQU		1073
kWindowFloatSideGrowProc		EQU		1075
kWindowFloatSideHorizZoomProc	EQU		1077
kWindowFloatSideHorizZoomGrowProc EQU	1079
kWindowFloatSideVertZoomProc	EQU		1081
kWindowFloatSideVertZoomGrowProc EQU	1083
kWindowFloatSideFullZoomProc	EQU		1085
kWindowFloatSideFullZoomGrowProc EQU	1087

															; Region values to pass into GetWindowRegion 
kWindowTitleBarRgn				EQU		0
kWindowTitleTextRgn				EQU		1
kWindowCloseBoxRgn				EQU		2
kWindowZoomBoxRgn				EQU		3
kWindowDragRgn					EQU		5
kWindowGrowRgn					EQU		6
kWindowCollapseBoxRgn			EQU		7
kWindowStructureRgn				EQU		32
kWindowContentRgn				EQU		33
; typedef UInt16 						WindowRegionCode


															; Window Features returned by GetWindowFeatures 
kWindowCanGrow					EQU		$01
kWindowCanZoom					EQU		$02
kWindowCanCollapse				EQU		$04
kWindowIsModal					EQU		$08
kWindowCanGetWindowRegion		EQU		$10
kWindowIsAlert					EQU		$20
kWindowHasTitleBar				EQU		$40

															; New window messages 
kWindowMsgGetFeatures			EQU		7
kWindowMsgGetRegion				EQU		8

															; New Window part codes 
inCollapseBox					EQU		11

															; Window Definition hit test result codes ("WindowPart")
wInCollapseBox					EQU		9
;  Window positioning constants 

kWindowDefaultPosition			EQU		$0000
kWindowCenterMainScreen			EQU		$280A
kWindowAlertPositionMainScreen	EQU		$300A
kWindowStaggerMainScreen		EQU		$380A
kWindowCenterParentWindow		EQU		$A80A
kWindowAlertPositionParentWindow EQU	$B00A
kWindowStaggerParentWindow		EQU		$B80A
kWindowCenterParentWindowScreen	EQU		$680A
kWindowAlertPositionParentWindowScreen EQU $700A
kWindowStaggerParentWindowScreen EQU	$780A
;  GetWindowRegionRec - used for WDEF calls with kWindowMsgGetRegion 
GetWindowRegionRec		RECORD 0
winRgn					 ds.l	1				; offset: $0 (0)
regionCode				 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct GetWindowRegionRec *	GetWindowRegionPtr

; ——————————————————————————————————————————————————————————————————————————————————
;  Dialog Manager constants, etc.													
; ——————————————————————————————————————————————————————————————————————————————————

															; Alert types to pass into StandardAlert 
kAlertStopAlert					EQU		0
kAlertNoteAlert					EQU		1
kAlertCautionAlert				EQU		2
kAlertPlainAlert				EQU		3
; typedef SInt16 						AlertType


kAlertDefaultOKText				EQU		-1					; "OK"
kAlertDefaultCancelText			EQU		-1					; "Cancel"
kAlertDefaultOtherText			EQU		-1					; "Don't Save"
;  StandardAlert alert button numbers 

kAlertStdAlertOKButton			EQU		1
kAlertStdAlertCancelButton		EQU		2
kAlertStdAlertOtherButton		EQU		3
kAlertStdAlertHelpButton		EQU		4

															; Dialog Flags for use in NewFeaturesDialog or dlgx resource 
kDialogFlagsUseThemeBackground	EQU		$01
kDialogFlagsUseControlHierarchy	EQU		$02
kDialogFlagsHandleMovableModal	EQU		$04
kDialogFlagsUseThemeControls	EQU		$08

															; Alert Flags for use in alrx resource 
kAlertFlagsUseThemeBackground	EQU		$01
kAlertFlagsUseControlHierarchy	EQU		$02
kAlertFlagsAlertIsMovable		EQU		$04
kAlertFlagsUseThemeControls		EQU		$08
;  For dftb resource 

kDialogFontNoFontStyle			EQU		0
kDialogFontUseFontMask			EQU		$0001
kDialogFontUseFaceMask			EQU		$0002
kDialogFontUseSizeMask			EQU		$0004
kDialogFontUseForeColorMask		EQU		$0008
kDialogFontUseBackColorMask		EQU		$0010
kDialogFontUseModeMask			EQU		$0020
kDialogFontUseJustMask			EQU		$0040
kDialogFontUseAllMask			EQU		$00FF
kDialogFontAddFontSizeMask		EQU		$0100
kDialogFontUseFontMaskMask		EQU		$0200
AlertStdAlertParamRec	RECORD 0
movable					 ds.b	1				; offset: $0 (0)		;  Make alert movable modal 
helpButton				 ds.b	1				; offset: $1 (1)		;  Is there a help button? 
filterProc				 ds.l	1				; offset: $2 (2)		;  Event filter 
defaultText				 ds.l	1				; offset: $6 (6)		;  Text for button in OK position 
cancelText				 ds.l	1				; offset: $A (10)		;  Text for button in cancel position 
otherText				 ds.l	1				; offset: $E (14)		;  Text for button in left position 
defaultButton			 ds.w	1				; offset: $12 (18)		;  Which button behaves as the default 
cancelButton			 ds.w	1				; offset: $14 (20)		;  Which one behaves as cancel (can be 0) 
position				 ds.w	1				; offset: $16 (22)		;  Position (kWindowDefaultPosition in this case 
;  equals kWindowAlertPositionParentWindowScreen) 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct AlertStdAlertParamRec * AlertStdAlertParamPtr

; ——————————————————————————————————————————————————————————————————————————————————
;  Control Manager constants, etc.													
; ——————————————————————————————————————————————————————————————————————————————————

_ControlDispatch				EQU		$AA73

															; resource types for new controls 
kControlTabListResType			EQU		'tab#'				; used for tab control only
kControlListDescResType			EQU		'ldes'				; used for list box control only

															; new part codes for new controls 
kControlEditTextPart			EQU		5
kControlPicturePart				EQU		6
kControlIconPart				EQU		7
kControlClockPart				EQU		8
kControlListBoxPart				EQU		24
kControlListBoxDoubleClickPart	EQU		25

kControlSupportsNewMessages		EQU		' ok '				; CDEF should return as result of kControlMsgTestNewMsgSupport
;  focusing part codes 

kControlFocusNoPart				EQU		0					; tells control to clear its focus
kControlFocusNextPart			EQU		-1					; tells control to focus on the next part
kControlFocusPrevPart			EQU		-2					; tells control to focus on the previous part
; typedef SInt16 						ControlFocusPart

;  Key Filter result codes 															
; 																					
;  Certain controls can have a keyfilter attached to them. The filter proc should	
;  return one of the two constants below. If kKeyFilterBlockKey is returned, the	
;  key is blocked and never makes it to the control. If kKeyFilterPassKey is		
;  returned, the control receives the keystroke.									

kControlKeyFilterBlockKey		EQU		0
kControlKeyFilterPassKey		EQU		1
; typedef SInt16 						ControlKeyFilterResult

; ——————————————————————————————————————————————————————————————————————————————————————
;  	SPECIAL FONT USAGE NOTES: You can specify the font to use for many control types.
;	The constants below are meta-font numbers which you can use to set a particular
;	control's font usage. There are essentially two modes you can use: 1) default,
;	which is essentially the same as it always has been, i.e. it uses the system font, unless
;	directed to use the window font via a control variant. 2) you can specify to use
;	the big or small system font in a generic manner. The Big system font is the font
;	used in menus, etc. Chicago has filled that role for some time now. Small system
;	font is currently Geneva 10. The meta-font number implies the size and style.
;	
;	NOTE:		Not all font attributes are used by all controls. Most, in fact, ignore
;				the fore and back color (Static Text is the only one that does, for
;				backwards compatibility). Also size, face, and addFontSize are ignored
;				when using the meta-font numbering.
;

; ——————————————————————————————————————————————————————————————————————————————————————

															; Meta-font numbering - see not above 
kControlFontBigSystemFont		EQU		-1					; force to big system font
kControlFontSmallSystemFont		EQU		-2					; force to small system font
kControlFontSmallBoldSystemFont	EQU		-3					; force to small bold system font
;  Add these masks together to set the flags field of a ControlFontStyleRec	
;  They specify which fields to apply to the text. It is important to make	
;  sure that you specify only the fields that you wish to set.				

kControlUseFontMask				EQU		$0001
kControlUseFaceMask				EQU		$0002
kControlUseSizeMask				EQU		$0004
kControlUseForeColorMask		EQU		$0008
kControlUseBackColorMask		EQU		$0010
kControlUseModeMask				EQU		$0020
kControlUseJustMask				EQU		$0040
kControlUseAllMask				EQU		$00FF
kControlAddFontSizeMask			EQU		$0100
ControlFontStyleRec		RECORD 0
flags					 ds.w	1				; offset: $0 (0)
font					 ds.w	1				; offset: $2 (2)
size					 ds.w	1				; offset: $4 (4)
style					 ds.w	1				; offset: $6 (6)
mode					 ds.w	1				; offset: $8 (8)
just					 ds.w	1				; offset: $A (10)
foreColor				 ds		RGBColor		; offset: $C (12)
backColor				 ds		RGBColor		; offset: $12 (18)
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct ControlFontStyleRec *	ControlFontStylePtr

; ——————————————————————————————————————————————————————————————————————————————————————
;  Common data tags for Get/SetControlData												
; ——————————————————————————————————————————————————————————————————————————————————————

kControlFontStyleTag			EQU		'font'
kControlKeyFilterTag			EQU		'fltr'
; ——————————————————————————————————————————————————————————————————————————————————————
;  Errors are in the range -30580 .. -30599												
; ——————————————————————————————————————————————————————————————————————————————————————

errMessageNotSupported			EQU		-30580
errDataNotSupported				EQU		-30581
errControlDoesntSupportFocus	EQU		-30582
errWindowDoesntSupportFocus		EQU		-30583
errUnknownControl				EQU		-30584
errCouldntSetFocus				EQU		-30585
errNoRootControl				EQU		-30586
errRootAlreadyExists			EQU		-30587
errInvalidPartCode				EQU		-30588
errControlsAlreadyExist			EQU		-30589
errControlIsNotEmbedder			EQU		-30590
errDataSizeMismatch				EQU		-30591
errControlHiddenOrDisabled		EQU		-30592
errWindowRegionCodeInvalid		EQU		-30593
errCantEmbedIntoSelf			EQU		-30594
errCantEmbedRoot				EQU		-30595
errItemNotControl				EQU		-30596

															; Control feature bits - returned by GetControlFeatures 
kControlSupportsGhosting		EQU		$01
kControlSupportsEmbedding		EQU		$02
kControlSupportsFocus			EQU		$04
kControlWantsIdle				EQU		$08
kControlWantsActivate			EQU		$10
kControlHandlesTracking			EQU		$20
kControlSupportsDataAccess		EQU		$40
kControlHasSpecialBackground	EQU		$80
kControlGetsFocusOnClick		EQU		$0100
kControlSupportsCalcBestRect	EQU		$0200
kControlSupportsLiveFeedback	EQU		$0400

															; Control Messages 
kControlMsgDrawGhost			EQU		13
kControlMsgCalcBestRect			EQU		14					; Calculate best fitting rectangle for control
kControlMsgHandleTracking		EQU		15
kControlMsgFocus				EQU		16					; param indicates action.
kControlMsgKeyDown				EQU		17
kControlMsgIdle					EQU		18
kControlMsgGetFeatures			EQU		19
kControlMsgSetData				EQU		20
kControlMsgGetData				EQU		21
kControlMsgActivate				EQU		22
kControlMsgSetUpBackground		EQU		23
kControlMsgCalcValue			EQU		24
kControlMsgSubControlHit		EQU		25
kControlMsgCalcValueFromPos		EQU		26
kControlMsgTestNewMsgSupport	EQU		27					; See if this control supports new messaging
; ——————————————————————————————————————————————————————————————————————————————————————
;  	This structure is passed into a CDEF when called with the kControlMsgHandleTracking	
; 	message 																			
; ——————————————————————————————————————————————————————————————————————————————————————
ControlTrackingRec		RECORD 0
startPt					 ds		Point			; offset: $0 (0)
modifiers				 ds.w	1				; offset: $4 (4)
action					 ds.l	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct ControlTrackingRec *	ControlTrackingPtr

; ——————————————————————————————————————————————————————————————————————————————————————
;  This structure is passed into a CDEF when called with the kControlMsgKeyDown message 
; ——————————————————————————————————————————————————————————————————————————————————————
ControlKeyDownRec		RECORD 0
modifiers				 ds.w	1				; offset: $0 (0)
keyCode					 ds.w	1				; offset: $2 (2)
charCode				 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct ControlKeyDownRec *	ControlKeyDownPtr

; ——————————————————————————————————————————————————————————————————————————————————————
;  This structure is passed into a CDEF when called with the kControlMsgGetData or		
;  kControlMsgSetData message 															
; ——————————————————————————————————————————————————————————————————————————————————————
ControlDataAccessRec	RECORD 0
tag						 ds.l	1				; offset: $0 (0)
part					 ds.l	1				; offset: $4 (4)
size					 ds.l	1				; offset: $8 (8)
dataPtr					 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct ControlDataAccessRec *	ControlDataAccessPtr

; ——————————————————————————————————————————————————————————————————————————————————————
;  This structure is passed into a CDEF when called with the kControlCalcBestRect msg 	
; ——————————————————————————————————————————————————————————————————————————————————————
ControlCalcSizeRec		RECORD 0
height					 ds.w	1				; offset: $0 (0)
width					 ds.w	1				; offset: $2 (2)
baseLine				 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct ControlCalcSizeRec *	ControlCalcSizePtr

; ——————————————————————————————————————————————————————————————————————————————————————
;  This structure is passed into a CDEF when called with the kControlMsgSetUpBackground 
;  message is sent																		
; ——————————————————————————————————————————————————————————————————————————————————————
ControlBackgroundRec	RECORD 0
depth					 ds.w	1				; offset: $0 (0)
colorDevice				 ds.b	1				; offset: $2 (2)
						 ORG 4
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct ControlBackgroundRec *	ControlBackgroundPtr

; ——————————————————————————————————————————————————————————————————————————————————————
; 	Key Filter																			
; 																						
;  Definition of a key filter for intercepting and possibly changing keystrokes			
;  which are destined for a control														
; ——————————————————————————————————————————————————————————————————————————————————————
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• BEVEL BUTTON INTERFACE (CDEF 2)													
; ——————————————————————————————————————————————————————————————————————————————————————
; 	Bevel buttons allow you to control the content type (pict/icon/etc.), the behavior	
;  (pushbutton/toggle/sticky), and the bevel size. You also have the option of			
; 	attaching a menu to it. When a menu is present, you can specify which way the 		
; 	popup arrow is facing (down or right).												
; 																						
; 	This is all made possible by overloading the Min, Max, and Value parameters for the	
; 	control, as well as adjusting the variant. Here's the breakdown of what goes where:	
; 																						
; 	Parameter					What Goes Here											
; 	———————————————————			————————————————————————————————————————————————————	
; 	Min							Hi Byte = Behavior, Lo Byte = content type.				
; 	Max							ResID for resource-based content types.					
; 	Value						MenuID to attach, 0 = no menu, please.					
; 																						
; 	The variant is broken down into two halfs. The low 2 bits control the bevel type.	
; 	Bit 2 controls the popup arrow direction (if a menu is present) and bit 3 controls	
; 	whether or not to use the control's owning window's font.							
; 																						
; 	Constants for all you need to put this together are below. The values for behaviors	
; 	are set up so that you can simply add them to the content type and pass them into	
; 	the Min parameter of NewControl.													
; 																						
; 	An example call:																	
; 																						
; 	control = NewControl( window, &bounds, "\p", true, 0, kContentIconSuiteRes + 		
; 							kBehaviorToggles, myIconSuiteID, bevelButtonSmallBevelProc,	
; 							0L );														
; 																						
; 	Attaching a menu:																	
; 																						
; 	control = NewControl( window, &bounds, "\p", true, kMyMenuID, kContentIconSuiteRes,	
; 			myIconSuiteID, bevelButtonSmallBevelProc + kBevelButtonMenuOnRight, 0L );	
; 																						
; 	This will attach menu ID kMyMenuID to the button, with the popup arrow facing right.
; 	This also puts the menu up to the right of the button. You can also specify that a	
; 	menu can have multiple items checked at once by adding kBehaviorMultiValueMenus		
; 	into the Min parameter. If you do use multivalue menus, the GetBevelButtonMenuValue	
; 	helper function will return the last item chosen from the menu, whether or not it	
; 	was checked.																		
; 																						
; 	NOTE: 	Bevel buttons with menus actually have *two* values. The value of the 		
; 			button (on/off), and the value of the menu. The menu value can be gotten	
; 			with the GetBevelButtonMenuValue helper function.							
; 																						
; 	Handle-based Content																
; 	————————————————————																
; 	You can create your control and then set the content to an existing handle to an	
; 	icon suite, etc. using the macros below. Please keep in mind that resource-based	
; 	content is owned by the control, handle-based content is owned by you. The CDEF will
; 	not try to dispose of handle-based content. If you are changing the content type of	
; 	the button on the fly, you must make sure that if you are replacing a handle-		
; 	based content with a resource-based content to properly dispose of the handle,		
; 	else a memory leak will ensue.														
; 																						

															; Bevel Button Proc IDs 
kControlBevelButtonSmallBevelProc EQU	32
kControlBevelButtonNormalBevelProc EQU	33
kControlBevelButtonLargeBevelProc EQU	34

															; Bevel button graphic alignment values 
kControlBevelButtonAlignSysDirection EQU -1					; only left or right
kControlBevelButtonAlignCenter	EQU		0
kControlBevelButtonAlignLeft	EQU		1
kControlBevelButtonAlignRight	EQU		2
kControlBevelButtonAlignTop		EQU		3
kControlBevelButtonAlignBottom	EQU		4
kControlBevelButtonAlignTopLeft	EQU		5
kControlBevelButtonAlignBottomLeft EQU	6
kControlBevelButtonAlignTopRight EQU	7
kControlBevelButtonAlignBottomRight EQU	8
; typedef SInt16 						ControlButtonGraphicAlignment


															; Bevel button text alignment values 
kControlBevelButtonAlignTextSysDirection EQU 0
kControlBevelButtonAlignTextCenter EQU	1
kControlBevelButtonAlignTextFlushRight EQU -1
kControlBevelButtonAlignTextFlushLeft EQU -2
; typedef SInt16 						ControlButtonTextAlignment


															; Bevel button text placement values 
kControlBevelButtonPlaceSysDirection EQU -1					; if graphic on right, then on left
kControlBevelButtonPlaceNormally EQU	0
kControlBevelButtonPlaceToRightOfGraphic EQU 1
kControlBevelButtonPlaceToLeftOfGraphic EQU 2
kControlBevelButtonPlaceBelowGraphic EQU 3
kControlBevelButtonPlaceAboveGraphic EQU 4
; typedef SInt16 						ControlButtonTextPlacement

;  Add these variant codes to kBevelButtonSmallBevelProc to change the type of button 

kControlBevelButtonSmallBevelVariant EQU 0
kControlBevelButtonNormalBevelVariant EQU $01
kControlBevelButtonLargeBevelVariant EQU $02
kControlBevelButtonMenuOnRight	EQU		$04

;   Behaviors of bevel buttons. These are set up so you can add
;   them together with the content types.



kControlBehaviorPushbutton		EQU		0
kControlBehaviorToggles			EQU		$0100
kControlBehaviorSticky			EQU		$0200
kControlBehaviorMultiValueMenu	EQU		$4000				; only makes sense when a menu is attached.
kControlBehaviorOffsetContents	EQU		$8000
;  Content types supported by bevel buttons *and* image wells

kControlContentTextOnly			EQU		0
kControlContentIconSuiteRes		EQU		1
kControlContentCIconRes			EQU		2
kControlContentPictRes			EQU		3
kControlContentIconSuiteHandle	EQU		129
kControlContentCIconHandle		EQU		130
kControlContentPictHandle		EQU		131
kControlContentIconRef			EQU		132
; typedef SInt16 						ControlContentType

;  Data tags supported by the bevel button controls 

kControlBevelButtonContentTag	EQU		'cont'				; ButtonContentInfo
kControlBevelButtonTransformTag	EQU		'tran'				; IconTransformType
kControlBevelButtonTextAlignTag	EQU		'tali'				; ButtonTextAlignment
kControlBevelButtonTextOffsetTag EQU	'toff'				; SInt16
kControlBevelButtonGraphicAlignTag EQU	'gali'				; ButtonGraphicAlignment
kControlBevelButtonGraphicOffsetTag EQU	'goff'				; Point
kControlBevelButtonTextPlaceTag	EQU		'tplc'				; ButtonTextPlacement
kControlBevelButtonMenuValueTag	EQU		'mval'				; SInt16
kControlBevelButtonMenuHandleTag EQU	'mhnd'				; MenuHandle
;  Structure to pass into bevel buttons and image wells to set/get content type 
ControlButtonContentInfo RECORD 0
contentType				 ds.w	1				; offset: $0 (0)
resID					 ds.w	1				; offset: $2 (2)
						 ORG 2
cIconHandle				 ds.l	1				; offset: $2 (2)
						 ORG 2
iconSuite				 ds.l	1				; offset: $2 (2)
						 ORG 2
iconRef					 ds.l	1				; offset: $2 (2)
						 ORG 2
picture					 ds.l	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct ControlButtonContentInfo * ControlButtonContentInfoPtr

; ——————————————————————————————————————————————————————————————————————————————————————
; 	• SLIDER (CDEF 3)																	
; ——————————————————————————————————————————————————————————————————————————————————————
; 	There are several variants that control the behavior of the slider control. Any		
; 	combination of the following three constants can be added to the basic CDEF ID		
; 	(kSliderProc).																		
; 																						
; 	Variants:																			
; 																						
; 		kSliderLiveFeedback	 	Slider does not use "ghosted" indicator when tracking.	
; 								ActionProc is called (set via SetControlAction) as the	
; 								indicator is dragged. The value is updated so that the	
; 								actionproc can adjust some other property based on the	
; 								value each time the action proc is called. If no action	
; 								proc is installed, it reverts to the ghost indicator.	
; 																						
; 		kSliderHasTickMarks	 	Slider is drawn with 'tick marks'. The control			
; 								rectangle must be large enough to accomidate the tick	
; 								marks.													
; 
;/*		kSliderReverseDirection	Slider thumb points in opposite direction than normal.	
; 								If the slider is vertical, the thumb will point to the	
; 								left, if the slider is horizontal, the thumb will point	
; 								upwards.												
; 																						
; 		kSliderNonDirectional	This option overrides the kSliderReverseDirection and	
; 								kSliderHasTickMarks variants. It creates an indicator	
; 								which is rectangular and doesn't point in any direction	
; 								like the normal indicator does.							

															; Slider proc IDs 
kControlSliderProc				EQU		48
kControlSliderLiveFeedback		EQU		$01
kControlSliderHasTickMarks		EQU		$02
kControlSliderReverseDirection	EQU		$04
kControlSliderNonDirectional	EQU		$08

; ——————————————————————————————————————————————————————————————————————————————————————
; 	• DISCLOSURE TRIANGLE (CDEF 4)														
; ——————————————————————————————————————————————————————————————————————————————————————
; 	This control can be used as either left or right facing. It can also handle its own	
; 	tracking if you wish. This means that when the 'autotoggle' variant is used, if the	
; 	user clicks the control, it's state will change automatically from open to closed	
; 	and vice-versa depending on its initial state. After a successful call to Track-	
;  	Control, you can just check the current value to see what state it was switched to.	

															; Triangle proc IDs 
kControlTriangleProc			EQU		64
kControlTriangleLeftFacingProc	EQU		65
kControlTriangleAutoToggleProc	EQU		66
kControlTriangleLeftFacingAutoToggleProc EQU 67

															; Tagged data supported by disclosure triangles 
kControlTriangleLastValueTag	EQU		'last'				; SInt16
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• PROGRESS INDICATOR (CDEF 5)														
; ——————————————————————————————————————————————————————————————————————————————————————
; 	This CDEF implements both determinate and indeterminate progress bars. To switch, 	
; 	just use SetControlData to set the indeterminate flag to make it indeterminate call	
; 	IdleControls to step thru the animation. IdleControls should be called at least		
; 	once during your event loop.														
; 																						

															; Progress Bar proc IDs 
kControlProgressBarProc			EQU		80

															; Tagged data supported by progress bars 
kControlProgressBarIndeterminateTag EQU	'inde'				; Boolean
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• LITTLE ARROWS (CDEF 6)															
; ——————————————————————————————————————————————————————————————————————————————————————
;  	This control implements the little up and down arrows you'd see in the Memory		
; 	control panel for adjusting the cache size. 										

															; Little Arrows proc IDs 
kControlLittleArrowsProc		EQU		96
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• CHASING ARROWS (CDEF 7)															
; ——————————————————————————————————————————————————————————————————————————————————————
; 	To animate this control, make sure to call IdleControls repeatedly.					
; 																						

															; Chasing Arrows proc IDs 
kControlChasingArrowsProc		EQU		112
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• TABS (CDEF 8)																		
; ——————————————————————————————————————————————————————————————————————————————————————
; 	Tabs use an auxiliary resource (tab#) to hold tab information such as the tab name	
; 	and an icon suite ID for each tab.													
; 																						
; 	The ID of the tab# resource that you wish to associate with a tab control should 	
; 	be passed in as the Value parameter of the control. If you are using GetNewControl, 
; 	then the Value slot in the CNTL resource should have the ID of the 'tab#' resource	
; 	on creation.																		
; 																						

															; Tabs proc IDs 
kControlTabLargeProc			EQU		128					; Large tab size	
kControlTabSmallProc			EQU		129					; Small tab size	

															; Tagged data supported by progress bars 
kControlTabContentRectTag		EQU		'rect'				; Rect
kControlTabEnabledFlagTag		EQU		'enab'				; Boolean
kControlTabFontStyleTag			EQU		'font'				; ControlFontStyleRec
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• VISUAL SEPARATOR (CDEF 9)															
; ——————————————————————————————————————————————————————————————————————————————————————
; 	Separator lines determine their orientation (horizontal or vertical) automatically	
; 	based on the relative height and width of their contrlRect.							

															; Visual separator proc IDs 
kControlSeparatorLineProc		EQU		144

; ——————————————————————————————————————————————————————————————————————————————————————
; 	• GROUP BOX (CDEF 10)																
; ——————————————————————————————————————————————————————————————————————————————————————
; 	The group box CDEF can be use in several ways. It can have no title, a text title, 	
; 	a check box as the title, or a popup button as a title. There are two versions of 	
; 	group boxes, primary and secondary, which look slightly different.					

															; Group Box proc IDs 
kControlGroupBoxTextTitleProc	EQU		160
kControlGroupBoxCheckBoxProc	EQU		161
kControlGroupBoxPopupButtonProc	EQU		162
kControlGroupBoxSecondaryTextTitleProc EQU 164
kControlGroupBoxSecondaryCheckBoxProc EQU 165
kControlGroupBoxSecondaryPopupButtonProc EQU 166

															; Tagged data supported by group box 
kControlGroupBoxMenuHandleTag	EQU		'mhan'				; MenuHandle (popup title only)
kControlGroupBoxFontStyleTag	EQU		'font'				; ControlFontStyleRec
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• IMAGE WELL (CDEF 11)																
; ——————————————————————————————————————————————————————————————————————————————————————
; 	Image Wells allow you to control the content type (pict/icon/etc.) shown in the 	
; 	well.																				
; 																						
; 	This is made possible by overloading the Min and Value parameters for the control.	
; 																						
; 	Parameter					What Goes Here											
; 	———————————————————			——————————————————————————————————————————————————		
; 	Min							content type (see constants for bevel buttons)			
; 	Value						Resource ID of content type, if resource-based.			
; 																						
; 																						
; 	Checked State																		
; 	—————————————																		
; 	The checked state is enabled by setting the value of the control to 1, just like a 	
; 	check box.																			
; 																						
; 	Handle-based Content																
; 	————————————————————																
; 	You can create your control and then set the content to an existing handle to an	
; 	icon suite, etc. using the macros below. Please keep in mind that resource-based	
; 	content is owned by the control, handle-based content is owned by you. The CDEF will
; 	not try to dispose of handle-based content. If you are changing the content type of	
; 	the button on the fly, you must make sure that if you are replacing a handle-		
; 	based content with a resource-based content to properly dispose of the handle,		
; 	else a memory leak will ensue.														
; 																						
; 																						
; 	AutoTracking																		
; 	————————————																		
; 	Image Wells are capable of autotracking. The current autotracking feature sets the 	
; 	value itself, so that the control remains hilited. It behaves as a sort of palette 	
; 	type object where clicking selects it, it cannot be delected by clicking it again, 	
; 	clicking on another object should cause the focus to change (as in Get Info windows)
; 	and the application should then set the value to 0 to take away the checked border.	
; 																						

															; Image Well proc IDs 
kControlImageWellProc			EQU		176
kControlImageWellAutoTrackProc	EQU		177

															; Tagged data supported by image wells 
kControlImageWellContentTag		EQU		'cont'				; ButtonContentInfo
kControlImageWellTransformTag	EQU		'tran'				; IconTransformType
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• POPUP ARROW (CDEF 12)																
; ——————————————————————————————————————————————————————————————————————————————————————
; 	The popup arrow CDEF is used to draw the small arrow normally associated with a 	
; 	popup control. The arrow can point in four directions, and a small or large version 
; 	can be used. This control is provided to allow clients to draw the arrow in a 		
; 	normalized fashion which will take advantage of themes automatically.				
; 																						

															; Popup Arrow proc IDs 
kControlPopupArrowEastProc		EQU		192
kControlPopupArrowWestProc		EQU		193
kControlPopupArrowNorthProc		EQU		194
kControlPopupArrowSouthProc		EQU		195
kControlPopupArrowSmallEastProc	EQU		196
kControlPopupArrowSmallWestProc	EQU		197
kControlPopupArrowSmallNorthProc EQU	198
kControlPopupArrowSmallSouthProc EQU	199
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• PLACARD (CDEF 14)																	
; ——————————————————————————————————————————————————————————————————————————————————————

															; Placard proc IDs 
kControlPlacardProc				EQU		224
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• CLOCK (CDEF 15)																	
; ——————————————————————————————————————————————————————————————————————————————————————
;  	NOTE:	You can specify more options in the Value paramter when creating the clock.	
; 			See below.																	

															; Clock proc IDs 
kControlClockTimeProc			EQU		240
kControlClockTimeSecondsProc	EQU		241
kControlClockDateProc			EQU		242
kControlClockMonthYearProc		EQU		243
; ——————————————————————————————————————————————————————————————————————————————————————
;  	These flags can be passed into 'value' field on creation of the control.			
;  	Value is set to 0 after control is created.											
; 																						
; 	The kClockIsLive value tells the clock to automatically update on idle (clock will	
; 	have the current time). This flag is only valid when the kClockIsDisplayOnly flag	
; 	is set.																				
; ——————————————————————————————————————————————————————————————————————————————————————

kControlClockNoFlags			EQU		0
kControlClockIsDisplayOnly		EQU		1
kControlClockIsLive				EQU		2

															; Tagged data supported by clocks 
kControlClockLongDateTag		EQU		'date'				; LongDateRec
kControlClockFontStyleTag		EQU		'font'				; ControlFontStyleRec
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• USER PANE (CDEF 16)																
; ——————————————————————————————————————————————————————————————————————————————————————

															; User Pane proc IDs 
kControlUserPaneProc			EQU		256
;  Tagged data supported by user panes 
;  Currently, they are all proc ptrs for doing things like drawing and hit testing, etc. 

kControlUserItemDrawProcTag		EQU		'uidp'				; UserItemUPP
kControlUserPaneDrawProcTag		EQU		'draw'				; ControlUserPaneDrawingUPP
kControlUserPaneHitTestProcTag	EQU		'hitt'				; ControlUserPaneHitTestUPP
kControlUserPaneTrackingProcTag	EQU		'trak'				; ControlUserPaneTrackingUPP
kControlUserPaneIdleProcTag		EQU		'idle'				; ControlUserPaneIdleUPP
kControlUserPaneKeyDownProcTag	EQU		'keyd'				; ControlUserPaneKeyDownUPP
kControlUserPaneActivateProcTag	EQU		'acti'				; ControlUserPaneActivateUPP
kControlUserPaneFocusProcTag	EQU		'foci'				; ControlUserPaneFocusUPP
kControlUserPaneBackgroundProcTag EQU	'back'				; ControlUserPaneBackgroundUPP

;  ——————————————————————————————————————————————————————————————————————————————————————————
;  	• EDIT TEXT (CDEF 17)
;  ——————————————————————————————————————————————————————————————————————————————————————————



															; Edit Text proc IDs 
kControlEditTextProc			EQU		272
kControlEditTextDialogProc		EQU		273
kControlEditTextPasswordProc	EQU		274

															; Tagged data supported by edit text 
kControlEditTextStyleTag		EQU		'font'				; ControlFontStyleRec
kControlEditTextTextTag			EQU		'text'				; Buffer of chars - you supply the buffer
kControlEditTextTEHandleTag		EQU		'than'				; The TEHandle of the text edit record
kControlEditTextKeyFilterTag	EQU		'fltr'
kControlEditTextSelectionTag	EQU		'sele'				; EditTextSelectionRec
kControlEditTextPasswordTag		EQU		'pass'				; The clear text password text
ControlEditTextSelectionRec RECORD 0
;  Structure for getting the edit text selection 
selStart				 ds.w	1				; offset: $0 (0)
selEnd					 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct ControlEditTextSelectionRec * ControlEditTextSelectionPtr

; ——————————————————————————————————————————————————————————————————————————————————————
; 	• STATIC TEXT (CDEF 18)																
; ——————————————————————————————————————————————————————————————————————————————————————
;  Static Text proc IDs 

kControlStaticTextProc			EQU		288
;  Tagged data supported by static text 

kControlStaticTextStyleTag		EQU		'font'				; ControlFontStyleRec
kControlStaticTextTextTag		EQU		'text'				; Copy of text
kControlStaticTextTextHeightTag	EQU		'thei'				; SInt16
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• PICTURE CONTROL (CDEF 19)															
; ——————————————————————————————————————————————————————————————————————————————————————
; 	Value parameter should contain the ID of the picture you wish to display when		
; 	creating controls of this type. If you don't want the control tracked at all, use 	
; 	the 'no track' variant.																

															; Picture control proc IDs 
kControlPictureProc				EQU		304
kControlPictureNoTrackProc		EQU		305					; immediately returns kControlPicturePart
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• ICON CONTROL (CDEF 20)															
; ——————————————————————————————————————————————————————————————————————————————————————
; 	Value parameter should contain the ID of the ICON or cicn you wish to display when	
; 	creating controls of this type. If you don't want the control tracked at all, use 	
; 	the 'no track' variant.																
;  Icon control proc IDs 

kControlIconProc				EQU		320
kControlIconNoTrackProc			EQU		321					; immediately returns kControlIconPart
kControlIconSuiteProc			EQU		322
kControlIconSuiteNoTrackProc	EQU		323					; immediately returns kControlIconPart
;  Tagged data supported by icon controls 

kControlIconTransformTag		EQU		'trfm'				; IconTransformType
kControlIconAlignmentTag		EQU		'algn'				; IconAlignmentType
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• WINDOW HEADER (CDEF 21)															
; ——————————————————————————————————————————————————————————————————————————————————————

															; Window Header proc IDs 
kControlWindowHeaderProc		EQU		336					; normal header
kControlWindowListViewHeaderProc EQU	337					; variant for list views - no bottom line
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• LIST BOX (CDEF 22)																
; ——————————————————————————————————————————————————————————————————————————————————————
; 	Lists use an auxiliary resource to define their format. The resource type used is 	
; 	'ldes' and a definition for it can be found in Appearance.r. The resource ID for 	
; 	the ldes is passed in the 'value' parameter when creating the control.				

															; List Box proc IDs 
kControlListBoxProc				EQU		352
kControlListBoxAutoSizeProc		EQU		353

															; Tagged data supported by list box 
kControlListBoxListHandleTag	EQU		'lhan'				; ListHandle
kControlListBoxKeyFilterTag		EQU		'fltr'				; ControlKeyFilterUPP
kControlListBoxFontStyleTag		EQU		'font'				; ControlFontStyleRec
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• PUSH BUTTON (CDEF 23)																
; ——————————————————————————————————————————————————————————————————————————————————————
; 	The new standard checkbox and radio button controls support a "mixed" value that	
; 	indicates that the current setting contains a mixed set of on and off values. The 	
; 	control value used to display this indication is defined in Controls.h:				
; 																						
; 		kControlCheckBoxMixedValue = 2													
; 																						
; 	Two new variants of the standard pushbutton have been added to the standard control	
; 	suite that draw a color icon next to the control title. One variant draws the icon	
; 	on the left side, the other draws it on the right side (when the system justifica-	
; 	tion is right to left, these are reversed).											
; 																						
; 	When either of the icon pushbuttons are created, the contrlMax field of the control 
; 	record is used to determine the ID of the 'cicn' resource drawn in the pushbutton.	
; 																						
; 	In addition, a push button can now be told to draw with a default outline using the	
; 	SetControlData routine with the kPushButtonDefaultTag below.						
; 																						

															; Theme Push Button/Check Box/Radio Button proc IDs 
kControlPushButtonProc			EQU		368
kControlCheckBoxProc			EQU		369
kControlRadioButtonProc			EQU		370
kControlPushButLeftIconProc		EQU		374					; Standard pushbutton with left-side icon
kControlPushButRightIconProc	EQU		375					; Standard pushbutton with right-side icon

															; Tagged data supported by standard buttons 
kControlPushButtonDefaultTag	EQU		'dflt'				; default ring flag
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• SCROLL BAR (CDEF 24)																
; ——————————————————————————————————————————————————————————————————————————————————————
; 	This is the new Appearance scroll bar.												
; 																						

															; Theme Scroll Bar proc IDs 
kControlScrollBarProc			EQU		384					; normal scroll bar
kControlScrollBarLiveProc		EQU		386					; live scrolling variant
; ——————————————————————————————————————————————————————————————————————————————————————
; 	• POPUP BUTTON (CDEF 25)															
; ——————————————————————————————————————————————————————————————————————————————————————
; 	This is the new Appearance Popup Button. It takes the same variants and does the 	
; 	same overloading as the previous popup menu control. There are some differences:	
; 																						
; 	Passing in a menu ID of -12345 causes the popup not to try and get the menu from a	
; 	resource. Instead, you can build the menu and later stuff the menuhandle field in 	
; 	the popup data information.															
; 																						
; 	You can pass -1 in the Max parameter to have the control calculate the width of the	
; 	title on its own instead of guessing and then tweaking to get it right. It adds the	
; 	appropriate amount of space between the title and the popup.						
; 																						

															; Theme Popup Button proc IDs 
kControlPopupButtonProc			EQU		400
kControlPopupFixedWidthVariant	EQU		$01
kControlPopupVariableWidthVariant EQU	$02
kControlPopupUseAddResMenuVariant EQU	$04
kControlPopupUseWFontVariant	EQU		$08
; ——————————————————————————————————————————————————————————————————————————————————
;  Menu Manager constants, etc.														
; ——————————————————————————————————————————————————————————————————————————————————

kMenuStdMenuProc				EQU		63
kMenuStdMenuBarProc				EQU		63

kMenuNoModifiers				EQU		0					; Mask for no modifiers
kMenuShiftModifier				EQU		$01					; Mask for shift key modifier
kMenuOptionModifier				EQU		$02					; Mask for option key modifier
kMenuControlModifier			EQU		$04					; Mask for control key modifier
kMenuNoCommandModifier			EQU		$08					; Mask for no command key modifier

kMenuNoIcon						EQU		0					; No icon
kMenuIconType					EQU		1					; Type for ICON
kMenuShrinkIconType				EQU		2					; Type for ICON plotted 16 x 16
kMenuSmallIconType				EQU		3					; Type for SICN
kMenuColorIconType				EQU		4					; Type for cicn
kMenuIconSuiteType				EQU		5					; Type for Icon Suite
kMenuIconRefType				EQU		6					; Type for Icon Ref
; ——————————————————————————————————————————————————————————————————————————————————
; 	Appearance Manager APIs															
; ——————————————————————————————————————————————————————————————————————————————————
;  Registering Appearance-Savvy Applications 
;
; pascal OSStatus RegisterAppearanceClient(void)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RegisterAppearanceClient
			move.w              #$0015,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RegisterAppearanceClient
	ENDIF

;
; pascal OSStatus UnregisterAppearanceClient(void)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UnregisterAppearanceClient
			move.w              #$0016,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UnregisterAppearanceClient
	ENDIF

; *****************************************************************************
;	NOTES ON THEME BRUSHES
;	Theme brushes can be either colors or patterns, depending on the theme.
;	Because of this, you should be prepared to handle the case where a brush
;	is a pattern and save and restore the pnPixPat and bkPixPat fields of
;	your GrafPorts when saving the fore and back colors. Also, since patterns
;	in bkPixPat override the background color of the window, you should use
;	BackPat to set your background pattern to a normal white pattern. This
;	will ensure that you can use RGBBackColor to set your back color to white,
;	call EraseRect and get the expected results.
;****************************************************************************


;
; pascal OSStatus SetThemePen(ThemeBrush brush, SInt16 depth, Boolean colorDevice)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetThemePen
			move.w              #$0001,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetThemePen
	ENDIF

;
; pascal OSStatus SetThemeBackground(ThemeBrush brush, SInt16 depth, Boolean colorDevice)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetThemeBackground
			move.w              #$0002,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetThemeBackground
	ENDIF

;
; pascal OSStatus SetThemeTextColor(ThemeTextColor color, SInt16 depth, Boolean colorDevice)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetThemeTextColor
			move.w              #$0003,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetThemeTextColor
	ENDIF

;
; pascal OSStatus SetThemeWindowBackground(WindowPtr window, ThemeBrush brush, Boolean update)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetThemeWindowBackground
			move.w              #$0004,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetThemeWindowBackground
	ENDIF


;  Window Placards, Headers and Frames 
;
; pascal OSStatus DrawThemeWindowHeader(const Rect *rect, ThemeDrawState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DrawThemeWindowHeader
			move.w              #$0005,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DrawThemeWindowHeader
	ENDIF

;
; pascal OSStatus DrawThemeWindowListViewHeader(const Rect *rect, ThemeDrawState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DrawThemeWindowListViewHeader
			move.w              #$0006,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DrawThemeWindowListViewHeader
	ENDIF

;
; pascal OSStatus DrawThemePlacard(const Rect *rect, ThemeDrawState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DrawThemePlacard
			move.w              #$0007,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DrawThemePlacard
	ENDIF

;
; pascal OSStatus DrawThemeEditTextFrame(const Rect *rect, ThemeDrawState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DrawThemeEditTextFrame
			move.w              #$0009,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DrawThemeEditTextFrame
	ENDIF

;
; pascal OSStatus DrawThemeListBoxFrame(const Rect *rect, ThemeDrawState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DrawThemeListBoxFrame
			move.w              #$000A,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DrawThemeListBoxFrame
	ENDIF

;  Keyboard Focus Drawing 
;
; pascal OSStatus DrawThemeFocusRect(const Rect *rect, Boolean hasFocus)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DrawThemeFocusRect
			move.w              #$000B,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DrawThemeFocusRect
	ENDIF

;  Dialog Group Boxes and Separators 
;
; pascal OSStatus DrawThemePrimaryGroup(const Rect *rect, ThemeDrawState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DrawThemePrimaryGroup
			move.w              #$000C,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DrawThemePrimaryGroup
	ENDIF

;
; pascal OSStatus DrawThemeSecondaryGroup(const Rect *rect, ThemeDrawState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DrawThemeSecondaryGroup
			move.w              #$000D,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DrawThemeSecondaryGroup
	ENDIF

;
; pascal OSStatus DrawThemeSeparator(const Rect *rect, ThemeDrawState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DrawThemeSeparator
			move.w              #$000E,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DrawThemeSeparator
	ENDIF


; ——————————————————————————————————————————————————————————————————————————————————
; 	Window Manager APIs																
; ——————————————————————————————————————————————————————————————————————————————————
;
; pascal OSStatus GetWindowFeatures(WindowPtr window, UInt32 *features)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetWindowFeatures
			move.w              #$0013,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetWindowFeatures
	ENDIF

;
; pascal Boolean IsWindowCollapsable(WindowPtr window)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IsWindowCollapsable
			move.w              #$000F,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsWindowCollapsable
	ENDIF

;
; pascal Boolean IsWindowCollapsed(WindowPtr window)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IsWindowCollapsed
			move.w              #$0010,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsWindowCollapsed
	ENDIF

;
; pascal OSStatus CollapseWindow(WindowPtr window, Boolean collapseIt)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CollapseWindow
			move.w              #$0011,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CollapseWindow
	ENDIF

;
; pascal OSStatus CollapseAllWindows(Boolean collapseEm)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CollapseAllWindows
			move.w              #$0012,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CollapseAllWindows
	ENDIF

;
; pascal OSStatus GetWindowRegion(WindowPtr window, WindowRegionCode regionCode, RgnHandle winRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetWindowRegion
			move.w              #$0014,D0
			dc.w            	$AA74
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetWindowRegion
	ENDIF

; ——————————————————————————————————————————————————————————————————————————————————
; 	Dialog Manager APIs																
; ——————————————————————————————————————————————————————————————————————————————————
;
; pascal DialogPtr NewFeaturesDialog(void *wStorage, const Rect *boundsRect, ConstStr255Param title, Boolean visible, SInt16 procID, WindowPtr behind, Boolean goAwayFlag, SInt32 refCon, Handle itmLstHndl, UInt32 flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewFeaturesDialog
			move.w              #$110C,D0
			dc.w            	$AA68
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewFeaturesDialog
	ENDIF

;
; pascal OSErr AutoSizeDialog(DialogPtr dialog)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AutoSizeDialog
			move.w              #$020D,D0
			dc.w            	$AA68
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AutoSizeDialog
	ENDIF

;
; pascal OSErr StandardAlert(AlertType alertType, StringPtr error, StringPtr explanation, AlertStdAlertParamPtr alertParam, SInt16 *itemHit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_StandardAlert
			move.w              #$090E,D0
			dc.w            	$AA68
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StandardAlert
	ENDIF

;
; pascal OSErr GetDialogItemAsControl(DialogPtr dialog, SInt16 itemNo, ControlHandle *control)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetDialogItemAsControl
			move.w              #$050F,D0
			dc.w            	$AA68
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetDialogItemAsControl
	ENDIF

;
; pascal OSErr MoveDialogItem(DialogPtr dialog, SInt16 itemNo, SInt16 horiz, SInt16 vert)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MoveDialogItem
			move.w              #$0510,D0
			dc.w            	$AA68
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MoveDialogItem
	ENDIF

;
; pascal OSErr SizeDialogItem(DialogPtr dialog, SInt16 itemNo, SInt16 height, SInt16 width)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SizeDialogItem
			move.w              #$0511,D0
			dc.w            	$AA68
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SizeDialogItem
	ENDIF

; ——————————————————————————————————————————————————————————————————————————————————
; 	Control Manager APIs															
; ——————————————————————————————————————————————————————————————————————————————————

;   These routines are available only thru the shared library/glue
;   Bevel button routines



;
; pascal OSErr GetBevelButtonMenuValue(ControlHandle button, SInt16 *value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetBevelButtonMenuValue
	ENDIF

;
; pascal OSErr SetBevelButtonMenuValue(ControlHandle button, SInt16 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetBevelButtonMenuValue
	ENDIF

;
; pascal OSErr GetBevelButtonMenuHandle(ControlHandle button, MenuHandle *handle)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetBevelButtonMenuHandle
	ENDIF

;
; pascal OSErr GetBevelButtonContentInfo(ControlHandle button, ControlButtonContentInfoPtr content)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetBevelButtonContentInfo
	ENDIF

;
; pascal OSErr SetBevelButtonContentInfo(ControlHandle button, ControlButtonContentInfoPtr content)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetBevelButtonContentInfo
	ENDIF

;
; pascal OSErr SetBevelButtonTransform(ControlHandle button, IconTransformType transform)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetBevelButtonTransform
	ENDIF

;
; pascal OSErr SetBevelButtonGraphicAlignment(ControlHandle button, ControlButtonGraphicAlignment align, SInt16 hOffset, SInt16 vOffset)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetBevelButtonGraphicAlignment
	ENDIF

;
; pascal OSErr SetBevelButtonTextAlignment(ControlHandle button, ControlButtonTextAlignment align, SInt16 hOffset)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetBevelButtonTextAlignment
	ENDIF

;
; pascal OSErr SetBevelButtonTextPlacement(ControlHandle button, ControlButtonTextPlacement where)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetBevelButtonTextPlacement
	ENDIF

;  Image well routines

;
; pascal OSErr GetImageWellContentInfo(ControlHandle button, ControlButtonContentInfoPtr content)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetImageWellContentInfo
	ENDIF

;
; pascal OSErr SetImageWellContentInfo(ControlHandle button, ControlButtonContentInfoPtr content)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetImageWellContentInfo
	ENDIF

;
; pascal OSErr SetImageWellTransform(ControlHandle button, IconTransformType transform)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetImageWellTransform
	ENDIF

;  Tab routines

;
; pascal OSErr GetTabContentRect(ControlHandle tabControl, Rect *contentRect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTabContentRect
	ENDIF

;
; pascal OSErr SetTabEnabled(ControlHandle tabControl, SInt16 tabToHilite, Boolean enabled)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTabEnabled
	ENDIF

;  Disclosure triangles

;
; pascal OSErr SetDisclosureTriangleLastValue(ControlHandle tabControl, SInt16 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetDisclosureTriangleLastValue
	ENDIF

;  Trap-based routines

;
; pascal SInt32 SendControlMessage(ControlHandle theControl, SInt16 message, SInt32 param)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SendControlMessage
			move.w              #$FFFE,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SendControlMessage
	ENDIF

;
; pascal OSErr DumpControlHierarchy(WindowPtr window, const FSSpec *outFile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DumpControlHierarchy
			move.w              #$FFFF,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DumpControlHierarchy
	ENDIF

;
; pascal OSErr CreateRootControl(WindowPtr window, ControlHandle *control)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CreateRootControl
			move.w              #$0001,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CreateRootControl
	ENDIF

;
; pascal OSErr GetRootControl(WindowPtr window, ControlHandle *control)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetRootControl
			move.w              #$0002,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetRootControl
	ENDIF

;
; pascal OSErr EmbedControl(ControlHandle control, ControlHandle container)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_EmbedControl
			move.w              #$0003,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EmbedControl
	ENDIF

;
; pascal OSErr AutoEmbedControl(ControlHandle control, WindowPtr window)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AutoEmbedControl
			move.w              #$0004,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AutoEmbedControl
	ENDIF

;
; pascal Boolean IsControlActive(ControlHandle control)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IsControlActive
			move.w              #$0005,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsControlActive
	ENDIF

;
; pascal Boolean IsControlVisible(ControlHandle control)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IsControlVisible
			move.w              #$0006,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsControlVisible
	ENDIF

;
; pascal OSErr ActivateControl(ControlHandle control)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ActivateControl
			move.w              #$0007,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ActivateControl
	ENDIF

;
; pascal OSErr DeactivateControl(ControlHandle control)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DeactivateControl
			move.w              #$0008,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeactivateControl
	ENDIF

;
; pascal ControlHandle FindControlUnderMouse(Point where, WindowPtr window, SInt16 *part)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FindControlUnderMouse
			move.w              #$0009,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FindControlUnderMouse
	ENDIF

;
; pascal SInt16 HandleControlClick(ControlHandle control, Point where, SInt16 modifiers, ControlActionUPP action)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_HandleControlClick
			move.w              #$000A,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HandleControlClick
	ENDIF

;
; pascal SInt16 HandleControlKey(ControlHandle control, SInt16 keyCode, SInt16 charCode, SInt16 modifiers)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_HandleControlKey
			move.w              #$000B,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HandleControlKey
	ENDIF

;
; pascal void IdleControls(WindowPtr window)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IdleControls
			move.w              #$000C,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IdleControls
	ENDIF

;
; pascal OSErr GetKeyboardFocus(WindowPtr window, ControlHandle *control)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetKeyboardFocus
			move.w              #$000D,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetKeyboardFocus
	ENDIF

;
; pascal OSErr SetKeyboardFocus(WindowPtr window, ControlHandle control, ControlFocusPart part)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetKeyboardFocus
			move.w              #$000E,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetKeyboardFocus
	ENDIF

;
; pascal OSErr AdvanceKeyboardFocus(WindowPtr window)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AdvanceKeyboardFocus
			move.w              #$000F,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AdvanceKeyboardFocus
	ENDIF

;
; pascal OSErr ReverseKeyboardFocus(WindowPtr window)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ReverseKeyboardFocus
			move.w              #$0010,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ReverseKeyboardFocus
	ENDIF

;
; pascal OSErr GetControlFeatures(ControlHandle control, UInt32 *features)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetControlFeatures
			move.w              #$0011,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetControlFeatures
	ENDIF

;
; pascal OSErr SetControlData(ControlHandle control, ControlPartCode part, ResType tagName, Size size, Ptr data)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetControlData
			move.w              #$0012,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetControlData
	ENDIF

;
; pascal OSErr GetControlData(ControlHandle control, ControlPartCode part, ResType tagName, Size bufferSize, Ptr buffer, Size *actualSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetControlData
			move.w              #$0013,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetControlData
	ENDIF

;
; pascal OSErr GetControlDataSize(ControlHandle control, ControlPartCode part, ResType tagName, Size *maxSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetControlDataSize
			move.w              #$0014,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetControlDataSize
	ENDIF

;
; pascal OSErr GetSuperControl(ControlHandle control, ControlHandle *parent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetSuperControl
			move.w              #$0015,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSuperControl
	ENDIF

;
; pascal OSErr CountSubControls(ControlHandle control, SInt16 *numChildren)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CountSubControls
			move.w              #$0016,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CountSubControls
	ENDIF

;
; pascal OSErr GetIndexedSubControl(ControlHandle control, SInt16 index, ControlHandle *subControl)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetIndexedSubControl
			move.w              #$0017,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetIndexedSubControl
	ENDIF

;
; pascal void DrawControlInCurrentPort(ControlHandle theControl)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DrawControlInCurrentPort
			move.w              #$0018,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DrawControlInCurrentPort
	ENDIF

;
; pascal OSErr ClearKeyboardFocus(WindowPtr window)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClearKeyboardFocus
			move.w              #$0019,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClearKeyboardFocus
	ENDIF

;
; pascal OSErr SetControlSupervisor(ControlHandle control, ControlHandle boss)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetControlSupervisor
			move.w              #$001A,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetControlSupervisor
	ENDIF

;
; pascal OSErr GetBestControlRect(ControlHandle control, Rect *rect, SInt16 *baseLineOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetBestControlRect
			move.w              #$001B,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetBestControlRect
	ENDIF

;
; pascal OSErr SetControlFontStyle(ControlHandle control, ControlFontStyleRec *style)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetControlFontStyle
			move.w              #$001C,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetControlFontStyle
	ENDIF

;
; pascal OSErr SetUpControlBackground(ControlHandle control, SInt16 depth, Boolean colorDevice)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetUpControlBackground
			move.w              #$001D,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetUpControlBackground
	ENDIF

;
; pascal OSErr SetControlVisibility(ControlHandle control, Boolean isVisible, Boolean draw)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetControlVisibility
			move.w              #$001E,D0
			dc.w            	$AA73
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetControlVisibility
	ENDIF

; ——————————————————————————————————————————————————————————————————————————————————
; 	Menu Manager APIs																
; ——————————————————————————————————————————————————————————————————————————————————
;
; pascal UInt32 MenuEvent(const EventRecord *event)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MenuEvent
			move.w              #$020C,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MenuEvent
	ENDIF

;
; pascal OSErr SetMenuItemCommandID(MenuHandle menu, SInt16 item, UInt32 commandID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMenuItemCommandID
			move.w              #$0502,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMenuItemCommandID
	ENDIF

;
; pascal OSErr GetMenuItemCommandID(MenuHandle menu, SInt16 item, UInt32 *commandID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMenuItemCommandID
			move.w              #$0503,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMenuItemCommandID
	ENDIF

;
; pascal OSErr SetMenuItemModifiers(MenuHandle menu, SInt16 item, UInt8 modifiers)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMenuItemModifiers
			move.w              #$0404,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMenuItemModifiers
	ENDIF

;
; pascal OSErr GetMenuItemModifiers(MenuHandle menu, SInt16 item, UInt8 *modifiers)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMenuItemModifiers
			move.w              #$0505,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMenuItemModifiers
	ENDIF

;
; pascal OSErr SetMenuItemIconHandle(MenuHandle menu, SInt16 item, UInt8 iconType, Handle icon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMenuItemIconHandle
			move.w              #$0606,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMenuItemIconHandle
	ENDIF

;
; pascal OSErr GetMenuItemIconHandle(MenuHandle menu, SInt16 item, UInt8 *iconType, Handle *icon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMenuItemIconHandle
			move.w              #$0707,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMenuItemIconHandle
	ENDIF

;
; pascal OSErr SetMenuItemTextEncoding(MenuHandle menu, SInt16 item, TextEncoding scriptID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMenuItemTextEncoding
			move.w              #$0408,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMenuItemTextEncoding
	ENDIF

;
; pascal OSErr GetMenuItemTextEncoding(MenuHandle menu, SInt16 item, TextEncoding *scriptID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMenuItemTextEncoding
			move.w              #$0509,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMenuItemTextEncoding
	ENDIF

;
; pascal OSErr SetMenuItemHierarchicalID(MenuHandle menu, SInt16 item, SInt16 hierID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMenuItemHierarchicalID
			move.w              #$040D,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMenuItemHierarchicalID
	ENDIF

;
; pascal OSErr GetMenuItemHierarchicalID(MenuHandle menu, SInt16 item, SInt16 *hierID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMenuItemHierarchicalID
			move.w              #$050E,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMenuItemHierarchicalID
	ENDIF

;
; pascal OSErr SetMenuItemFontID(MenuHandle menu, SInt16 item, SInt16 fontID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMenuItemFontID
			move.w              #$040F,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMenuItemFontID
	ENDIF

;
; pascal OSErr GetMenuItemFontID(MenuHandle menu, SInt16 item, SInt16 *fontID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMenuItemFontID
			move.w              #$0510,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMenuItemFontID
	ENDIF

;
; pascal OSErr SetMenuItemRefCon(MenuHandle menu, SInt16 item, UInt32 refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMenuItemRefCon
			move.w              #$050A,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMenuItemRefCon
	ENDIF

;
; pascal OSErr GetMenuItemRefCon(MenuHandle menu, SInt16 item, UInt32 *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMenuItemRefCon
			move.w              #$050B,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMenuItemRefCon
	ENDIF

;
; pascal OSErr SetMenuItemRefCon2(MenuHandle menu, SInt16 item, UInt32 refCon2)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMenuItemRefCon2
			move.w              #$0511,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMenuItemRefCon2
	ENDIF

;
; pascal OSErr GetMenuItemRefCon2(MenuHandle menu, SInt16 item, UInt32 *refCon2)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMenuItemRefCon2
			move.w              #$0512,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMenuItemRefCon2
	ENDIF

;
; pascal OSErr SetMenuItemKeyGlyph(MenuHandle menu, SInt16 item, SInt16 glyph)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMenuItemKeyGlyph
			move.w              #$0513,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMenuItemKeyGlyph
	ENDIF

;
; pascal OSErr GetMenuItemKeyGlyph(MenuHandle menu, SInt16 item, SInt16 *glyph)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMenuItemKeyGlyph
			move.w              #$0514,D0
			dc.w            	$A825
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMenuItemKeyGlyph
	ENDIF

	ENDIF ; __APPEARANCE__ 


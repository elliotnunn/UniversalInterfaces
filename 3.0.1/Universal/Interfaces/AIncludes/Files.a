;
;	File:		Files.a
;
;	Contains:	File Manager (HFS and MFS) Interfaces.
;
;	Version:	Technology:	System 7.5
;				Release:	Universal Interfaces 3.0.1
;
;	Copyright:	© 1985-1997 by Apple Computer, Inc., all rights reserved
;
;	Bugs?:		Please include the the file and version information (from above) with
;				the problem description.  Developers belonging to one of the Apple
;				developer programs can submit bug reports to:
;
;					devsupport@apple.com
;
;
	IF &TYPE('__FILES__') = 'UNDEFINED' THEN
__FILES__ SET 1

	IF &TYPE('__TYPES__') = 'UNDEFINED' THEN
	include 'Types.a'
	ENDIF
	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF
	IF &TYPE('__OSUTILS__') = 'UNDEFINED' THEN
	include 'OSUtils.a'
	ENDIF

;  Finder constants where moved to Finder.≈ 
	IF &TYPE('__FINDER__') = 'UNDEFINED' THEN
	include 'Finder.a'
	ENDIF


fsAtMark						EQU		0
fsCurPerm						EQU		0
fsRdPerm						EQU		1
fInvisible						EQU		16384
fsWrPerm						EQU		2
fsRdWrPerm						EQU		3
fsRdWrShPerm					EQU		4
fsFromStart						EQU		1
fsFromLEOF						EQU		2
fsFromMark						EQU		3
rdVerify						EQU		64
ioMapBuffer						EQU		4
ioModeReserved					EQU		8
ioDirFlg						EQU		4					; see IM IV-125 
ioDirMask						EQU		$10
fsRtParID						EQU		1
fsRtDirID						EQU		2


															; CatSearch Search bitmask Constants 
fsSBPartialName					EQU		1
fsSBFullName					EQU		2
fsSBFlAttrib					EQU		4
fsSBFlFndrInfo					EQU		8
fsSBFlLgLen						EQU		32
fsSBFlPyLen						EQU		64
fsSBFlRLgLen					EQU		128
fsSBFlRPyLen					EQU		256
fsSBFlCrDat						EQU		512
fsSBFlMdDat						EQU		1024
fsSBFlBkDat						EQU		2048
fsSBFlXFndrInfo					EQU		4096
fsSBFlParID						EQU		8192
fsSBNegate						EQU		16384
fsSBDrUsrWds					EQU		8
fsSBDrNmFls						EQU		16
fsSBDrCrDat						EQU		512
fsSBDrMdDat						EQU		1024
fsSBDrBkDat						EQU		2048
fsSBDrFndrInfo					EQU		4096
fsSBDrParID						EQU		8192

															; CatSearch Search bit value Constants 
fsSBPartialNameBit				EQU		0					;ioFileName points to a substring
fsSBFullNameBit					EQU		1					;ioFileName points to a match string
fsSBFlAttribBit					EQU		2					;search includes file attributes
fsSBFlFndrInfoBit				EQU		3					;search includes finder info
fsSBFlLgLenBit					EQU		5					;search includes data logical length
fsSBFlPyLenBit					EQU		6					;search includes data physical length
fsSBFlRLgLenBit					EQU		7					;search includes resource logical length
fsSBFlRPyLenBit					EQU		8					;search includes resource physical length
fsSBFlCrDatBit					EQU		9					;search includes create date
fsSBFlMdDatBit					EQU		10					;search includes modification date
fsSBFlBkDatBit					EQU		11					;search includes backup date
fsSBFlXFndrInfoBit				EQU		12					;search includes extended finder info
fsSBFlParIDBit					EQU		13					;search includes file's parent ID
fsSBNegateBit					EQU		14					;return all non-matches
fsSBDrUsrWdsBit					EQU		3					;search includes directory finder info
fsSBDrNmFlsBit					EQU		4					;search includes directory valence
fsSBDrCrDatBit					EQU		9					;directory-named version of fsSBFlCrDatBit
fsSBDrMdDatBit					EQU		10					;directory-named version of fsSBFlMdDatBit
fsSBDrBkDatBit					EQU		11					;directory-named version of fsSBFlBkDatBit
fsSBDrFndrInfoBit				EQU		12					;directory-named version of fsSBFlXFndrInfoBit
fsSBDrParIDBit					EQU		13					;directory-named version of fsSBFlParIDBit

															; vMAttrib (GetVolParms) bit position constants 
bLimitFCBs						EQU		31
bLocalWList						EQU		30
bNoMiniFndr						EQU		29
bNoVNEdit						EQU		28
bNoLclSync						EQU		27
bTrshOffLine					EQU		26
bNoSwitchTo						EQU		25
bNoDeskItems					EQU		20
bNoBootBlks						EQU		19
bAccessCntl						EQU		18
bNoSysDir						EQU		17
bHasExtFSVol					EQU		16
bHasOpenDeny					EQU		15
bHasCopyFile					EQU		14
bHasMoveRename					EQU		13
bHasDesktopMgr					EQU		12
bHasShortName					EQU		11
bHasFolderLock					EQU		10
bHasPersonalAccessPrivileges	EQU		9
bHasUserGroupList				EQU		8
bHasCatSearch					EQU		7
bHasFileIDs						EQU		6
bHasBTreeMgr					EQU		5
bHasBlankAccessPrivileges		EQU		4
bSupportsAsyncRequests			EQU		3					; asynchronous requests to this volume are handled correctly at any time


															; Desktop Database icon Constants 
kLargeIcon						EQU		1
kLarge4BitIcon					EQU		2
kLarge8BitIcon					EQU		3
kSmallIcon						EQU		4
kSmall4BitIcon					EQU		5
kSmall8BitIcon					EQU		6

kLargeIconSize					EQU		256
kLarge4BitIconSize				EQU		512
kLarge8BitIconSize				EQU		1024
kSmallIconSize					EQU		64
kSmall4BitIconSize				EQU		128
kSmall8BitIconSize				EQU		256

															; Foreign Privilege Model Identifiers 
fsUnixPriv						EQU		1

															; Authentication Constants 
kNoUserAuthentication			EQU		1
kPassword						EQU		2
kEncryptPassword				EQU		3
kTwoWayEncryptPassword			EQU		6

;  mapping codes (ioObjType) for MapName & MapID 

kOwnerID2Name					EQU		1
kGroupID2Name					EQU		2
kOwnerName2ID					EQU		3
kGroupName2ID					EQU		4					; types of oj object to be returned (ioObjType) for _GetUGEntry 
kReturnNextUser					EQU		1
kReturnNextGroup				EQU		2
kReturnNextUG					EQU		3


;  Folder and File values of access privileges 

kfullPrivileges					EQU		$00070007			;			; all privileges for everybody and owner
kownerPrivileges				EQU		$00000007			;			; all privileges for owner only
;  values of user IDs and group IDs 

knoUser							EQU		0
kadministratorUser				EQU		1

knoGroup						EQU		0

GetVolParmsInfoBuffer	RECORD 0
vMVersion				 ds.w	1				; offset: $0 (0)		; version number
vMAttrib				 ds.l	1				; offset: $2 (2)		; bit vector of attributes (see vMAttrib constants)
vMLocalHand				 ds.l	1				; offset: $6 (6)		; handle to private data
vMServerAdr				 ds.l	1				; offset: $A (10)		; AppleTalk server address or zero
vMVolumeGrade			 ds.l	1				; offset: $E (14)		; approx. speed rating or zero if unrated
vMForeignPrivID			 ds.w	1				; offset: $12 (18)		; foreign privilege model supported or zero if none
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef ParamBlockRec *				ParmBlkPtr

IOParam					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioRefNum				 ds.w	1				; offset: $18 (24)		; refNum for I/O operation
ioVersNum				 ds.b	1				; offset: $1A (26)		; version number
ioPermssn				 ds.b	1				; offset: $1B (27)		; Open: permissions (byte)
ioMisc					 ds.l	1				; offset: $1C (28)		; Rename: new name (GetEOF,SetEOF: logical end of file) (Open: optional ptr to buffer) (SetFileType: new type)
ioBuffer				 ds.l	1				; offset: $20 (32)		; data buffer Ptr
ioReqCount				 ds.l	1				; offset: $24 (36)		; requested byte count; also = ioNewDirID
ioActCount				 ds.l	1				; offset: $28 (40)		; actual byte count completed
ioPosMode				 ds.w	1				; offset: $2C (44)		; initial file positioning
ioPosOffset				 ds.l	1				; offset: $2E (46)		; file position offset
sizeof					 EQU *					; size:   $32 (50)
						ENDR
; typedef struct IOParam *				IOParamPtr

FileParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioFRefNum				 ds.w	1				; offset: $18 (24)		; reference number
ioFVersNum				 ds.b	1				; offset: $1A (26)		; version number
filler1					 ds.b	1				; offset: $1B (27)
ioFDirIndex				 ds.w	1				; offset: $1C (28)		; GetFInfo directory index
ioFlAttrib				 ds.b	1				; offset: $1E (30)		; GetFInfo: in-use bit=7, lock bit=0
ioFlVersNum				 ds.b	1				; offset: $1F (31)		; file version number
ioFlFndrInfo			 ds		FInfo			; offset: $20 (32)		; user info
ioFlNum					 ds.l	1				; offset: $30 (48)		; GetFInfo: file number; TF- ioDirID
ioFlStBlk				 ds.w	1				; offset: $34 (52)		; start file block (0 if none)
ioFlLgLen				 ds.l	1				; offset: $36 (54)		; logical length (EOF)
ioFlPyLen				 ds.l	1				; offset: $3A (58)		; physical length
ioFlRStBlk				 ds.w	1				; offset: $3E (62)		; start block rsrc fork
ioFlRLgLen				 ds.l	1				; offset: $40 (64)		; file logical length rsrc fork
ioFlRPyLen				 ds.l	1				; offset: $44 (68)		; file physical length rsrc fork
ioFlCrDat				 ds.l	1				; offset: $48 (72)		; file creation date& time (32 bits in secs)
ioFlMdDat				 ds.l	1				; offset: $4C (76)		; last modified date and time
sizeof					 EQU *					; size:   $50 (80)
						ENDR
; typedef struct FileParam *			FileParamPtr

VolumeParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
filler2					 ds.l	1				; offset: $18 (24)
ioVolIndex				 ds.w	1				; offset: $1C (28)		; volume index number
ioVCrDate				 ds.l	1				; offset: $1E (30)		; creation date and time
ioVLsBkUp				 ds.l	1				; offset: $22 (34)		; last backup date and time
ioVAtrb					 ds.w	1				; offset: $26 (38)		; volume attrib
ioVNmFls				 ds.w	1				; offset: $28 (40)		; number of files in directory
ioVDirSt				 ds.w	1				; offset: $2A (42)		; start block of file directory
ioVBlLn					 ds.w	1				; offset: $2C (44)		; GetVolInfo: length of dir in blocks
ioVNmAlBlks				 ds.w	1				; offset: $2E (46)		; for compatibilty ioVNmAlBlks * ioVAlBlkSiz <= 2 GB
ioVAlBlkSiz				 ds.l	1				; offset: $30 (48)		; for compatibilty ioVAlBlkSiz is <= $0000FE00 (65,024)
ioVClpSiz				 ds.l	1				; offset: $34 (52)		; GetVolInfo: bytes to allocate at a time
ioAlBlSt				 ds.w	1				; offset: $38 (56)		; starting disk(512-byte) block in block map
ioVNxtFNum				 ds.l	1				; offset: $3A (58)		; GetVolInfo: next free file number
ioVFrBlk				 ds.w	1				; offset: $3E (62)		; GetVolInfo: # free alloc blks for this vol
sizeof					 EQU *					; size:   $40 (64)
						ENDR
; typedef struct VolumeParam *			VolumeParamPtr

CntrlParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioCRefNum				 ds.w	1				; offset: $18 (24)		; refNum for I/O operation
csCode					 ds.w	1				; offset: $1A (26)		; word for control status code
csParam					 ds.w	11				; offset: $1C (28)		; operation-defined parameters
sizeof					 EQU *					; size:   $32 (50)
						ENDR
; typedef struct CntrlParam *			CntrlParamPtr

SlotDevParam			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioSRefNum				 ds.w	1				; offset: $18 (24)
ioSVersNum				 ds.b	1				; offset: $1A (26)
ioSPermssn				 ds.b	1				; offset: $1B (27)
ioSMix					 ds.l	1				; offset: $1C (28)
ioSFlags				 ds.w	1				; offset: $20 (32)
ioSlot					 ds.b	1				; offset: $22 (34)
ioID					 ds.b	1				; offset: $23 (35)
sizeof					 EQU *					; size:   $24 (36)
						ENDR
; typedef struct SlotDevParam *			SlotDevParamPtr

MultiDevParam			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioMRefNum				 ds.w	1				; offset: $18 (24)
ioMVersNum				 ds.b	1				; offset: $1A (26)
ioMPermssn				 ds.b	1				; offset: $1B (27)
ioMMix					 ds.l	1				; offset: $1C (28)
ioMFlags				 ds.w	1				; offset: $20 (32)
ioSEBlkPtr				 ds.l	1				; offset: $22 (34)
sizeof					 EQU *					; size:   $26 (38)
						ENDR
; typedef struct MultiDevParam *		MultiDevParamPtr

ParamBlockRec			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioRefNum				 ds.w	1				; offset: $18 (24)		; refNum for I/O operation
ioVersNum				 ds.b	1				; offset: $1A (26)		; version number
ioPermssn				 ds.b	1				; offset: $1B (27)		; Open: permissions (byte)
ioMisc					 ds.l	1				; offset: $1C (28)		; Rename: new name (GetEOF,SetEOF: logical end of file) (Open: optional ptr to buffer) (SetFileType: new type)
ioBuffer				 ds.l	1				; offset: $20 (32)		; data buffer Ptr
ioReqCount				 ds.l	1				; offset: $24 (36)		; requested byte count; also = ioNewDirID
ioActCount				 ds.l	1				; offset: $28 (40)		; actual byte count completed
ioPosMode				 ds.w	1				; offset: $2C (44)		; initial file positioning
ioPosOffset				 ds.l	1				; offset: $2E (46)		; file position offset
						 ORG 24
ioFRefNum				 ds.w	1				; offset: $18 (24)		; reference number
ioFVersNum				 ds.b	1				; offset: $1A (26)		; version number
filler1					 ds.b	1				; offset: $1B (27)
ioFDirIndex				 ds.w	1				; offset: $1C (28)		; GetFInfo directory index
ioFlAttrib				 ds.b	1				; offset: $1E (30)		; GetFInfo: in-use bit=7, lock bit=0
ioFlVersNum				 ds.b	1				; offset: $1F (31)		; file version number
ioFlFndrInfo			 ds		FInfo			; offset: $20 (32)		; user info
ioFlNum					 ds.l	1				; offset: $30 (48)		; GetFInfo: file number; TF- ioDirID
ioFlStBlk				 ds.w	1				; offset: $34 (52)		; start file block (0 if none)
ioFlLgLen				 ds.l	1				; offset: $36 (54)		; logical length (EOF)
ioFlPyLen				 ds.l	1				; offset: $3A (58)		; physical length
ioFlRStBlk				 ds.w	1				; offset: $3E (62)		; start block rsrc fork
ioFlRLgLen				 ds.l	1				; offset: $40 (64)		; file logical length rsrc fork
ioFlRPyLen				 ds.l	1				; offset: $44 (68)		; file physical length rsrc fork
ioFlCrDat				 ds.l	1				; offset: $48 (72)		; file creation date& time (32 bits in secs)
ioFlMdDat				 ds.l	1				; offset: $4C (76)		; last modified date and time
						 ORG 24
filler2					 ds.l	1				; offset: $18 (24)
ioVolIndex				 ds.w	1				; offset: $1C (28)		; volume index number
ioVCrDate				 ds.l	1				; offset: $1E (30)		; creation date and time
ioVLsBkUp				 ds.l	1				; offset: $22 (34)		; last backup date and time
ioVAtrb					 ds.w	1				; offset: $26 (38)		; volume attrib
ioVNmFls				 ds.w	1				; offset: $28 (40)		; number of files in directory
ioVDirSt				 ds.w	1				; offset: $2A (42)		; start block of file directory
ioVBlLn					 ds.w	1				; offset: $2C (44)		; GetVolInfo: length of dir in blocks
ioVNmAlBlks				 ds.w	1				; offset: $2E (46)		; for compatibilty ioVNmAlBlks * ioVAlBlkSiz <= 2 GB
ioVAlBlkSiz				 ds.l	1				; offset: $30 (48)		; for compatibilty ioVAlBlkSiz is <= $0000FE00 (65,024)
ioVClpSiz				 ds.l	1				; offset: $34 (52)		; GetVolInfo: bytes to allocate at a time
ioAlBlSt				 ds.w	1				; offset: $38 (56)		; starting disk(512-byte) block in block map
ioVNxtFNum				 ds.l	1				; offset: $3A (58)		; GetVolInfo: next free file number
ioVFrBlk				 ds.w	1				; offset: $3E (62)		; GetVolInfo: # free alloc blks for this vol
						 ORG 24
ioCRefNum				 ds.w	1				; offset: $18 (24)		; refNum for I/O operation
csCode					 ds.w	1				; offset: $1A (26)		; word for control status code
csParam					 ds.w	11				; offset: $1C (28)		; operation-defined parameters
						 ORG 24
ioSRefNum				 ds.w	1				; offset: $18 (24)
ioSVersNum				 ds.b	1				; offset: $1A (26)
ioSPermssn				 ds.b	1				; offset: $1B (27)
ioSMix					 ds.l	1				; offset: $1C (28)
ioSFlags				 ds.w	1				; offset: $20 (32)
ioSlot					 ds.b	1				; offset: $22 (34)
ioID					 ds.b	1				; offset: $23 (35)
						 ORG 24
ioMRefNum				 ds.w	1				; offset: $18 (24)
ioMVersNum				 ds.b	1				; offset: $1A (26)
ioMPermssn				 ds.b	1				; offset: $1B (27)
ioMMix					 ds.l	1				; offset: $1C (28)
ioMFlags				 ds.w	1				; offset: $20 (32)
ioSEBlkPtr				 ds.l	1				; offset: $22 (34)
						 ORG 80
sizeof					 EQU *					; size:   $50 (80)
						ENDR
CInfoPBRec				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioFRefNum				 ds.w	1				; offset: $18 (24)
ioFVersNum				 ds.b	1				; offset: $1A (26)
filler1					 ds.b	1				; offset: $1B (27)
ioFDirIndex				 ds.w	1				; offset: $1C (28)
ioFlAttrib				 ds.b	1				; offset: $1E (30)
ioACUser				 ds.b	1				; offset: $1F (31)
ioFlFndrInfo			 ds		FInfo			; offset: $20 (32)
ioDirID					 ds.l	1				; offset: $30 (48)
ioFlStBlk				 ds.w	1				; offset: $34 (52)
ioFlLgLen				 ds.l	1				; offset: $36 (54)
ioFlPyLen				 ds.l	1				; offset: $3A (58)
ioFlRStBlk				 ds.w	1				; offset: $3E (62)
ioFlRLgLen				 ds.l	1				; offset: $40 (64)
ioFlRPyLen				 ds.l	1				; offset: $44 (68)
ioFlCrDat				 ds.l	1				; offset: $48 (72)
ioFlMdDat				 ds.l	1				; offset: $4C (76)
ioFlBkDat				 ds.l	1				; offset: $50 (80)
ioFlXFndrInfo			 ds		FXInfo			; offset: $54 (84)
ioFlParID				 ds.l	1				; offset: $64 (100)
ioFlClpSiz				 ds.l	1				; offset: $68 (104)
						 ORG 32
ioDrUsrWds				 ds		DInfo			; offset: $20 (32)
ioDrDirID				 ds.l	1				; offset: $30 (48)
ioDrNmFls				 ds.w	1				; offset: $34 (52)
filler3					 ds.w	9				; offset: $36 (54)
ioDrCrDat				 ds.l	1				; offset: $48 (72)
ioDrMdDat				 ds.l	1				; offset: $4C (76)
ioDrBkDat				 ds.l	1				; offset: $50 (80)
ioDrFndrInfo			 ds		DXInfo			; offset: $54 (84)
ioDrParID				 ds.l	1				; offset: $64 (100)
						 ORG 108
sizeof					 EQU *					; size:   $6C (108)
						ENDR
; typedef struct CInfoPBRec *			CInfoPBPtr

XCInfoPBRec				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)		;  --> A pointer to a completion routine 
ioResult				 ds.w	1				; offset: $10 (16)		;  --> The result code of the function 
ioNamePtr				 ds.l	1				; offset: $12 (18)		;  --> Pointer to pathname to object 
ioVRefNum				 ds.w	1				; offset: $16 (22)		;  --> A volume specification 
filler1					 ds.l	1				; offset: $18 (24)
ioShortNamePtr			 ds.l	1				; offset: $1C (28)		;  <-> A pointer to the short name string buffer - required! 
filler2					 ds.w	1				; offset: $20 (32)
ioPDType				 ds.w	1				; offset: $22 (34)		;  <-- The ProDOS file type 
ioPDAuxType				 ds.l	1				; offset: $24 (36)		;  <-- The ProDOS aux type 
filler3					 ds.l	2				; offset: $28 (40)
ioDirID					 ds.l	1				; offset: $30 (48)		;  --> A directory ID 
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct XCInfoPBRec *			XCInfoPBPtr

;  Catalog position record 
CatPositionRec			RECORD 0
initialize				 ds.l	1				; offset: $0 (0)
priv					 ds.w	6				; offset: $4 (4)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
FSSpec					RECORD 0
vRefNum					 ds.w	1				; offset: $0 (0)
parID					 ds.l	1				; offset: $2 (2)
name					 ds		Str63			; offset: $6 (6)
sizeof					 EQU *					; size:   $46 (70)
						ENDR
; typedef struct FSSpec *				FSSpecPtr

; typedef FSSpecPtr *					FSSpecHandle

;  pointer to array of FSSpecs 
;  
;	The only difference between "const FSSpec*" and "ConstFSSpecPtr" is 
;	that as a parameter, ConstFSSpecPtr is allowed to be NULL 
;

; typedef const struct FSSpec *			ConstFSSpecPtr


;  
;	The following are structures to be filled out with the _PBGetVolMountInfo call
;	and passed back into the _PBVolumeMount call for external file system mounts. 
;

;  the "signature" of the file system 
; typedef OSType 						VolumeType


															; the signature for AppleShare 
AppleShareMediaType				EQU		'afpm'
; 
;	VolMount stuff was once in FSM.≈
;

VolMountInfoHeader		RECORD 0
length					 ds.w	1				; offset: $0 (0)		;  length of location data (including self) 
media					 ds.l	1				; offset: $2 (2)		;  type of media.  Variable length data follows 
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct VolMountInfoHeader *	VolMountInfoPtr

;  The new volume mount info record.  The old one is included for compatibility. 
;	the new record allows access by foriegn filesystems writers to the flags 
;	portion of the record. This portion is now public.  
;

VolumeMountInfoHeader	RECORD 0
length					 ds.w	1				; offset: $0 (0)		;  length of location data (including self) 
media					 ds.l	1				; offset: $2 (2)		;  type of media (must be registered with Apple) 
flags					 ds.w	1				; offset: $6 (6)		;  volume mount flags. Variable length data follows 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct VolumeMountInfoHeader * VolumeMountInfoHeaderPtr

;  volume mount flags 

volMountNoLoginMsgFlagBit		EQU		0					; Input to VolumeMount: If set, the file system 
volMountNoLoginMsgFlagMask		EQU		$0001				;  should suppresss any log-in message/greeting dialog 
volMountExtendedFlagsBit		EQU		7					; Input to VolumeMount: If set, the mount info is a 
volMountExtendedFlagsMask		EQU		$0080				;  AFPXVolMountInfo record for 3.7 AppleShare Client 
volMountInteractBit				EQU		15					; Input to VolumeMount: If set, it's OK for the file system 
volMountInteractMask			EQU		$8000				;  to perform user interaction to mount the volume 
volMountChangedBit				EQU		14					; Output from VoumeMount: If set, the volume was mounted, but 
volMountChangedMask				EQU		$4000				;  the volume mounting information record needs to be updated. 
volMountFSReservedMask			EQU		$00FF				; bits 0-7 are defined by each file system for its own use 
volMountSysReservedMask			EQU		$FF00				; bits 8-15 are reserved for Apple system use 


AFPVolMountInfo			RECORD 0
length					 ds.w	1				; offset: $0 (0)		;  length of location data (including self) 
media					 ds.l	1				; offset: $2 (2)		;  type of media 
flags					 ds.w	1				; offset: $6 (6)		;  bits for no messages, no reconnect 
nbpInterval				 ds.b	1				; offset: $8 (8)		;  NBP Interval parameter (IM2, p.322) 
nbpCount				 ds.b	1				; offset: $9 (9)		;  NBP Interval parameter (IM2, p.322) 
uamType					 ds.w	1				; offset: $A (10)		;  User Authentication Method 
zoneNameOffset			 ds.w	1				; offset: $C (12)		;  short positive offset from start of struct to Zone Name 
serverNameOffset		 ds.w	1				; offset: $E (14)		;  offset to pascal Server Name string 
volNameOffset			 ds.w	1				; offset: $10 (16)		;  offset to pascal Volume Name string 
userNameOffset			 ds.w	1				; offset: $12 (18)		;  offset to pascal User Name string 
userPasswordOffset		 ds.w	1				; offset: $14 (20)		;  offset to pascal User Password string 
volPasswordOffset		 ds.w	1				; offset: $16 (22)		;  offset to pascal Volume Password string 
AFPData					 ds.b	144				; offset: $18 (24)		;  variable length data may follow 
sizeof					 EQU *					; size:   $A8 (168)
						ENDR
; typedef struct AFPVolMountInfo *		AFPVolMountInfoPtr



;  AFPXVolMountInfo is the new AFP volume mount info record, requires the 3.7 AppleShare Client 
AFPXVolMountInfo		RECORD 0
length					 ds.w	1				; offset: $0 (0)		;  length of location data (including self) 
media					 ds.l	1				; offset: $2 (2)		;  type of media 
flags					 ds.w	1				; offset: $6 (6)		;  bits for no messages, no reconnect 
nbpInterval				 ds.b	1				; offset: $8 (8)		;  NBP Interval parameter (IM2, p.322) 
nbpCount				 ds.b	1				; offset: $9 (9)		;  NBP Interval parameter (IM2, p.322) 
uamType					 ds.w	1				; offset: $A (10)		;  User Authentication Method type 
zoneNameOffset			 ds.w	1				; offset: $C (12)		;  short positive offset from start of struct to Zone Name 
serverNameOffset		 ds.w	1				; offset: $E (14)		;  offset to pascal Server Name string 
volNameOffset			 ds.w	1				; offset: $10 (16)		;  offset to pascal Volume Name string 
userNameOffset			 ds.w	1				; offset: $12 (18)		;  offset to pascal User Name string 
userPasswordOffset		 ds.w	1				; offset: $14 (20)		;  offset to pascal User Password string 
volPasswordOffset		 ds.w	1				; offset: $16 (22)		;  offset to pascal Volume Password string 
extendedFlags			 ds.w	1				; offset: $18 (24)		;  extended flags word 
uamNameOffset			 ds.w	1				; offset: $1A (26)		;  offset to a pascal UAM name string 
alternateAddressOffset	 ds.w	1				; offset: $1C (28)		;  offset to Alternate Addresses in tagged format 
AFPData					 ds.b	176				; offset: $1E (30)		;  variable length data may follow 
sizeof					 EQU *					; size:   $CE (206)
						ENDR
; typedef struct AFPXVolMountInfo *		AFPXVolMountInfoPtr


kAFPExtendedFlagsAlternateAddressMask EQU 1					;  bit in AFPXVolMountInfo.extendedFlags that means alternateAddressOffset is used


															; constants for use in AFPTagData.fType field
kAFPTagTypeIP					EQU		$01
kAFPTagTypeIPPort				EQU		$02
kAFPTagTypeDDP					EQU		$03					; Currently unused


															; constants for use in AFPTagData.fLength field
kAFPTagLengthIP					EQU		$06
kAFPTagLengthIPPort				EQU		$08
kAFPTagLengthDDP				EQU		$06
AFPTagData				RECORD 0
fLength					 ds.b	1				; offset: $0 (0)		;  length of this data tag including the fLength field 
fType					 ds.b	1				; offset: $1 (1)
fData					 ds.b	1				; offset: $2 (2) <-- really an array of length one ;  variable length data 
						 ORG 4
sizeof					 EQU *					; size:   $4 (4)
						ENDR
AFPAlternateAddress		RECORD 0
fAddressCount			 ds.b	1				; offset: $0 (0)
fAddressList			 ds.b	1				; offset: $1 (1) <-- really an array of length one ;  actually variable length packed set of AFPTagData 
sizeof					 EQU *					; size:   $2 (2)
						ENDR


DTPBRec					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioDTRefNum				 ds.w	1				; offset: $18 (24)		;  desktop refnum 
ioIndex					 ds.w	1				; offset: $1A (26)
ioTagInfo				 ds.l	1				; offset: $1C (28)
ioDTBuffer				 ds.l	1				; offset: $20 (32)
ioDTReqCount			 ds.l	1				; offset: $24 (36)
ioDTActCount			 ds.l	1				; offset: $28 (40)
ioFiller1				 ds.b	1				; offset: $2C (44)
ioIconType				 ds.b	1				; offset: $2D (45)
ioFiller2				 ds.w	1				; offset: $2E (46)
ioDirID					 ds.l	1				; offset: $30 (48)
ioFileCreator			 ds.l	1				; offset: $34 (52)
ioFileType				 ds.l	1				; offset: $38 (56)
ioFiller3				 ds.l	1				; offset: $3C (60)
ioDTLgLen				 ds.l	1				; offset: $40 (64)
ioDTPyLen				 ds.l	1				; offset: $44 (68)
ioFiller4				 ds.w	14				; offset: $48 (72)
ioAPPLParID				 ds.l	1				; offset: $64 (100)
sizeof					 EQU *					; size:   $68 (104)
						ENDR
; typedef struct DTPBRec *				DTPBPtr

HIOParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioRefNum				 ds.w	1				; offset: $18 (24)
ioVersNum				 ds.b	1				; offset: $1A (26)
ioPermssn				 ds.b	1				; offset: $1B (27)
ioMisc					 ds.l	1				; offset: $1C (28)
ioBuffer				 ds.l	1				; offset: $20 (32)
ioReqCount				 ds.l	1				; offset: $24 (36)
ioActCount				 ds.l	1				; offset: $28 (40)
ioPosMode				 ds.w	1				; offset: $2C (44)
ioPosOffset				 ds.l	1				; offset: $2E (46)
sizeof					 EQU *					; size:   $32 (50)
						ENDR
; typedef struct HIOParam *				HIOParamPtr

HFileParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioFRefNum				 ds.w	1				; offset: $18 (24)
ioFVersNum				 ds.b	1				; offset: $1A (26)
filler1					 ds.b	1				; offset: $1B (27)
ioFDirIndex				 ds.w	1				; offset: $1C (28)
ioFlAttrib				 ds.b	1				; offset: $1E (30)
ioFlVersNum				 ds.b	1				; offset: $1F (31)
ioFlFndrInfo			 ds		FInfo			; offset: $20 (32)
ioDirID					 ds.l	1				; offset: $30 (48)
ioFlStBlk				 ds.w	1				; offset: $34 (52)
ioFlLgLen				 ds.l	1				; offset: $36 (54)
ioFlPyLen				 ds.l	1				; offset: $3A (58)
ioFlRStBlk				 ds.w	1				; offset: $3E (62)
ioFlRLgLen				 ds.l	1				; offset: $40 (64)
ioFlRPyLen				 ds.l	1				; offset: $44 (68)
ioFlCrDat				 ds.l	1				; offset: $48 (72)
ioFlMdDat				 ds.l	1				; offset: $4C (76)
sizeof					 EQU *					; size:   $50 (80)
						ENDR
; typedef struct HFileParam *			HFileParamPtr

HVolumeParam			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
filler2					 ds.l	1				; offset: $18 (24)
ioVolIndex				 ds.w	1				; offset: $1C (28)
ioVCrDate				 ds.l	1				; offset: $1E (30)
ioVLsMod				 ds.l	1				; offset: $22 (34)
ioVAtrb					 ds.w	1				; offset: $26 (38)
ioVNmFls				 ds.w	1				; offset: $28 (40)
ioVBitMap				 ds.w	1				; offset: $2A (42)
ioAllocPtr				 ds.w	1				; offset: $2C (44)
ioVNmAlBlks				 ds.w	1				; offset: $2E (46)
ioVAlBlkSiz				 ds.l	1				; offset: $30 (48)
ioVClpSiz				 ds.l	1				; offset: $34 (52)
ioAlBlSt				 ds.w	1				; offset: $38 (56)
ioVNxtCNID				 ds.l	1				; offset: $3A (58)
ioVFrBlk				 ds.w	1				; offset: $3E (62)
ioVSigWord				 ds.w	1				; offset: $40 (64)
ioVDrvInfo				 ds.w	1				; offset: $42 (66)
ioVDRefNum				 ds.w	1				; offset: $44 (68)
ioVFSID					 ds.w	1				; offset: $46 (70)
ioVBkUp					 ds.l	1				; offset: $48 (72)
ioVSeqNum				 ds.w	1				; offset: $4C (76)
ioVWrCnt				 ds.l	1				; offset: $4E (78)
ioVFilCnt				 ds.l	1				; offset: $52 (82)
ioVDirCnt				 ds.l	1				; offset: $56 (86)
ioVFndrInfo				 ds.l	8				; offset: $5A (90)
sizeof					 EQU *					; size:   $7A (122)
						ENDR
; typedef struct HVolumeParam *			HVolumeParamPtr


															; Large Volume Constants 
kWidePosOffsetBit				EQU		8
kMaximumBlocksIn4GB				EQU		$007FFFFF
XIOParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
ioNamePtr				 ds.l	1				; offset: $12 (18)
ioVRefNum				 ds.w	1				; offset: $16 (22)
ioRefNum				 ds.w	1				; offset: $18 (24)
ioVersNum				 ds.b	1				; offset: $1A (26)
ioPermssn				 ds.b	1				; offset: $1B (27)
ioMisc					 ds.l	1				; offset: $1C (28)
ioBuffer				 ds.l	1				; offset: $20 (32)
ioReqCount				 ds.l	1				; offset: $24 (36)
ioActCount				 ds.l	1				; offset: $28 (40)
ioPosMode				 ds.w	1				; offset: $2C (44)		;  must have kUseWidePositioning bit set 
ioWPosOffset			 ds		wide			; offset: $2E (46)		;  wide positioning offset 
sizeof					 EQU *					; size:   $36 (54)
						ENDR
; typedef struct XIOParam *				XIOParamPtr

XVolumeParam			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
ioNamePtr				 ds.l	1				; offset: $12 (18)
ioVRefNum				 ds.w	1				; offset: $16 (22)
ioXVersion				 ds.l	1				; offset: $18 (24)		;  this XVolumeParam version (0) 
ioVolIndex				 ds.w	1				; offset: $1C (28)
ioVCrDate				 ds.l	1				; offset: $1E (30)
ioVLsMod				 ds.l	1				; offset: $22 (34)
ioVAtrb					 ds.w	1				; offset: $26 (38)
ioVNmFls				 ds.w	1				; offset: $28 (40)
ioVBitMap				 ds.w	1				; offset: $2A (42)
ioAllocPtr				 ds.w	1				; offset: $2C (44)
ioVNmAlBlks				 ds.w	1				; offset: $2E (46)
ioVAlBlkSiz				 ds.l	1				; offset: $30 (48)
ioVClpSiz				 ds.l	1				; offset: $34 (52)
ioAlBlSt				 ds.w	1				; offset: $38 (56)
ioVNxtCNID				 ds.l	1				; offset: $3A (58)
ioVFrBlk				 ds.w	1				; offset: $3E (62)
ioVSigWord				 ds.w	1				; offset: $40 (64)
ioVDrvInfo				 ds.w	1				; offset: $42 (66)
ioVDRefNum				 ds.w	1				; offset: $44 (68)
ioVFSID					 ds.w	1				; offset: $46 (70)
ioVBkUp					 ds.l	1				; offset: $48 (72)
ioVSeqNum				 ds.w	1				; offset: $4C (76)
ioVWrCnt				 ds.l	1				; offset: $4E (78)
ioVFilCnt				 ds.l	1				; offset: $52 (82)
ioVDirCnt				 ds.l	1				; offset: $56 (86)
ioVFndrInfo				 ds.l	8				; offset: $5A (90)
ioVTotalBytes			 ds		UnsignedWide	; offset: $7A (122)		;  total number of bytes on volume 
ioVFreeBytes			 ds		UnsignedWide	; offset: $82 (130)		;  number of free bytes on volume 
sizeof					 EQU *					; size:   $8A (138)
						ENDR
; typedef struct XVolumeParam *			XVolumeParamPtr

AccessParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
filler3					 ds.w	1				; offset: $18 (24)
ioDenyModes				 ds.w	1				; offset: $1A (26)		; access rights data
filler4					 ds.w	1				; offset: $1C (28)
filler5					 ds.b	1				; offset: $1E (30)
ioACUser				 ds.b	1				; offset: $1F (31)		; access rights for directory only
filler6					 ds.l	1				; offset: $20 (32)
ioACOwnerID				 ds.l	1				; offset: $24 (36)		; owner ID
ioACGroupID				 ds.l	1				; offset: $28 (40)		; group ID
ioACAccess				 ds.l	1				; offset: $2C (44)		; access rights
ioDirID					 ds.l	1				; offset: $30 (48)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct AccessParam *			AccessParamPtr

ObjParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
filler7					 ds.w	1				; offset: $18 (24)
ioObjType				 ds.w	1				; offset: $1A (26)		; function code
ioObjNamePtr			 ds.l	1				; offset: $1C (28)		; ptr to returned creator/group name
ioObjID					 ds.l	1				; offset: $20 (32)		; creator/group ID
sizeof					 EQU *					; size:   $24 (36)
						ENDR
; typedef struct ObjParam *				ObjParamPtr

CopyParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioDstVRefNum			 ds.w	1				; offset: $18 (24)		; destination vol identifier
filler8					 ds.w	1				; offset: $1A (26)
ioNewName				 ds.l	1				; offset: $1C (28)		; ptr to destination pathname
ioCopyName				 ds.l	1				; offset: $20 (32)		; ptr to optional name
ioNewDirID				 ds.l	1				; offset: $24 (36)		; destination directory ID
filler14				 ds.l	1				; offset: $28 (40)
filler15				 ds.l	1				; offset: $2C (44)
ioDirID					 ds.l	1				; offset: $30 (48)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct CopyParam *			CopyParamPtr

WDParam					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
filler9					 ds.w	1				; offset: $18 (24)
ioWDIndex				 ds.w	1				; offset: $1A (26)
ioWDProcID				 ds.l	1				; offset: $1C (28)
ioWDVRefNum				 ds.w	1				; offset: $20 (32)
filler10				 ds.w	1				; offset: $22 (34)
filler11				 ds.l	1				; offset: $24 (36)
filler12				 ds.l	1				; offset: $28 (40)
filler13				 ds.l	1				; offset: $2C (44)
ioWDDirID				 ds.l	1				; offset: $30 (48)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct WDParam *				WDParamPtr

FIDParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
filler14				 ds.l	1				; offset: $18 (24)
ioDestNamePtr			 ds.l	1				; offset: $1C (28)		;  dest file name 
filler15				 ds.l	1				; offset: $20 (32)
ioDestDirID				 ds.l	1				; offset: $24 (36)		;  dest file's directory id 
filler16				 ds.l	1				; offset: $28 (40)
filler17				 ds.l	1				; offset: $2C (44)
ioSrcDirID				 ds.l	1				; offset: $30 (48)		;  source file's directory id 
filler18				 ds.w	1				; offset: $34 (52)
ioFileID				 ds.l	1				; offset: $36 (54)		;  file ID 
sizeof					 EQU *					; size:   $3A (58)
						ENDR
; typedef struct FIDParam *				FIDParamPtr

ForeignPrivParam		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioFiller21				 ds.l	1				; offset: $18 (24)
ioFiller22				 ds.l	1				; offset: $1C (28)
ioForeignPrivBuffer		 ds.l	1				; offset: $20 (32)
ioForeignPrivActCount	 ds.l	1				; offset: $24 (36)
ioForeignPrivReqCount	 ds.l	1				; offset: $28 (40)
ioFiller23				 ds.l	1				; offset: $2C (44)
ioForeignPrivDirID		 ds.l	1				; offset: $30 (48)
ioForeignPrivInfo1		 ds.l	1				; offset: $34 (52)
ioForeignPrivInfo2		 ds.l	1				; offset: $38 (56)
ioForeignPrivInfo3		 ds.l	1				; offset: $3C (60)
ioForeignPrivInfo4		 ds.l	1				; offset: $40 (64)
sizeof					 EQU *					; size:   $44 (68)
						ENDR
; typedef struct ForeignPrivParam *		ForeignPrivParamPtr

CSParam					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioMatchPtr				 ds.l	1				; offset: $18 (24)		;  match array 
ioReqMatchCount			 ds.l	1				; offset: $1C (28)		;  maximum allowable matches 
ioActMatchCount			 ds.l	1				; offset: $20 (32)		;  actual match count 
ioSearchBits			 ds.l	1				; offset: $24 (36)		;  search criteria selector 
ioSearchInfo1			 ds.l	1				; offset: $28 (40)		;  search values and range lower bounds 
ioSearchInfo2			 ds.l	1				; offset: $2C (44)		;  search values and range upper bounds 
ioSearchTime			 ds.l	1				; offset: $30 (48)		;  length of time to run search 
ioCatPosition			 ds		CatPositionRec ; offset: $34 (52)		;  current position in the catalog 
ioOptBuffer				 ds.l	1				; offset: $44 (68)		;  optional performance enhancement buffer 
ioOptBufSize			 ds.l	1				; offset: $48 (72)		;  size of buffer pointed to by ioOptBuffer 
sizeof					 EQU *					; size:   $4C (76)
						ENDR
; typedef struct CSParam *				CSParamPtr

HParamBlockRec			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioRefNum				 ds.w	1				; offset: $18 (24)
ioVersNum				 ds.b	1				; offset: $1A (26)
ioPermssn				 ds.b	1				; offset: $1B (27)
ioMisc					 ds.l	1				; offset: $1C (28)
ioBuffer				 ds.l	1				; offset: $20 (32)
ioReqCount				 ds.l	1				; offset: $24 (36)
ioActCount				 ds.l	1				; offset: $28 (40)
ioPosMode				 ds.w	1				; offset: $2C (44)
ioPosOffset				 ds.l	1				; offset: $2E (46)
						 ORG 24
ioFRefNum				 ds.w	1				; offset: $18 (24)
ioFVersNum				 ds.b	1				; offset: $1A (26)
filler1					 ds.b	1				; offset: $1B (27)
ioFDirIndex				 ds.w	1				; offset: $1C (28)
ioFlAttrib				 ds.b	1				; offset: $1E (30)
ioFlVersNum				 ds.b	1				; offset: $1F (31)
ioFlFndrInfo			 ds		FInfo			; offset: $20 (32)
ioDirID					 ds.l	1				; offset: $30 (48)
ioFlStBlk				 ds.w	1				; offset: $34 (52)
ioFlLgLen				 ds.l	1				; offset: $36 (54)
ioFlPyLen				 ds.l	1				; offset: $3A (58)
ioFlRStBlk				 ds.w	1				; offset: $3E (62)
ioFlRLgLen				 ds.l	1				; offset: $40 (64)
ioFlRPyLen				 ds.l	1				; offset: $44 (68)
ioFlCrDat				 ds.l	1				; offset: $48 (72)
ioFlMdDat				 ds.l	1				; offset: $4C (76)
						 ORG 24
filler2					 ds.l	1				; offset: $18 (24)
ioVolIndex				 ds.w	1				; offset: $1C (28)
ioVCrDate				 ds.l	1				; offset: $1E (30)
ioVLsMod				 ds.l	1				; offset: $22 (34)
ioVAtrb					 ds.w	1				; offset: $26 (38)
ioVNmFls				 ds.w	1				; offset: $28 (40)
ioVBitMap				 ds.w	1				; offset: $2A (42)
ioAllocPtr				 ds.w	1				; offset: $2C (44)
ioVNmAlBlks				 ds.w	1				; offset: $2E (46)
ioVAlBlkSiz				 ds.l	1				; offset: $30 (48)
ioVClpSiz				 ds.l	1				; offset: $34 (52)
ioAlBlSt				 ds.w	1				; offset: $38 (56)
ioVNxtCNID				 ds.l	1				; offset: $3A (58)
ioVFrBlk				 ds.w	1				; offset: $3E (62)
ioVSigWord				 ds.w	1				; offset: $40 (64)
ioVDrvInfo				 ds.w	1				; offset: $42 (66)
ioVDRefNum				 ds.w	1				; offset: $44 (68)
ioVFSID					 ds.w	1				; offset: $46 (70)
ioVBkUp					 ds.l	1				; offset: $48 (72)
ioVSeqNum				 ds.w	1				; offset: $4C (76)
ioVWrCnt				 ds.l	1				; offset: $4E (78)
ioVFilCnt				 ds.l	1				; offset: $52 (82)
ioVDirCnt				 ds.l	1				; offset: $56 (86)
ioVFndrInfo				 ds.l	8				; offset: $5A (90)
						 ORG 24
filler3					 ds.w	1				; offset: $18 (24)
ioDenyModes				 ds.w	1				; offset: $1A (26)		; access rights data
filler4					 ds.w	1				; offset: $1C (28)
filler5					 ds.b	1				; offset: $1E (30)
ioACUser				 ds.b	1				; offset: $1F (31)		; access rights for directory only
filler6					 ds.l	1				; offset: $20 (32)
ioACOwnerID				 ds.l	1				; offset: $24 (36)		; owner ID
ioACGroupID				 ds.l	1				; offset: $28 (40)		; group ID
ioACAccess				 ds.l	1				; offset: $2C (44)		; access rights
						 ORG 24
filler7					 ds.w	1				; offset: $18 (24)
ioObjType				 ds.w	1				; offset: $1A (26)		; function code
ioObjNamePtr			 ds.l	1				; offset: $1C (28)		; ptr to returned creator/group name
ioObjID					 ds.l	1				; offset: $20 (32)		; creator/group ID
						 ORG 24
ioDstVRefNum			 ds.w	1				; offset: $18 (24)		; destination vol identifier
filler8					 ds.w	1				; offset: $1A (26)
ioNewName				 ds.l	1				; offset: $1C (28)		; ptr to destination pathname
ioCopyName				 ds.l	1				; offset: $20 (32)		; ptr to optional name
ioNewDirID				 ds.l	1				; offset: $24 (36)		; destination directory ID
						 ORG 24
filler9					 ds.w	1				; offset: $18 (24)
ioWDIndex				 ds.w	1				; offset: $1A (26)
ioWDProcID				 ds.l	1				; offset: $1C (28)
ioWDVRefNum				 ds.w	1				; offset: $20 (32)
filler10				 ds.w	1				; offset: $22 (34)
filler11				 ds.l	1				; offset: $24 (36)
filler12				 ds.l	1				; offset: $28 (40)
filler13				 ds.l	1				; offset: $2C (44)
ioWDDirID				 ds.l	1				; offset: $30 (48)
						 ORG 24
filler14				 ds.l	1				; offset: $18 (24)
ioDestNamePtr			 ds.l	1				; offset: $1C (28)		;  dest file name 
filler15				 ds.l	1				; offset: $20 (32)
ioDestDirID				 ds.l	1				; offset: $24 (36)		;  dest file's directory id 
filler16				 ds.l	1				; offset: $28 (40)
filler17				 ds.l	1				; offset: $2C (44)
ioSrcDirID				 ds.l	1				; offset: $30 (48)		;  source file's directory id 
filler18				 ds.w	1				; offset: $34 (52)
ioFileID				 ds.l	1				; offset: $36 (54)		;  file ID 
						 ORG 24
ioMatchPtr				 ds.l	1				; offset: $18 (24)		;  match array 
ioReqMatchCount			 ds.l	1				; offset: $1C (28)		;  maximum allowable matches 
ioActMatchCount			 ds.l	1				; offset: $20 (32)		;  actual match count 
ioSearchBits			 ds.l	1				; offset: $24 (36)		;  search criteria selector 
ioSearchInfo1			 ds.l	1				; offset: $28 (40)		;  search values and range lower bounds 
ioSearchInfo2			 ds.l	1				; offset: $2C (44)		;  search values and range upper bounds 
ioSearchTime			 ds.l	1				; offset: $30 (48)		;  length of time to run search 
ioCatPosition			 ds		CatPositionRec ; offset: $34 (52)		;  current position in the catalog 
ioOptBuffer				 ds.l	1				; offset: $44 (68)		;  optional performance enhancement buffer 
ioOptBufSize			 ds.l	1				; offset: $48 (72)		;  size of buffer pointed to by ioOptBuffer 
						 ORG 24
ioFiller21				 ds.l	1				; offset: $18 (24)
ioFiller22				 ds.l	1				; offset: $1C (28)
ioForeignPrivBuffer		 ds.l	1				; offset: $20 (32)
ioForeignPrivActCount	 ds.l	1				; offset: $24 (36)
ioForeignPrivReqCount	 ds.l	1				; offset: $28 (40)
ioFiller23				 ds.l	1				; offset: $2C (44)
ioForeignPrivDirID		 ds.l	1				; offset: $30 (48)
ioForeignPrivInfo1		 ds.l	1				; offset: $34 (52)
ioForeignPrivInfo2		 ds.l	1				; offset: $38 (56)
ioForeignPrivInfo3		 ds.l	1				; offset: $3C (60)
ioForeignPrivInfo4		 ds.l	1				; offset: $40 (64)
						 ORG 122
sizeof					 EQU *					; size:   $7A (122)
						ENDR
; typedef struct HParamBlockRec *		HParmBlkPtr


CMovePBRec				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
ioNamePtr				 ds.l	1				; offset: $12 (18)
ioVRefNum				 ds.w	1				; offset: $16 (22)
filler1					 ds.l	1				; offset: $18 (24)
ioNewName				 ds.l	1				; offset: $1C (28)
filler2					 ds.l	1				; offset: $20 (32)
ioNewDirID				 ds.l	1				; offset: $24 (36)
filler3					 ds.l	2				; offset: $28 (40)
ioDirID					 ds.l	1				; offset: $30 (48)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct CMovePBRec *			CMovePBPtr

WDPBRec					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
ioNamePtr				 ds.l	1				; offset: $12 (18)
ioVRefNum				 ds.w	1				; offset: $16 (22)
filler1					 ds.w	1				; offset: $18 (24)
ioWDIndex				 ds.w	1				; offset: $1A (26)
ioWDProcID				 ds.l	1				; offset: $1C (28)
ioWDVRefNum				 ds.w	1				; offset: $20 (32)
filler2					 ds.w	7				; offset: $22 (34)
ioWDDirID				 ds.l	1				; offset: $30 (48)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct WDPBRec *				WDPBPtr

FCBPBRec				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
ioNamePtr				 ds.l	1				; offset: $12 (18)
ioVRefNum				 ds.w	1				; offset: $16 (22)
ioRefNum				 ds.w	1				; offset: $18 (24)
filler					 ds.w	1				; offset: $1A (26)
ioFCBIndx				 ds.w	1				; offset: $1C (28)
filler1					 ds.w	1				; offset: $1E (30)
ioFCBFlNm				 ds.l	1				; offset: $20 (32)
ioFCBFlags				 ds.w	1				; offset: $24 (36)
ioFCBStBlk				 ds.w	1				; offset: $26 (38)
ioFCBEOF				 ds.l	1				; offset: $28 (40)
ioFCBPLen				 ds.l	1				; offset: $2C (44)
ioFCBCrPs				 ds.l	1				; offset: $30 (48)
ioFCBVRefNum			 ds.w	1				; offset: $34 (52)
ioFCBClpSiz				 ds.l	1				; offset: $36 (54)
ioFCBParID				 ds.l	1				; offset: $3A (58)
sizeof					 EQU *					; size:   $3E (62)
						ENDR
; typedef struct FCBPBRec *				FCBPBPtr

VCB						RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
vcbFlags				 ds.w	1				; offset: $6 (6)
vcbSigWord				 ds.w	1				; offset: $8 (8)
vcbCrDate				 ds.l	1				; offset: $A (10)
vcbLsMod				 ds.l	1				; offset: $E (14)
vcbAtrb					 ds.w	1				; offset: $12 (18)
vcbNmFls				 ds.w	1				; offset: $14 (20)
vcbVBMSt				 ds.w	1				; offset: $16 (22)
vcbAllocPtr				 ds.w	1				; offset: $18 (24)
vcbNmAlBlks				 ds.w	1				; offset: $1A (26)
vcbAlBlkSiz				 ds.l	1				; offset: $1C (28)
vcbClpSiz				 ds.l	1				; offset: $20 (32)
vcbAlBlSt				 ds.w	1				; offset: $24 (36)
vcbNxtCNID				 ds.l	1				; offset: $26 (38)
vcbFreeBks				 ds.w	1				; offset: $2A (42)
vcbVN					 ds		Str27			; offset: $2C (44)
vcbDrvNum				 ds.w	1				; offset: $48 (72)
vcbDRefNum				 ds.w	1				; offset: $4A (74)
vcbFSID					 ds.w	1				; offset: $4C (76)
vcbVRefNum				 ds.w	1				; offset: $4E (78)
vcbMAdr					 ds.l	1				; offset: $50 (80)
vcbBufAdr				 ds.l	1				; offset: $54 (84)
vcbMLen					 ds.w	1				; offset: $58 (88)
vcbDirIndex				 ds.w	1				; offset: $5A (90)
vcbDirBlk				 ds.w	1				; offset: $5C (92)
vcbVolBkUp				 ds.l	1				; offset: $5E (94)
vcbVSeqNum				 ds.w	1				; offset: $62 (98)
vcbWrCnt				 ds.l	1				; offset: $64 (100)
vcbXTClpSiz				 ds.l	1				; offset: $68 (104)
vcbCTClpSiz				 ds.l	1				; offset: $6C (108)
vcbNmRtDirs				 ds.w	1				; offset: $70 (112)
vcbFilCnt				 ds.l	1				; offset: $72 (114)
vcbDirCnt				 ds.l	1				; offset: $76 (118)
vcbFndrInfo				 ds.l	8				; offset: $7A (122)
vcbVCSize				 ds.w	1				; offset: $9A (154)
vcbVBMCSiz				 ds.w	1				; offset: $9C (156)
vcbCtlCSiz				 ds.w	1				; offset: $9E (158)
vcbXTAlBlks				 ds.w	1				; offset: $A0 (160)
vcbCTAlBlks				 ds.w	1				; offset: $A2 (162)
vcbXTRef				 ds.w	1				; offset: $A4 (164)
vcbCTRef				 ds.w	1				; offset: $A6 (166)
vcbCtlBuf				 ds.l	1				; offset: $A8 (168)
vcbDirIDM				 ds.l	1				; offset: $AC (172)
vcbOffsM				 ds.w	1				; offset: $B0 (176)
sizeof					 EQU *					; size:   $B2 (178)
						ENDR
; typedef struct VCB *					VCBPtr

DrvQEl					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
dQDrive					 ds.w	1				; offset: $6 (6)
dQRefNum				 ds.w	1				; offset: $8 (8)
dQFSID					 ds.w	1				; offset: $A (10)
dQDrvSz					 ds.w	1				; offset: $C (12)
dQDrvSz2				 ds.w	1				; offset: $E (14)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct DrvQEl *				DrvQElPtr

	IF OLDROUTINELOCATIONS THEN
;
; pascal OSErr PBOpenSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBOpenSync:	OPWORD	$A000
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenSync
	ENDIF

;
; pascal OSErr PBOpenAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBOpenAsync:	OPWORD	$A400
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenAsync
	ENDIF

;
; pascal OSErr PBOpenImmed(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBOpenImmed:	OPWORD	$A200
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenImmed
	ENDIF

;
; pascal OSErr PBCloseSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBCloseSync:	OPWORD	$A001
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCloseSync
	ENDIF

;
; pascal OSErr PBCloseAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBCloseAsync:	OPWORD	$A401
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCloseAsync
	ENDIF

;
; pascal OSErr PBCloseImmed(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBCloseImmed:	OPWORD	$A201
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCloseImmed
	ENDIF

;
; pascal OSErr PBReadSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBReadSync:	OPWORD	$A002
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBReadSync
	ENDIF

;
; pascal OSErr PBReadAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBReadAsync:	OPWORD	$A402
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBReadAsync
	ENDIF

;
; pascal OSErr PBReadImmed(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBReadImmed:	OPWORD	$A202
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBReadImmed
	ENDIF

;
; pascal OSErr PBWriteSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBWriteSync:	OPWORD	$A003
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBWriteSync
	ENDIF

;
; pascal OSErr PBWriteAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBWriteAsync:	OPWORD	$A403
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBWriteAsync
	ENDIF

;
; pascal OSErr PBWriteImmed(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBWriteImmed:	OPWORD	$A203
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBWriteImmed
	ENDIF

	ENDIF	; OLDROUTINELOCATIONS
;
; pascal OSErr PBGetVInfoSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetVInfoSync:	OPWORD	$A007
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVInfoSync
	ENDIF

;
; pascal OSErr PBGetVInfoAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetVInfoAsync:	OPWORD	$A407
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVInfoAsync
	ENDIF

;
; pascal OSErr PBXGetVolInfoSync(XVolumeParamPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBXGetVolInfoSync
			moveq           	#18,D0
			dc.w            	$A060
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBXGetVolInfoSync
	ENDIF

;
; pascal OSErr PBXGetVolInfoAsync(XVolumeParamPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBXGetVolInfoAsync
			moveq           	#18,D0
			dc.w            	$A460
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBXGetVolInfoAsync
	ENDIF

;
; pascal OSErr PBGetVolSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetVolSync:	OPWORD	$A014
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVolSync
	ENDIF

;
; pascal OSErr PBGetVolAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetVolAsync:	OPWORD	$A414
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVolAsync
	ENDIF

;
; pascal OSErr PBSetVolSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetVolSync:	OPWORD	$A015
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetVolSync
	ENDIF

;
; pascal OSErr PBSetVolAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetVolAsync:	OPWORD	$A415
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetVolAsync
	ENDIF

;
; pascal OSErr PBFlushVolSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBFlushVolSync:	OPWORD	$A013
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBFlushVolSync
	ENDIF

;
; pascal OSErr PBFlushVolAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBFlushVolAsync:	OPWORD	$A413
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBFlushVolAsync
	ENDIF

;
; pascal OSErr PBCreateSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBCreateSync:	OPWORD	$A008
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateSync
	ENDIF

;
; pascal OSErr PBCreateAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBCreateAsync:	OPWORD	$A408
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateAsync
	ENDIF

;
; pascal OSErr PBDeleteSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBDeleteSync:	OPWORD	$A009
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDeleteSync
	ENDIF

;
; pascal OSErr PBDeleteAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBDeleteAsync:	OPWORD	$A409
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDeleteAsync
	ENDIF

;
; pascal OSErr PBOpenDFSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBOpenDFSync
			moveq           	#26,D0
			dc.w            	$A060
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenDFSync
	ENDIF

;
; pascal OSErr PBOpenDFAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBOpenDFAsync
			moveq           	#26,D0
			dc.w            	$A460
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenDFAsync
	ENDIF

;
; pascal OSErr PBOpenRFSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBOpenRFSync:	OPWORD	$A00A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenRFSync
	ENDIF

;
; pascal OSErr PBOpenRFAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBOpenRFAsync:	OPWORD	$A40A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenRFAsync
	ENDIF

;
; pascal OSErr PBRenameSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBRenameSync:	OPWORD	$A00B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBRenameSync
	ENDIF

;
; pascal OSErr PBRenameAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBRenameAsync:	OPWORD	$A40B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBRenameAsync
	ENDIF

;
; pascal OSErr PBGetFInfoSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetFInfoSync:	OPWORD	$A00C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetFInfoSync
	ENDIF

;
; pascal OSErr PBGetFInfoAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetFInfoAsync:	OPWORD	$A40C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetFInfoAsync
	ENDIF

;
; pascal OSErr PBSetFInfoSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFInfoSync:	OPWORD	$A00D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFInfoSync
	ENDIF

;
; pascal OSErr PBSetFInfoAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFInfoAsync:	OPWORD	$A40D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFInfoAsync
	ENDIF

;
; pascal OSErr PBSetFLockSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFLockSync:	OPWORD	$A041
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFLockSync
	ENDIF

;
; pascal OSErr PBSetFLockAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFLockAsync:	OPWORD	$A441
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFLockAsync
	ENDIF

;
; pascal OSErr PBRstFLockSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBRstFLockSync:	OPWORD	$A042
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBRstFLockSync
	ENDIF

;
; pascal OSErr PBRstFLockAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBRstFLockAsync:	OPWORD	$A442
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBRstFLockAsync
	ENDIF

;
; pascal OSErr PBSetFVersSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFVersSync:	OPWORD	$A043
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFVersSync
	ENDIF

;
; pascal OSErr PBSetFVersAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFVersAsync:	OPWORD	$A443
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFVersAsync
	ENDIF

;
; pascal OSErr PBAllocateSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBAllocateSync:	OPWORD	$A010
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBAllocateSync
	ENDIF

;
; pascal OSErr PBAllocateAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBAllocateAsync:	OPWORD	$A410
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBAllocateAsync
	ENDIF

;
; pascal OSErr PBGetEOFSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetEOFSync:	OPWORD	$A011
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetEOFSync
	ENDIF

;
; pascal OSErr PBGetEOFAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetEOFAsync:	OPWORD	$A411
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetEOFAsync
	ENDIF

;
; pascal OSErr PBSetEOFSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetEOFSync:	OPWORD	$A012
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetEOFSync
	ENDIF

;
; pascal OSErr PBSetEOFAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetEOFAsync:	OPWORD	$A412
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetEOFAsync
	ENDIF

;
; pascal OSErr PBGetFPosSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetFPosSync:	OPWORD	$A018
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetFPosSync
	ENDIF

;
; pascal OSErr PBGetFPosAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetFPosAsync:	OPWORD	$A418
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetFPosAsync
	ENDIF

;
; pascal OSErr PBSetFPosSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFPosSync:	OPWORD	$A044
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFPosSync
	ENDIF

;
; pascal OSErr PBSetFPosAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFPosAsync:	OPWORD	$A444
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFPosAsync
	ENDIF

;
; pascal OSErr PBFlushFileSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBFlushFileSync:	OPWORD	$A045
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBFlushFileSync
	ENDIF

;
; pascal OSErr PBFlushFileAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBFlushFileAsync:	OPWORD	$A445
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBFlushFileAsync
	ENDIF

;
; pascal OSErr PBMountVol(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBMountVol:	OPWORD	$A00F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBMountVol
	ENDIF

;
; pascal OSErr PBUnmountVol(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBUnmountVol:	OPWORD	$A00E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBUnmountVol
	ENDIF

;
; pascal OSErr PBUnmountVolImmed(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBUnmountVolImmed:	OPWORD	$A20E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBUnmountVolImmed
	ENDIF

;
; pascal OSErr PBEject(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBEject:	OPWORD	$A017
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBEject
	ENDIF

;
; pascal OSErr PBOffLine(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBOffLine:	OPWORD	$A035
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOffLine
	ENDIF

;
; pascal OSErr PBCatSearchSync(CSParamPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCatSearchSync
			moveq           	#24,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCatSearchSync
	ENDIF

;
; pascal OSErr PBCatSearchAsync(CSParamPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCatSearchAsync
			moveq           	#24,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCatSearchAsync
	ENDIF

;
; pascal OSErr SetVol(ConstStr63Param volName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetVol
	ENDIF

;
; pascal OSErr UnmountVol(ConstStr63Param volName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UnmountVol
	ENDIF

;
; pascal OSErr Eject(ConstStr63Param volName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Eject
	ENDIF

;
; pascal OSErr FlushVol(ConstStr63Param volName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlushVol
	ENDIF

;
; pascal OSErr HSetVol(ConstStr63Param volName, short vRefNum, long dirID)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HSetVol
	ENDIF

	IF OLDROUTINELOCATIONS THEN
;
; pascal void AddDrive(short drvrRefNum, short drvNum, DrvQElPtr qEl)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddDrive
	ENDIF

	ENDIF	; OLDROUTINELOCATIONS
;
; pascal OSErr FSOpen(ConstStr255Param fileName, short vRefNum, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSOpen
	ENDIF

;
; pascal OSErr OpenDF(ConstStr255Param fileName, short vRefNum, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenDF
	ENDIF

;
; pascal OSErr FSClose(short refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSClose
	ENDIF

;
; pascal OSErr FSRead(short refNum, long *count, void *buffPtr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSRead
	ENDIF

;
; pascal OSErr FSWrite(short refNum, long *count, const void *buffPtr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSWrite
	ENDIF

;
; pascal OSErr GetVInfo(short drvNum, StringPtr volName, short *vRefNum, long *freeBytes)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetVInfo
	ENDIF

;
; pascal OSErr GetFInfo(ConstStr255Param fileName, short vRefNum, FInfo *fndrInfo)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetFInfo
	ENDIF

;
; pascal OSErr GetVol(StringPtr volName, short *vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetVol
	ENDIF

;
; pascal OSErr Create(ConstStr255Param fileName, short vRefNum, OSType creator, OSType fileType)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Create
	ENDIF

;
; pascal OSErr FSDelete(ConstStr255Param fileName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSDelete
	ENDIF

;
; pascal OSErr OpenRF(ConstStr255Param fileName, short vRefNum, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenRF
	ENDIF

;
; pascal OSErr Rename(ConstStr255Param oldName, short vRefNum, ConstStr255Param newName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Rename
	ENDIF

;
; pascal OSErr SetFInfo(ConstStr255Param fileName, short vRefNum, const FInfo *fndrInfo)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetFInfo
	ENDIF

;
; pascal OSErr SetFLock(ConstStr255Param fileName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetFLock
	ENDIF

;
; pascal OSErr RstFLock(ConstStr255Param fileName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RstFLock
	ENDIF

;
; pascal OSErr Allocate(short refNum, long *count)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Allocate
	ENDIF

;
; pascal OSErr GetEOF(short refNum, long *logEOF)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetEOF
	ENDIF

;
; pascal OSErr SetEOF(short refNum, long logEOF)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetEOF
	ENDIF

;
; pascal OSErr GetFPos(short refNum, long *filePos)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetFPos
	ENDIF

;
; pascal OSErr SetFPos(short refNum, short posMode, long posOff)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetFPos
	ENDIF

;
; pascal OSErr GetVRefNum(short fileRefNum, short *vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetVRefNum
	ENDIF

;
; pascal OSErr PBOpenWDSync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBOpenWDSync
			moveq           	#1,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenWDSync
	ENDIF

;
; pascal OSErr PBOpenWDAsync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBOpenWDAsync
			moveq           	#1,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenWDAsync
	ENDIF

;
; pascal OSErr PBCloseWDSync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCloseWDSync
			moveq           	#2,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCloseWDSync
	ENDIF

;
; pascal OSErr PBCloseWDAsync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCloseWDAsync
			moveq           	#2,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCloseWDAsync
	ENDIF

;
; pascal OSErr PBHSetVolSync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHSetVolSync:	OPWORD	$A215
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetVolSync
	ENDIF

;
; pascal OSErr PBHSetVolAsync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHSetVolAsync:	OPWORD	$A615
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetVolAsync
	ENDIF

;
; pascal OSErr PBHGetVolSync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHGetVolSync:	OPWORD	$A214
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetVolSync
	ENDIF

;
; pascal OSErr PBHGetVolAsync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHGetVolAsync:	OPWORD	$A614
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetVolAsync
	ENDIF

;
; pascal OSErr PBCatMoveSync(CMovePBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCatMoveSync
			moveq           	#5,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCatMoveSync
	ENDIF

;
; pascal OSErr PBCatMoveAsync(CMovePBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCatMoveAsync
			moveq           	#5,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCatMoveAsync
	ENDIF

;
; pascal OSErr PBDirCreateSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDirCreateSync
			moveq           	#6,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDirCreateSync
	ENDIF

;
; pascal OSErr PBDirCreateAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDirCreateAsync
			moveq           	#6,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDirCreateAsync
	ENDIF

;
; pascal OSErr PBGetWDInfoSync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetWDInfoSync
			moveq           	#7,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetWDInfoSync
	ENDIF

;
; pascal OSErr PBGetWDInfoAsync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetWDInfoAsync
			moveq           	#7,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetWDInfoAsync
	ENDIF

;
; pascal OSErr PBGetFCBInfoSync(FCBPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetFCBInfoSync
			moveq           	#8,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetFCBInfoSync
	ENDIF

;
; pascal OSErr PBGetFCBInfoAsync(FCBPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetFCBInfoAsync
			moveq           	#8,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetFCBInfoAsync
	ENDIF

;
; pascal OSErr PBGetCatInfoSync(CInfoPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetCatInfoSync
			moveq           	#9,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetCatInfoSync
	ENDIF

;
; pascal OSErr PBGetCatInfoAsync(CInfoPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetCatInfoAsync
			moveq           	#9,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetCatInfoAsync
	ENDIF

;
; pascal OSErr PBSetCatInfoSync(CInfoPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetCatInfoSync
			moveq           	#10,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetCatInfoSync
	ENDIF

;
; pascal OSErr PBSetCatInfoAsync(CInfoPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetCatInfoAsync
			moveq           	#10,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetCatInfoAsync
	ENDIF

;
; pascal OSErr PBAllocContigSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBAllocContigSync:	OPWORD	$A210
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBAllocContigSync
	ENDIF

;
; pascal OSErr PBAllocContigAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBAllocContigAsync:	OPWORD	$A610
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBAllocContigAsync
	ENDIF

;
; pascal OSErr PBLockRangeSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBLockRangeSync
			moveq           	#16,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBLockRangeSync
	ENDIF

;
; pascal OSErr PBLockRangeAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBLockRangeAsync
			moveq           	#16,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBLockRangeAsync
	ENDIF

;
; pascal OSErr PBUnlockRangeSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBUnlockRangeSync
			moveq           	#17,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBUnlockRangeSync
	ENDIF

;
; pascal OSErr PBUnlockRangeAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBUnlockRangeAsync
			moveq           	#17,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBUnlockRangeAsync
	ENDIF

;
; pascal OSErr PBSetVInfoSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetVInfoSync
			moveq           	#11,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetVInfoSync
	ENDIF

;
; pascal OSErr PBSetVInfoAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetVInfoAsync
			moveq           	#11,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetVInfoAsync
	ENDIF

;
; pascal OSErr PBHGetVInfoSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHGetVInfoSync:	OPWORD	$A207
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetVInfoSync
	ENDIF

;
; pascal OSErr PBHGetVInfoAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHGetVInfoAsync:	OPWORD	$A607
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetVInfoAsync
	ENDIF

;
; pascal OSErr PBHOpenSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHOpenSync:	OPWORD	$A200
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenSync
	ENDIF

;
; pascal OSErr PBHOpenAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHOpenAsync:	OPWORD	$A600
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenAsync
	ENDIF

;
; pascal OSErr PBHOpenRFSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHOpenRFSync:	OPWORD	$A20A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenRFSync
	ENDIF

;
; pascal OSErr PBHOpenRFAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHOpenRFAsync:	OPWORD	$A60A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenRFAsync
	ENDIF

;
; pascal OSErr PBHOpenDFSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHOpenDFSync
			moveq           	#26,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenDFSync
	ENDIF

;
; pascal OSErr PBHOpenDFAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHOpenDFAsync
			moveq           	#26,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenDFAsync
	ENDIF

;
; pascal OSErr PBHCreateSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHCreateSync:	OPWORD	$A208
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHCreateSync
	ENDIF

;
; pascal OSErr PBHCreateAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHCreateAsync:	OPWORD	$A608
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHCreateAsync
	ENDIF

;
; pascal OSErr PBHDeleteSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHDeleteSync:	OPWORD	$A209
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHDeleteSync
	ENDIF

;
; pascal OSErr PBHDeleteAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHDeleteAsync:	OPWORD	$A609
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHDeleteAsync
	ENDIF

;
; pascal OSErr PBHRenameSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHRenameSync:	OPWORD	$A20B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHRenameSync
	ENDIF

;
; pascal OSErr PBHRenameAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHRenameAsync:	OPWORD	$A60B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHRenameAsync
	ENDIF

;
; pascal OSErr PBHRstFLockSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHRstFLockSync:	OPWORD	$A242
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHRstFLockSync
	ENDIF

;
; pascal OSErr PBHRstFLockAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHRstFLockAsync:	OPWORD	$A642
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHRstFLockAsync
	ENDIF

;
; pascal OSErr PBHSetFLockSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHSetFLockSync:	OPWORD	$A241
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetFLockSync
	ENDIF

;
; pascal OSErr PBHSetFLockAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHSetFLockAsync:	OPWORD	$A641
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetFLockAsync
	ENDIF

;
; pascal OSErr PBHGetFInfoSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHGetFInfoSync:	OPWORD	$A20C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetFInfoSync
	ENDIF

;
; pascal OSErr PBHGetFInfoAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHGetFInfoAsync:	OPWORD	$A60C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetFInfoAsync
	ENDIF

;
; pascal OSErr PBHSetFInfoSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHSetFInfoSync:	OPWORD	$A20D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetFInfoSync
	ENDIF

;
; pascal OSErr PBHSetFInfoAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHSetFInfoAsync:	OPWORD	$A60D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetFInfoAsync
	ENDIF

;
; pascal OSErr PBMakeFSSpecSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBMakeFSSpecSync
			moveq           	#27,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBMakeFSSpecSync
	ENDIF

;
; pascal OSErr PBMakeFSSpecAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBMakeFSSpecAsync
			moveq           	#27,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBMakeFSSpecAsync
	ENDIF

;
; pascal void FInitQueue(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FInitQueue:	OPWORD	$A016
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FInitQueue
	ENDIF


;
; pascal QHdrPtr GetFSQHdr(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetFSQHdr            &dest=(sp)
			move.l            #$00000360,&dest
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetFSQHdr
	ENDIF

;
; pascal QHdrPtr GetVCBQHdr(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetVCBQHdr           &dest=(sp)
			move.l            #$00000356,&dest
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetVCBQHdr
	ENDIF

	IF OLDROUTINELOCATIONS THEN
;
; pascal QHdrPtr GetDrvQHdr(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetDrvQHdr           &dest=(sp)
			move.l            #$00000308,&dest
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetDrvQHdr
	ENDIF

	ENDIF	; OLDROUTINELOCATIONS
;
; pascal OSErr HGetVol(StringPtr volName, short *vRefNum, long *dirID)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HGetVol
	ENDIF

;
; pascal OSErr HOpen(short vRefNum, long dirID, ConstStr255Param fileName, SInt8 permission, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HOpen
	ENDIF

;
; pascal OSErr HOpenDF(short vRefNum, long dirID, ConstStr255Param fileName, SInt8 permission, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HOpenDF
	ENDIF

;
; pascal OSErr HOpenRF(short vRefNum, long dirID, ConstStr255Param fileName, SInt8 permission, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HOpenRF
	ENDIF

;
; pascal OSErr AllocContig(short refNum, long *count)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AllocContig
	ENDIF

;
; pascal OSErr HCreate(short vRefNum, long dirID, ConstStr255Param fileName, OSType creator, OSType fileType)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HCreate
	ENDIF

;
; pascal OSErr DirCreate(short vRefNum, long parentDirID, ConstStr255Param directoryName, long *createdDirID)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DirCreate
	ENDIF

;
; pascal OSErr HDelete(short vRefNum, long dirID, ConstStr255Param fileName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HDelete
	ENDIF

;
; pascal OSErr HGetFInfo(short vRefNum, long dirID, ConstStr255Param fileName, FInfo *fndrInfo)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HGetFInfo
	ENDIF

;
; pascal OSErr HSetFInfo(short vRefNum, long dirID, ConstStr255Param fileName, const FInfo *fndrInfo)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HSetFInfo
	ENDIF

;
; pascal OSErr HSetFLock(short vRefNum, long dirID, ConstStr255Param fileName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HSetFLock
	ENDIF

;
; pascal OSErr HRstFLock(short vRefNum, long dirID, ConstStr255Param fileName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HRstFLock
	ENDIF

;
; pascal OSErr HRename(short vRefNum, long dirID, ConstStr255Param oldName, ConstStr255Param newName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HRename
	ENDIF

;
; pascal OSErr CatMove(short vRefNum, long dirID, ConstStr255Param oldName, long newDirID, ConstStr255Param newName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CatMove
	ENDIF

;
; pascal OSErr OpenWD(short vRefNum, long dirID, long procID, short *wdRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenWD
	ENDIF

;
; pascal OSErr CloseWD(short wdRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CloseWD
	ENDIF

;
; pascal OSErr GetWDInfo(short wdRefNum, short *vRefNum, long *dirID, long *procID)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetWDInfo
	ENDIF

;   shared environment  
;
; pascal OSErr PBHGetVolParmsSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHGetVolParmsSync
			moveq           	#48,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetVolParmsSync
	ENDIF

;
; pascal OSErr PBHGetVolParmsAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHGetVolParmsAsync
			moveq           	#48,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetVolParmsAsync
	ENDIF

;
; pascal OSErr PBHGetLogInInfoSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHGetLogInInfoSync
			moveq           	#49,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetLogInInfoSync
	ENDIF

;
; pascal OSErr PBHGetLogInInfoAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHGetLogInInfoAsync
			moveq           	#49,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetLogInInfoAsync
	ENDIF

;
; pascal OSErr PBHGetDirAccessSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHGetDirAccessSync
			moveq           	#50,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetDirAccessSync
	ENDIF

;
; pascal OSErr PBHGetDirAccessAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHGetDirAccessAsync
			moveq           	#50,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetDirAccessAsync
	ENDIF

;
; pascal OSErr PBHSetDirAccessSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHSetDirAccessSync
			moveq           	#51,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetDirAccessSync
	ENDIF

;
; pascal OSErr PBHSetDirAccessAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHSetDirAccessAsync
			moveq           	#51,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetDirAccessAsync
	ENDIF

;
; pascal OSErr PBHMapIDSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHMapIDSync
			moveq           	#52,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHMapIDSync
	ENDIF

;
; pascal OSErr PBHMapIDAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHMapIDAsync
			moveq           	#52,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHMapIDAsync
	ENDIF

;
; pascal OSErr PBHMapNameSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHMapNameSync
			moveq           	#53,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHMapNameSync
	ENDIF

;
; pascal OSErr PBHMapNameAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHMapNameAsync
			moveq           	#53,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHMapNameAsync
	ENDIF

;
; pascal OSErr PBHCopyFileSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHCopyFileSync
			moveq           	#54,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHCopyFileSync
	ENDIF

;
; pascal OSErr PBHCopyFileAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHCopyFileAsync
			moveq           	#54,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHCopyFileAsync
	ENDIF

;
; pascal OSErr PBHMoveRenameSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHMoveRenameSync
			moveq           	#55,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHMoveRenameSync
	ENDIF

;
; pascal OSErr PBHMoveRenameAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHMoveRenameAsync
			moveq           	#55,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHMoveRenameAsync
	ENDIF

;
; pascal OSErr PBHOpenDenySync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHOpenDenySync
			moveq           	#56,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenDenySync
	ENDIF

;
; pascal OSErr PBHOpenDenyAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHOpenDenyAsync
			moveq           	#56,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenDenyAsync
	ENDIF

;
; pascal OSErr PBHOpenRFDenySync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHOpenRFDenySync
			moveq           	#57,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenRFDenySync
	ENDIF

;
; pascal OSErr PBHOpenRFDenyAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHOpenRFDenyAsync
			moveq           	#57,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenRFDenyAsync
	ENDIF

;
; pascal OSErr PBGetXCatInfoSync(XCInfoPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetXCatInfoSync
			moveq           	#58,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetXCatInfoSync
	ENDIF

;
; pascal OSErr PBGetXCatInfoAsync(XCInfoPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetXCatInfoAsync
			moveq           	#58,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetXCatInfoAsync
	ENDIF

;
; pascal OSErr PBExchangeFilesSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBExchangeFilesSync
			moveq           	#23,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBExchangeFilesSync
	ENDIF

;
; pascal OSErr PBExchangeFilesAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBExchangeFilesAsync
			moveq           	#23,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBExchangeFilesAsync
	ENDIF

;
; pascal OSErr PBCreateFileIDRefSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCreateFileIDRefSync
			moveq           	#20,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateFileIDRefSync
	ENDIF

;
; pascal OSErr PBCreateFileIDRefAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCreateFileIDRefAsync
			moveq           	#20,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateFileIDRefAsync
	ENDIF

;
; pascal OSErr PBResolveFileIDRefSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBResolveFileIDRefSync
			moveq           	#22,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBResolveFileIDRefSync
	ENDIF

;
; pascal OSErr PBResolveFileIDRefAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBResolveFileIDRefAsync
			moveq           	#22,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBResolveFileIDRefAsync
	ENDIF

;
; pascal OSErr PBDeleteFileIDRefSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDeleteFileIDRefSync
			moveq           	#21,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDeleteFileIDRefSync
	ENDIF

;
; pascal OSErr PBDeleteFileIDRefAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDeleteFileIDRefAsync
			moveq           	#21,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDeleteFileIDRefAsync
	ENDIF

;
; pascal OSErr PBGetForeignPrivsSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetForeignPrivsSync
			moveq           	#96,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetForeignPrivsSync
	ENDIF

;
; pascal OSErr PBGetForeignPrivsAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetForeignPrivsAsync
			moveq           	#96,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetForeignPrivsAsync
	ENDIF

;
; pascal OSErr PBSetForeignPrivsSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetForeignPrivsSync
			moveq           	#97,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetForeignPrivsSync
	ENDIF

;
; pascal OSErr PBSetForeignPrivsAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetForeignPrivsAsync
			moveq           	#97,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetForeignPrivsAsync
	ENDIF

;   Desktop Manager  
;
; pascal OSErr PBDTGetPath(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetPath
			moveq           	#32,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetPath
	ENDIF

;
; pascal OSErr PBDTCloseDown(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTCloseDown
			moveq           	#33,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTCloseDown
	ENDIF

;
; pascal OSErr PBDTAddIconSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTAddIconSync
			moveq           	#34,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTAddIconSync
	ENDIF

;
; pascal OSErr PBDTAddIconAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTAddIconAsync
			moveq           	#34,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTAddIconAsync
	ENDIF

;
; pascal OSErr PBDTGetIconSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetIconSync
			moveq           	#35,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetIconSync
	ENDIF

;
; pascal OSErr PBDTGetIconAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetIconAsync
			moveq           	#35,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetIconAsync
	ENDIF

;
; pascal OSErr PBDTGetIconInfoSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetIconInfoSync
			moveq           	#36,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetIconInfoSync
	ENDIF

;
; pascal OSErr PBDTGetIconInfoAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetIconInfoAsync
			moveq           	#36,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetIconInfoAsync
	ENDIF

;
; pascal OSErr PBDTAddAPPLSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTAddAPPLSync
			moveq           	#37,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTAddAPPLSync
	ENDIF

;
; pascal OSErr PBDTAddAPPLAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTAddAPPLAsync
			moveq           	#37,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTAddAPPLAsync
	ENDIF

;
; pascal OSErr PBDTRemoveAPPLSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTRemoveAPPLSync
			moveq           	#38,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTRemoveAPPLSync
	ENDIF

;
; pascal OSErr PBDTRemoveAPPLAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTRemoveAPPLAsync
			moveq           	#38,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTRemoveAPPLAsync
	ENDIF

;
; pascal OSErr PBDTGetAPPLSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetAPPLSync
			moveq           	#39,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetAPPLSync
	ENDIF

;
; pascal OSErr PBDTGetAPPLAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetAPPLAsync
			moveq           	#39,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetAPPLAsync
	ENDIF

;
; pascal OSErr PBDTSetCommentSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTSetCommentSync
			moveq           	#40,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTSetCommentSync
	ENDIF

;
; pascal OSErr PBDTSetCommentAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTSetCommentAsync
			moveq           	#40,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTSetCommentAsync
	ENDIF

;
; pascal OSErr PBDTRemoveCommentSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTRemoveCommentSync
			moveq           	#41,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTRemoveCommentSync
	ENDIF

;
; pascal OSErr PBDTRemoveCommentAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTRemoveCommentAsync
			moveq           	#41,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTRemoveCommentAsync
	ENDIF

;
; pascal OSErr PBDTGetCommentSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetCommentSync
			moveq           	#42,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetCommentSync
	ENDIF

;
; pascal OSErr PBDTGetCommentAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetCommentAsync
			moveq           	#42,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetCommentAsync
	ENDIF

;
; pascal OSErr PBDTFlushSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTFlushSync
			moveq           	#43,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTFlushSync
	ENDIF

;
; pascal OSErr PBDTFlushAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTFlushAsync
			moveq           	#43,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTFlushAsync
	ENDIF

;
; pascal OSErr PBDTResetSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTResetSync
			moveq           	#44,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTResetSync
	ENDIF

;
; pascal OSErr PBDTResetAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTResetAsync
			moveq           	#44,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTResetAsync
	ENDIF

;
; pascal OSErr PBDTGetInfoSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetInfoSync
			moveq           	#45,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetInfoSync
	ENDIF

;
; pascal OSErr PBDTGetInfoAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetInfoAsync
			moveq           	#45,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetInfoAsync
	ENDIF

;
; pascal OSErr PBDTOpenInform(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTOpenInform
			moveq           	#46,D0
			dc.w            	$A060
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTOpenInform
	ENDIF

;
; pascal OSErr PBDTDeleteSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTDeleteSync
			moveq           	#47,D0
			dc.w            	$A060
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTDeleteSync
	ENDIF

;
; pascal OSErr PBDTDeleteAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTDeleteAsync
			moveq           	#47,D0
			dc.w            	$A460
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTDeleteAsync
	ENDIF

;   VolumeMount traps  
;
; pascal OSErr PBGetVolMountInfoSize(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetVolMountInfoSize
			moveq           	#63,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVolMountInfoSize
	ENDIF

;
; pascal OSErr PBGetVolMountInfo(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetVolMountInfo
			moveq           	#64,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVolMountInfo
	ENDIF

;
; pascal OSErr PBVolumeMount(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBVolumeMount
			moveq           	#65,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBVolumeMount
	ENDIF

;   FSp traps  
;
; pascal OSErr FSMakeFSSpec(short vRefNum, long dirID, ConstStr255Param fileName, FSSpec *spec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSMakeFSSpec
			moveq           	#1,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSMakeFSSpec
	ENDIF

;
; pascal OSErr FSpOpenDF(const FSSpec *spec, SInt8 permission, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpOpenDF
			moveq           	#2,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpOpenDF
	ENDIF

;
; pascal OSErr FSpOpenRF(const FSSpec *spec, SInt8 permission, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpOpenRF
			moveq           	#3,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpOpenRF
	ENDIF

;
; pascal OSErr FSpCreate(const FSSpec *spec, OSType creator, OSType fileType, ScriptCode scriptTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpCreate
			moveq           	#4,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpCreate
	ENDIF

;
; pascal OSErr FSpDirCreate(const FSSpec *spec, ScriptCode scriptTag, long *createdDirID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpDirCreate
			moveq           	#5,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpDirCreate
	ENDIF

;
; pascal OSErr FSpDelete(const FSSpec *spec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpDelete
			moveq           	#6,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpDelete
	ENDIF

;
; pascal OSErr FSpGetFInfo(const FSSpec *spec, FInfo *fndrInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpGetFInfo
			moveq           	#7,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpGetFInfo
	ENDIF

;
; pascal OSErr FSpSetFInfo(const FSSpec *spec, const FInfo *fndrInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpSetFInfo
			moveq           	#8,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpSetFInfo
	ENDIF

;
; pascal OSErr FSpSetFLock(const FSSpec *spec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpSetFLock
			moveq           	#9,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpSetFLock
	ENDIF

;
; pascal OSErr FSpRstFLock(const FSSpec *spec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpRstFLock
			moveq           	#10,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpRstFLock
	ENDIF

;
; pascal OSErr FSpRename(const FSSpec *spec, ConstStr255Param newName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpRename
			moveq           	#11,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpRename
	ENDIF

;
; pascal OSErr FSpCatMove(const FSSpec *source, const FSSpec *dest)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpCatMove
			moveq           	#12,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpCatMove
	ENDIF

;
; pascal OSErr FSpExchangeFiles(const FSSpec *source, const FSSpec *dest)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpExchangeFiles
			moveq           	#15,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpExchangeFiles
	ENDIF


;
; pascal OSErr PBShareSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBShareSync
			moveq           	#66,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBShareSync
	ENDIF

;
; pascal OSErr PBShareAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBShareAsync
			moveq           	#66,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBShareAsync
	ENDIF

;
; pascal OSErr PBUnshareSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBUnshareSync
			moveq           	#67,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBUnshareSync
	ENDIF

;
; pascal OSErr PBUnshareAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBUnshareAsync
			moveq           	#67,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBUnshareAsync
	ENDIF

;
; pascal OSErr PBGetUGEntrySync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetUGEntrySync
			moveq           	#68,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetUGEntrySync
	ENDIF

;
; pascal OSErr PBGetUGEntryAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetUGEntryAsync
			moveq           	#68,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetUGEntryAsync
	ENDIF




	IF TARGET_CPU_68K THEN
; 
;	PBGetAltAccess and PBSetAltAccess are obsolete and will not be supported 
;	on PowerPC. Equivalent functionality is provided by the routines 
;	PBGetForeignPrivs and PBSetForeignPrivs.
;

;
; pascal OSErr PBGetAltAccessSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetAltAccessSync
			moveq           	#96,D0
			dc.w            	$A060
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetAltAccessSync
	ENDIF

;
; pascal OSErr PBGetAltAccessAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetAltAccessAsync
			moveq           	#96,D0
			dc.w            	$A460
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetAltAccessAsync
	ENDIF

;
; pascal OSErr PBSetAltAccessSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetAltAccessSync
			moveq           	#97,D0
			dc.w            	$A060
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetAltAccessSync
	ENDIF

;
; pascal OSErr PBSetAltAccessAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetAltAccessAsync
			moveq           	#97,D0
			dc.w            	$A460
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetAltAccessAsync
	ENDIF

	ENDIF	; TARGET_CPU_68K

; 
;	The PBxxx() routines are obsolete.  
;	
;	Use the PBxxxSync() or PBxxxAsync() version instead.
;

	IF OLDROUTINELOCATIONS THEN
	ENDIF	; OLDROUTINELOCATIONS
	ENDIF ; __FILES__ 


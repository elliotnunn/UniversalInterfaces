;
;	File:		GXMath.a
;
;	Contains:	QuickDraw GX math routine interfaces.
;
;	Version:	Technology:	Quickdraw GX 1.1
;				Release:	Universal Interfaces 3.0.1
;
;	Copyright:	© 1994-1997 by Apple Computer, Inc., all rights reserved.
;
;	Bugs?:		Please include the the file and version information (from above) with
;				the problem description.  Developers belonging to one of the Apple
;				developer programs can submit bug reports to:
;
;					devsupport@apple.com
;
;
	IF &TYPE('__GXMATH__') = 'UNDEFINED' THEN
__GXMATH__ SET 1

	IF &TYPE('__CONDITIONALMACROS__') = 'UNDEFINED' THEN
	include 'ConditionalMacros.a'
	ENDIF
	IF &TYPE('__TYPES__') = 'UNDEFINED' THEN
	include 'Types.a'
	ENDIF
	IF &TYPE('__FIXMATH__') = 'UNDEFINED' THEN
	include 'FixMath.a'
	ENDIF


gxPoint					RECORD 0
x						 ds.l	1				; offset: $0 (0)
y						 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef unsigned short 				gxColorValue

gxPolar					RECORD 0
radius					 ds.l	1				; offset: $0 (0)
angle					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
gxMapping				RECORD 0
map						 ds.l	3 * 3			; offset: $0 (0)
sizeof					 EQU *					; size:   $24 (36)
						ENDR


gxColorValue1					EQU		$0000FFFF			; gxColorValue 1.0 

gxPositiveInfinity				EQU		$7FFFFFFF			; for Fixed and Fract 
gxNegativeInfinity				EQU		$80000000			; for Fixed and Fract 

;
; extern gxMapping *CopyToMapping(gxMapping *target, const gxMapping *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CopyToMapping
			move.w              #$0031,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyToMapping
	ENDIF

;
; extern gxMapping *InvertMapping(gxMapping *target, const gxMapping *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InvertMapping
			move.w              #$0032,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvertMapping
	ENDIF

;
; extern gxMapping *MapMapping(gxMapping *target, const gxMapping *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MapMapping
			move.w              #$0033,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MapMapping
	ENDIF

;
; extern gxMapping *MoveMapping(gxMapping *target, Fixed hOffset, Fixed vOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MoveMapping
			move.w              #$0034,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MoveMapping
	ENDIF

;
; extern gxMapping *MoveMappingTo(gxMapping *target, Fixed hPosition, Fixed vPosition)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MoveMappingTo
			move.w              #$0035,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MoveMappingTo
	ENDIF

;
; extern gxMapping *NormalizeMapping(gxMapping *target)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NormalizeMapping
			move.w              #$0036,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NormalizeMapping
	ENDIF

;
; extern gxMapping *RotateMapping(gxMapping *target, Fixed angle, Fixed xCenter, Fixed yCenter)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RotateMapping
			move.w              #$0037,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RotateMapping
	ENDIF

;
; extern gxMapping *ScaleMapping(gxMapping *target, Fixed hFactor, Fixed vFactor, Fixed xCenter, Fixed yCenter)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ScaleMapping
			move.w              #$0038,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ScaleMapping
	ENDIF

;
; extern gxMapping *ResetMapping(gxMapping *target)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ResetMapping
			move.w              #$0039,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ResetMapping
	ENDIF

;
; extern gxMapping *SkewMapping(gxMapping *target, Fixed skewX, Fixed skewY, Fixed xCenter, Fixed yCenter)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SkewMapping
			move.w              #$003A,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SkewMapping
	ENDIF

;
; extern void MapPoints(const gxMapping *source, long count, gxPoint vector[2147483647])
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MapPoints
			move.w              #$003B,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MapPoints
	ENDIF

;
; extern short FirstBit(unsigned long x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FirstBit
			move.w              #$003C,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FirstBit
	ENDIF

;
; extern short WideScale(const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideScale
			move.w              #$003D,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideScale
	ENDIF

;
; extern short LinearRoot(Fixed first, Fixed last, Fract t[2147483647])
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LinearRoot
			move.w              #$003E,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LinearRoot
	ENDIF

;
; extern short QuadraticRoot(Fixed first, Fixed control, Fixed last, Fract t[2147483647])
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QuadraticRoot
			move.w              #$003F,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QuadraticRoot
	ENDIF

;
; extern gxPoint *PolarToPoint(const gxPolar *ra, gxPoint *xy)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PolarToPoint
			move.w              #$0040,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PolarToPoint
	ENDIF

;
; extern gxPolar *PointToPolar(const gxPoint *xy, gxPolar *ra)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PointToPolar
			move.w              #$0041,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PointToPolar
	ENDIF

;
; extern Fract FractCubeRoot(Fract source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FractCubeRoot
			move.w              #$0042,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FractCubeRoot
	ENDIF

;
; extern Fract FractDivide(Fract dividend, Fract divisor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FractDivide
			move.w              #$0043,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FractDivide
	ENDIF

;
; extern Fract FractMultiply(Fract multiplicand, Fract multiplier)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FractMultiply
			move.w              #$0044,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FractMultiply
	ENDIF

;
; extern Fract FractSineCosine(Fixed degrees, Fract *cosine)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FractSineCosine
			move.w              #$0045,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FractSineCosine
	ENDIF

;
; extern Fract FractSquareRoot(Fract source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FractSquareRoot
			move.w              #$0046,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FractSquareRoot
	ENDIF

;
; extern Fixed FixedDivide(Fixed dividend, Fixed divisor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FixedDivide
			move.w              #$0047,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FixedDivide
	ENDIF

;
; extern Fixed FixedMultiply(Fixed multiplicand, Fixed multiplier)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FixedMultiply
			move.w              #$0048,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FixedMultiply
	ENDIF

;  This next call is (source * multiplier / divisor) -- it avoids underflow, overflow by using wides 
;
; extern long MultiplyDivide(long source, long multiplier, long divisor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MultiplyDivide
			move.w              #$0049,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MultiplyDivide
	ENDIF

;
; extern unsigned long Magnitude(long deltaX, long deltaY)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Magnitude
			move.w              #$004A,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Magnitude
	ENDIF

;
; extern long VectorMultiplyDivide(long count, const long *vector1, long step1, const long *vector2, long step2, long divisor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VectorMultiplyDivide
			move.w              #$004B,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VectorMultiplyDivide
	ENDIF




;  wide operations are defined within FixMath.h only for PowerPC 
	IF ¬ TARGET_CPU_PPC THEN
;
; extern wide *WideAdd(wide *target, const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideAdd
			move.w              #$004C,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideAdd
	ENDIF

;
; extern short WideCompare(const wide *target, const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideCompare
			move.w              #$004D,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideCompare
	ENDIF

;
; extern wide *WideNegate(wide *target)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideNegate
			move.w              #$004E,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideNegate
	ENDIF

;
; extern wide *WideShift(wide *target, long shift)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideShift
			move.w              #$004F,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideShift
	ENDIF

;
; extern unsigned long WideSquareRoot(const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideSquareRoot
			move.w              #$0050,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideSquareRoot
	ENDIF

;
; extern wide *WideSubtract(wide *target, const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideSubtract
			move.w              #$0051,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideSubtract
	ENDIF

;
; extern wide *WideMultiply(long multiplicand, long multiplier, wide *target)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideMultiply
			move.w              #$0052,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideMultiply
	ENDIF

;  returns the quotient 
;
; extern long WideDivide(const wide *dividend, long divisor, long *remainder)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideDivide
			move.w              #$0053,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideDivide
	ENDIF

;  quotient replaces dividend 
;
; extern wide *WideWideDivide(wide *dividend, long divisor, long *remainder)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideWideDivide
			move.w              #$0055,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideWideDivide
	ENDIF

	ENDIF


;
; extern wide *VectorMultiply(long count, const long *vector1, long step1, const long *vector2, long step2, wide *dot)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VectorMultiply
			move.w              #$0054,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VectorMultiply
	ENDIF

;
; extern unsigned long RandomBits(long count, long focus)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RandomBits
			move.w              #$0056,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RandomBits
	ENDIF

;
; extern void SetRandomSeed(const wide *seed)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetRandomSeed
			move.w              #$0057,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetRandomSeed
	ENDIF

;
; extern wide *GetRandomSeed(wide *seed)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetRandomSeed
			move.w              #$0058,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetRandomSeed
	ENDIF




	ENDIF ; __GXMATH__ 


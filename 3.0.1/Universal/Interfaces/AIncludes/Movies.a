;
;	File:		Movies.a
;
;	Contains:	QuickTime Interfaces.
;
;	Version:	Technology:	QuickTime 2.5
;				Release:	Universal Interfaces 3.0.1
;
;	Copyright:	© 1990-1997 by Apple Computer, Inc., all rights reserved
;
;	Bugs?:		Please include the the file and version information (from above) with
;				the problem description.  Developers belonging to one of the Apple
;				developer programs can submit bug reports to:
;
;					devsupport@apple.com
;
;
	IF &TYPE('__MOVIES__') = 'UNDEFINED' THEN
__MOVIES__ SET 1

	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF
	IF &TYPE('__ALIASES__') = 'UNDEFINED' THEN
	include 'Aliases.a'
	ENDIF
	IF &TYPE('__EVENTS__') = 'UNDEFINED' THEN
	include 'Events.a'
	ENDIF
	IF &TYPE('__MENUS__') = 'UNDEFINED' THEN
	include 'Menus.a'
	ENDIF
	IF &TYPE('__COMPONENTS__') = 'UNDEFINED' THEN
	include 'Components.a'
	ENDIF
	IF &TYPE('__IMAGECOMPRESSION__') = 'UNDEFINED' THEN
	include 'ImageCompression.a'
	ENDIF


;   "kFix1" is defined in FixMath as "fixed1"  
;  error codes are in Errors.[haa] 
;  gestalt codes are in Gestalt.[hpa] 

MovieFileType					EQU		'MooV'

MediaHandlerType				EQU		'mhlr'
DataHandlerType					EQU		'dhlr'

VideoMediaType					EQU		'vide'
SoundMediaType					EQU		'soun'
TextMediaType					EQU		'text'
BaseMediaType					EQU		'gnrc'
MPEGMediaType					EQU		'MPEG'
MusicMediaType					EQU		'musi'
TimeCodeMediaType				EQU		'tmcd'
SpriteMediaType					EQU		'sprt'
TweenMediaType					EQU		'twen'
ThreeDeeMediaType				EQU		'qd3d'
HandleDataHandlerSubType		EQU		'hndl'
ResourceDataHandlerSubType		EQU		'rsrc'

VisualMediaCharacteristic		EQU		'eyes'
AudioMediaCharacteristic		EQU		'ears'
kCharacteristicCanSendVideo		EQU		'vsnd'

DoTheRightThing					EQU		0

MovieRecord				RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct MovieRecord *			Movie

TrackRecord				RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct TrackRecord *			Track

MediaRecord				RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct MediaRecord *			Media

UserDataRecord			RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct UserDataRecord *		UserData

TrackEditStateRecord	RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct TrackEditStateRecord *	TrackEditState

MovieEditStateRecord	RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct MovieEditStateRecord *	MovieEditState

SpriteWorldRecord		RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct SpriteWorldRecord *	SpriteWorld

SpriteRecord			RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct SpriteRecord *			Sprite

SampleDescription		RECORD 0
descSize				 ds.l	1				; offset: $0 (0)
dataFormat				 ds.l	1				; offset: $4 (4)
resvd1					 ds.l	1				; offset: $8 (8)
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct SampleDescription *	SampleDescriptionPtr

; typedef SampleDescriptionPtr *		SampleDescriptionHandle

; typedef Handle 						QTAtomContainer

; typedef long 							QTAtom

; typedef long 							QTAtomType

; typedef long 							QTAtomID



SoundDescription		RECORD 0
descSize				 ds.l	1				; offset: $0 (0)		;  total size of SoundDescription including extra data 
dataFormat				 ds.l	1				; offset: $4 (4)		;   
resvd1					 ds.l	1				; offset: $8 (8)		;  reserved for apple use 
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
version					 ds.w	1				; offset: $10 (16)		;  which version is this data 
revlevel				 ds.w	1				; offset: $12 (18)		;  what version of that codec did this 
vendor					 ds.l	1				; offset: $14 (20)		;  whose  codec compressed this data 
numChannels				 ds.w	1				; offset: $18 (24)		;  number of channels of sound 
sampleSize				 ds.w	1				; offset: $1A (26)		;  number of bits per sample 
compressionID			 ds.w	1				; offset: $1C (28)		;  sound compression used, 0 if none 
packetSize				 ds.w	1				; offset: $1E (30)		;  packet size for compression, 0 if no compression 
sampleRate				 ds.l	1				; offset: $20 (32)		;  sample rate sound is captured at 
sizeof					 EQU *					; size:   $24 (36)
						ENDR
; typedef struct SoundDescription *		SoundDescriptionPtr

; typedef SoundDescriptionPtr *			SoundDescriptionHandle

TextDescription			RECORD 0
descSize				 ds.l	1				; offset: $0 (0)		;  Total size of TextDescription
dataFormat				 ds.l	1				; offset: $4 (4)		;  'text'
resvd1					 ds.l	1				; offset: $8 (8)
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
displayFlags			 ds.l	1				; offset: $10 (16)		;  see enum below for flag values
textJustification		 ds.l	1				; offset: $14 (20)		;  Can be: teCenter,teFlush -Default,-Right,-Left
bgColor					 ds		RGBColor		; offset: $18 (24)		;  Background color
defaultTextBox			 ds		Rect			; offset: $1E (30)		;  Location to place the text within the track bounds
defaultStyle			 ds		ScrpSTElement	; offset: $26 (38)		;  Default style (struct defined in TextEdit.h)
defaultFontName			 ds.b	1				; offset: $3A (58) <-- really an array of length one ;  Font Name (pascal string - struct extended to fit) 
						 ORG 60
sizeof					 EQU *					; size:   $3C (60)
						ENDR
; typedef struct TextDescription *		TextDescriptionPtr

; typedef TextDescriptionPtr *			TextDescriptionHandle

ThreeDeeDescription		RECORD 0
descSize				 ds.l	1				; offset: $0 (0)		;  total size of ThreeDeeDescription including extra data 
dataFormat				 ds.l	1				; offset: $4 (4)		;   
resvd1					 ds.l	1				; offset: $8 (8)		;  reserved for apple use 
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
version					 ds.l	1				; offset: $10 (16)		;  which version is this data 
rendererType			 ds.l	1				; offset: $14 (20)		;  which renderer to use, 0 for default 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct ThreeDeeDescription *	ThreeDeeDescriptionPtr

; typedef ThreeDeeDescriptionPtr *		ThreeDeeDescriptionHandle

DataReferenceRecord		RECORD 0
dataRefType				 ds.l	1				; offset: $0 (0)
dataRef					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct DataReferenceRecord *	DataReferencePtr

; --------------------------
;  Music Sample Description
;--------------------------

MusicDescription		RECORD 0
descSize				 ds.l	1				; offset: $0 (0)
dataFormat				 ds.l	1				; offset: $4 (4)		;  'musi' 
resvd1					 ds.l	1				; offset: $8 (8)
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
musicFlags				 ds.l	1				; offset: $10 (16)
headerData				 ds.l	1				; offset: $14 (20) <-- really an array of length one ;  variable size! 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct MusicDescription *		MusicDescriptionPtr

; typedef MusicDescriptionPtr *			MusicDescriptionHandle


kMusicFlagDontPlay2Soft			EQU		$00000001


dfDontDisplay					EQU		$01					; Don't display the text
dfDontAutoScale					EQU		$02					; Don't scale text as track bounds grows or shrinks
dfClipToTextBox					EQU		$04					; Clip update to the textbox
dfUseMovieBGColor				EQU		$08					; Set text background to movie's background color
dfShrinkTextBoxToFit			EQU		$10					; Compute minimum box to fit the sample
dfScrollIn						EQU		$20					; Scroll text in until last of text is in view 
dfScrollOut						EQU		$40					; Scroll text out until last of text is gone (if both set, scroll in then out)
dfHorizScroll					EQU		$80					; Scroll text horizontally (otherwise it's vertical)
dfReverseScroll					EQU		$0100				; vert: scroll down rather than up; horiz: scroll backwards (justfication dependent)
dfContinuousScroll				EQU		$0200				; new samples cause previous samples to scroll out 
dfFlowHoriz						EQU		$0400				; horiz scroll text flows in textbox rather than extend to right 
dfContinuousKaraoke				EQU		$0800				; ignore begin offset, hilite everything up to the end offset(karaoke)
dfDropShadow					EQU		$1000				; display text with a drop shadow 
dfAntiAlias						EQU		$2000				; attempt to display text anti aliased
dfKeyedText						EQU		$4000				; key the text over background
dfInverseHilite					EQU		$8000				; Use inverse hiliting rather than using hilite color
dfTextColorHilite				EQU		$00010000			; changes text color in place of hiliting. 

searchTextDontGoToFoundTime		EQU		$00010000
searchTextDontHiliteFoundText	EQU		$00020000
searchTextOneTrackOnly			EQU		$00040000
searchTextEnabledTracksOnly		EQU		$00080000

k3DMediaRendererEntry			EQU		'rend'
k3DMediaRendererName			EQU		'name'
k3DMediaRendererCode			EQU		'rcod'
;  progress messages 

movieProgressOpen				EQU		0
movieProgressUpdatePercent		EQU		1
movieProgressClose				EQU		2
;  progress operations 

progressOpFlatten				EQU		1
progressOpInsertTrackSegment	EQU		2
progressOpInsertMovieSegment	EQU		3
progressOpPaste					EQU		4
progressOpAddMovieSelection		EQU		5
progressOpCopy					EQU		6
progressOpCut					EQU		7
progressOpLoadMovieIntoRam		EQU		8
progressOpLoadTrackIntoRam		EQU		9
progressOpLoadMediaIntoRam		EQU		10
progressOpImportMovie			EQU		11
progressOpExportMovie			EQU		12

mediaQualityDraft				EQU		$0000
mediaQualityNormal				EQU		$0040
mediaQualityBetter				EQU		$0080
mediaQualityBest				EQU		$00C0
; typedef ComponentInstance 			MediaHandler

; typedef ComponentInstance 			DataHandler

; typedef Component 					MediaHandlerComponent

; typedef Component 					DataHandlerComponent

; typedef ComponentResult 				HandlerError

;  TimeBase equates 
; typedef long 							TimeValue

; typedef long 							TimeScale

CompTimeValue			RECORD 0
f						 ds		wide
sizeof					 EQU *					; size:   $8 (8)
						ENDR



loopTimeBase					EQU		1
palindromeLoopTimeBase			EQU		2
maintainTimeBaseZero			EQU		4
; typedef unsigned long 				TimeBaseFlags

TimeBaseRecord			RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct TimeBaseRecord *		TimeBase

CallBackRecord			RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct CallBackRecord *		QTCallBack

TimeRecord				RECORD 0
value					 ds		CompTimeValue	; offset: $0 (0)		;  units 
scale					 ds.l	1				; offset: $8 (8)		;  units per second 
base					 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
;  CallBack equates 

triggerTimeFwd					EQU		$0001				; when curTime exceeds triggerTime going forward 
triggerTimeBwd					EQU		$0002				; when curTime exceeds triggerTime going backwards 
triggerTimeEither				EQU		$0003				; when curTime exceeds triggerTime going either direction 
triggerRateLT					EQU		$0004				; when rate changes to less than trigger value 
triggerRateGT					EQU		$0008				; when rate changes to greater than trigger value 
triggerRateEqual				EQU		$0010				; when rate changes to equal trigger value 
triggerRateLTE					EQU		$0014
triggerRateGTE					EQU		$0018
triggerRateNotEqual				EQU		$001C
triggerRateChange				EQU		0
triggerAtStart					EQU		$0001
triggerAtStop					EQU		$0002
; typedef unsigned short 				QTCallBackFlags


timeBaseBeforeStartTime			EQU		1
timeBaseAfterStopTime			EQU		2
; typedef unsigned long 				TimeBaseStatus


callBackAtTime					EQU		1
callBackAtRate					EQU		2
callBackAtTimeJump				EQU		3
callBackAtExtremes				EQU		4
callBackAtInterrupt				EQU		$8000
callBackAtDeferredTask			EQU		$4000
; typedef unsigned short 				QTCallBackType


qtcbNeedsRateChanges			EQU		1					; wants to know about rate changes 
qtcbNeedsTimeChanges			EQU		2					; wants to know about time changes 
qtcbNeedsStartStopChanges		EQU		4					; wants to know when TimeBase start/stop is changed
QTCallBackHeader		RECORD 0
callBackFlags			 ds.l	1				; offset: $0 (0)
reserved1				 ds.l	1				; offset: $4 (4)
qtPrivate				 ds.b	40				; offset: $8 (8)
sizeof					 EQU *					; size:   $30 (48)
						ENDR
QTSyncTaskRecord		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
proc					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct QTSyncTaskRecord *		QTSyncTaskPtr


keepInRam						EQU		$01					; load and make non-purgable
unkeepInRam						EQU		$02					; mark as purgable
flushFromRam					EQU		$04					; empty those handles
loadForwardTrackEdits			EQU		$08					;	load track edits into ram for playing forward
loadBackwardTrackEdits			EQU		$10					;	load track edits into ram for playing in reverse

newMovieActive					EQU		$01
newMovieDontResolveDataRefs		EQU		$02
newMovieDontAskUnresolvedDataRefs EQU	$04
newMovieDontAutoAlternates		EQU		$08
newMovieDontUpdateForeBackPointers EQU	$10
;  track usage bits 

trackUsageInMovie				EQU		$02
trackUsageInPreview				EQU		$04
trackUsageInPoster				EQU		$08
;  Add/GetMediaSample flags 

mediaSampleNotSync				EQU		$01					; sample is not a sync sample (eg. is frame differenced 
mediaSampleShadowSync			EQU		$02					; sample is a shadow sync 

pasteInParallel					EQU		$01
showUserSettingsDialog			EQU		$02
movieToFileOnlyExport			EQU		$04
movieFileSpecValid				EQU		$08

nextTimeMediaSample				EQU		$01
nextTimeMediaEdit				EQU		$02
nextTimeTrackEdit				EQU		$04
nextTimeSyncSample				EQU		$08
nextTimeStep					EQU		$10
nextTimeEdgeOK					EQU		$4000
nextTimeIgnoreActiveSegment		EQU		$8000
; typedef unsigned short 				nextTimeFlagsEnum


createMovieFileDeleteCurFile	EQU		$80000000
createMovieFileDontCreateMovie	EQU		$40000000
createMovieFileDontOpenFile		EQU		$20000000
; typedef unsigned long 				createMovieFileFlagsEnum


flattenAddMovieToDataFork		EQU		$00000001
flattenActiveTracksOnly			EQU		$00000004
flattenDontInterleaveFlatten	EQU		$00000008
flattenFSSpecPtrIsDataRefRecordPtr EQU	$00000010
; typedef unsigned long 				movieFlattenFlagsEnum


movieInDataForkResID			EQU		-1					; magic res ID 

mcTopLeftMovie					EQU		$01					; usually centered 
mcScaleMovieToFit				EQU		$02					; usually only scales down 
mcWithBadge						EQU		$04					; give me a badge 
mcNotVisible					EQU		$08					; don't show controller 
mcWithFrame						EQU		$10					; gimme a frame 

movieScrapDontZeroScrap			EQU		$01
movieScrapOnlyPutMovie			EQU		$02

dataRefSelfReference			EQU		$01
dataRefWasNotResolved			EQU		$02
; typedef unsigned long 				dataRefAttributesFlags


hintsScrubMode					EQU		$01					; mask == && (if flags == scrub on, flags != scrub off) 
hintsLoop						EQU		$02
hintsDontPurge					EQU		$04
hintsUseScreenBuffer			EQU		$20
hintsAllowInterlace				EQU		$40
hintsUseSoundInterp				EQU		$80
hintsHighQuality				EQU		$0100				; slooooow 
hintsPalindrome					EQU		$0200
hintsInactive					EQU		$0800
; typedef unsigned long 				playHintsEnum


mediaHandlerFlagBaseClient		EQU		1
; typedef unsigned long 				mediaHandlerFlagsEnum


movieTrackMediaType				EQU		$01
movieTrackCharacteristic		EQU		$02
movieTrackEnabledOnly			EQU		$04
SampleReferenceRecord	RECORD 0
dataOffset				 ds.l	1				; offset: $0 (0)
dataSize				 ds.l	1				; offset: $4 (4)
durationPerSample		 ds.l	1				; offset: $8 (8)
numberOfSamples			 ds.l	1				; offset: $C (12)
sampleFlags				 ds.w	1				; offset: $10 (16)
sizeof					 EQU *					; size:   $12 (18)
						ENDR
; typedef struct SampleReferenceRecord * SampleReferencePtr


; *************************
;* Initialization Routines 
;*************************

;
; pascal OSErr EnterMovies(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_EnterMovies
			moveq           	#1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EnterMovies
	ENDIF

;
; pascal void ExitMovies(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ExitMovies
			moveq           	#2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ExitMovies
	ENDIF

; *************************
;* Error Routines 
;*************************


;
; pascal OSErr GetMoviesError(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviesError
			moveq           	#3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviesError
	ENDIF

;
; pascal void ClearMoviesStickyError(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClearMoviesStickyError
			move.w              #$00DE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClearMoviesStickyError
	ENDIF

;
; pascal OSErr GetMoviesStickyError(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviesStickyError
			moveq           	#4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviesStickyError
	ENDIF

;
; pascal void SetMoviesErrorProc(MoviesErrorUPP errProc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviesErrorProc
			move.w              #$00EF,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviesErrorProc
	ENDIF

; *************************
;* Idle Routines 
;*************************

;
; pascal void MoviesTask(Movie theMovie, long maxMilliSecToUse)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MoviesTask
			moveq           	#5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MoviesTask
	ENDIF

;
; pascal OSErr PrerollMovie(Movie theMovie, TimeValue time, Fixed Rate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PrerollMovie
			moveq           	#6,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PrerollMovie
	ENDIF

;
; pascal OSErr LoadMovieIntoRam(Movie theMovie, TimeValue time, TimeValue duration, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LoadMovieIntoRam
			moveq           	#7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LoadMovieIntoRam
	ENDIF

;
; pascal OSErr LoadTrackIntoRam(Track theTrack, TimeValue time, TimeValue duration, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LoadTrackIntoRam
			move.w              #$016E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LoadTrackIntoRam
	ENDIF

;
; pascal OSErr LoadMediaIntoRam(Media theMedia, TimeValue time, TimeValue duration, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LoadMediaIntoRam
			moveq           	#8,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LoadMediaIntoRam
	ENDIF

;
; pascal void SetMovieActive(Movie theMovie, Boolean active)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieActive
			moveq           	#9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieActive
	ENDIF

;
; pascal Boolean GetMovieActive(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieActive
			moveq           	#10,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieActive
	ENDIF

; *************************
;* calls for playing movies, previews, posters
;*************************

;
; pascal void StartMovie(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_StartMovie
			moveq           	#11,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StartMovie
	ENDIF

;
; pascal void StopMovie(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_StopMovie
			moveq           	#12,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StopMovie
	ENDIF

;
; pascal void GoToBeginningOfMovie(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GoToBeginningOfMovie
			moveq           	#13,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GoToBeginningOfMovie
	ENDIF

;
; pascal void GoToEndOfMovie(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GoToEndOfMovie
			moveq           	#14,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GoToEndOfMovie
	ENDIF

;
; pascal Boolean IsMovieDone(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IsMovieDone
			move.w              #$00DD,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsMovieDone
	ENDIF

;
; pascal Boolean GetMoviePreviewMode(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePreviewMode
			moveq           	#15,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePreviewMode
	ENDIF

;
; pascal void SetMoviePreviewMode(Movie theMovie, Boolean usePreview)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePreviewMode
			moveq           	#16,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePreviewMode
	ENDIF

;
; pascal void ShowMoviePoster(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ShowMoviePoster
			moveq           	#17,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ShowMoviePoster
	ENDIF

;
; pascal void PlayMoviePreview(Movie theMovie, MoviePreviewCallOutUPP callOutProc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PlayMoviePreview
			move.w              #$00F2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PlayMoviePreview
	ENDIF

; *************************
;* calls for controlling movies & tracks which are playing
;*************************

;
; pascal TimeBase GetMovieTimeBase(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieTimeBase
			moveq           	#18,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieTimeBase
	ENDIF

;
; pascal void SetMovieMasterTimeBase(Movie theMovie, TimeBase tb, const TimeRecord *slaveZero)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieMasterTimeBase
			move.w              #$0167,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieMasterTimeBase
	ENDIF

;
; pascal void SetMovieMasterClock(Movie theMovie, Component clockMeister, const TimeRecord *slaveZero)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieMasterClock
			move.w              #$0168,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieMasterClock
	ENDIF

;
; pascal void GetMovieGWorld(Movie theMovie, CGrafPtr *port, GDHandle *gdh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieGWorld
			moveq           	#21,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieGWorld
	ENDIF

;
; pascal void SetMovieGWorld(Movie theMovie, CGrafPtr port, GDHandle gdh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieGWorld
			moveq           	#22,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieGWorld
	ENDIF


movieDrawingCallWhenChanged		EQU		0
movieDrawingCallAlways			EQU		1
;
; pascal void SetMovieDrawingCompleteProc(Movie theMovie, long flags, MovieDrawingCompleteUPP proc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieDrawingCompleteProc
			move.w              #$01DE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieDrawingCompleteProc
	ENDIF


;
; pascal void GetMovieNaturalBoundsRect(Movie theMovie, Rect *naturalBounds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieNaturalBoundsRect
			move.w              #$022C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieNaturalBoundsRect
	ENDIF

;
; pascal Track GetNextTrackForCompositing(Movie theMovie, Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetNextTrackForCompositing
			move.w              #$01FA,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetNextTrackForCompositing
	ENDIF

;
; pascal Track GetPrevTrackForCompositing(Movie theMovie, Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetPrevTrackForCompositing
			move.w              #$01FB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPrevTrackForCompositing
	ENDIF

;
; pascal OSErr SetMovieCompositeBufferFlags(Movie theMovie, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieCompositeBufferFlags
			move.w              #$027E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieCompositeBufferFlags
	ENDIF

;
; pascal OSErr GetMovieCompositeBufferFlags(Movie theMovie, long *flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieCompositeBufferFlags
			move.w              #$027F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieCompositeBufferFlags
	ENDIF

;
; pascal void SetTrackGWorld(Track theTrack, CGrafPtr port, GDHandle gdh, TrackTransferUPP proc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackGWorld
			move.w              #$009D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackGWorld
	ENDIF

;
; pascal PicHandle GetMoviePict(Movie theMovie, TimeValue time)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePict
			moveq           	#29,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePict
	ENDIF

;
; pascal PicHandle GetTrackPict(Track theTrack, TimeValue time)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackPict
			moveq           	#30,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackPict
	ENDIF

;
; pascal PicHandle GetMoviePosterPict(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePosterPict
			move.w              #$00F7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePosterPict
	ENDIF

;  called between Begin & EndUpdate 
;
; pascal OSErr UpdateMovie(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UpdateMovie
			moveq           	#31,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UpdateMovie
	ENDIF

;
; pascal OSErr InvalidateMovieRegion(Movie theMovie, RgnHandle invalidRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InvalidateMovieRegion
			move.w              #$022A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvalidateMovieRegion
	ENDIF

; *** spatial movie routines ***
;
; pascal void GetMovieBox(Movie theMovie, Rect *boxRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieBox
			move.w              #$00F9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieBox
	ENDIF

;
; pascal void SetMovieBox(Movie theMovie, const Rect *boxRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieBox
			move.w              #$00FA,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieBox
	ENDIF

; * movie display clip 
;
; pascal RgnHandle GetMovieDisplayClipRgn(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieDisplayClipRgn
			move.w              #$00FC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieDisplayClipRgn
	ENDIF

;
; pascal void SetMovieDisplayClipRgn(Movie theMovie, RgnHandle theClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieDisplayClipRgn
			move.w              #$00FD,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieDisplayClipRgn
	ENDIF

; * movie src clip 
;
; pascal RgnHandle GetMovieClipRgn(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieClipRgn
			move.w              #$0100,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieClipRgn
	ENDIF

;
; pascal void SetMovieClipRgn(Movie theMovie, RgnHandle theClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieClipRgn
			move.w              #$0101,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieClipRgn
	ENDIF

; * track src clip 
;
; pascal RgnHandle GetTrackClipRgn(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackClipRgn
			move.w              #$0102,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackClipRgn
	ENDIF

;
; pascal void SetTrackClipRgn(Track theTrack, RgnHandle theClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackClipRgn
			move.w              #$0103,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackClipRgn
	ENDIF

; * bounds in display space (not clipped by display clip) 
;
; pascal RgnHandle GetMovieDisplayBoundsRgn(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieDisplayBoundsRgn
			move.w              #$00FB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieDisplayBoundsRgn
	ENDIF

;
; pascal RgnHandle GetTrackDisplayBoundsRgn(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackDisplayBoundsRgn
			move.w              #$0112,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackDisplayBoundsRgn
	ENDIF

; * bounds in movie space 
;
; pascal RgnHandle GetMovieBoundsRgn(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieBoundsRgn
			move.w              #$00FE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieBoundsRgn
	ENDIF

;
; pascal RgnHandle GetTrackMovieBoundsRgn(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackMovieBoundsRgn
			move.w              #$00FF,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackMovieBoundsRgn
	ENDIF

; * bounds in track space 
;
; pascal RgnHandle GetTrackBoundsRgn(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackBoundsRgn
			move.w              #$0111,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackBoundsRgn
	ENDIF

; * mattes - always in track space 
;
; pascal PixMapHandle GetTrackMatte(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackMatte
			move.w              #$0115,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackMatte
	ENDIF

;
; pascal void SetTrackMatte(Track theTrack, PixMapHandle theMatte)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackMatte
			move.w              #$0116,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackMatte
	ENDIF

;
; pascal void DisposeMatte(PixMapHandle theMatte)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeMatte
			move.w              #$014A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeMatte
	ENDIF

; *************************
;* calls for getting/saving movies
;*************************

;
; pascal Movie NewMovie(long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovie
			move.w              #$0187,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovie
	ENDIF

;
; pascal OSErr PutMovieIntoHandle(Movie theMovie, Handle publicMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PutMovieIntoHandle
			moveq           	#34,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutMovieIntoHandle
	ENDIF

;
; pascal OSErr PutMovieIntoDataFork(Movie theMovie, short fRefNum, long offset, long maxSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PutMovieIntoDataFork
			move.w              #$01B4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutMovieIntoDataFork
	ENDIF

;
; pascal void DisposeMovie(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeMovie
			moveq           	#35,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeMovie
	ENDIF

; *************************
;* Movie State Routines
;*************************

;
; pascal unsigned long GetMovieCreationTime(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieCreationTime
			moveq           	#38,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieCreationTime
	ENDIF

;
; pascal unsigned long GetMovieModificationTime(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieModificationTime
			moveq           	#39,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieModificationTime
	ENDIF

;
; pascal TimeScale GetMovieTimeScale(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieTimeScale
			moveq           	#41,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieTimeScale
	ENDIF

;
; pascal void SetMovieTimeScale(Movie theMovie, TimeScale timeScale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieTimeScale
			moveq           	#42,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieTimeScale
	ENDIF

;
; pascal TimeValue GetMovieDuration(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieDuration
			moveq           	#43,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieDuration
	ENDIF

;
; pascal Fixed GetMovieRate(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieRate
			moveq           	#44,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieRate
	ENDIF

;
; pascal void SetMovieRate(Movie theMovie, Fixed rate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieRate
			moveq           	#45,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieRate
	ENDIF

;
; pascal Fixed GetMoviePreferredRate(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePreferredRate
			move.w              #$00F3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePreferredRate
	ENDIF

;
; pascal void SetMoviePreferredRate(Movie theMovie, Fixed rate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePreferredRate
			move.w              #$00F4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePreferredRate
	ENDIF

;
; pascal short GetMoviePreferredVolume(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePreferredVolume
			move.w              #$00F5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePreferredVolume
	ENDIF

;
; pascal void SetMoviePreferredVolume(Movie theMovie, short volume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePreferredVolume
			move.w              #$00F6,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePreferredVolume
	ENDIF

;
; pascal short GetMovieVolume(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieVolume
			moveq           	#46,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieVolume
	ENDIF

;
; pascal void SetMovieVolume(Movie theMovie, short volume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieVolume
			moveq           	#47,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieVolume
	ENDIF

;
; pascal void GetMovieMatrix(Movie theMovie, MatrixRecord *matrix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieMatrix
			moveq           	#49,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieMatrix
	ENDIF

;
; pascal void SetMovieMatrix(Movie theMovie, const MatrixRecord *matrix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieMatrix
			moveq           	#50,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieMatrix
	ENDIF

;
; pascal void GetMoviePreviewTime(Movie theMovie, TimeValue *previewTime, TimeValue *previewDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePreviewTime
			moveq           	#51,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePreviewTime
	ENDIF

;
; pascal void SetMoviePreviewTime(Movie theMovie, TimeValue previewTime, TimeValue previewDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePreviewTime
			moveq           	#52,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePreviewTime
	ENDIF

;
; pascal TimeValue GetMoviePosterTime(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePosterTime
			moveq           	#53,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePosterTime
	ENDIF

;
; pascal void SetMoviePosterTime(Movie theMovie, TimeValue posterTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePosterTime
			moveq           	#54,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePosterTime
	ENDIF

;
; pascal void GetMovieSelection(Movie theMovie, TimeValue *selectionTime, TimeValue *selectionDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieSelection
			moveq           	#55,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieSelection
	ENDIF

;
; pascal void SetMovieSelection(Movie theMovie, TimeValue selectionTime, TimeValue selectionDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieSelection
			moveq           	#56,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieSelection
	ENDIF

;
; pascal void SetMovieActiveSegment(Movie theMovie, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieActiveSegment
			move.w              #$015C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieActiveSegment
	ENDIF

;
; pascal void GetMovieActiveSegment(Movie theMovie, TimeValue *startTime, TimeValue *duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieActiveSegment
			move.w              #$015D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieActiveSegment
	ENDIF

;
; pascal TimeValue GetMovieTime(Movie theMovie, TimeRecord *currentTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieTime
			moveq           	#57,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieTime
	ENDIF

;
; pascal void SetMovieTime(Movie theMovie, const TimeRecord *newtime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieTime
			moveq           	#60,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieTime
	ENDIF

;
; pascal void SetMovieTimeValue(Movie theMovie, TimeValue newtime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieTimeValue
			moveq           	#61,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieTimeValue
	ENDIF


;
; pascal UserData GetMovieUserData(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieUserData
			moveq           	#62,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieUserData
	ENDIF


; *************************
;* Track/Media finding routines
;*************************

;
; pascal long GetMovieTrackCount(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieTrackCount
			moveq           	#63,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieTrackCount
	ENDIF

;
; pascal Track GetMovieTrack(Movie theMovie, long trackID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieTrack
			moveq           	#64,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieTrack
	ENDIF

;
; pascal Track GetMovieIndTrack(Movie theMovie, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieIndTrack
			move.w              #$0117,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieIndTrack
	ENDIF

;
; pascal Track GetMovieIndTrackType(Movie theMovie, long index, OSType trackType, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieIndTrackType
			move.w              #$0208,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieIndTrackType
	ENDIF

;
; pascal long GetTrackID(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackID
			move.w              #$0127,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackID
	ENDIF

;
; pascal Movie GetTrackMovie(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackMovie
			move.w              #$00D0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackMovie
	ENDIF

; *************************
;* Track creation routines
;*************************

;
; pascal Track NewMovieTrack(Movie theMovie, Fixed width, Fixed height, short trackVolume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieTrack
			move.w              #$0188,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieTrack
	ENDIF

;
; pascal void DisposeMovieTrack(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeMovieTrack
			moveq           	#66,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeMovieTrack
	ENDIF

; *************************
;* Track State routines
;*************************

;
; pascal unsigned long GetTrackCreationTime(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackCreationTime
			moveq           	#67,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackCreationTime
	ENDIF

;
; pascal unsigned long GetTrackModificationTime(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackModificationTime
			moveq           	#68,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackModificationTime
	ENDIF


;
; pascal Boolean GetTrackEnabled(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackEnabled
			moveq           	#69,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackEnabled
	ENDIF

;
; pascal void SetTrackEnabled(Track theTrack, Boolean isEnabled)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackEnabled
			moveq           	#70,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackEnabled
	ENDIF

;
; pascal long GetTrackUsage(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackUsage
			moveq           	#71,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackUsage
	ENDIF

;
; pascal void SetTrackUsage(Track theTrack, long usage)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackUsage
			moveq           	#72,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackUsage
	ENDIF

;
; pascal TimeValue GetTrackDuration(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackDuration
			moveq           	#75,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackDuration
	ENDIF

;
; pascal TimeValue GetTrackOffset(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackOffset
			moveq           	#76,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackOffset
	ENDIF

;
; pascal void SetTrackOffset(Track theTrack, TimeValue movieOffsetTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackOffset
			moveq           	#77,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackOffset
	ENDIF

;
; pascal short GetTrackLayer(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackLayer
			moveq           	#80,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackLayer
	ENDIF

;
; pascal void SetTrackLayer(Track theTrack, short layer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackLayer
			moveq           	#81,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackLayer
	ENDIF

;
; pascal Track GetTrackAlternate(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackAlternate
			moveq           	#82,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackAlternate
	ENDIF

;
; pascal void SetTrackAlternate(Track theTrack, Track alternateT)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackAlternate
			moveq           	#83,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackAlternate
	ENDIF

;
; pascal void SetAutoTrackAlternatesEnabled(Movie theMovie, Boolean enable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetAutoTrackAlternatesEnabled
			move.w              #$015E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetAutoTrackAlternatesEnabled
	ENDIF

;
; pascal void SelectMovieAlternates(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SelectMovieAlternates
			move.w              #$015F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SelectMovieAlternates
	ENDIF

;
; pascal short GetTrackVolume(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackVolume
			moveq           	#84,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackVolume
	ENDIF

;
; pascal void SetTrackVolume(Track theTrack, short volume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackVolume
			moveq           	#85,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackVolume
	ENDIF

;
; pascal void GetTrackMatrix(Track theTrack, MatrixRecord *matrix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackMatrix
			moveq           	#86,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackMatrix
	ENDIF

;
; pascal void SetTrackMatrix(Track theTrack, const MatrixRecord *matrix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackMatrix
			moveq           	#87,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackMatrix
	ENDIF

;
; pascal void GetTrackDimensions(Track theTrack, Fixed *width, Fixed *height)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackDimensions
			moveq           	#93,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackDimensions
	ENDIF

;
; pascal void SetTrackDimensions(Track theTrack, Fixed width, Fixed height)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackDimensions
			moveq           	#94,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackDimensions
	ENDIF

;
; pascal UserData GetTrackUserData(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackUserData
			moveq           	#95,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackUserData
	ENDIF

;
; pascal OSErr GetTrackDisplayMatrix(Track theTrack, MatrixRecord *matrix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackDisplayMatrix
			move.w              #$0263,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackDisplayMatrix
	ENDIF

;
; pascal OSErr GetTrackSoundLocalizationSettings(Track theTrack, Handle *settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackSoundLocalizationSettings
			move.w              #$0282,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackSoundLocalizationSettings
	ENDIF

;
; pascal OSErr SetTrackSoundLocalizationSettings(Track theTrack, Handle settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackSoundLocalizationSettings
			move.w              #$0283,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackSoundLocalizationSettings
	ENDIF

; *************************
;* get Media routines
;*************************

;
; pascal Media NewTrackMedia(Track theTrack, OSType mediaType, TimeScale timeScale, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewTrackMedia
			move.w              #$018E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewTrackMedia
	ENDIF

;
; pascal void DisposeTrackMedia(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeTrackMedia
			moveq           	#97,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeTrackMedia
	ENDIF

;
; pascal Media GetTrackMedia(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackMedia
			moveq           	#98,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackMedia
	ENDIF

;
; pascal Track GetMediaTrack(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaTrack
			move.w              #$00C5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaTrack
	ENDIF



; *************************
;* Media State routines
;*************************

;
; pascal unsigned long GetMediaCreationTime(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaCreationTime
			moveq           	#102,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaCreationTime
	ENDIF

;
; pascal unsigned long GetMediaModificationTime(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaModificationTime
			moveq           	#103,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaModificationTime
	ENDIF

;
; pascal TimeScale GetMediaTimeScale(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaTimeScale
			moveq           	#104,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaTimeScale
	ENDIF

;
; pascal void SetMediaTimeScale(Media theMedia, TimeScale timeScale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaTimeScale
			moveq           	#105,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaTimeScale
	ENDIF

;
; pascal TimeValue GetMediaDuration(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDuration
			moveq           	#106,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDuration
	ENDIF

;
; pascal short GetMediaLanguage(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaLanguage
			moveq           	#107,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaLanguage
	ENDIF

;
; pascal void SetMediaLanguage(Media theMedia, short language)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaLanguage
			moveq           	#108,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaLanguage
	ENDIF

;
; pascal short GetMediaQuality(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaQuality
			moveq           	#109,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaQuality
	ENDIF

;
; pascal void SetMediaQuality(Media theMedia, short quality)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaQuality
			moveq           	#110,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaQuality
	ENDIF

;
; pascal void GetMediaHandlerDescription(Media theMedia, OSType *mediaType, Str255 creatorName, OSType *creatorManufacturer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaHandlerDescription
			moveq           	#111,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaHandlerDescription
	ENDIF

;
; pascal UserData GetMediaUserData(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaUserData
			moveq           	#112,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaUserData
	ENDIF

;
; pascal OSErr GetMediaInputMap(Media theMedia, QTAtomContainer *inputMap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaInputMap
			move.w              #$0249,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaInputMap
	ENDIF

;
; pascal OSErr SetMediaInputMap(Media theMedia, QTAtomContainer inputMap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaInputMap
			move.w              #$024A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaInputMap
	ENDIF

; *************************
;* Media Handler routines
;*************************

;
; pascal MediaHandler GetMediaHandler(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaHandler
			moveq           	#113,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaHandler
	ENDIF

;
; pascal OSErr SetMediaHandler(Media theMedia, MediaHandlerComponent mH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaHandler
			move.w              #$0190,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaHandler
	ENDIF


; *************************
;* Media's Data routines
;*************************

;
; pascal OSErr BeginMediaEdits(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_BeginMediaEdits
			moveq           	#114,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BeginMediaEdits
	ENDIF

;
; pascal OSErr EndMediaEdits(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_EndMediaEdits
			moveq           	#115,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EndMediaEdits
	ENDIF

;
; pascal OSErr SetMediaDefaultDataRefIndex(Media theMedia, short index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaDefaultDataRefIndex
			move.w              #$01E0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaDefaultDataRefIndex
	ENDIF

;
; pascal void GetMediaDataHandlerDescription(Media theMedia, short index, OSType *dhType, Str255 creatorName, OSType *creatorManufacturer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDataHandlerDescription
			move.w              #$019E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDataHandlerDescription
	ENDIF

;
; pascal DataHandler GetMediaDataHandler(Media theMedia, short index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDataHandler
			move.w              #$019F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDataHandler
	ENDIF

;
; pascal OSErr SetMediaDataHandler(Media theMedia, short index, DataHandlerComponent dataHandler)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaDataHandler
			move.w              #$01A0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaDataHandler
	ENDIF

;
; pascal Component GetDataHandler(Handle dataRef, OSType dataHandlerSubType, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetDataHandler
			move.w              #$01ED,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetDataHandler
	ENDIF


; *************************
;* Media Sample Table Routines
;*************************

;
; pascal long GetMediaSampleDescriptionCount(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSampleDescriptionCount
			moveq           	#119,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSampleDescriptionCount
	ENDIF

;
; pascal void GetMediaSampleDescription(Media theMedia, long index, SampleDescriptionHandle descH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSampleDescription
			moveq           	#120,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSampleDescription
	ENDIF

;
; pascal OSErr SetMediaSampleDescription(Media theMedia, long index, SampleDescriptionHandle descH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaSampleDescription
			move.w              #$01D0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaSampleDescription
	ENDIF

;
; pascal long GetMediaSampleCount(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSampleCount
			moveq           	#121,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSampleCount
	ENDIF

;
; pascal void SampleNumToMediaTime(Media theMedia, long logicalSampleNum, TimeValue *sampleTime, TimeValue *sampleDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SampleNumToMediaTime
			moveq           	#122,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SampleNumToMediaTime
	ENDIF

;
; pascal void MediaTimeToSampleNum(Media theMedia, TimeValue time, long *sampleNum, TimeValue *sampleTime, TimeValue *sampleDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MediaTimeToSampleNum
			moveq           	#123,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MediaTimeToSampleNum
	ENDIF


;
; pascal OSErr AddMediaSample(Media theMedia, Handle dataIn, long inOffset, unsigned long size, TimeValue durationPerSample, SampleDescriptionHandle sampleDescriptionH, long numberOfSamples, short sampleFlags, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMediaSample
			moveq           	#124,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMediaSample
	ENDIF

;
; pascal OSErr AddMediaSampleReference(Media theMedia, long dataOffset, unsigned long size, TimeValue durationPerSample, SampleDescriptionHandle sampleDescriptionH, long numberOfSamples, short sampleFlags, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMediaSampleReference
			moveq           	#125,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMediaSampleReference
	ENDIF

;
; pascal OSErr AddMediaSampleReferences(Media theMedia, SampleDescriptionHandle sampleDescriptionH, long numberOfSamples, SampleReferencePtr sampleRefs, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMediaSampleReferences
			move.w              #$01F7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMediaSampleReferences
	ENDIF

;
; pascal OSErr GetMediaSample(Media theMedia, Handle dataOut, long maxSizeToGrow, long *size, TimeValue time, TimeValue *sampleTime, TimeValue *durationPerSample, SampleDescriptionHandle sampleDescriptionH, long *sampleDescriptionIndex, long maxNumberOfSamples, long *numberOfSamples, short *sampleFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSample
			moveq           	#126,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSample
	ENDIF

;
; pascal OSErr GetMediaSampleReference(Media theMedia, long *dataOffset, long *size, TimeValue time, TimeValue *sampleTime, TimeValue *durationPerSample, SampleDescriptionHandle sampleDescriptionH, long *sampleDescriptionIndex, long maxNumberOfSamples, long *numberOfSamples, short *sampleFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSampleReference
			moveq           	#127,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSampleReference
	ENDIF

;
; pascal OSErr GetMediaSampleReferences(Media theMedia, TimeValue time, TimeValue *sampleTime, SampleDescriptionHandle sampleDescriptionH, long *sampleDescriptionIndex, long maxNumberOfEntries, long *actualNumberofEntries, SampleReferencePtr sampleRefs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSampleReferences
			move.w              #$0235,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSampleReferences
	ENDIF

;
; pascal OSErr SetMediaPreferredChunkSize(Media theMedia, long maxChunkSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaPreferredChunkSize
			move.w              #$01F8,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaPreferredChunkSize
	ENDIF

;
; pascal OSErr GetMediaPreferredChunkSize(Media theMedia, long *maxChunkSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaPreferredChunkSize
			move.w              #$01F9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaPreferredChunkSize
	ENDIF

;
; pascal OSErr SetMediaShadowSync(Media theMedia, long frameDiffSampleNum, long syncSampleNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaShadowSync
			move.w              #$0121,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaShadowSync
	ENDIF

;
; pascal OSErr GetMediaShadowSync(Media theMedia, long frameDiffSampleNum, long *syncSampleNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaShadowSync
			move.w              #$0122,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaShadowSync
	ENDIF

; *************************
;* Editing Routines
;*************************

;
; pascal OSErr InsertMediaIntoTrack(Track theTrack, TimeValue trackStart, TimeValue mediaTime, TimeValue mediaDuration, Fixed mediaRate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InsertMediaIntoTrack
			move.w              #$0183,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InsertMediaIntoTrack
	ENDIF

;
; pascal OSErr InsertTrackSegment(Track srcTrack, Track dstTrack, TimeValue srcIn, TimeValue srcDuration, TimeValue dstIn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InsertTrackSegment
			move.w              #$0085,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InsertTrackSegment
	ENDIF

;
; pascal OSErr InsertMovieSegment(Movie srcMovie, Movie dstMovie, TimeValue srcIn, TimeValue srcDuration, TimeValue dstIn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InsertMovieSegment
			move.w              #$0086,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InsertMovieSegment
	ENDIF

;
; pascal OSErr InsertEmptyTrackSegment(Track dstTrack, TimeValue dstIn, TimeValue dstDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InsertEmptyTrackSegment
			move.w              #$0087,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InsertEmptyTrackSegment
	ENDIF

;
; pascal OSErr InsertEmptyMovieSegment(Movie dstMovie, TimeValue dstIn, TimeValue dstDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InsertEmptyMovieSegment
			move.w              #$0088,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InsertEmptyMovieSegment
	ENDIF

;
; pascal OSErr DeleteTrackSegment(Track theTrack, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DeleteTrackSegment
			move.w              #$0089,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeleteTrackSegment
	ENDIF

;
; pascal OSErr DeleteMovieSegment(Movie theMovie, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DeleteMovieSegment
			move.w              #$008A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeleteMovieSegment
	ENDIF

;
; pascal OSErr ScaleTrackSegment(Track theTrack, TimeValue startTime, TimeValue oldDuration, TimeValue newDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ScaleTrackSegment
			move.w              #$008B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ScaleTrackSegment
	ENDIF

;
; pascal OSErr ScaleMovieSegment(Movie theMovie, TimeValue startTime, TimeValue oldDuration, TimeValue newDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ScaleMovieSegment
			move.w              #$008C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ScaleMovieSegment
	ENDIF


; *************************
;* Hi-level Editing Routines
;*************************

;
; pascal Movie CutMovieSelection(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CutMovieSelection
			move.w              #$008D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CutMovieSelection
	ENDIF

;
; pascal Movie CopyMovieSelection(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CopyMovieSelection
			move.w              #$008E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyMovieSelection
	ENDIF

;
; pascal void PasteMovieSelection(Movie theMovie, Movie src)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PasteMovieSelection
			move.w              #$008F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PasteMovieSelection
	ENDIF

;
; pascal void AddMovieSelection(Movie theMovie, Movie src)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMovieSelection
			move.w              #$0152,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMovieSelection
	ENDIF

;
; pascal void ClearMovieSelection(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClearMovieSelection
			move.w              #$00E1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClearMovieSelection
	ENDIF

;
; pascal OSErr PasteHandleIntoMovie(Handle h, OSType handleType, Movie theMovie, long flags, ComponentInstance userComp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PasteHandleIntoMovie
			move.w              #$00CB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PasteHandleIntoMovie
	ENDIF

;
; pascal OSErr PutMovieIntoTypedHandle(Movie theMovie, Track targetTrack, OSType handleType, Handle publicMovie, TimeValue start, TimeValue dur, long flags, ComponentInstance userComp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PutMovieIntoTypedHandle
			move.w              #$01CD,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutMovieIntoTypedHandle
	ENDIF

;
; pascal Component IsScrapMovie(Track targetTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IsScrapMovie
			move.w              #$00CC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsScrapMovie
	ENDIF

; *************************
;* Middle-level Editing Routines
;*************************

;
; pascal OSErr CopyTrackSettings(Track srcTrack, Track dstTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CopyTrackSettings
			move.w              #$0153,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyTrackSettings
	ENDIF

;
; pascal OSErr CopyMovieSettings(Movie srcMovie, Movie dstMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CopyMovieSettings
			move.w              #$0154,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyMovieSettings
	ENDIF

;
; pascal OSErr AddEmptyTrackToMovie(Track srcTrack, Movie dstMovie, Handle dataRef, OSType dataRefType, Track *dstTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddEmptyTrackToMovie
			moveq           	#116,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddEmptyTrackToMovie
	ENDIF

; *************************
;* movie & track edit state routines
;*************************

;
; pascal MovieEditState NewMovieEditState(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieEditState
			move.w              #$0104,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieEditState
	ENDIF

;
; pascal OSErr UseMovieEditState(Movie theMovie, MovieEditState toState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UseMovieEditState
			move.w              #$0105,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UseMovieEditState
	ENDIF

;
; pascal OSErr DisposeMovieEditState(MovieEditState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeMovieEditState
			move.w              #$0106,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeMovieEditState
	ENDIF

;
; pascal TrackEditState NewTrackEditState(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewTrackEditState
			move.w              #$0107,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewTrackEditState
	ENDIF

;
; pascal OSErr UseTrackEditState(Track theTrack, TrackEditState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UseTrackEditState
			move.w              #$0108,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UseTrackEditState
	ENDIF

;
; pascal OSErr DisposeTrackEditState(TrackEditState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeTrackEditState
			move.w              #$0109,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeTrackEditState
	ENDIF

; *************************
;* track reference routines
;*************************

;
; pascal OSErr AddTrackReference(Track theTrack, Track refTrack, OSType refType, long *addedIndex)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddTrackReference
			move.w              #$01F0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddTrackReference
	ENDIF

;
; pascal OSErr DeleteTrackReference(Track theTrack, OSType refType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DeleteTrackReference
			move.w              #$01F1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeleteTrackReference
	ENDIF

;
; pascal OSErr SetTrackReference(Track theTrack, Track refTrack, OSType refType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackReference
			move.w              #$01F2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackReference
	ENDIF

;
; pascal Track GetTrackReference(Track theTrack, OSType refType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackReference
			move.w              #$01F3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackReference
	ENDIF

;
; pascal OSType GetNextTrackReferenceType(Track theTrack, OSType refType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetNextTrackReferenceType
			move.w              #$01F4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetNextTrackReferenceType
	ENDIF

;
; pascal long GetTrackReferenceCount(Track theTrack, OSType refType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackReferenceCount
			move.w              #$01F5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackReferenceCount
	ENDIF


; *************************
;* high level file conversion routines
;*************************

;
; pascal OSErr ConvertFileToMovieFile(const FSSpec *inputFile, const FSSpec *outputFile, OSType creator, ScriptCode scriptTag, short *resID, long flags, ComponentInstance userComp, MovieProgressUPP proc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ConvertFileToMovieFile
			move.w              #$01CB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ConvertFileToMovieFile
	ENDIF

;
; pascal OSErr ConvertMovieToFile(Movie theMovie, Track onlyTrack, FSSpec *outputFile, OSType fileType, OSType creator, ScriptCode scriptTag, short *resID, long flags, ComponentInstance userComp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ConvertMovieToFile
			move.w              #$01CC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ConvertMovieToFile
	ENDIF

; *************************
;* Movie Timebase Conversion Routines
;*************************

;
; pascal TimeValue TrackTimeToMediaTime(TimeValue value, Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TrackTimeToMediaTime
			move.w              #$0096,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TrackTimeToMediaTime
	ENDIF

;
; pascal Fixed GetTrackEditRate(Track theTrack, TimeValue atTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackEditRate
			move.w              #$0123,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackEditRate
	ENDIF


; *************************
;* Miscellaneous Routines
;*************************


;
; pascal long GetMovieDataSize(Movie theMovie, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieDataSize
			move.w              #$0098,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieDataSize
	ENDIF

;
; pascal long GetTrackDataSize(Track theTrack, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackDataSize
			move.w              #$0149,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackDataSize
	ENDIF

;
; pascal long GetMediaDataSize(Media theMedia, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDataSize
			move.w              #$0099,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDataSize
	ENDIF

;
; pascal Boolean PtInMovie(Movie theMovie, Point pt)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PtInMovie
			move.w              #$009A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PtInMovie
	ENDIF

;
; pascal Boolean PtInTrack(Track theTrack, Point pt)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PtInTrack
			move.w              #$009B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PtInTrack
	ENDIF


; *************************
;* Group Selection Routines
;*************************


;
; pascal void SetMovieLanguage(Movie theMovie, long language)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieLanguage
			move.w              #$009C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieLanguage
	ENDIF


; *************************
;* User Data
;*************************


;
; pascal OSErr GetUserData(UserData theUserData, Handle data, OSType udType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetUserData
			move.w              #$009E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetUserData
	ENDIF

;
; pascal OSErr AddUserData(UserData theUserData, Handle data, OSType udType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddUserData
			move.w              #$009F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddUserData
	ENDIF

;
; pascal OSErr RemoveUserData(UserData theUserData, OSType udType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RemoveUserData
			move.w              #$00A0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveUserData
	ENDIF

;
; pascal short CountUserDataType(UserData theUserData, OSType udType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CountUserDataType
			move.w              #$014B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CountUserDataType
	ENDIF

;
; pascal long GetNextUserDataType(UserData theUserData, OSType udType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetNextUserDataType
			move.w              #$01A5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetNextUserDataType
	ENDIF

;
; pascal OSErr GetUserDataItem(UserData theUserData, void *data, long size, OSType udType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetUserDataItem
			move.w              #$0126,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetUserDataItem
	ENDIF

;
; pascal OSErr SetUserDataItem(UserData theUserData, void *data, long size, OSType udType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetUserDataItem
			move.w              #$012E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetUserDataItem
	ENDIF

;
; pascal OSErr AddUserDataText(UserData theUserData, Handle data, OSType udType, long index, short itlRegionTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddUserDataText
			move.w              #$014C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddUserDataText
	ENDIF

;
; pascal OSErr GetUserDataText(UserData theUserData, Handle data, OSType udType, long index, short itlRegionTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetUserDataText
			move.w              #$014D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetUserDataText
	ENDIF

;
; pascal OSErr RemoveUserDataText(UserData theUserData, OSType udType, long index, short itlRegionTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RemoveUserDataText
			move.w              #$014E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveUserDataText
	ENDIF

;
; pascal OSErr NewUserData(UserData *theUserData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewUserData
			move.w              #$012F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewUserData
	ENDIF

;
; pascal OSErr DisposeUserData(UserData theUserData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeUserData
			move.w              #$0130,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeUserData
	ENDIF

;
; pascal OSErr NewUserDataFromHandle(Handle h, UserData *theUserData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewUserDataFromHandle
			move.w              #$0131,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewUserDataFromHandle
	ENDIF

;
; pascal OSErr PutUserDataIntoHandle(UserData theUserData, Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PutUserDataIntoHandle
			move.w              #$0132,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutUserDataIntoHandle
	ENDIF

;
; pascal void GetMediaNextInterestingTime(Media theMedia, short interestingTimeFlags, TimeValue time, Fixed rate, TimeValue *interestingTime, TimeValue *interestingDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaNextInterestingTime
			move.w              #$016D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaNextInterestingTime
	ENDIF

;
; pascal void GetTrackNextInterestingTime(Track theTrack, short interestingTimeFlags, TimeValue time, Fixed rate, TimeValue *interestingTime, TimeValue *interestingDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackNextInterestingTime
			move.w              #$00E2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackNextInterestingTime
	ENDIF

;
; pascal void GetMovieNextInterestingTime(Movie theMovie, short interestingTimeFlags, short numMediaTypes, const OSType *whichMediaTypes, TimeValue time, Fixed rate, TimeValue *interestingTime, TimeValue *interestingDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieNextInterestingTime
			move.w              #$010E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieNextInterestingTime
	ENDIF


;
; pascal OSErr CreateMovieFile(const FSSpec *fileSpec, OSType creator, ScriptCode scriptTag, long createMovieFileFlags, short *resRefNum, Movie *newmovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CreateMovieFile
			move.w              #$0191,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CreateMovieFile
	ENDIF

;
; pascal OSErr OpenMovieFile(const FSSpec *fileSpec, short *resRefNum, SInt8 permission)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OpenMovieFile
			move.w              #$0192,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenMovieFile
	ENDIF

;
; pascal OSErr CloseMovieFile(short resRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CloseMovieFile
			move.w              #$00D5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CloseMovieFile
	ENDIF

;
; pascal OSErr DeleteMovieFile(const FSSpec *fileSpec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DeleteMovieFile
			move.w              #$0175,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeleteMovieFile
	ENDIF

;
; pascal OSErr NewMovieFromFile(Movie *theMovie, short resRefNum, short *resId, StringPtr resName, short newMovieFlags, Boolean *dataRefWasChanged)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromFile
			move.w              #$00F0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromFile
	ENDIF

;
; pascal OSErr NewMovieFromHandle(Movie *theMovie, Handle h, short newMovieFlags, Boolean *dataRefWasChanged)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromHandle
			move.w              #$00F1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromHandle
	ENDIF

;
; pascal OSErr NewMovieFromDataFork(Movie *theMovie, short fRefNum, long fileOffset, short newMovieFlags, Boolean *dataRefWasChanged)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromDataFork
			move.w              #$01B3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromDataFork
	ENDIF

;
; pascal OSErr NewMovieFromUserProc(Movie *m, short flags, Boolean *dataRefWasChanged, GetMovieUPP getProc, void *refCon, Handle defaultDataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromUserProc
			move.w              #$01EC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromUserProc
	ENDIF

;
; pascal OSErr NewMovieFromDataRef(Movie *m, short flags, short *id, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromDataRef
			move.w              #$0220,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromDataRef
	ENDIF

;
; pascal OSErr AddMovieResource(Movie theMovie, short resRefNum, short *resId, ConstStr255Param resName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMovieResource
			move.w              #$00D7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMovieResource
	ENDIF

;
; pascal OSErr UpdateMovieResource(Movie theMovie, short resRefNum, short resId, ConstStr255Param resName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UpdateMovieResource
			move.w              #$00D8,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UpdateMovieResource
	ENDIF

;
; pascal OSErr RemoveMovieResource(short resRefNum, short resId)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RemoveMovieResource
			move.w              #$0176,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveMovieResource
	ENDIF

;
; pascal Boolean HasMovieChanged(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_HasMovieChanged
			move.w              #$00D9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HasMovieChanged
	ENDIF

;
; pascal void ClearMovieChanged(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClearMovieChanged
			move.w              #$0113,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClearMovieChanged
	ENDIF

;
; pascal OSErr SetMovieDefaultDataRef(Movie theMovie, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieDefaultDataRef
			move.w              #$01C1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieDefaultDataRef
	ENDIF

;
; pascal OSErr GetMovieDefaultDataRef(Movie theMovie, Handle *dataRef, OSType *dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieDefaultDataRef
			move.w              #$01D2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieDefaultDataRef
	ENDIF

;
; pascal OSErr SetMovieColorTable(Movie theMovie, CTabHandle ctab)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieColorTable
			move.w              #$0205,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieColorTable
	ENDIF

;
; pascal OSErr GetMovieColorTable(Movie theMovie, CTabHandle *ctab)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieColorTable
			move.w              #$0206,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieColorTable
	ENDIF

;
; pascal void FlattenMovie(Movie theMovie, long movieFlattenFlags, const FSSpec *theFile, OSType creator, ScriptCode scriptTag, long createMovieFileFlags, short *resId, ConstStr255Param resName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlattenMovie
			move.w              #$019B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlattenMovie
	ENDIF

;
; pascal Movie FlattenMovieData(Movie theMovie, long movieFlattenFlags, const FSSpec *theFile, OSType creator, ScriptCode scriptTag, long createMovieFileFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlattenMovieData
			move.w              #$019C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlattenMovieData
	ENDIF

;
; pascal void SetMovieProgressProc(Movie theMovie, MovieProgressUPP p, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieProgressProc
			move.w              #$019A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieProgressProc
	ENDIF

;
; pascal OSErr MovieSearchText(Movie theMovie, Ptr text, long size, long searchFlags, Track *searchTrack, TimeValue *searchTime, long *searchOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieSearchText
			move.w              #$0207,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieSearchText
	ENDIF

;
; pascal void GetPosterBox(Movie theMovie, Rect *boxRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetPosterBox
			move.w              #$016F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPosterBox
	ENDIF

;
; pascal void SetPosterBox(Movie theMovie, const Rect *boxRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetPosterBox
			move.w              #$0170,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetPosterBox
	ENDIF

;
; pascal RgnHandle GetMovieSegmentDisplayBoundsRgn(Movie theMovie, TimeValue time, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieSegmentDisplayBoundsRgn
			move.w              #$016C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieSegmentDisplayBoundsRgn
	ENDIF

;
; pascal RgnHandle GetTrackSegmentDisplayBoundsRgn(Track theTrack, TimeValue time, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackSegmentDisplayBoundsRgn
			move.w              #$016B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackSegmentDisplayBoundsRgn
	ENDIF

;
; pascal void SetMovieCoverProcs(Movie theMovie, MovieRgnCoverUPP uncoverProc, MovieRgnCoverUPP coverProc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieCoverProcs
			move.w              #$0179,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieCoverProcs
	ENDIF

;
; pascal OSErr GetMovieCoverProcs(Movie theMovie, MovieRgnCoverUPP *uncoverProc, MovieRgnCoverUPP *coverProc, long *refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieCoverProcs
			move.w              #$01DD,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieCoverProcs
	ENDIF

;
; pascal ComponentResult GetTrackStatus(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackStatus
			move.w              #$0172,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackStatus
	ENDIF

;
; pascal ComponentResult GetMovieStatus(Movie theMovie, Track *firstProblemTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieStatus
			move.w              #$0173,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieStatus
	ENDIF

; ***
;	Movie Controller support routines
;***

;
; pascal ComponentInstance NewMovieController(Movie theMovie, const Rect *movieRect, long someFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieController
			move.w              #$018A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieController
	ENDIF

;
; pascal void DisposeMovieController(ComponentInstance mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeMovieController
			move.w              #$018B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeMovieController
	ENDIF

;
; pascal void ShowMovieInformation(Movie theMovie, ModalFilterUPP filterProc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ShowMovieInformation
			move.w              #$0209,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ShowMovieInformation
	ENDIF


; *****
;	Scrap routines
;****

;
; pascal OSErr PutMovieOnScrap(Movie theMovie, long movieScrapFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PutMovieOnScrap
			move.w              #$018C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutMovieOnScrap
	ENDIF

;
; pascal Movie NewMovieFromScrap(long newMovieFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromScrap
			move.w              #$018D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromScrap
	ENDIF


; *****
;	DataRef routines
;****


;
; pascal OSErr GetMediaDataRef(Media theMedia, short index, Handle *dataRef, OSType *dataRefType, long *dataRefAttributes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDataRef
			move.w              #$0197,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDataRef
	ENDIF

;
; pascal OSErr SetMediaDataRef(Media theMedia, short index, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaDataRef
			move.w              #$01C9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaDataRef
	ENDIF

;
; pascal OSErr SetMediaDataRefAttributes(Media theMedia, short index, long dataRefAttributes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaDataRefAttributes
			move.w              #$01CA,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaDataRefAttributes
	ENDIF

;
; pascal OSErr AddMediaDataRef(Media theMedia, short *index, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMediaDataRef
			move.w              #$0198,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMediaDataRef
	ENDIF

;
; pascal OSErr GetMediaDataRefCount(Media theMedia, short *count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDataRefCount
			move.w              #$0199,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDataRefCount
	ENDIF

; *****
;	Playback hint routines
;****

;
; pascal void SetMoviePlayHints(Movie theMovie, long flags, long flagsMask)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePlayHints
			move.w              #$01A1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePlayHints
	ENDIF

;
; pascal void SetMediaPlayHints(Media theMedia, long flags, long flagsMask)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaPlayHints
			move.w              #$01A2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaPlayHints
	ENDIF

; *****
;	Load time track hints
;****


preloadAlways					EQU		$00000001
preloadOnlyIfEnabled			EQU		$00000002
;
; pascal void SetTrackLoadSettings(Track theTrack, TimeValue preloadTime, TimeValue preloadDuration, long preloadFlags, long defaultHints)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackLoadSettings
			move.w              #$01E3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackLoadSettings
	ENDIF

;
; pascal void GetTrackLoadSettings(Track theTrack, TimeValue *preloadTime, TimeValue *preloadDuration, long *preloadFlags, long *defaultHints)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackLoadSettings
			move.w              #$01E4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackLoadSettings
	ENDIF

; *****
;	Big screen TV
;****


fullScreenHideCursor			EQU		$00000001
fullScreenAllowEvents			EQU		$00000002
fullScreenDontChangeMenuBar		EQU		$00000004
fullScreenPreflightSize			EQU		$00000008
;
; pascal OSErr BeginFullScreen(Ptr *restoreState, GDHandle whichGD, short *desiredWidth, short *desiredHeight, WindowPtr *newWindow, RGBColor *eraseColor, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_BeginFullScreen
			move.w              #$0233,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BeginFullScreen
	ENDIF

;
; pascal OSErr EndFullScreen(Ptr fullState, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_EndFullScreen
			move.w              #$0234,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EndFullScreen
	ENDIF

; *****
;	Sprite Toolbox
;****


kBackgroundSpriteLayerNum		EQU		32767
;   Sprite Properties

kSpritePropertyMatrix			EQU		1
kSpritePropertyImageDescription	EQU		2
kSpritePropertyImageDataPtr		EQU		3
kSpritePropertyVisible			EQU		4
kSpritePropertyLayer			EQU		5
kSpritePropertyGraphicsMode		EQU		6
kSpritePropertyImageIndex		EQU		100
kSpriteTrackPropertyBackgroundColor EQU	101
kSpriteTrackPropertyOffscreenBitDepth EQU 102
kSpriteTrackPropertySampleFormat EQU	103
;  flagsIn for SpriteWorldIdle

kOnlyDrawToSpriteWorld			EQU		$00000001
kSpriteWorldPreflight			EQU		$00000002
;  flagsOut for SpriteWorldIdle

kSpriteWorldDidDraw				EQU		$00000001
kSpriteWorldNeedsToDraw			EQU		$00000002
;  flags for sprite track sample format

kKeyFrameAndSingleOverride		EQU		$00000002
kKeyFrameAndAllOverrides		EQU		$00000004
;
; pascal OSErr NewSpriteWorld(SpriteWorld *newSpriteWorld, GWorldPtr destination, GWorldPtr spriteLayer, RGBColor *backgroundColor, GWorldPtr background)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewSpriteWorld
			move.w              #$0239,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewSpriteWorld
	ENDIF

;
; pascal void DisposeSpriteWorld(SpriteWorld theSpriteWorld)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeSpriteWorld
			move.w              #$023A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeSpriteWorld
	ENDIF

;
; pascal OSErr SetSpriteWorldClip(SpriteWorld theSpriteWorld, RgnHandle clipRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetSpriteWorldClip
			move.w              #$023B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSpriteWorldClip
	ENDIF

;
; pascal OSErr SetSpriteWorldMatrix(SpriteWorld theSpriteWorld, const MatrixRecord *matrix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetSpriteWorldMatrix
			move.w              #$023C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSpriteWorldMatrix
	ENDIF

;
; pascal OSErr SpriteWorldIdle(SpriteWorld theSpriteWorld, long flagsIn, long *flagsOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteWorldIdle
			move.w              #$023D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteWorldIdle
	ENDIF

;
; pascal OSErr InvalidateSpriteWorld(SpriteWorld theSpriteWorld, Rect *invalidArea)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InvalidateSpriteWorld
			move.w              #$023E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvalidateSpriteWorld
	ENDIF

;
; pascal OSErr SpriteWorldHitTest(SpriteWorld theSpriteWorld, long flags, Point loc, Sprite *spriteHit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteWorldHitTest
			move.w              #$0246,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteWorldHitTest
	ENDIF

;
; pascal OSErr SpriteHitTest(Sprite theSprite, long flags, Point loc, Boolean *wasHit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteHitTest
			move.w              #$0247,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteHitTest
	ENDIF

;
; pascal void DisposeAllSprites(SpriteWorld theSpriteWorld)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeAllSprites
			move.w              #$023F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeAllSprites
	ENDIF

;
; pascal OSErr NewSprite(Sprite *newSprite, SpriteWorld itsSpriteWorld, ImageDescriptionHandle idh, Ptr imageDataPtr, MatrixRecord *matrix, Boolean visible, short layer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewSprite
			move.w              #$0240,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewSprite
	ENDIF

;
; pascal void DisposeSprite(Sprite theSprite)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeSprite
			move.w              #$0241,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeSprite
	ENDIF

;
; pascal void InvalidateSprite(Sprite theSprite)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InvalidateSprite
			move.w              #$0242,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvalidateSprite
	ENDIF

;
; pascal OSErr SetSpriteProperty(Sprite theSprite, long propertyType, void *propertyValue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetSpriteProperty
			move.w              #$0243,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSpriteProperty
	ENDIF

;
; pascal OSErr GetSpriteProperty(Sprite theSprite, long propertyType, void *propertyValue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetSpriteProperty
			move.w              #$0244,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSpriteProperty
	ENDIF

; *****
;	QT Atom Data Support
;****


kParentAtomIsContainer			EQU		0
;  create and dispose QTAtomContainer objects

;
; pascal OSErr QTNewAtomContainer(QTAtomContainer *atomData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTNewAtomContainer
			move.w              #$020C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTNewAtomContainer
	ENDIF

;
; pascal OSErr QTDisposeAtomContainer(QTAtomContainer atomData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTDisposeAtomContainer
			move.w              #$020D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTDisposeAtomContainer
	ENDIF

;  locating nested atoms within QTAtomContainer container
;
; pascal QTAtomType QTGetNextChildType(QTAtomContainer container, QTAtom parentAtom, QTAtomType currentChildType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTGetNextChildType
			move.w              #$020E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTGetNextChildType
	ENDIF

;
; pascal short QTCountChildrenOfType(QTAtomContainer container, QTAtom parentAtom, QTAtomType childType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTCountChildrenOfType
			move.w              #$020F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTCountChildrenOfType
	ENDIF

;
; pascal QTAtom QTFindChildByIndex(QTAtomContainer container, QTAtom parentAtom, QTAtomType atomType, short index, QTAtomID *id)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTFindChildByIndex
			move.w              #$0210,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTFindChildByIndex
	ENDIF

;
; pascal QTAtom QTFindChildByID(QTAtomContainer container, QTAtom parentAtom, QTAtomType atomType, QTAtomID id, short *index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTFindChildByID
			move.w              #$021D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTFindChildByID
	ENDIF

;
; pascal OSErr QTNextChildAnyType(QTAtomContainer container, QTAtom parentAtom, QTAtom currentChild, QTAtom *nextChild)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTNextChildAnyType
			move.w              #$0200,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTNextChildAnyType
	ENDIF

;  set a leaf atom's data
;
; pascal OSErr QTSetAtomData(QTAtomContainer container, QTAtom atom, long dataSize, void *atomData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTSetAtomData
			move.w              #$0211,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTSetAtomData
	ENDIF

;  extracting data
;
; pascal OSErr QTCopyAtomDataToHandle(QTAtomContainer container, QTAtom atom, Handle targetHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTCopyAtomDataToHandle
			move.w              #$0212,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTCopyAtomDataToHandle
	ENDIF

;
; pascal OSErr QTCopyAtomDataToPtr(QTAtomContainer container, QTAtom atom, Boolean sizeOrLessOK, long size, void *targetPtr, long *actualSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTCopyAtomDataToPtr
			move.w              #$0213,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTCopyAtomDataToPtr
	ENDIF

;
; pascal OSErr QTGetAtomTypeAndID(QTAtomContainer container, QTAtom atom, QTAtomType *atomType, QTAtomID *id)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTGetAtomTypeAndID
			move.w              #$0232,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTGetAtomTypeAndID
	ENDIF

;  extract a copy of an atom and all of it's children, caller disposes
;
; pascal OSErr QTCopyAtom(QTAtomContainer container, QTAtom atom, QTAtomContainer *targetContainer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTCopyAtom
			move.w              #$0214,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTCopyAtom
	ENDIF

;  obtaining direct reference to atom data
;
; pascal OSErr QTLockContainer(QTAtomContainer container)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTLockContainer
			move.w              #$0215,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTLockContainer
	ENDIF

;
; pascal OSErr QTGetAtomDataPtr(QTAtomContainer container, QTAtom atom, long *dataSize, Ptr *atomData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTGetAtomDataPtr
			move.w              #$0216,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTGetAtomDataPtr
	ENDIF

;
; pascal OSErr QTUnlockContainer(QTAtomContainer container)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTUnlockContainer
			move.w              #$0217,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTUnlockContainer
	ENDIF


;   building QTAtomContainer trees
;   creates and inserts new atom at specified index, existing atoms at or after index are moved toward end of list
;   used for Top-Down tree creation


;
; pascal OSErr QTInsertChild(QTAtomContainer container, QTAtom parentAtom, QTAtomType atomType, QTAtomID id, short index, long dataSize, void *data, QTAtom *newAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTInsertChild
			move.w              #$0218,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTInsertChild
	ENDIF

;  inserts children from childrenContainer as children of parentAtom
;
; pascal OSErr QTInsertChildren(QTAtomContainer container, QTAtom parentAtom, QTAtomContainer childrenContainer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTInsertChildren
			move.w              #$0219,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTInsertChildren
	ENDIF

;  destruction
;
; pascal OSErr QTRemoveAtom(QTAtomContainer container, QTAtom atom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTRemoveAtom
			move.w              #$021A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTRemoveAtom
	ENDIF

;
; pascal OSErr QTRemoveChildren(QTAtomContainer container, QTAtom atom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTRemoveChildren
			move.w              #$021B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTRemoveChildren
	ENDIF

;  replacement must be same type as target
;
; pascal OSErr QTReplaceAtom(QTAtomContainer targetContainer, QTAtom targetAtom, QTAtomContainer replacementContainer, QTAtom replacementAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTReplaceAtom
			move.w              #$021C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTReplaceAtom
	ENDIF

;
; pascal OSErr QTSwapAtoms(QTAtomContainer container, QTAtom atom1, QTAtom atom2)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTSwapAtoms
			move.w              #$01FF,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTSwapAtoms
	ENDIF

;
; pascal OSErr QTSetAtomID(QTAtomContainer container, QTAtom atom, QTAtomID newID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTSetAtomID
			move.w              #$0231,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTSetAtomID
	ENDIF

;
; pascal OSErr SetMediaPropertyAtom(Media theMedia, QTAtomContainer propertyAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaPropertyAtom
			move.w              #$022E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaPropertyAtom
	ENDIF

;
; pascal OSErr GetMediaPropertyAtom(Media theMedia, QTAtomContainer *propertyAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaPropertyAtom
			move.w              #$022F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaPropertyAtom
	ENDIF


; *****
;	QT International Text Atom Support
;****


kITextRemoveEverythingBut		EQU		$00
kITextRemoveLeaveSuggestedAlternate EQU	$02

kITextAtomType					EQU		'itxt'
kITextStringAtomType			EQU		'text'
;
; pascal OSErr ITextAddString(QTAtomContainer container, QTAtom parentAtom, RegionCode theRegionCode, ConstStr255Param theString)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ITextAddString
			move.w              #$027A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ITextAddString
	ENDIF

;
; pascal OSErr ITextRemoveString(QTAtomContainer container, QTAtom parentAtom, RegionCode theRegionCode, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ITextRemoveString
			move.w              #$027B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ITextRemoveString
	ENDIF

;
; pascal OSErr ITextGetString(QTAtomContainer container, QTAtom parentAtom, RegionCode requestedRegion, RegionCode *foundRegion, StringPtr theString)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ITextGetString
			move.w              #$027C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ITextGetString
	ENDIF


; *************************
;* modifier track types
;*************************


kTrackModifierInput				EQU		$696E				; is really 'in'
kTrackModifierType				EQU		$7479				; is really 'ty'
kTrackModifierReference			EQU		'ssrc'
kTrackModifierObjectID			EQU		'obid'
kTrackModifierInputName			EQU		'name'

kInputMapSubInputID				EQU		'subi'

kTrackModifierTypeMatrix		EQU		1
kTrackModifierTypeClip			EQU		2
kTrackModifierTypeGraphicsMode	EQU		5
kTrackModifierTypeVolume		EQU		3
kTrackModifierTypeBalance		EQU		4
kTrackModifierTypeImage			EQU		'vide'				; was kTrackModifierTypeSpriteImage
kTrackModifierObjectMatrix		EQU		6
kTrackModifierObjectGraphicsMode EQU	7
kTrackModifierType3d4x4Matrix	EQU		8
kTrackModifierCameraData		EQU		9
kTrackModifierSoundLocalizationData EQU	10
ModifierTrackGraphicsModeRecord RECORD 0
graphicsMode			 ds.l	1				; offset: $0 (0)
opColor					 ds		RGBColor		; offset: $4 (4)
sizeof					 EQU *					; size:   $A (10)
						ENDR

; *************************
;* tween track types
;*************************


kTweenTypeShort					EQU		1
kTweenTypeLong					EQU		2
kTweenTypeFixed					EQU		3
kTweenTypePoint					EQU		4
kTweenTypeQDRect				EQU		5
kTweenTypeQDRegion				EQU		6
kTweenTypeMatrix				EQU		7
kTweenTypeRGBColor				EQU		8
kTweenTypeGraphicsModeWithRGBColor EQU	9
kTweenType3dScale				EQU		'3sca'
kTweenType3dTranslate			EQU		'3tra'
kTweenType3dRotate				EQU		'3rot'
kTweenType3dRotateAboutPoint	EQU		'3rap'
kTweenType3dRotateAboutAxis		EQU		'3rax'
kTweenType3dQuaternion			EQU		'3qua'
kTweenType3dMatrix				EQU		'3mat'
kTweenType3dCameraData			EQU		'3cam'
kTweenType3dSoundLocalizationData EQU	'3slc'

kTweenEntry						EQU		'twen'
kTweenData						EQU		'data'
kTweenType						EQU		'twnt'
kTweenStartOffset				EQU		'twst'
kTweenDuration					EQU		'twdu'
kTween3dInitialCondition		EQU		'icnd'
kTweenInterpolationStyle		EQU		'isty'
kTweenRegionData				EQU		'qdrg'
kTweenPictureData				EQU		'PICT'




internalComponentErr			EQU		-2070
notImplementedMusicOSErr		EQU		-2071
cantSendToSynthesizerOSErr		EQU		-2072
cantReceiveFromSynthesizerOSErr	EQU		-2073
illegalVoiceAllocationOSErr		EQU		-2074
illegalPartOSErr				EQU		-2075
illegalChannelOSErr				EQU		-2076
illegalKnobOSErr				EQU		-2077
illegalKnobValueOSErr			EQU		-2078
illegalInstrumentOSErr			EQU		-2079
illegalControllerOSErr			EQU		-2080
midiManagerAbsentOSErr			EQU		-2081
synthesizerNotRespondingOSErr	EQU		-2082
synthesizerOSErr				EQU		-2083
illegalNoteChannelOSErr			EQU		-2084
noteChannelNotAllocatedOSErr	EQU		-2085
tunePlayerFullOSErr				EQU		-2086
tuneParseOSErr					EQU		-2087


; *************************
;* Video Media routines
;*************************




videoFlagDontLeanAhead			EQU		$00000001



;  use these two routines at your own peril
;
; pascal ComponentResult VideoMediaResetStatistics(MediaHandler mh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VideoMediaResetStatistics
			move.l              #$00000105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VideoMediaResetStatistics
	ENDIF

;
; pascal ComponentResult VideoMediaGetStatistics(MediaHandler mh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VideoMediaGetStatistics
			move.l              #$00000106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VideoMediaGetStatistics
	ENDIF





; *************************
;* Text Media routines
;*************************




;  Return displayFlags for TextProc 

txtProcDefaultDisplay			EQU		0					;	Use the media's default
txtProcDontDisplay				EQU		1					;	Don't display the text
txtProcDoDisplay				EQU		2					;	Do display the text
;
; pascal ComponentResult TextMediaSetTextProc(MediaHandler mh, TextMediaUPP TextProc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaSetTextProc
			move.l              #$00080101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaSetTextProc
	ENDIF

;
; pascal ComponentResult TextMediaAddTextSample(MediaHandler mh, Ptr text, unsigned long size, short fontNumber, short fontSize, Style textFace, RGBColor *textColor, RGBColor *backColor, short textJustification, Rect *textBox, long displayFlags, TimeValue scrollDelay, short hiliteStart, short hiliteEnd, RGBColor *rgbHiliteColor, TimeValue duration, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaAddTextSample
			move.l              #$00340102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaAddTextSample
	ENDIF

;
; pascal ComponentResult TextMediaAddTESample(MediaHandler mh, TEHandle hTE, RGBColor *backColor, short textJustification, Rect *textBox, long displayFlags, TimeValue scrollDelay, short hiliteStart, short hiliteEnd, RGBColor *rgbHiliteColor, TimeValue duration, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaAddTESample
			move.l              #$00260103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaAddTESample
	ENDIF

;
; pascal ComponentResult TextMediaAddHiliteSample(MediaHandler mh, short hiliteStart, short hiliteEnd, RGBColor *rgbHiliteColor, TimeValue duration, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaAddHiliteSample
			move.l              #$00100104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaAddHiliteSample
	ENDIF


findTextEdgeOK					EQU		$01					; Okay to find text at specified sample time
findTextCaseSensitive			EQU		$02					; Case sensitive search
findTextReverseSearch			EQU		$04					; Search from sampleTime backwards
findTextWrapAround				EQU		$08					; Wrap search when beginning or end of movie is hit
findTextUseOffset				EQU		$10					; Begin search at the given character offset into sample rather than edge
;
; pascal ComponentResult TextMediaFindNextText(MediaHandler mh, Ptr text, long size, short findFlags, TimeValue startTime, TimeValue *foundTime, TimeValue *foundDuration, long *offset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaFindNextText
			move.l              #$001A0105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaFindNextText
	ENDIF

;
; pascal ComponentResult TextMediaHiliteTextSample(MediaHandler mh, TimeValue sampleTime, short hiliteStart, short hiliteEnd, RGBColor *rgbHiliteColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaHiliteTextSample
			move.l              #$000C0106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaHiliteTextSample
	ENDIF


dropShadowOffsetType			EQU		'drpo'
dropShadowTranslucencyType		EQU		'drpt'
;
; pascal ComponentResult TextMediaSetTextSampleData(MediaHandler mh, void *data, OSType dataType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaSetTextSampleData
			move.l              #$00080107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaSetTextSampleData
	ENDIF




; *************************
;* Sprite Media routines
;*************************

;  flags for HitTestSpriteMedia 

spriteHitTestBounds				EQU		$00000001			;	point must only be within sprite's bounding box
spriteHitTestImage				EQU		$00000002			;  point must be within the shape of the sprite's image
;  atom types for sprite media 

kSpriteAtomType					EQU		'sprt'
kSpriteImagesContainerAtomType	EQU		'imct'
kSpriteImageAtomType			EQU		'imag'
kSpriteImageDataAtomType		EQU		'imda'
kSpriteSharedDataAtomType		EQU		'dflt'
kSpriteNameAtomType				EQU		'name'
;
; pascal ComponentResult SpriteMediaSetProperty(MediaHandler mh, short spriteIndex, long propertyType, void *propertyValue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaSetProperty
			move.l              #$000A0101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaSetProperty
	ENDIF

;
; pascal ComponentResult SpriteMediaGetProperty(MediaHandler mh, short spriteIndex, long propertyType, void *propertyValue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetProperty
			move.l              #$000A0102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetProperty
	ENDIF

;
; pascal ComponentResult SpriteMediaHitTestSprites(MediaHandler mh, long flags, Point loc, short *spriteHitIndex)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaHitTestSprites
			move.l              #$000C0103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaHitTestSprites
	ENDIF

;
; pascal ComponentResult SpriteMediaCountSprites(MediaHandler mh, short *numSprites)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaCountSprites
			move.l              #$00040104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaCountSprites
	ENDIF

;
; pascal ComponentResult SpriteMediaCountImages(MediaHandler mh, short *numImages)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaCountImages
			move.l              #$00040105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaCountImages
	ENDIF

;
; pascal ComponentResult SpriteMediaGetIndImageDescription(MediaHandler mh, short imageIndex, ImageDescriptionHandle imageDescription)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetIndImageDescription
			move.l              #$00060106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetIndImageDescription
	ENDIF

;
; pascal ComponentResult SpriteMediaGetDisplayedSampleNumber(MediaHandler mh, long *sampleNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetDisplayedSampleNumber
			move.l              #$00040107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetDisplayedSampleNumber
	ENDIF


; *************************
;* 3D Media routines
;*************************

;
; pascal ComponentResult Media3DGetNamedObjectList(MediaHandler mh, QTAtomContainer *objectList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DGetNamedObjectList
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DGetNamedObjectList
	ENDIF

;
; pascal ComponentResult Media3DGetRendererList(MediaHandler mh, QTAtomContainer *rendererList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DGetRendererList
			move.l              #$00040102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DGetRendererList
	ENDIF



; ****************************************
;*										*
;*  	M O V I E   C O N T R O L L E R		*
;*										*
;***************************************


MovieControllerComponentType	EQU		'play'

; typedef ComponentInstance 			MovieController


mcActionIdle					EQU		1					; no param
mcActionDraw					EQU		2					; param is WindowPtr
mcActionActivate				EQU		3					; no param
mcActionDeactivate				EQU		4					; no param
mcActionMouseDown				EQU		5					; param is pointer to EventRecord
mcActionKey						EQU		6					; param is pointer to EventRecord
mcActionPlay					EQU		8					; param is Fixed, play rate
mcActionGoToTime				EQU		12					; param is TimeRecord
mcActionSetVolume				EQU		14					; param is a short
mcActionGetVolume				EQU		15					; param is pointer to a short
mcActionStep					EQU		18					; param is number of steps (short)
mcActionSetLooping				EQU		21					; param is Boolean
mcActionGetLooping				EQU		22					; param is pointer to a Boolean
mcActionSetLoopIsPalindrome		EQU		23					; param is Boolean
mcActionGetLoopIsPalindrome		EQU		24					; param is pointer to a Boolean
mcActionSetGrowBoxBounds		EQU		25					; param is a Rect
mcActionControllerSizeChanged	EQU		26					; no param
mcActionSetSelectionBegin		EQU		29					; param is TimeRecord
mcActionSetSelectionDuration	EQU		30					; param is TimeRecord, action only taken on set-duration
mcActionSetKeysEnabled			EQU		32					; param is Boolean
mcActionGetKeysEnabled			EQU		33					; param is pointer to Boolean
mcActionSetPlaySelection		EQU		34					; param is Boolean
mcActionGetPlaySelection		EQU		35					; param is pointer to Boolean
mcActionSetUseBadge				EQU		36					; param is Boolean
mcActionGetUseBadge				EQU		37					; param is pointer to Boolean
mcActionSetFlags				EQU		38					; param is long of flags
mcActionGetFlags				EQU		39					; param is pointer to a long of flags
mcActionSetPlayEveryFrame		EQU		40					; param is Boolean
mcActionGetPlayEveryFrame		EQU		41					; param is pointer to Boolean
mcActionGetPlayRate				EQU		42					; param is pointer to Fixed
mcActionShowBalloon				EQU		43					; param is a pointer to a boolean. set to false to stop balloon
mcActionBadgeClick				EQU		44					; param is pointer to Boolean. set to false to ignore click
mcActionMovieClick				EQU		45					; param is pointer to event record. change “what” to nullEvt to kill click
mcActionSuspend					EQU		46					; no param
mcActionResume					EQU		47					; no param
mcActionSetControllerKeysEnabled EQU	48					; param is Boolean
mcActionGetTimeSliderRect		EQU		49					; param is pointer to rect
mcActionMovieEdited				EQU		50					; no param
mcActionGetDragEnabled			EQU		51					; param is pointer to Boolean
mcActionSetDragEnabled			EQU		52					; param is Boolean
mcActionGetSelectionBegin		EQU		53					; param is TimeRecord
mcActionGetSelectionDuration	EQU		54					; param is TimeRecord
mcActionPrerollAndPlay			EQU		55					; param is Fixed, play rate
mcActionGetCursorSettingEnabled	EQU		56					; param is pointer to Boolean
mcActionSetCursorSettingEnabled	EQU		57					; param is Boolean
mcActionSetColorTable			EQU		58					; param is CTabHandle
; typedef short 						mcAction


mcFlagSuppressMovieFrame		EQU		$01
mcFlagSuppressStepButtons		EQU		$02
mcFlagSuppressSpeakerButton		EQU		$04
mcFlagsUseWindowPalette			EQU		$08
mcFlagsDontInvalidate			EQU		$10


mcPositionDontInvalidate		EQU		$20
; typedef unsigned long 				mcFlags

; 
;	menu related stuff
;


mcInfoUndoAvailable				EQU		$01
mcInfoCutAvailable				EQU		$02
mcInfoCopyAvailable				EQU		$04
mcInfoPasteAvailable			EQU		$08
mcInfoClearAvailable			EQU		$10
mcInfoHasSound					EQU		$20
mcInfoIsPlaying					EQU		$40
mcInfoIsLooping					EQU		$80
mcInfoIsInPalindrome			EQU		$0100
mcInfoEditingEnabled			EQU		$0200
mcInfoMovieIsInteractive		EQU		$0400
;  menu item codes

mcMenuUndo						EQU		1
mcMenuCut						EQU		3
mcMenuCopy						EQU		4
mcMenuPaste						EQU		5
mcMenuClear						EQU		6



;  target management 
;
; pascal ComponentResult MCSetMovie(MovieController mc, Movie theMovie, WindowPtr movieWindow, Point where)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetMovie
			move.l              #$000C0002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetMovie
	ENDIF

;
; pascal Movie MCGetIndMovie(MovieController mc, short index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetIndMovie
			move.l              #$00020005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetIndMovie
	ENDIF


;
; pascal ComponentResult MCRemoveAllMovies(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCRemoveAllMovies
			move.l              #$00000006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCRemoveAllMovies
	ENDIF

;
; pascal ComponentResult MCRemoveAMovie(MovieController mc, Movie m)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCRemoveAMovie
			move.l              #$00040003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCRemoveAMovie
	ENDIF

;
; pascal ComponentResult MCRemoveMovie(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCRemoveMovie
			move.l              #$00000006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCRemoveMovie
	ENDIF

;  event handling etc. 
;
; pascal ComponentResult MCIsPlayerEvent(MovieController mc, const EventRecord *e)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCIsPlayerEvent
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCIsPlayerEvent
	ENDIF

;  obsolete. use MCSetActionFilterWithRefCon instead. 
;
; pascal ComponentResult MCSetActionFilter(MovieController mc, MCActionFilterUPP blob)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetActionFilter
			move.l              #$00040008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetActionFilter
	ENDIF

; 
;	proc is of the form:
;		Boolean userPlayerFilter(MovieController mc, short *action, void *params) =
;	proc returns TRUE if it handles the action, FALSE if not
;	action is passed as a VAR so that it could be changed by filter
;	this is consistent with the current dialog manager stuff
;	params is any potential parameters that go with the action
;		such as set playback rate to xxx.
;

;
; pascal ComponentResult MCDoAction(MovieController mc, short action, void *params)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCDoAction
			move.l              #$00060009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCDoAction
	ENDIF

;  state type things 
;
; pascal ComponentResult MCSetControllerAttached(MovieController mc, Boolean attach)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetControllerAttached
			move.l              #$0002000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetControllerAttached
	ENDIF

;
; pascal ComponentResult MCIsControllerAttached(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCIsControllerAttached
			move.l              #$0000000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCIsControllerAttached
	ENDIF

;
; pascal ComponentResult MCSetControllerPort(MovieController mc, CGrafPtr gp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetControllerPort
			move.l              #$0004000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetControllerPort
	ENDIF

;
; pascal CGrafPtr MCGetControllerPort(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetControllerPort
			move.l              #$0000000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetControllerPort
	ENDIF

;
; pascal ComponentResult MCSetVisible(MovieController mc, Boolean visible)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetVisible
			move.l              #$0002000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetVisible
	ENDIF

;
; pascal ComponentResult MCGetVisible(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetVisible
			move.l              #$0000000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetVisible
	ENDIF

;
; pascal ComponentResult MCGetControllerBoundsRect(MovieController mc, Rect *bounds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetControllerBoundsRect
			move.l              #$00040010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetControllerBoundsRect
	ENDIF

;
; pascal ComponentResult MCSetControllerBoundsRect(MovieController mc, const Rect *bounds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetControllerBoundsRect
			move.l              #$00040011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetControllerBoundsRect
	ENDIF

;
; pascal RgnHandle MCGetControllerBoundsRgn(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetControllerBoundsRgn
			move.l              #$00000012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetControllerBoundsRgn
	ENDIF

;
; pascal RgnHandle MCGetWindowRgn(MovieController mc, WindowPtr w)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetWindowRgn
			move.l              #$00040013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetWindowRgn
	ENDIF


;  other stuff 
;
; pascal ComponentResult MCMovieChanged(MovieController mc, Movie m)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCMovieChanged
			move.l              #$00040014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCMovieChanged
	ENDIF


; 
;	called when the app has changed thing about the movie (like bounding rect) or rate. So that we
;		can update our graphical (and internal) state accordingly.
;

;
; pascal ComponentResult MCSetDuration(MovieController mc, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetDuration
			move.l              #$00040015,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetDuration
	ENDIF

; 
;	duration to use for time slider -- will be reset next time MCMovieChanged is called
;		or MCSetMovie is called
;

;
; pascal TimeValue MCGetCurrentTime(MovieController mc, TimeScale *scale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetCurrentTime
			move.l              #$00040016,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetCurrentTime
	ENDIF

; 
;	returns the time value and the time scale it is on. if there are no movies, the
;		time scale is passed back as 0. scale is an optional parameter
;
;

;
; pascal ComponentResult MCNewAttachedController(MovieController mc, Movie theMovie, WindowPtr w, Point where)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCNewAttachedController
			move.l              #$000C0017,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCNewAttachedController
	ENDIF

; 
;	makes theMovie the only movie attached to the controller. makes the controller visible.
;	the window and where parameters are passed a long to MCSetMovie and behave as
;	described there
;

;
; pascal ComponentResult MCDraw(MovieController mc, WindowPtr w)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCDraw
			move.l              #$00040018,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCDraw
	ENDIF

;
; pascal ComponentResult MCActivate(MovieController mc, WindowPtr w, Boolean activate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCActivate
			move.l              #$00060019,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCActivate
	ENDIF

;
; pascal ComponentResult MCIdle(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCIdle
			move.l              #$0000001A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCIdle
	ENDIF

;
; pascal ComponentResult MCKey(MovieController mc, SInt8 key, long modifiers)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCKey
			move.l              #$0006001B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCKey
	ENDIF

;
; pascal ComponentResult MCClick(MovieController mc, WindowPtr w, Point where, long when, long modifiers)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCClick
			move.l              #$0010001C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCClick
	ENDIF


; 
;	calls for editing
;

;
; pascal ComponentResult MCEnableEditing(MovieController mc, Boolean enabled)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCEnableEditing
			move.l              #$0002001D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCEnableEditing
	ENDIF

;
; pascal long MCIsEditingEnabled(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCIsEditingEnabled
			move.l              #$0000001E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCIsEditingEnabled
	ENDIF

;
; pascal Movie MCCopy(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCCopy
			move.l              #$0000001F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCCopy
	ENDIF

;
; pascal Movie MCCut(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCCut
			move.l              #$00000020,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCCut
	ENDIF

;
; pascal ComponentResult MCPaste(MovieController mc, Movie srcMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCPaste
			move.l              #$00040021,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCPaste
	ENDIF

;
; pascal ComponentResult MCClear(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCClear
			move.l              #$00000022,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCClear
	ENDIF

;
; pascal ComponentResult MCUndo(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCUndo
			move.l              #$00000023,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCUndo
	ENDIF


; 
; *	somewhat special stuff
; 

;
; pascal ComponentResult MCPositionController(MovieController mc, const Rect *movieRect, const Rect *controllerRect, long someFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCPositionController
			move.l              #$000C0024,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCPositionController
	ENDIF


;
; pascal ComponentResult MCGetControllerInfo(MovieController mc, long *someFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetControllerInfo
			move.l              #$00040025,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetControllerInfo
	ENDIF



;
; pascal ComponentResult MCSetClip(MovieController mc, RgnHandle theClip, RgnHandle movieClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetClip
			move.l              #$00080028,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetClip
	ENDIF

;
; pascal ComponentResult MCGetClip(MovieController mc, RgnHandle *theClip, RgnHandle *movieClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetClip
			move.l              #$00080029,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetClip
	ENDIF


;
; pascal ComponentResult MCDrawBadge(MovieController mc, RgnHandle movieRgn, RgnHandle *badgeRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCDrawBadge
			move.l              #$0008002A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCDrawBadge
	ENDIF

;
; pascal ComponentResult MCSetUpEditMenu(MovieController mc, long modifiers, MenuHandle mh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetUpEditMenu
			move.l              #$0008002B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetUpEditMenu
	ENDIF

;
; pascal ComponentResult MCGetMenuString(MovieController mc, long modifiers, short item, Str255 aString)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetMenuString
			move.l              #$000A002C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetMenuString
	ENDIF

;
; pascal ComponentResult MCSetActionFilterWithRefCon(MovieController mc, MCActionFilterWithRefConUPP blob, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetActionFilterWithRefCon
			move.l              #$0008002D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetActionFilterWithRefCon
	ENDIF

;
; pascal ComponentResult MCPtInController(MovieController mc, Point thePt, Boolean *inController)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCPtInController
			move.l              #$0008002E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCPtInController
	ENDIF

;
; pascal ComponentResult MCInvalidate(MovieController mc, WindowPtr w, RgnHandle invalidRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCInvalidate
			move.l              #$0008002F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCInvalidate
	ENDIF





; ****************************************
;*										*
;*  		T  I  M  E  B  A  S  E			*
;*										*
;***************************************

;
; pascal TimeBase NewTimeBase(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewTimeBase
			move.w              #$00A5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewTimeBase
	ENDIF

;
; pascal void DisposeTimeBase(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeTimeBase
			move.w              #$00B6,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeTimeBase
	ENDIF

;
; pascal TimeValue GetTimeBaseTime(TimeBase tb, TimeScale s, TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseTime
			move.w              #$00A6,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseTime
	ENDIF

;
; pascal void SetTimeBaseTime(TimeBase tb, const TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseTime
			move.w              #$00A7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseTime
	ENDIF

;
; pascal void SetTimeBaseValue(TimeBase tb, TimeValue t, TimeScale s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseValue
			move.w              #$00A8,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseValue
	ENDIF

;
; pascal Fixed GetTimeBaseRate(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseRate
			move.w              #$00A9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseRate
	ENDIF

;
; pascal void SetTimeBaseRate(TimeBase tb, Fixed r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseRate
			move.w              #$00AA,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseRate
	ENDIF

;
; pascal TimeValue GetTimeBaseStartTime(TimeBase tb, TimeScale s, TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseStartTime
			move.w              #$00AB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseStartTime
	ENDIF

;
; pascal void SetTimeBaseStartTime(TimeBase tb, const TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseStartTime
			move.w              #$00AC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseStartTime
	ENDIF

;
; pascal TimeValue GetTimeBaseStopTime(TimeBase tb, TimeScale s, TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseStopTime
			move.w              #$00AD,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseStopTime
	ENDIF

;
; pascal void SetTimeBaseStopTime(TimeBase tb, const TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseStopTime
			move.w              #$00AE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseStopTime
	ENDIF

;
; pascal long GetTimeBaseFlags(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseFlags
			move.w              #$00B1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseFlags
	ENDIF

;
; pascal void SetTimeBaseFlags(TimeBase tb, long timeBaseFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseFlags
			move.w              #$00B2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseFlags
	ENDIF

;
; pascal void SetTimeBaseMasterTimeBase(TimeBase slave, TimeBase master, const TimeRecord *slaveZero)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseMasterTimeBase
			move.w              #$00B4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseMasterTimeBase
	ENDIF

;
; pascal TimeBase GetTimeBaseMasterTimeBase(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseMasterTimeBase
			move.w              #$00AF,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseMasterTimeBase
	ENDIF

;
; pascal void SetTimeBaseMasterClock(TimeBase slave, Component clockMeister, const TimeRecord *slaveZero)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseMasterClock
			move.w              #$00B3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseMasterClock
	ENDIF

;
; pascal ComponentInstance GetTimeBaseMasterClock(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseMasterClock
			move.w              #$00B0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseMasterClock
	ENDIF

;
; pascal void ConvertTime(TimeRecord *inout, TimeBase newBase)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ConvertTime
			move.w              #$00B5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ConvertTime
	ENDIF

;
; pascal void ConvertTimeScale(TimeRecord *inout, TimeScale newScale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ConvertTimeScale
			move.w              #$00B7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ConvertTimeScale
	ENDIF

;
; pascal void AddTime(TimeRecord *dst, const TimeRecord *src)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddTime
			move.w              #$010C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddTime
	ENDIF

;
; pascal void SubtractTime(TimeRecord *dst, const TimeRecord *src)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SubtractTime
			move.w              #$010D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SubtractTime
	ENDIF

;
; pascal long GetTimeBaseStatus(TimeBase tb, TimeRecord *unpinnedTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseStatus
			move.w              #$010B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseStatus
	ENDIF

;
; pascal void SetTimeBaseZero(TimeBase tb, TimeRecord *zero)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseZero
			move.w              #$0128,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseZero
	ENDIF

;
; pascal Fixed GetTimeBaseEffectiveRate(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseEffectiveRate
			move.w              #$0124,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseEffectiveRate
	ENDIF


; ****************************************
;*										*
;*  		C  A  L  L  B  A  C  K 			*
;*										*
;***************************************

;
; pascal QTCallBack NewCallBack(TimeBase tb, short cbType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewCallBack
			move.w              #$00EB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewCallBack
	ENDIF

;
; pascal void DisposeCallBack(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeCallBack
			move.w              #$00EC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeCallBack
	ENDIF

;
; pascal short GetCallBackType(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetCallBackType
			move.w              #$00ED,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCallBackType
	ENDIF

;
; pascal TimeBase GetCallBackTimeBase(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetCallBackTimeBase
			move.w              #$00EE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCallBackTimeBase
	ENDIF

;
; pascal OSErr CallMeWhen(QTCallBack cb, QTCallBackUPP callBackProc, long refCon, long param1, long param2, long param3)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CallMeWhen
			move.w              #$00B8,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CallMeWhen
	ENDIF

;
; pascal void CancelCallBack(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CancelCallBack
			move.w              #$00B9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CancelCallBack
	ENDIF


; ****************************************
;*										*
;*  		C L O C K   C A L L B A C K  	*
;*  		      S U P P O R T  			*
;*										*
;***************************************

;
; pascal OSErr AddCallBackToTimeBase(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddCallBackToTimeBase
			move.w              #$0129,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddCallBackToTimeBase
	ENDIF

;
; pascal OSErr RemoveCallBackFromTimeBase(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RemoveCallBackFromTimeBase
			move.w              #$012A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveCallBackFromTimeBase
	ENDIF

;
; pascal QTCallBack GetFirstCallBack(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetFirstCallBack
			move.w              #$012B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetFirstCallBack
	ENDIF

;
; pascal QTCallBack GetNextCallBack(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetNextCallBack
			move.w              #$012C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetNextCallBack
	ENDIF

;
; pascal void ExecuteCallBack(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ExecuteCallBack
			move.w              #$012D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ExecuteCallBack
	ENDIF

; ****************************************
;*										*
;*  		S Y N C    T A S K S		  	*
;*  		      S U P P O R T  			*
;*										*
;***************************************

;
; pascal OSErr QueueSyncTask(QTSyncTaskPtr task)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QueueSyncTask
			move.w              #$0203,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QueueSyncTask
	ENDIF

;
; pascal OSErr DequeueSyncTask(QTSyncTaskPtr qElem)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DequeueSyncTask
			move.w              #$0204,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DequeueSyncTask
	ENDIF



;  UPP call backs 


	ENDIF ; __MOVIES__ 


;
;	File:		OCEMail.a
;
;	Contains:	Apple Open Collaboration Environment OCEMail Interfaces.
;
;	Version:	Technology:	AOCE Toolbox 1.02
;				Release:	Universal Interfaces 3.0.1
;
;	Copyright:	Â© 1994-1997 by Apple Computer, Inc., all rights reserved.
;
;	Bugs?:		Please include the the file and version information (from above) with
;				the problem description.  Developers belonging to one of the Apple
;				developer programs can submit bug reports to:
;
;					devsupport@apple.com
;
;
	IF &TYPE('__OCEMAIL__') = 'UNDEFINED' THEN
__OCEMAIL__ SET 1

	IF &TYPE('__TYPES__') = 'UNDEFINED' THEN
	include 'Types.a'
	ENDIF
	IF &TYPE('__FILES__') = 'UNDEFINED' THEN
	include 'Files.a'
	ENDIF
	IF &TYPE('__TEXTEDIT__') = 'UNDEFINED' THEN
	include 'TextEdit.a'
	ENDIF

	IF &TYPE('__DIGITALSIGNATURE__') = 'UNDEFINED' THEN
	include 'DigitalSignature.a'
	ENDIF
	IF &TYPE('__OCE__') = 'UNDEFINED' THEN
	include 'OCE.a'
	ENDIF
	IF &TYPE('__OCEAUTHDIR__') = 'UNDEFINED' THEN
	include 'OCEAuthDir.a'
	ENDIF
	IF &TYPE('__OCEMESSAGING__') = 'UNDEFINED' THEN
	include 'OCEMessaging.a'
	ENDIF

; *************************************************************************************
;  Common Definitions 
; *************************************************************************************

;  reference to a new or open letter or message 
; typedef long 							MailMsgRef

;  reference to an open msam queue 
; typedef long 							MSAMQueueRef

;  identifies slots managed by a PMSAM 
; typedef unsigned short 				MSAMSlotID

;  reference to an active mailbox 
; typedef long 							MailboxRef

;  identifies slots within a mailbox 
; typedef unsigned short 				MailSlotID

;  identifies a letter in a mailbox 
MailSeqNum				RECORD 0
slotID					 ds.w	1				; offset: $0 (0)
seqNum					 ds.l	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
;  A MailBuffer is used to describe a buffer used for an IO operation.
;The location of the buffer is pointed to by 'buffer'. 
;When reading, the size of the buffer is 'bufferSize' 
;and the size of data actually read is 'dataSize'.
;When writing, the size of data to be written is 'bufferSize' 
;and the size of data actually written is 'dataSize'.
;

MailBuffer				RECORD 0
bufferSize				 ds.l	1				; offset: $0 (0)
buffer					 ds.l	1				; offset: $4 (4)
dataSize				 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
;  A MailReply is used to describe a commonly used reply buffer format.
;It contains a count of tuples followed by an array of tuples.
;The format of the tuple itself depends on each particular call.
;

MailReply				RECORD 0
tupleCount				 ds.w	1				; offset: $0 (0)
;  tuple[tupleCount] 
sizeof					 EQU *					; size:   $2 (2)
						ENDR
;  Shared Memory Communication Area used when Mail Manager sends 
;High Level Events to a PMSAM. 
;

SMCA					RECORD 0
smcaLength				 ds.w	1				; offset: $0 (0)		;  includes size of smcaLength field 
result					 ds.w	1				; offset: $2 (2)
userBytes				 ds.l	1				; offset: $4 (4)
slotCID					 ds		CreationID		; offset: $8 (8)		;  for create/modify/delete slot calls 
						 ORG 8
msgHint					 ds.l	1				; offset: $8 (8)		;  for kMailEPPCMsgOpened 
						 ORG 16
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; *************************************************************************************
;  Value of creator and types fields for messages and blocks defined by MailManager 

kMailAppleMailCreator			EQU		'apml'				; message and letter block creator 
kMailLtrMsgType					EQU		'lttr'				; message type of letters, reports 
kMailLtrHdrType					EQU		'lthd'				; contains letter header 
kMailContentType				EQU		'body'				; contains content of letter 
kMailEnclosureListType			EQU		'elst'				; contains list of enclosures 
kMailEnclosureDesktopType		EQU		'edsk'				; contains desktop mgr info for enclosures 
kMailEnclosureFileType			EQU		'asgl'				; contains a file enclosure, format is defined by AppleSingle 
kMailImageBodyType				EQU		'imag'				; contains image of letter 
kMailMSAMType					EQU		'gwyi'				; contains msam specific information 
kMailTunnelLtrType				EQU		'tunl'				; used to read a tunnelled message 
kMailHopInfoType				EQU		'hopi'				; used to read hopInfo for a tunnelled message 
kMailReportType					EQU		'rpti'				; contains report info 
kMailFamily						EQU		'mail'				; Defines family of "mail" msgs: content, header, etc 
kMailFamilyFile					EQU		'file'				; Defines family of "direct display" msgs 
; 	
;kMailImageBodyType:
;	format is struct TPfPgDir - in Printing.h
;	*	struct TPfPgDir {
;	*		short	pageCount;		- number of pages in the image.
;	*		long	iPgPos[129];	- iPgPos[n] is the offset from the start of the block
;	*								- to image of page n.
;	*								- iPgPos[n+1] - iPgPos[n] is the length of page n.
;
;kMailReportType:
;Reports have the isReport bit set in MailIndications and contain a block of type kMailReport.
;This block has a header, IPMReportBlockHeader,
;followed by an array of elements, each of type IPMRecipientReport
;
;Various families used by mail or related msgs
;



; *************************************************************************************
; typedef unsigned short 				MailAttributeID

;  Values of MailAttributeID 
;  Message store attributes - stored in the catalog 
;  Will always be present in a letter and have fixed sizes 

kMailLetterFlagsBit				EQU		1					; MailLetterFlags 
															; Letter attributes - stored in the letter will always be present in a letter and have fixed sizes 
kMailIndicationsBit				EQU		3					; MailIndications 
kMailMsgTypeBit					EQU		4					; OCECreatorType 
kMailLetterIDBit				EQU		5					; MailLetterID 
kMailSendTimeStampBit			EQU		6					; MailTime 
kMailNestingLevelBit			EQU		7					; MailNestingLevel 
kMailMsgFamilyBit				EQU		8					; OSType 
															; Letter attributes - stored in the letter may be present in a letter and have fixed sizes 
kMailReplyIDBit					EQU		9					; MailLetterID 
kMailConversationIDBit			EQU		10					; MailLetterID 
															; Letter attributes - stored in the letter may be present in a letter and have variable length sizes 
kMailSubjectBit					EQU		11					; RString 
kMailFromBit					EQU		12					; MailRecipient 
kMailToBit						EQU		13					; MailRecipient 
kMailCcBit						EQU		14					; MailRecipient 
kMailBccBit						EQU		15					; MailRecipient 
; typedef unsigned long 				MailAttributeMask

;  Values of MailAttributeMask 

kMailLetterFlagsMask			EQU		$00000001
kMailIndicationsMask			EQU		$00000004
kMailMsgTypeMask				EQU		$00000008
kMailLetterIDMask				EQU		$00000010
kMailSendTimeStampMask			EQU		$00000020
kMailNestingLevelMask			EQU		$00000040
kMailMsgFamilyMask				EQU		$00000080
kMailReplyIDMask				EQU		$00000100
kMailConversationIDMask			EQU		$00000200
kMailSubjectMask				EQU		$00000400
kMailFromMask					EQU		$00000800
kMailToMask						EQU		$00001000
kMailCcMask						EQU		$00002000
kMailBccMask					EQU		$00004000
; typedef unsigned long 				MailAttributeBitmap

; *************************************************************************************
; typedef unsigned short 				MailLetterSystemFlags

;  Values of MailLetterSystemFlags 
;  letter is available locally (either by nature or via cache) 

kMailIsLocalBit					EQU		2

kMailIsLocalMask				EQU		$00000004
; typedef unsigned short 				MailLetterUserFlags


kMailReadBit					EQU		0					; this letter has been opened 
kMailDontArchiveBit				EQU		1					; this letter is not to be archived either because it has already been archived or it should not be archived. 
kMailInTrashBit					EQU		2					; this letter is in trash 
;  Values of MailLetterUserFlags 

kMailReadMask					EQU		$00000001
kMailDontArchiveMask			EQU		$00000002
kMailInTrashMask				EQU		$00000004
MailLetterFlags			RECORD 0
sysFlags				 ds.w	1				; offset: $0 (0)
userFlags				 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
MailMaskedLetterFlags	RECORD 0
flagMask				 ds		MailLetterFlags ; offset: $0 (0)		;  flags that are to be set 
flagValues				 ds		MailLetterFlags ; offset: $4 (4)		;  and their values 
sizeof					 EQU *					; size:   $8 (8)
						ENDR

kMailOriginalInReportBit		EQU		1
kMailNonReceiptReportsBit		EQU		3
kMailReceiptReportsBit			EQU		4
kMailForwardedBit				EQU		5
kMailPriorityBit				EQU		6
kMailIsReportWithOriginalBit	EQU		8
kMailIsReportBit				EQU		9
kMailHasContentBit				EQU		10
kMailHasSignatureBit			EQU		11
kMailAuthenticatedBit			EQU		12
kMailSentBit					EQU		13
kMailNativeContentBit			EQU		14
kMailImageContentBit			EQU		15
kMailStandardContentBit			EQU		16
;  Values of MailIndications 

kMailStandardContentMask		EQU		$00008000
kMailImageContentMask			EQU		$00004000
kMailNativeContentMask			EQU		$00002000
kMailSentMask					EQU		$00001000
kMailAuthenticatedMask			EQU		$00000800
kMailHasSignatureMask			EQU		$00000400
kMailHasContentMask				EQU		$00000200
kMailIsReportMask				EQU		$00000100
kMailIsReportWithOriginalMask	EQU		$00000080
kMailPriorityMask				EQU		$00000060
kMailForwardedMask				EQU		$00000010
kMailReceiptReportsMask			EQU		$00000008
kMailNonReceiptReportsMask		EQU		$00000004
kMailOriginalInReportMask		EQU		$00000003
; typedef unsigned long 				MailIndications

;  values of the field originalInReport in MailIndications 

kMailNoOriginal					EQU		0					; do not enclose original in reports 
kMailEncloseOnNonReceipt		EQU		3					; enclose original in non-delivery reports 
MailLetterID			RECORD 0
f						 ds		IPMMsgID
sizeof					 EQU *					; size:   $10 (16)
						ENDR


MailTime				RECORD 0
time					 ds.l	1				; offset: $0 (0)		;  current UTC(GMT) time 
offset					 ds.l	1				; offset: $4 (4)		;  offset from GMT 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  innermost letter has nestingLevel 0 
; typedef unsigned short 				MailNestingLevel

MailRecipient			RECORD 0
f						 ds		OCERecipient
sizeof					 EQU *					; size:   $E (14)
						ENDR


; *************************************************************************************

kMailTextSegmentBit				EQU		0
kMailPictSegmentBit				EQU		1
kMailSoundSegmentBit			EQU		2
kMailStyledTextSegmentBit		EQU		3
kMailMovieSegmentBit			EQU		4
; typedef unsigned short 				MailSegmentMask

;  Values of MailSegmentMask 

kMailTextSegmentMask			EQU		$00000001
kMailPictSegmentMask			EQU		$00000002
kMailSoundSegmentMask			EQU		$00000004
kMailStyledTextSegmentMask		EQU		$00000008
kMailMovieSegmentMask			EQU		$00000010
; typedef unsigned short 				MailSegmentType

;  Values of MailSegmentType 

kMailInvalidSegmentType			EQU		0
kMailTextSegmentType			EQU		1
kMailPictSegmentType			EQU		2
kMailSoundSegmentType			EQU		3
kMailStyledTextSegmentType		EQU		4
kMailMovieSegmentType			EQU		5
; *************************************************************************************

kMailErrorLogEntryVersion		EQU		$0101
kMailMSAMErrorStringListID		EQU		128					; These 'STR#' resources should be 
kMailMSAMActionStringListID		EQU		129					; in the PMSAM resource fork 
; typedef unsigned short 				MailLogErrorType

;  Values of MailLogErrorType 

kMailELECorrectable				EQU		0
kMailELEError					EQU		1
kMailELEWarning					EQU		2
kMailELEInformational			EQU		3
; typedef short 						MailLogErrorCode

;  Values of MailLogErrorCode 

kMailMSAMErrorCode				EQU		0					; positive codes are indices into PMSAM defined strings 
kMailMiscError					EQU		-1					; negative codes are OCE defined 
kMailNoModem					EQU		-2					; modem required, but missing 
MailErrorLogEntryInfo	RECORD 0
version					 ds.w	1				; offset: $0 (0)
timeOccurred			 ds.l	1				; offset: $2 (2)		;  do not fill in 
reportingPMSAM			 ds		Str31			; offset: $6 (6)		;  do not fill in 
reportingMSAMSlot		 ds		Str31			; offset: $26 (38)		;  do not fill in 
errorType				 ds.w	1				; offset: $46 (70)
errorCode				 ds.w	1				; offset: $48 (72)
errorResource			 ds.w	1				; offset: $4A (74)		;  resources are valid if 
actionResource			 ds.w	1				; offset: $4C (76)		;  errorCode = kMailMSAMErrorCode index starts from 1 
filler					 ds.l	1				; offset: $4E (78)
filler2					 ds.w	1				; offset: $52 (82)
sizeof					 EQU *					; size:   $54 (84)
						ENDR
; *************************************************************************************
; typedef short 						MailBlockMode

;  Values of MailBlockMode 

kMailFromStart					EQU		1					; write data from offset calculated from 
kMailFromLEOB					EQU		2					; start of block, end of block, 
kMailFromMark					EQU		3					; or from the current mark 
MailEnclosureInfo		RECORD 0
enclosureName			 ds.l	1				; offset: $0 (0)
catInfo					 ds.l	1				; offset: $4 (4)
comment					 ds.l	1				; offset: $8 (8)
icon					 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; *************************************************************************************

kOCESetupLocationNone			EQU		0					; disconnect state 
kOCESetupLocationMax			EQU		8					; maximum location value 
; typedef char 							OCESetupLocation

;  location state is a bitmask, 0x1=>1st location active, 
; * 0x2 => 2nd, 0x4 => 3rd, etc.
; 

; typedef UInt8 						MailLocationFlags

MailLocationInfo		RECORD 0
location				 ds.b	1				; offset: $0 (0)
active					 ds.b	1				; offset: $1 (1)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
; *************************************************************************************
;  Definitions for Personal MSAMs 
; *************************************************************************************

kMailEPPCMsgVersion				EQU		3
MailEPPCMsg				RECORD 0
version					 ds.w	1				; offset: $0 (0)
theSMCA					 ds.l	1				; offset: $2 (2)		;  for 'crsl', 'mdsl', 'dlsl', 'sndi', 'msgo', 'admn' 
						 ORG 2
sequenceNumber			 ds.l	1				; offset: $2 (2)		;  for 'inqu', 'dlom' 
						 ORG 2
locationInfo			 ds		MailLocationInfo ; offset: $2 (2)		;  for 'locc' 
						 ORG 6
sizeof					 EQU *					; size:   $6 (6)
						ENDR
;  Values of OCE defined High Level Event message classes 

kMailEPPCCreateSlot				EQU		'crsl'
kMailEPPCModifySlot				EQU		'mdsl'
kMailEPPCDeleteSlot				EQU		'dlsl'
kMailEPPCShutDown				EQU		'quit'
kMailEPPCMailboxOpened			EQU		'mbop'
kMailEPPCMailboxClosed			EQU		'mbcl'
kMailEPPCMsgPending				EQU		'msgp'
kMailEPPCSendImmediate			EQU		'sndi'
kMailEPPCContinue				EQU		'cont'
kMailEPPCSchedule				EQU		'sked'
kMailEPPCAdmin					EQU		'admn'
kMailEPPCInQUpdate				EQU		'inqu'
kMailEPPCMsgOpened				EQU		'msgo'
kMailEPPCDeleteOutQMsg			EQU		'dlom'
kMailEPPCWakeup					EQU		'wkup'
kMailEPPCLocationChanged		EQU		'locc'
MailTimer				RECORD 0
frequency				 ds.l	1				; offset: $0 (0)		;  how often to connect 
						 ORG 0
connectTime				 ds.l	1				; offset: $0 (0)		;  time since midnight 
sizeof					 EQU *					; size:   $4 (4)
						ENDR

kMailTimerOff					EQU		0					; control is off 
kMailTimerTime					EQU		1					; specifies connect time (relative to midnight) 
kMailTimerFrequency				EQU		2					; specifies connect frequency 
; typedef Byte 							MailTimerKind

MailTimers				RECORD 0
sendTimeKind			 ds.b	1				; offset: $0 (0)		;  either kMailTimerTime or kMailTimerFrequency 
receiveTimeKind			 ds.b	1				; offset: $1 (1)		;  either kMailTimerTime or kMailTimerFrequency 
send					 ds		MailTimer		; offset: $2 (2)
receive					 ds		MailTimer		; offset: $6 (6)
sizeof					 EQU *					; size:   $A (10)
						ENDR

MailStandardSlotInfoAttribute RECORD 0
version					 ds.w	1				; offset: $0 (0)
active					 ds.b	1				; offset: $2 (2)		;  active if MailLocationMask(i) is set 
padByte					 ds.b	1				; offset: $3 (3)
sendReceiveTimer		 ds		MailTimers		; offset: $4 (4)
sizeof					 EQU *					; size:   $E (14)
						ENDR
PMSAMGetMSAMRecordPB	RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
msamCID					 ds		CreationID		; offset: $18 (24)
sizeof					 EQU *					; size:   $20 (32)
						ENDR
PMSAMOpenQueuesPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
inQueueRef				 ds.l	1				; offset: $18 (24)
outQueueRef				 ds.l	1				; offset: $1C (28)
msamSlotID				 ds.w	1				; offset: $20 (32)
filler					 ds.l	2				; offset: $22 (34)
sizeof					 EQU *					; size:   $2A (42)
						ENDR
; typedef unsigned short 				PMSAMStatus

;  Values of PMSAMStatus 

kPMSAMStatusPending				EQU		1					; for inQueue and outQueue 
kPMSAMStatusError				EQU		2					; for inQueue and outQueue 
kPMSAMStatusSending				EQU		3					; for outQueue only 
kPMSAMStatusCaching				EQU		4					; for inQueue only 
kPMSAMStatusSent				EQU		5					; for outQueue only 
PMSAMSetStatusPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
queueRef				 ds.l	1				; offset: $18 (24)
seqNum					 ds.l	1				; offset: $1C (28)
msgHint					 ds.l	1				; offset: $20 (32)		;  for posting cache error,set this to 0 when report outq status 
status					 ds.w	1				; offset: $24 (36)
sizeof					 EQU *					; size:   $26 (38)
						ENDR
PMSAMLogErrorPB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
msamSlotID				 ds.w	1				; offset: $18 (24)		;  0 for PMSAM errors 
logEntry				 ds.l	1				; offset: $1A (26)
filler					 ds.l	2				; offset: $1E (30)
sizeof					 EQU *					; size:   $26 (38)
						ENDR
; ***************************************************************************************

kMailMsgSummaryVersion			EQU		1
MailMasterData			RECORD 0
attrMask				 ds.l	1				; offset: $0 (0)		;  indicates attributes present in MsgSummary 
messageID				 ds		MailLetterID	; offset: $4 (4)
replyID					 ds		MailLetterID	; offset: $14 (20)
conversationID			 ds		MailLetterID	; offset: $24 (36)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
;  Values for addressedToMe in struct MailCoreData 

kAddressedAs_TO					EQU		$01
kAddressedAs_CC					EQU		$02
kAddressedAs_BCC				EQU		$04
MailCoreData			RECORD 0
letterFlags				 ds		MailLetterFlags ; offset: $0 (0)
messageSize				 ds.l	1				; offset: $4 (4)
letterIndications		 ds.l	1				; offset: $8 (8)
messageType				 ds		OCECreatorType ; offset: $C (12)
sendTime				 ds		MailTime		; offset: $14 (20)
messageFamily			 ds.l	1				; offset: $1C (28)
reserved				 ds.b	1				; offset: $20 (32)
addressedToMe			 ds.b	1				; offset: $21 (33)
agentInfo				 ds.b	6				; offset: $22 (34)		;  6 bytes of special info [set to zero] 
;  these are variable length and even padded 
sender					 ds		RString32		; offset: $28 (40)		;  recipient's entityName (trunc)
subject					 ds		RString32		; offset: $4C (76)		;  subject maybe truncated 
sizeof					 EQU *					; size:   $70 (112)
						ENDR
MSAMMsgSummary			RECORD 0
version					 ds.w	1				; offset: $0 (0)		;  following flags are defaulted by Toolbox 
msgDeleted				 ds.b	1				; offset: $2 (2)		;  true if msg is to be deleted by PMSAM 
msgUpdated				 ds.b	1				; offset: $3 (3)		;  true if msgSummary was updated by MailManager 
msgCached				 ds.b	1				; offset: $4 (4)		;  true if msg is in the slot's InQueue 
padByte					 ds.b	1				; offset: $5 (5)
masterData				 ds		MailMasterData ; offset: $6 (6)
coreData				 ds		MailCoreData	; offset: $3A (58)
sizeof					 EQU *					; size:   $AA (170)
						ENDR
;  PMSAM can put up to 128 bytes of private msg summary data 

kMailMaxPMSAMMsgSummaryData		EQU		128
PMSAMCreateMsgSummaryPB	RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
inQueueRef				 ds.l	1				; offset: $18 (24)
seqNum					 ds.l	1				; offset: $1C (28)		;  <- seq of the new message 
msgSummary				 ds.l	1				; offset: $20 (32)		;  attributes and mask filled in 
buffer					 ds.l	1				; offset: $24 (36)		;  PMSAM specific data to be appended 
sizeof					 EQU *					; size:   $28 (40)
						ENDR

PMSAMPutMsgSummaryPB	RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
inQueueRef				 ds.l	1				; offset: $18 (24)
seqNum					 ds.l	1				; offset: $1C (28)
letterFlags				 ds.l	1				; offset: $20 (32)		;  if not nil, then set msgStoreFlags 
buffer					 ds.l	1				; offset: $24 (36)		;  PMSAM specific data to be overwritten 
sizeof					 EQU *					; size:   $28 (40)
						ENDR
PMSAMGetMsgSummaryPB	RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
inQueueRef				 ds.l	1				; offset: $18 (24)
seqNum					 ds.l	1				; offset: $1C (28)
msgSummary				 ds.l	1				; offset: $20 (32)		;  if not nil, then read in the msgSummary 
buffer					 ds.l	1				; offset: $24 (36)		;  PMSAM specific data to be read 
msgSummaryOffset		 ds.w	1				; offset: $28 (40)		;  offset of PMSAM specific data from start of MsgSummary 
sizeof					 EQU *					; size:   $2A (42)
						ENDR
; ***************************************************************************************
;  Definitions for Server MSAMs 
; *************************************************************************************
; typedef unsigned short 				SMSAMAdminCode

;  Values of SMSAMAdminCode 

kSMSAMNotifyFwdrSetupChange		EQU		1
kSMSAMNotifyFwdrNameChange		EQU		2
kSMSAMNotifyFwdrPwdChange		EQU		3
kSMSAMGetDynamicFwdrParams		EQU		4
; typedef unsigned long 				SMSAMSlotChanges


kSMSAMFwdrHomeInternetChangedBit EQU	0
kSMSAMFwdrConnectedToChangedBit	EQU		1
kSMSAMFwdrForeignRLIsChangedBit	EQU		2
kSMSAMFwdrMnMServerChangedBit	EQU		3
;  Values of SMSAMSlotChanges 

kSMSAMFwdrEverythingChangedMask	EQU		-1
kSMSAMFwdrHomeInternetChangedMask EQU	$00000001
kSMSAMFwdrConnectedToChangedMask EQU	$00000002
kSMSAMFwdrForeignRLIsChangedMask EQU	$00000004
kSMSAMFwdrMnMServerChangedMask	EQU		$00000008
;  kSMSAMNotifyFwdrSetupChange 
SMSAMSetupChange		RECORD 0
whatChanged				 ds.l	1				; offset: $0 (0)		;   --> bitmap of what parameters changed 
serverHint				 ds		AddrBlock		; offset: $4 (4)		;   --> try this ADAP server first 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  kSMSAMNotifyFwdrNameChange 
SMSAMNameChange			RECORD 0
newName					 ds		RString			; offset: $0 (0)		;   --> msams new name 
serverHint				 ds		AddrBlock		; offset: $104 (260)	;   --> try this ADAP server first 
sizeof					 EQU *					; size:   $108 (264)
						ENDR
;  kSMSAMNotifyFwdrPasswordChange 
SMSAMPasswordChange		RECORD 0
newPassword				 ds		RString			; offset: $0 (0)		;   --> msams new password 
serverHint				 ds		AddrBlock		; offset: $104 (260)	;   --> try this ADAP server first 
sizeof					 EQU *					; size:   $108 (264)
						ENDR
;  kSMSAMGetDynamicFwdrParams 
SMSAMDynamicParams		RECORD 0
curDiskUsed				 ds.l	1				; offset: $0 (0)		;  <--  amount of disk space used by msam 
curMemoryUsed			 ds.l	1				; offset: $4 (4)		;  <--  amount of memory used by msam 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
SMSAMAdminEPPCRequest	RECORD 0
adminCode				 ds.w	1				; offset: $0 (0)
setupChange				 ds		SMSAMSetupChange ; offset: $2 (2)
						 ORG 2
nameChange				 ds		SMSAMNameChange ; offset: $2 (2)
						 ORG 2
passwordChange			 ds		SMSAMPasswordChange ; offset: $2 (2)
						 ORG 2
dynamicParams			 ds		SMSAMDynamicParams ; offset: $2 (2)
						 ORG 266
sizeof					 EQU *					; size:   $10A (266)
						ENDR
SMSAMSetupPB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
serverMSAM				 ds.l	1				; offset: $18 (24)
password				 ds.l	1				; offset: $1C (28)
gatewayType				 ds.l	1				; offset: $20 (32)
gatewayTypeDescription	 ds.l	1				; offset: $24 (36)
catalogServerHint		 ds		AddrBlock		; offset: $28 (40)
sizeof					 EQU *					; size:   $2C (44)
						ENDR
SMSAMStartupPB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
msamIdentity			 ds.l	1				; offset: $18 (24)
queueRef				 ds.l	1				; offset: $1C (28)
sizeof					 EQU *					; size:   $20 (32)
						ENDR
SMSAMShutdownPB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
queueRef				 ds.l	1				; offset: $18 (24)
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; ***************************************************************************************
;  Definitions for reading and writing MSAM Letters 
; ***************************************************************************************
MSAMEnumeratePB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
queueRef				 ds.l	1				; offset: $18 (24)
startSeqNum				 ds.l	1				; offset: $1C (28)
nextSeqNum				 ds.l	1				; offset: $20 (32)
;  buffer contains a Mail Reply. Each tuple is a MSAMEnumerateInQReply when enumerating the inQueue MSAMEnumerateOutQReply when enumerating the outQueue 
buffer					 ds		MailBuffer		; offset: $24 (36)
sizeof					 EQU *					; size:   $30 (48)
						ENDR
MSAMEnumerateInQReply	RECORD 0
seqNum					 ds.l	1				; offset: $0 (0)
msgDeleted				 ds.b	1				; offset: $4 (4)		;  true if msg is to be deleted by PMSAM 
msgUpdated				 ds.b	1				; offset: $5 (5)		;  true if MsgSummary has been updated by TB 
msgCached				 ds.b	1				; offset: $6 (6)		;  true if msg is in the incoming queue 
padByte					 ds.b	1				; offset: $7 (7)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
MSAMEnumerateOutQReply	RECORD 0
seqNum					 ds.l	1				; offset: $0 (0)
done					 ds.b	1				; offset: $4 (4)		;  true if all responsible recipients have been processed 
priority				 ds.b	1				; offset: $5 (5)
msgFamily				 ds.l	1				; offset: $6 (6)
approxSize				 ds.l	1				; offset: $A (10)
tunnelForm				 ds.b	1				; offset: $E (14)		;  true if this letter has to be tunnelled 
padByte					 ds.b	1				; offset: $F (15)
nextHop					 ds		NetworkSpec		; offset: $10 (16)		;  valid if tunnelForm is true 
msgType					 ds		OCECreatorType ; offset: $34 (52)
sizeof					 EQU *					; size:   $3C (60)
						ENDR
MSAMDeletePB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
queueRef				 ds.l	1				; offset: $18 (24)
seqNum					 ds.l	1				; offset: $1C (28)
msgOnly					 ds.b	1				; offset: $20 (32)		;  only valid for PMSAM & inQueue 
;  set true to delete message but not msgSummary 
padByte					 ds.b	1				; offset: $21 (33)
;  only valid for SMSAM & tunnelled messages 
result					 ds.w	1				; offset: $22 (34)
sizeof					 EQU *					; size:   $24 (36)
						ENDR
MSAMOpenPB				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
queueRef				 ds.l	1				; offset: $18 (24)
seqNum					 ds.l	1				; offset: $1C (28)
mailMsgRef				 ds.l	1				; offset: $20 (32)
sizeof					 EQU *					; size:   $24 (36)
						ENDR
MSAMOpenNestedPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
nestedRef				 ds.l	1				; offset: $1C (28)
sizeof					 EQU *					; size:   $20 (32)
						ENDR
MSAMClosePB				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
sizeof					 EQU *					; size:   $1C (28)
						ENDR
MSAMGetMsgHeaderPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
selector				 ds.b	1				; offset: $1C (28)
filler1					 ds.b	1				; offset: $1D (29)
offset					 ds.l	1				; offset: $1E (30)
buffer					 ds		MailBuffer		; offset: $22 (34)
remaining				 ds.l	1				; offset: $2E (46)
sizeof					 EQU *					; size:   $32 (50)
						ENDR
; 	MSAMGetAttributesPB.buffer returned will contain the attribute values of 
;	the attributes indicated in responseMask, 
;	from the attribute indicated by the least significant bit set
;	to the attribute indicated by the most significant bit set.
;	Note that recipients - from, to, cc, bcc cannot be read using
;	this call. Use GetRecipients to read these. 
;

MSAMGetAttributesPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
requestMask				 ds.l	1				; offset: $1C (28)		;  kMailIndicationsBit thru kMailSubjectBit 
buffer					 ds		MailBuffer		; offset: $20 (32)
responseMask			 ds.l	1				; offset: $2C (44)
more					 ds.b	1				; offset: $30 (48)
filler1					 ds.b	1				; offset: $31 (49)
sizeof					 EQU *					; size:   $32 (50)
						ENDR
;  attrID value to get resolved recipient list 

kMailResolvedList				EQU		0
MailOriginalRecipient	RECORD 0
index					 ds.w	1				; offset: $0 (0)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
;  Followed by OCEPackedRecipient 


MailResolvedRecipient	RECORD 0
index					 ds.w	1				; offset: $0 (0)
recipientFlags			 ds.w	1				; offset: $2 (2)
responsible				 ds.b	1				; offset: $4 (4)
padByte					 ds.b	1				; offset: $5 (5)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
;  Followed by OCEPackedRecipient 


;  	MSAMGetRecipientsPB.buffer contains a Mail Reply. Each tuple is a
;	MailOriginalRecipient if getting original recipients 
;							ie the attrID is kMail[From, To, Cc, Bcc]Bit
;	MailResolvedRecipient if getting resolved reicpients
;							ie the attrID is kMailResolvedList
;	Both tuples are word alligned.  
;

MSAMGetRecipientsPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
attrID					 ds.w	1				; offset: $1C (28)		;  kMailFromBit thru kMailBccBit 
startIndex				 ds.w	1				; offset: $1E (30)		;  starts at 1 
buffer					 ds		MailBuffer		; offset: $20 (32)
nextIndex				 ds.w	1				; offset: $2C (44)
more					 ds.b	1				; offset: $2E (46)
filler1					 ds.b	1				; offset: $2F (47)
sizeof					 EQU *					; size:   $30 (48)
						ENDR
MSAMGetContentPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
segmentMask				 ds.w	1				; offset: $1C (28)
buffer					 ds		MailBuffer		; offset: $1E (30)
textScrap				 ds.l	1				; offset: $2A (42)
script					 ds.w	1				; offset: $2E (46)
segmentType				 ds.w	1				; offset: $30 (48)
endOfScript				 ds.b	1				; offset: $32 (50)
endOfSegment			 ds.b	1				; offset: $33 (51)
endOfContent			 ds.b	1				; offset: $34 (52)
filler1					 ds.b	1				; offset: $35 (53)
segmentLength			 ds.l	1				; offset: $36 (54)		;  NEW: <-  valid first call in a segment 
segmentID				 ds.l	1				; offset: $3A (58)		;  NEW: <-> identifier for this segment 
sizeof					 EQU *					; size:   $3E (62)
						ENDR
MSAMGetEnclosurePB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
contentEnclosure		 ds.b	1				; offset: $1C (28)
padByte					 ds.b	1				; offset: $1D (29)
buffer					 ds		MailBuffer		; offset: $1E (30)
endOfFile				 ds.b	1				; offset: $2A (42)
endOfEnclosures			 ds.b	1				; offset: $2B (43)
sizeof					 EQU *					; size:   $2C (44)
						ENDR
MailBlockInfo			RECORD 0
blockType				 ds		OCECreatorType ; offset: $0 (0)
offset					 ds.l	1				; offset: $8 (8)
blockLength				 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
MSAMEnumerateBlocksPB	RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
startIndex				 ds.w	1				; offset: $1C (28)		;  starts at 1 
buffer					 ds		MailBuffer		; offset: $1E (30)
;  	buffer contains a Mail Reply. Each tuple is a MailBlockInfo 
nextIndex				 ds.w	1				; offset: $2A (42)
more					 ds.b	1				; offset: $2C (44)
filler1					 ds.b	1				; offset: $2D (45)
sizeof					 EQU *					; size:   $2E (46)
						ENDR
MSAMGetBlockPB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
blockType				 ds		OCECreatorType ; offset: $1C (28)
blockIndex				 ds.w	1				; offset: $24 (36)
buffer					 ds		MailBuffer		; offset: $26 (38)
dataOffset				 ds.l	1				; offset: $32 (50)
endOfBlock				 ds.b	1				; offset: $36 (54)
padByte					 ds.b	1				; offset: $37 (55)
remaining				 ds.l	1				; offset: $38 (56)
sizeof					 EQU *					; size:   $3C (60)
						ENDR
;  YOU SHOULD BE USING THE NEW FORM OF MARK RECIPIENTS
; * THIS VERSION IS MUCH SLOWER AND KEPT FOR COMPATIBILITY
; * REASONS.
;

;  not valid for tunnel form letters 
MSAMMarkRecipientsPB	RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
queueRef				 ds.l	1				; offset: $18 (24)
seqNum					 ds.l	1				; offset: $1C (28)
buffer					 ds		MailBuffer		; offset: $20 (32)		;  	buffer contains a Mail Reply. Each tuple is an unsigned short, the index of a recipient to be marked. 
sizeof					 EQU *					; size:   $2C (44)
						ENDR
;  
; * same as MSAMMarkRecipients except it takes a mailMsgRef instead of 
; * queueRef, seqNum 
;

;  not valid for tunnel form letters 
MSAMnMarkRecipientsPB	RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
buffer					 ds		MailBuffer		; offset: $1C (28)		;  	buffer contains a Mail Reply. Each tuple is an unsigned short, the index of a recipient to be marked. 
sizeof					 EQU *					; size:   $28 (40)
						ENDR
; ***************************************************************************************
MSAMCreatePB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
queueRef				 ds.l	1				; offset: $18 (24)
asLetter				 ds.b	1				; offset: $1C (28)		;  indicate if we should create as letter or msg 
filler1					 ds.b	1				; offset: $1D (29)
msgType					 ds		IPMMsgType		; offset: $1E (30)		;  up to application discretion: must be of IPMSenderTag  kIPMOSFormatType for asLetter=true 
refCon					 ds.l	1				; offset: $42 (66)		;  for messages only 
seqNum					 ds.l	1				; offset: $46 (70)		;  set if creating message in the inQueue 
tunnelForm				 ds.b	1				; offset: $4A (74)		;  if true tunnelForm else newForm 
bccRecipients			 ds.b	1				; offset: $4B (75)		;  true if creating letter with bcc recipients 
newRef					 ds.l	1				; offset: $4C (76)
sizeof					 EQU *					; size:   $50 (80)
						ENDR
MSAMBeginNestedPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
refCon					 ds.l	1				; offset: $1C (28)		;  for messages only 
msgType					 ds		IPMMsgType		; offset: $20 (32)
sizeof					 EQU *					; size:   $44 (68)
						ENDR
MSAMEndNestedPB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
sizeof					 EQU *					; size:   $1C (28)
						ENDR
MSAMSubmitPB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
submitFlag				 ds.b	1				; offset: $1C (28)
padByte					 ds.b	1				; offset: $1D (29)
msgID					 ds		MailLetterID	; offset: $1E (30)
sizeof					 EQU *					; size:   $2E (46)
						ENDR
MSAMPutMsgHeaderPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
replyQueue				 ds.l	1				; offset: $1C (28)
sender					 ds.l	1				; offset: $20 (32)
deliveryNotification	 ds.b	1				; offset: $24 (36)
priority				 ds.b	1				; offset: $25 (37)
sizeof					 EQU *					; size:   $26 (38)
						ENDR
MSAMPutAttributePB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
attrID					 ds.w	1				; offset: $1C (28)		;  kMailIndicationsBit thru kMailSubjectBit 
buffer					 ds		MailBuffer		; offset: $1E (30)
sizeof					 EQU *					; size:   $2A (42)
						ENDR
MSAMPutRecipientPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
attrID					 ds.w	1				; offset: $1C (28)		;  kMailFromBit thru kMailBccBit 
recipient				 ds.l	1				; offset: $1E (30)
responsible				 ds.b	1				; offset: $22 (34)		;  valid for server and message msams only 
filler1					 ds.b	1				; offset: $23 (35)
sizeof					 EQU *					; size:   $24 (36)
						ENDR
MSAMPutContentPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
segmentType				 ds.w	1				; offset: $1C (28)
append					 ds.b	1				; offset: $1E (30)
padByte					 ds.b	1				; offset: $1F (31)
buffer					 ds		MailBuffer		; offset: $20 (32)
textScrap				 ds.l	1				; offset: $2C (44)
startNewScript			 ds.b	1				; offset: $30 (48)
filler1					 ds.b	1				; offset: $31 (49)
script					 ds.w	1				; offset: $32 (50)		;  valid only if startNewScript is true 
sizeof					 EQU *					; size:   $34 (52)
						ENDR
MSAMPutEnclosurePB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
contentEnclosure		 ds.b	1				; offset: $1C (28)
padByte					 ds.b	1				; offset: $1D (29)
hfs						 ds.b	1				; offset: $1E (30)		;  true => in file system, false => in memory 
append					 ds.b	1				; offset: $1F (31)
buffer					 ds		MailBuffer		; offset: $20 (32)		;  Unused if hfs == true 
enclosure				 ds		FSSpec			; offset: $2C (44)
addlInfo				 ds		MailEnclosureInfo ; offset: $72 (114)
sizeof					 EQU *					; size:   $82 (130)
						ENDR
MSAMPutBlockPB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
refCon					 ds.l	1				; offset: $1C (28)		;  for messages only 
blockType				 ds		OCECreatorType ; offset: $20 (32)
append					 ds.b	1				; offset: $28 (40)
filler1					 ds.b	1				; offset: $29 (41)
buffer					 ds		MailBuffer		; offset: $2A (42)
mode					 ds.w	1				; offset: $36 (54)		;  if blockType is kMailTunnelLtrType or kMailHopInfoType  mode is assumed to be kMailFromMark 
offset					 ds.l	1				; offset: $38 (56)
sizeof					 EQU *					; size:   $3C (60)
						ENDR
; ***************************************************************************************
MSAMCreateReportPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
queueRef				 ds.l	1				; offset: $18 (24)		;  to distinguish personal and server MSAMs 
mailMsgRef				 ds.l	1				; offset: $1C (28)
msgID					 ds		MailLetterID	; offset: $20 (32)		;  kMailLetterIDBit of letter being reported upon 
sender					 ds.l	1				; offset: $30 (48)		;  sender of the letter you are creating report on 
sizeof					 EQU *					; size:   $34 (52)
						ENDR
MSAMPutRecipientReportPB RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailMsgRef				 ds.l	1				; offset: $18 (24)
recipientIndex			 ds.w	1				; offset: $1C (28)		;  recipient index in the original letter 
result					 ds.w	1				; offset: $1E (30)		;  result of sending the recipient 
sizeof					 EQU *					; size:   $20 (32)
						ENDR
; ***************************************************************************************
MailWakeupPMSAMPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
pmsamCID				 ds		CreationID		; offset: $18 (24)
mailSlotID				 ds.w	1				; offset: $20 (32)
sizeof					 EQU *					; size:   $22 (34)
						ENDR
MailCreateMailSlotPB	RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailboxRef				 ds.l	1				; offset: $18 (24)
timeout					 ds.l	1				; offset: $1C (28)
pmsamCID				 ds		CreationID		; offset: $20 (32)
smca					 ds		SMCA			; offset: $28 (40)
sizeof					 EQU *					; size:   $38 (56)
						ENDR
MailModifyMailSlotPB	RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
mailboxRef				 ds.l	1				; offset: $18 (24)
timeout					 ds.l	1				; offset: $1C (28)
pmsamCID				 ds		CreationID		; offset: $20 (32)
smca					 ds		SMCA			; offset: $28 (40)
sizeof					 EQU *					; size:   $38 (56)
						ENDR
MSAMParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
reservedH1				 ds.l	1				; offset: $4 (4)
reservedH2				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
saveA5					 ds.l	1				; offset: $12 (18)
reqCode					 ds.w	1				; offset: $16 (22)
						 ORG 0
pmsamGetMSAMRecord		 ds		PMSAMGetMSAMRecordPB ; offset: $0 (0)
						 ORG 0
pmsamOpenQueues			 ds		PMSAMOpenQueuesPB ; offset: $0 (0)
						 ORG 0
pmsamSetStatus			 ds		PMSAMSetStatusPB ; offset: $0 (0)
						 ORG 0
pmsamLogError			 ds		PMSAMLogErrorPB ; offset: $0 (0)
						 ORG 0
smsamSetup				 ds		SMSAMSetupPB	; offset: $0 (0)
						 ORG 0
smsamStartup			 ds		SMSAMStartupPB ; offset: $0 (0)
						 ORG 0
smsamShutdown			 ds		SMSAMShutdownPB ; offset: $0 (0)
						 ORG 0
msamEnumerate			 ds		MSAMEnumeratePB ; offset: $0 (0)
						 ORG 0
msamDelete				 ds		MSAMDeletePB	; offset: $0 (0)
						 ORG 0
msamOpen				 ds		MSAMOpenPB		; offset: $0 (0)
						 ORG 0
msamOpenNested			 ds		MSAMOpenNestedPB ; offset: $0 (0)
						 ORG 0
msamClose				 ds		MSAMClosePB		; offset: $0 (0)
						 ORG 0
msamGetMsgHeader		 ds		MSAMGetMsgHeaderPB ; offset: $0 (0)
						 ORG 0
msamGetAttributes		 ds		MSAMGetAttributesPB ; offset: $0 (0)
						 ORG 0
msamGetRecipients		 ds		MSAMGetRecipientsPB ; offset: $0 (0)
						 ORG 0
msamGetContent			 ds		MSAMGetContentPB ; offset: $0 (0)
						 ORG 0
msamGetEnclosure		 ds		MSAMGetEnclosurePB ; offset: $0 (0)
						 ORG 0
msamEnumerateBlocks		 ds		MSAMEnumerateBlocksPB ; offset: $0 (0)
						 ORG 0
msamGetBlock			 ds		MSAMGetBlockPB ; offset: $0 (0)
						 ORG 0
msamMarkRecipients		 ds		MSAMMarkRecipientsPB ; offset: $0 (0)
						 ORG 0
msamnMarkRecipients		 ds		MSAMnMarkRecipientsPB ; offset: $0 (0)
						 ORG 0
msamCreate				 ds		MSAMCreatePB	; offset: $0 (0)
						 ORG 0
msamBeginNested			 ds		MSAMBeginNestedPB ; offset: $0 (0)
						 ORG 0
msamEndNested			 ds		MSAMEndNestedPB ; offset: $0 (0)
						 ORG 0
msamSubmit				 ds		MSAMSubmitPB	; offset: $0 (0)
						 ORG 0
msamPutMsgHeader		 ds		MSAMPutMsgHeaderPB ; offset: $0 (0)
						 ORG 0
msamPutAttribute		 ds		MSAMPutAttributePB ; offset: $0 (0)
						 ORG 0
msamPutRecipient		 ds		MSAMPutRecipientPB ; offset: $0 (0)
						 ORG 0
msamPutContent			 ds		MSAMPutContentPB ; offset: $0 (0)
						 ORG 0
msamPutEnclosure		 ds		MSAMPutEnclosurePB ; offset: $0 (0)		;  this field is SYSTEM8_DEPRECATED
						 ORG 0
msamPutBlock			 ds		MSAMPutBlockPB ; offset: $0 (0)
						 ORG 0
msamCreateReport		 ds		MSAMCreateReportPB ; offset: $0 (0)		;  Reports and Error Handling Calls 
						 ORG 0
msamPutRecipientReport	 ds		MSAMPutRecipientReportPB ; offset: $0 (0)
						 ORG 0
pmsamCreateMsgSummary	 ds		PMSAMCreateMsgSummaryPB ; offset: $0 (0)
						 ORG 0
pmsamPutMsgSummary		 ds		PMSAMPutMsgSummaryPB ; offset: $0 (0)
						 ORG 0
pmsamGetMsgSummary		 ds		PMSAMGetMsgSummaryPB ; offset: $0 (0)
						 ORG 0
wakeupPMSAM				 ds		MailWakeupPMSAMPB ; offset: $0 (0)
						 ORG 0
createMailSlot			 ds		MailCreateMailSlotPB ; offset: $0 (0)
						 ORG 0
modifyMailSlot			 ds		MailModifyMailSlotPB ; offset: $0 (0)
						 ORG 130
sizeof					 EQU *					; size:   $82 (130)
						ENDR
;  ASYNCHRONOUS ONLY, client must call WaitNextEvent 
;
; pascal OSErr MailCreateMailSlot(MSAMParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MailCreateMailSlot
			moveq           	#1,D0
			move.b              D0,-(sp)
			move.w              #$052B,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MailCreateMailSlot
	ENDIF

;  ASYNCHRONOUS ONLY, client must call WaitNextEvent 
;
; pascal OSErr MailModifyMailSlot(MSAMParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MailModifyMailSlot
			moveq           	#1,D0
			move.b              D0,-(sp)
			move.w              #$052C,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MailModifyMailSlot
	ENDIF

;  ASYNCHRONOUS ONLY, client must call WaitNextEvent 
;
; pascal OSErr MailWakeupPMSAM(MSAMParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MailWakeupPMSAM
			moveq           	#1,D0
			move.b              D0,-(sp)
			move.w              #$0507,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MailWakeupPMSAM
	ENDIF

;  Personal MSAM Glue Routines 
;
; pascal OSErr PMSAMOpenQueues(MSAMParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PMSAMOpenQueues
			moveq           	#0,D0
			move.b              D0,-(sp)
			move.w              #$0500,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PMSAMOpenQueues
	ENDIF

;
; pascal OSErr PMSAMSetStatus(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PMSAMSetStatus
			move.w              #$0527,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PMSAMSetStatus
	ENDIF

;  SYNC ONLY 
;
; pascal OSErr PMSAMGetMSAMRecord(MSAMParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PMSAMGetMSAMRecord
			moveq           	#0,D0
			move.b              D0,-(sp)
			move.w              #$0506,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PMSAMGetMSAMRecord
	ENDIF

;  Server MSAM Glue Routines 
;  SYNC ONLY 
;
; pascal OSErr SMSAMSetup(MSAMParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SMSAMSetup
			moveq           	#0,D0
			move.b              D0,-(sp)
			move.w              #$0523,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SMSAMSetup
	ENDIF

;  SYNC ONLY 
;
; pascal OSErr SMSAMStartup(MSAMParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SMSAMStartup
			moveq           	#0,D0
			move.b              D0,-(sp)
			move.w              #$0501,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SMSAMStartup
	ENDIF

;
; pascal OSErr SMSAMShutdown(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SMSAMShutdown
			move.w              #$0502,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SMSAMShutdown
	ENDIF

;  Get Interface Glue Routines 
;
; pascal OSErr MSAMEnumerate(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMEnumerate
			move.w              #$0503,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMEnumerate
	ENDIF

;
; pascal OSErr MSAMDelete(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMDelete
			move.w              #$0504,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMDelete
	ENDIF

;
; pascal OSErr MSAMMarkRecipients(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMMarkRecipients
			move.w              #$0505,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMMarkRecipients
	ENDIF

;
; pascal OSErr MSAMnMarkRecipients(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMnMarkRecipients
			move.w              #$0512,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMnMarkRecipients
	ENDIF

;
; pascal OSErr MSAMOpen(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMOpen
			move.w              #$0508,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMOpen
	ENDIF

;
; pascal OSErr MSAMOpenNested(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMOpenNested
			move.w              #$0509,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMOpenNested
	ENDIF

;
; pascal OSErr MSAMClose(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMClose
			move.w              #$050A,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMClose
	ENDIF

;
; pascal OSErr MSAMGetRecipients(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMGetRecipients
			move.w              #$050C,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMGetRecipients
	ENDIF

;
; pascal OSErr MSAMGetAttributes(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMGetAttributes
			move.w              #$050B,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMGetAttributes
	ENDIF

;
; pascal OSErr MSAMGetContent(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMGetContent
			move.w              #$050D,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMGetContent
	ENDIF

;
; pascal OSErr MSAMGetEnclosure(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMGetEnclosure
			move.w              #$050E,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMGetEnclosure
	ENDIF

;
; pascal OSErr MSAMEnumerateBlocks(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMEnumerateBlocks
			move.w              #$050F,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMEnumerateBlocks
	ENDIF

;
; pascal OSErr MSAMGetBlock(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMGetBlock
			move.w              #$0510,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMGetBlock
	ENDIF

;
; pascal OSErr MSAMGetMsgHeader(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMGetMsgHeader
			move.w              #$0511,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMGetMsgHeader
	ENDIF

;  Put Interface Glue Routines 
;
; pascal OSErr MSAMCreate(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMCreate
			move.w              #$0514,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMCreate
	ENDIF

;
; pascal OSErr MSAMBeginNested(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMBeginNested
			move.w              #$0515,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMBeginNested
	ENDIF

;
; pascal OSErr MSAMEndNested(MSAMParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMEndNested
			moveq           	#0,D0
			move.b              D0,-(sp)
			move.w              #$0516,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMEndNested
	ENDIF

;   SYNCHRONOUS ONLY 
;
; pascal OSErr MSAMSubmit(MSAMParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMSubmit
			moveq           	#0,D0
			move.b              D0,-(sp)
			move.w              #$0517,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMSubmit
	ENDIF

;
; pascal OSErr MSAMPutAttribute(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMPutAttribute
			move.w              #$0518,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMPutAttribute
	ENDIF

;
; pascal OSErr MSAMPutRecipient(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMPutRecipient
			move.w              #$0519,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMPutRecipient
	ENDIF

;
; pascal OSErr MSAMPutContent(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMPutContent
			move.w              #$051A,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMPutContent
	ENDIF

;   SYNCHRONOUS ONLY 
;
; pascal OSErr MSAMPutEnclosure(MSAMParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMPutEnclosure
			moveq           	#0,D0
			move.b              D0,-(sp)
			move.w              #$051B,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMPutEnclosure
	ENDIF

;
; pascal OSErr MSAMPutBlock(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMPutBlock
			move.w              #$051C,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMPutBlock
	ENDIF

;
; pascal OSErr MSAMPutMsgHeader(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMPutMsgHeader
			move.w              #$051D,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMPutMsgHeader
	ENDIF

;  Reports and Error Handling Glue Routines 
;
; pascal OSErr MSAMCreateReport(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMCreateReport
			move.w              #$051F,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMCreateReport
	ENDIF

;
; pascal OSErr MSAMPutRecipientReport(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MSAMPutRecipientReport
			move.w              #$0520,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MSAMPutRecipientReport
	ENDIF

;
; pascal OSErr PMSAMLogError(MSAMParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PMSAMLogError
			moveq           	#0,D0
			move.b              D0,-(sp)
			move.w              #$0521,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PMSAMLogError
	ENDIF

;  MsgSummary Glue Routines 
;
; pascal OSErr PMSAMCreateMsgSummary(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PMSAMCreateMsgSummary
			move.w              #$0522,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PMSAMCreateMsgSummary
	ENDIF

;
; pascal OSErr PMSAMPutMsgSummary(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PMSAMPutMsgSummary
			move.w              #$0525,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PMSAMPutMsgSummary
	ENDIF

;
; pascal OSErr PMSAMGetMsgSummary(MSAMParam *paramBlock, Boolean asyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PMSAMGetMsgSummary
			move.w              #$0526,-(sp)
			dc.w            	$AA5E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PMSAMGetMsgSummary
	ENDIF


	ENDIF ; __OCEMAIL__ 


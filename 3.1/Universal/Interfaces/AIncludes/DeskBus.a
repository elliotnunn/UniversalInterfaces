;
;	File:		DeskBus.a
;
;	Contains:	Apple Desktop Bus (ADB) Interfaces.
;
;	Version:	Technology:	System 7.5
;				Release:	Universal Interfaces 3.1
;
;	Copyright:	© 1987-1998 by Apple Computer, Inc., all rights reserved
;
;	Bugs?:		Please include the the file and version information (from above) with
;				the problem description.  Developers belonging to one of the Apple
;				developer programs can submit bug reports to:
;
;					devsupport@apple.com
;
;
	IF &TYPE('__DESKBUS__') = 'UNDEFINED' THEN
__DESKBUS__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF

	IF TARGET_OS_MAC THEN
; typedef SInt8 						ADBAddress

; 
;	TempADBServiceRoutineUPP is needed because of circular definition of
;	ADBServiceRoutineProcPtr and ADBServiceRoutineUpp depending on each other.
;

; typedef ProcPtr 						TempADBServiceRoutineUPP

ADBDataBlock			RECORD 0
devType					 ds.b	1				; offset: $0 (0)		;  original handler ID 
origADBAddr				 ds.b	1				; offset: $1 (1)		;  original ADB Address 
dbServiceRtPtr			 ds.l	1				; offset: $2 (2)		;  service routine pointer 
dbDataAreaAddr			 ds.l	1				; offset: $6 (6)		;  this field is passed as the refCon parameter to the service routine 
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct ADBDataBlock *			ADBDBlkPtr

ADBSetInfoBlock			RECORD 0
siService				 ds.l	1				; offset: $0 (0)		;  service routine pointer 
siDataAreaAddr			 ds.l	1				; offset: $4 (4)		;  this field is passed as the refCon parameter to the service routine 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct ADBSetInfoBlock *		ADBSInfoPtr

;  ADBOpBlock is only used when calling ADBOp from 68k assembly code 
ADBOpBlock				RECORD 0
dataBuffPtr				 ds.l	1				; offset: $0 (0)		;  buffer: pointer to variable length data buffer 
opServiceRtPtr			 ds.l	1				; offset: $4 (4)		;  completionProc: completion routine pointer 
opDataAreaPtr			 ds.l	1				; offset: $8 (8)		;  refCon: this field is passed as the refCon parameter to the completion routine 
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct ADBOpBlock *			ADBOpBPtr

;
; pascal void ADBReInit(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ADBReInit:	OPWORD	$A07B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ADBReInit
	ENDIF

; 
;	ADBOp has a different interface for 68k assembly than for everything else
;	for 68k assembly the interface is 
;	#pragma parameter __D0 ADBOp(__A0,__D0)
;	OSErr ADBOp( ADBOpBlock * pb, short commandNum );
;

; 
;	IMPORTANT NOTE:
;	"Inside Macintosh: Devices" documents the completion routine for ADBOp will be called with
;	four parameters using 68k register based calling conventions, specifically the completion routine
;	passed in should be of type ADBServiceRoutineProcPtr. However, when upp types were first added
;	to this interface file, the type ADBCompletionUPP was mistakenly used for the second parameter
;	to ADBOp. Since applications have shipped using completion routines of type ADBCompletionUPP,
;	the mistake cannot be corrected.
;	The only difference between ADBServiceRoutineUPP and ADBCompletionUPP is the former takes an extra
;	argument which is a pointer to itself, fortunately not needed for PowerPC code.
;	For compatibility with existing 68k code, when an ADBOp completion routine is called,
;	68k register A1 will point to the completion routine, as documented in Inside Mac.
;

;
; pascal OSErr ADBOp(Ptr refCon, ADBCompletionUPP compRout, Ptr buffer, short commandNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ADBOp:	OPWORD	$A07C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ADBOp
	ENDIF

;
; pascal short CountADBs(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	short           <= D0
		_CountADBs:	OPWORD	$A077
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CountADBs
	ENDIF

;
; pascal ADBAddress GetIndADB(ADBDataBlock *info, short devTableIndex)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	info            => A0
		;	devTableIndex   => D0
		; returns:
		;	ADBAddress      <= D0
		_GetIndADB:	OPWORD	$A078
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetIndADB
	ENDIF

;
; pascal OSErr GetADBInfo(ADBDataBlock *info, ADBAddress adbAddr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	info            => A0
		;	adbAddr         => D0
		; returns:
		;	OSErr           <= D0
		_GetADBInfo:	OPWORD	$A079
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetADBInfo
	ENDIF

;
; pascal OSErr SetADBInfo(const ADBSetInfoBlock *info, ADBAddress adbAddr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	info            => A0
		;	adbAddr         => D0
		; returns:
		;	OSErr           <= D0
		_SetADBInfo:	OPWORD	$A07A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetADBInfo
	ENDIF

	ENDIF	; TARGET_OS_MAC
	ENDIF ; __DESKBUS__ 


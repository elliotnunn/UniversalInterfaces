;
;	File:		QDOffscreen.a
;
;	Contains:	Quickdraw Offscreen GWorld Interfaces.
;
;	Version:	Technology:	Mac OS 8
;				Release:	Universal Interfaces 3.1
;
;	Copyright:	© 1985-1998 by Apple Computer, Inc., all rights reserved
;
;	Bugs?:		Please include the the file and version information (from above) with
;				the problem description.  Developers belonging to one of the Apple
;				developer programs can submit bug reports to:
;
;					devsupport@apple.com
;
;
	IF &TYPE('__QDOFFSCREEN__') = 'UNDEFINED' THEN
__QDOFFSCREEN__ SET 1

	IF &TYPE('__ERRORS__') = 'UNDEFINED' THEN
	include 'Errors.a'
	ENDIF
	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF


pixPurgeBit						EQU		0
noNewDeviceBit					EQU		1
useTempMemBit					EQU		2
keepLocalBit					EQU		3
pixelsPurgeableBit				EQU		6
pixelsLockedBit					EQU		7
mapPixBit						EQU		16
newDepthBit						EQU		17
alignPixBit						EQU		18
newRowBytesBit					EQU		19
reallocPixBit					EQU		20
clipPixBit						EQU		28
stretchPixBit					EQU		29
ditherPixBit					EQU		30
gwFlagErrBit					EQU		31

pixPurge						EQU		$00000001
noNewDevice						EQU		$00000002
useTempMem						EQU		$00000004
keepLocal						EQU		$00000008
pixelsPurgeable					EQU		$00000040
pixelsLocked					EQU		$00000080
kAllocDirectDrawSurface			EQU		$00004000
mapPix							EQU		$00010000
newDepth						EQU		$00020000
alignPix						EQU		$00040000
newRowBytes						EQU		$00080000
reallocPix						EQU		$00100000
clipPix							EQU		$10000000
stretchPix						EQU		$20000000
ditherPix						EQU		$40000000
gwFlagErr						EQU		$80000000
; typedef unsigned long 				GWorldFlags

;  Type definition of a GWorldPtr 
; typedef CGrafPtr 						GWorldPtr

;
; pascal QDErr NewGWorld(GWorldPtr *offscreenGWorld, short PixelDepth, const Rect *boundsRect, CTabHandle cTable, GDHandle aGDevice, GWorldFlags flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewGWorld
			move.l              #$00160000,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewGWorld
	ENDIF

	IF ¬ TARGET_OS_MAC THEN
;  Quicktime 3.0 
	IF TARGET_OS_WIN32 THEN
;  gdevice attribute bits

deviceIsIndirect				EQU		$00000001
deviceNeedsLock					EQU		$00000002
deviceIsStatic					EQU		$00000004
deviceIsExternalBuffer			EQU		$00000008
deviceIsDDSurface				EQU		$00000010
deviceIsDCISurface				EQU		$00000020
deviceIsGDISurface				EQU		$00000040
deviceIsAScreen					EQU		$00000080
deviceIsOverlaySurface			EQU		$00000100
;
; pascal void *GetGDeviceSurface(GDHandle gdh)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetGDeviceSurface
	ENDIF

;
; pascal unsigned long GetGDeviceAttributes(GDHandle gdh)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetGDeviceAttributes
	ENDIF

;  to allocate non-mac-rgb GWorlds use QTNewGWorld (ImageCompression.h) 
;
; pascal QDErr NewGWorldFromHBITMAP(GWorldPtr *offscreenGWorld, CTabHandle cTable, GDHandle aGDevice, GWorldFlags flags, void *newHBITMAP, void *newHDC)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewGWorldFromHBITMAP
	ENDIF

	ENDIF	; TARGET_OS_WIN32
;
; pascal QDErr NewGWorldFromPtr(GWorldPtr *offscreenGWorld, unsigned long PixelFormat, const Rect *boundsRect, CTabHandle cTable, GDHandle aGDevice, GWorldFlags flags, Ptr newBuffer, long rowBytes)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewGWorldFromPtr
	ENDIF

	ENDIF
;
; pascal Boolean LockPixels(PixMapHandle pm)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LockPixels
			move.l              #$00040001,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LockPixels
	ENDIF

;
; pascal void UnlockPixels(PixMapHandle pm)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UnlockPixels
			move.l              #$00040002,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UnlockPixels
	ENDIF

;
; pascal GWorldFlags UpdateGWorld(GWorldPtr *offscreenGWorld, short pixelDepth, const Rect *boundsRect, CTabHandle cTable, GDHandle aGDevice, GWorldFlags flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UpdateGWorld
			move.l              #$00160003,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UpdateGWorld
	ENDIF

;
; pascal void DisposeGWorld(GWorldPtr offscreenGWorld)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeGWorld
			move.l              #$00040004,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeGWorld
	ENDIF

;
; pascal void GetGWorld(CGrafPtr *port, GDHandle *gdh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetGWorld
			move.l              #$00080005,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetGWorld
	ENDIF

;
; pascal void SetGWorld(CGrafPtr port, GDHandle gdh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetGWorld
			move.l              #$00080006,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetGWorld
	ENDIF

;
; pascal void CTabChanged(CTabHandle ctab)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CTabChanged
			move.l              #$00040007,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CTabChanged
	ENDIF

;
; pascal void PixPatChanged(PixPatHandle ppat)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PixPatChanged
			move.l              #$00040008,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PixPatChanged
	ENDIF

;
; pascal void PortChanged(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PortChanged
			move.l              #$00040009,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PortChanged
	ENDIF

;
; pascal void GDeviceChanged(GDHandle gdh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GDeviceChanged
			move.l              #$0004000A,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GDeviceChanged
	ENDIF

;
; pascal void AllowPurgePixels(PixMapHandle pm)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AllowPurgePixels
			move.l              #$0004000B,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AllowPurgePixels
	ENDIF

;
; pascal void NoPurgePixels(PixMapHandle pm)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NoPurgePixels
			move.l              #$0004000C,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NoPurgePixels
	ENDIF

;
; pascal GWorldFlags GetPixelsState(PixMapHandle pm)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetPixelsState
			move.l              #$0004000D,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPixelsState
	ENDIF

;
; pascal void SetPixelsState(PixMapHandle pm, GWorldFlags state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetPixelsState
			move.l              #$0008000E,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetPixelsState
	ENDIF

;
; pascal Ptr GetPixBaseAddr(PixMapHandle pm)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetPixBaseAddr
			move.l              #$0004000F,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPixBaseAddr
	ENDIF

;
; pascal QDErr NewScreenBuffer(const Rect *globalRect, Boolean purgeable, GDHandle *gdh, PixMapHandle *offscreenPixMap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewScreenBuffer
			move.l              #$000E0010,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewScreenBuffer
	ENDIF

;
; pascal void DisposeScreenBuffer(PixMapHandle offscreenPixMap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeScreenBuffer
			move.l              #$00040011,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeScreenBuffer
	ENDIF

;
; pascal GDHandle GetGWorldDevice(GWorldPtr offscreenGWorld)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetGWorldDevice
			move.l              #$00040012,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetGWorldDevice
	ENDIF

;
; pascal Boolean QDDone(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QDDone
			move.l              #$00040013,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QDDone
	ENDIF

;
; pascal long OffscreenVersion(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OffscreenVersion
			moveq           	#20,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OffscreenVersion
	ENDIF

;
; pascal QDErr NewTempScreenBuffer(const Rect *globalRect, Boolean purgeable, GDHandle *gdh, PixMapHandle *offscreenPixMap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewTempScreenBuffer
			move.l              #$000E0015,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewTempScreenBuffer
	ENDIF

;
; pascal Boolean PixMap32Bit(PixMapHandle pmHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PixMap32Bit
			move.l              #$00040016,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PixMap32Bit
	ENDIF

;
; pascal PixMapHandle GetGWorldPixMap(GWorldPtr offscreenGWorld)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetGWorldPixMap
			move.l              #$00040017,D0
			dc.w            	$AB1D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetGWorldPixMap
	ENDIF


	ENDIF ; __QDOFFSCREEN__ 


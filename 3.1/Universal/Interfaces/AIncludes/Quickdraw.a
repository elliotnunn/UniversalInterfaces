;
;	File:		Quickdraw.a
;
;	Contains:	Interface to Quickdraw Graphics
;
;	Version:	Technology:	Mac OS 8.1
;				Release:	Universal Interfaces 3.1
;
;	Copyright:	© 1985-1998 by Apple Computer, Inc., all rights reserved
;
;	Bugs?:		Please include the the file and version information (from above) with
;				the problem description.  Developers belonging to one of the Apple
;				developer programs can submit bug reports to:
;
;					devsupport@apple.com
;
;
	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
__QUICKDRAW__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF
	IF &TYPE('__QUICKDRAWTEXT__') = 'UNDEFINED' THEN
	include 'QuickdrawText.a'
	ENDIF


invalColReq						EQU		-1					;invalid color table request

															; transfer modes 
srcCopy							EQU		0					;the 16 transfer modes
srcOr							EQU		1
srcXor							EQU		2
srcBic							EQU		3
notSrcCopy						EQU		4
notSrcOr						EQU		5
notSrcXor						EQU		6
notSrcBic						EQU		7
patCopy							EQU		8
patOr							EQU		9
patXor							EQU		10
patBic							EQU		11
notPatCopy						EQU		12
notPatOr						EQU		13
notPatXor						EQU		14
notPatBic						EQU		15					; Special Text Transfer Mode 
grayishTextOr					EQU		49
hilitetransfermode				EQU		50
hilite							EQU		50					; Arithmetic transfer modes 
blend							EQU		32
addPin							EQU		33
addOver							EQU		34
subPin							EQU		35
addMax							EQU		37
adMax							EQU		37
subOver							EQU		38
adMin							EQU		39
ditherCopy						EQU		64					; Transparent mode constant 
transparent						EQU		36

italicBit						EQU		1
ulineBit						EQU		2
outlineBit						EQU		3
shadowBit						EQU		4
condenseBit						EQU		5
extendBit						EQU		6

															; QuickDraw color separation constants 
normalBit						EQU		0					;normal screen mapping
inverseBit						EQU		1					;inverse screen mapping
redBit							EQU		4					;RGB additive mapping
greenBit						EQU		3
blueBit							EQU		2
cyanBit							EQU		8					;CMYBk subtractive mapping
magentaBit						EQU		7
yellowBit						EQU		6
blackBit						EQU		5

blackColor						EQU		33					;colors expressed in these mappings
whiteColor						EQU		30
redColor						EQU		205
greenColor						EQU		341
blueColor						EQU		409
cyanColor						EQU		273
magentaColor					EQU		137
yellowColor						EQU		69

picLParen						EQU		0					;standard picture comments
picRParen						EQU		1
clutType						EQU		0					;0 if lookup table
fixedType						EQU		1					;1 if fixed table
directType						EQU		2					;2 if direct values
gdDevType						EQU		0					;0 = monochrome 1 = color

interlacedDevice				EQU		2					; 1 if single pixel lines look bad 
roundedDevice					EQU		5					; 1 if device has been “rounded” into the GrayRgn 
hasAuxMenuBar					EQU		6					; 1 if device has an aux menu bar on it 
burstDevice						EQU		7
ext32Device						EQU		8
ramInit							EQU		10					;1 if initialized from 'scrn' resource
mainScreen						EQU		11					; 1 if main screen 
allInit							EQU		12					; 1 if all devices initialized 
screenDevice					EQU		13					;1 if screen device [not used]
noDriver						EQU		14					; 1 if no driver for this GDevice 
screenActive					EQU		15					;1 if in use
hiliteBit						EQU		7					;flag bit in HiliteMode (lowMem flag)
pHiliteBit						EQU		0					;flag bit in HiliteMode used with BitClr procedure
defQDColors						EQU		127					;resource ID of clut for default QDColors
															; pixel type 
RGBDirect						EQU		16					; 16 & 32 bits/pixel pixelType value 
															; pmVersion values 
baseAddr32						EQU		4					;pixmap base address is 32-bit address


sysPatListID					EQU		0
iBeamCursor						EQU		1
crossCursor						EQU		2
plusCursor						EQU		3
watchCursor						EQU		4

kQDGrafVerbFrame				EQU		0
kQDGrafVerbPaint				EQU		1
kQDGrafVerbErase				EQU		2
kQDGrafVerbInvert				EQU		3
kQDGrafVerbFill					EQU		4
	IF OLDROUTINENAMES THEN

frame							EQU		0
paint							EQU		1
erase							EQU		2
invert							EQU		3
fill							EQU		4
	ENDIF	; OLDROUTINENAMES
; typedef SInt8 						GrafVerb


chunky							EQU		0
chunkyPlanar					EQU		1
planar							EQU		2
; typedef SInt8 						PixelType

Bits16					RECORD 0
elements				 ds.w	16
sizeof					 EQU *					; size:   $20 (32)
						ENDR



; ***************   IMPORTANT NOTE REGARDING Pattern  **************************************
;   Patterns were originally defined as:
;   
;		C: 			typedef unsigned char Pattern[8];
;		Pascal:		Pattern = PACKED ARRAY [0..7] OF 0..255;
;		
;   The old array definition of Pattern would cause 68000 based CPU's to crash in certain circum-
;   stances. The new struct definition is safe, but may require source code changes to compile.
;	
;********************************************************************************************

Pattern					RECORD 0
pat						 ds.b	8				; offset: $0 (0)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; 
; ConstPatternParam is no longer needed.  It was first created when Pattern was an array.
; Now that Pattern is a struct, it is more straight forward to just add the "const" qualifier
; on the parameter type (e.g. "const Pattern * pat" instead of "ConstPatternParam pat").
;

; typedef struct Pattern *				PatPtr

; typedef PatPtr *						PatHandle

; typedef short 						QDErr


singleDevicesBit				EQU		0
dontMatchSeedsBit				EQU		1
allDevicesBit					EQU		2

singleDevices					EQU		$01
dontMatchSeeds					EQU		$02
allDevices						EQU		$04
; typedef unsigned long 				DeviceLoopFlags

BitMap					RECORD 0
baseAddr				 ds.l	1				; offset: $0 (0)
rowBytes				 ds.w	1				; offset: $4 (4)
bounds					 ds		Rect			; offset: $6 (6)
sizeof					 EQU *					; size:   $E (14)
						ENDR
; typedef struct BitMap *				BitMapPtr

; typedef BitMapPtr *					BitMapHandle

Cursor					RECORD 0
data					 ds		Bits16			; offset: $0 (0)
mask					 ds		Bits16			; offset: $20 (32)
hotSpot					 ds		Point			; offset: $40 (64)
sizeof					 EQU *					; size:   $44 (68)
						ENDR
; typedef struct Cursor *				CursPtr

; typedef CursPtr *						CursHandle

PenState				RECORD 0
pnLoc					 ds		Point			; offset: $0 (0)
pnSize					 ds		Point			; offset: $4 (4)
pnMode					 ds.w	1				; offset: $8 (8)
pnPat					 ds		Pattern			; offset: $A (10)
sizeof					 EQU *					; size:   $12 (18)
						ENDR
MacRegion				RECORD 0
rgnSize					 ds.w	1				; offset: $0 (0)		; size in bytes
rgnBBox					 ds		Rect			; offset: $2 (2)		; enclosing rectangle
sizeof					 EQU *					; size:   $A (10)
						ENDR
Region					RECORD 0
rgnSize					 ds.w	1				; offset: $0 (0)		; size in bytes
rgnBBox					 ds		Rect			; offset: $2 (2)		; enclosing rectangle
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct MacRegion *			RgnPtr

; typedef RgnPtr *						RgnHandle

Picture					RECORD 0
picSize					 ds.w	1				; offset: $0 (0)
picFrame				 ds		Rect			; offset: $2 (2)
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct Picture *				PicPtr

; typedef PicPtr *						PicHandle

MacPolygon				RECORD 0
polySize				 ds.w	1				; offset: $0 (0)
polyBBox				 ds		Rect			; offset: $2 (2)
polyPoints				 ds		Point			; offset: $A (10) <-- really an array of length one
sizeof					 EQU *					; size:   $E (14)
						ENDR
Polygon					RECORD 0
polySize				 ds.w	1				; offset: $0 (0)
polyBBox				 ds		Rect			; offset: $2 (2)
polyPoints				 ds		Point			; offset: $A (10) <-- really an array of length one
sizeof					 EQU *					; size:   $E (14)
						ENDR
; typedef struct MacPolygon *			PolyPtr

; typedef PolyPtr *						PolyHandle

QDProcs					RECORD 0
textProc				 ds.l	1				; offset: $0 (0)
lineProc				 ds.l	1				; offset: $4 (4)
rectProc				 ds.l	1				; offset: $8 (8)
rRectProc				 ds.l	1				; offset: $C (12)
ovalProc				 ds.l	1				; offset: $10 (16)
arcProc					 ds.l	1				; offset: $14 (20)
polyProc				 ds.l	1				; offset: $18 (24)
rgnProc					 ds.l	1				; offset: $1C (28)
bitsProc				 ds.l	1				; offset: $20 (32)
commentProc				 ds.l	1				; offset: $24 (36)
txMeasProc				 ds.l	1				; offset: $28 (40)
getPicProc				 ds.l	1				; offset: $2C (44)
putPicProc				 ds.l	1				; offset: $30 (48)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct QDProcs *				QDProcsPtr



GrafPort				RECORD 0
device					 ds.w	1				; offset: $0 (0)
portBits				 ds		BitMap			; offset: $2 (2)
portRect				 ds		Rect			; offset: $10 (16)
visRgn					 ds.l	1				; offset: $18 (24)
clipRgn					 ds.l	1				; offset: $1C (28)
bkPat					 ds		Pattern			; offset: $20 (32)
fillPat					 ds		Pattern			; offset: $28 (40)
pnLoc					 ds		Point			; offset: $30 (48)
pnSize					 ds		Point			; offset: $34 (52)
pnMode					 ds.w	1				; offset: $38 (56)
pnPat					 ds		Pattern			; offset: $3A (58)
pnVis					 ds.w	1				; offset: $42 (66)
txFont					 ds.w	1				; offset: $44 (68)
txFace					 ds.w	1				; offset: $46 (70)		; StyleField occupies 16-bits, but only first 8-bits are used
txMode					 ds.w	1				; offset: $48 (72)
txSize					 ds.w	1				; offset: $4A (74)
spExtra					 ds.l	1				; offset: $4C (76)
fgColor					 ds.l	1				; offset: $50 (80)
bkColor					 ds.l	1				; offset: $54 (84)
colrBit					 ds.w	1				; offset: $58 (88)
patStretch				 ds.w	1				; offset: $5A (90)
picSave					 ds.l	1				; offset: $5C (92)
rgnSave					 ds.l	1				; offset: $60 (96)
polySave				 ds.l	1				; offset: $64 (100)
grafProcs				 ds.l	1				; offset: $68 (104)
sizeof					 EQU *					; size:   $6C (108)
						ENDR
; typedef struct GrafPort *				GrafPtr


; 
; *	This set of definitions "belongs" in Windows.
; *	But, there is a circularity in the headers where Windows includes Controls and
; *	Controls includes Windows. To break the circle, the information
; *	needed by Controls is moved from Windows to Quickdraw.
; 

; typedef GrafPtr 						WindowPtr

; typedef WindowPtr 					DialogPtr

; typedef WindowPtr 					WindowRef

;  DragConstraint constants to pass to DragGray,DragTheRgn, or ConstrainedDragRgn
; typedef UInt16 						DragConstraint


kNoConstraint					EQU		0
kVerticalConstraint				EQU		1
kHorizontalConstraint			EQU		2

; 
; *	Here ends the list of things that "belong" in Windows.
; 



RGBColor				RECORD 0
red						 ds.w	1				; offset: $0 (0)		; magnitude of red component
green					 ds.w	1				; offset: $2 (2)		; magnitude of green component
blue					 ds.w	1				; offset: $4 (4)		; magnitude of blue component
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct RGBColor *				RGBColorPtr

; typedef RGBColorPtr *					RGBColorHdl

ColorSpec				RECORD 0
value					 ds.w	1				; offset: $0 (0)		; index or other value
rgb						 ds		RGBColor		; offset: $2 (2)		; true color
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct ColorSpec *			ColorSpecPtr

CSpecArray				RECORD 0
elements				 ds.b	1 * ColorSpec.sizeof
sizeof					 EQU *					; size:   $8 (8)
						ENDR


ColorTable				RECORD 0
ctSeed					 ds.l	1				; offset: $0 (0)		; unique identifier for table
ctFlags					 ds.w	1				; offset: $4 (4)		; high bit: 0 = PixMap; 1 = device
ctSize					 ds.w	1				; offset: $6 (6)		; number of entries in CTTable
ctTable					 ds		CSpecArray		; offset: $8 (8)		; array [0..0] of ColorSpec
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct ColorTable *			CTabPtr

; typedef CTabPtr *						CTabHandle

xColorSpec				RECORD 0
value					 ds.w	1				; offset: $0 (0)		; index or other value
rgb						 ds		RGBColor		; offset: $2 (2)		; true color
xalpha					 ds.w	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct xColorSpec *			xColorSpecPtr

xCSpecArray				RECORD 0
elements				 ds.b	1 * xColorSpec.sizeof
sizeof					 EQU *					; size:   $A (10)
						ENDR


MatchRec				RECORD 0
red						 ds.w	1				; offset: $0 (0)
green					 ds.w	1				; offset: $2 (2)
blue					 ds.w	1				; offset: $4 (4)
matchData				 ds.l	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $A (10)
						ENDR
; 
;	QuickTime 3.0 makes PixMap data structure available on non-Mac OS's.
;	In order to implement PixMap in these alternate environments, the PixMap
;	had to be extended. The pmReserved field was changed to pmExt which is
;	a Handle to extra info.  The planeBytes field was changed to pixelFormat.
;

	IF &TYPE('OLDPIXMAPSTRUCT') = 'UNDEFINED' THEN
	IF TARGET_OS_MAC THEN
	OLDPIXMAPSTRUCT: SET 1
	ELSE
	OLDPIXMAPSTRUCT: SET 0
	ENDIF	; TARGET_OS_MAC
	ENDIF
;  pixel formats

k1MonochromePixelFormat			EQU		$00000001			; 1 bit indexed
k2IndexedPixelFormat			EQU		$00000002			; 2 bit indexed
k4IndexedPixelFormat			EQU		$00000004			; 4 bit indexed
k8IndexedPixelFormat			EQU		$00000008			; 8 bit indexed
k16BE555PixelFormat				EQU		$00000010			; 16 bit BE rgb 555 (Mac)
k24RGBPixelFormat				EQU		$00000018			; 24 bit rgb 
k32ARGBPixelFormat				EQU		$00000020			; 32 bit argb	(Mac)
k1IndexedGrayPixelFormat		EQU		$00000021			; 1 bit indexed gray
k2IndexedGrayPixelFormat		EQU		$00000022			; 2 bit indexed gray
k4IndexedGrayPixelFormat		EQU		$00000024			; 4 bit indexed gray
k8IndexedGrayPixelFormat		EQU		$00000028			; 8 bit indexed gray

;  values for PixMap.pixelFormat

k16LE555PixelFormat				EQU		'L555'				; 16 bit LE rgb 555 (PC)
k16BE565PixelFormat				EQU		'B565'				; 16 bit BE rgb 565
k16LE565PixelFormat				EQU		'L565'				; 16 bit LE rgb 565
k24BGRPixelFormat				EQU		'24BG'				; 24 bit bgr 
k32BGRAPixelFormat				EQU		'BGRA'				; 32 bit bgra	(Matrox)
k32ABGRPixelFormat				EQU		'ABGR'				; 32 bit abgr	
k32RGBAPixelFormat				EQU		'RGBA'				; 32 bit rgba	
kYUVSPixelFormat				EQU		'yuvs'				; YUV 4:2:2 byte ordering 16-unsigned = 'YUY2'
kYUVUPixelFormat				EQU		'yuvu'				; YUV 4:2:2 byte ordering 16-signed
kYVU9PixelFormat				EQU		'YVU9'				; YVU9 Planar	9
kYUV411PixelFormat				EQU		'Y411'				; YUV 4:1:1 Interleaved	16
kYVYU422PixelFormat				EQU		'YVYU'				; YVYU 4:2:2 byte ordering	16
kUYVY422PixelFormat				EQU		'UYVY'				; UYVY 4:2:2 byte ordering	16
kYUV211PixelFormat				EQU		'Y211'				; YUV 2:1:1 Packed	8

	IF ¬ OLDPIXMAPSTRUCT THEN
PixMapExtension			RECORD 0
extSize					 ds.l	1				; offset: $0 (0)		; size of struct, duh!
pmBits					 ds.l	1				; offset: $4 (4)		; pixmap attributes bitfield
pmGD					 ds.l	1				; offset: $8 (8)		; this is a GDHandle
pmSeed					 ds.l	1				; offset: $C (12)
reserved0				 ds.l	1				; offset: $10 (16)		; reserved for future use
reserved1				 ds.l	1				; offset: $14 (20)
reserved2				 ds.l	1				; offset: $18 (24)
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct PixMapExtension *		PixMapExtPtr

; typedef PixMapExtPtr *				PixMapExtHandle

	ENDIF
PixMap					RECORD 0
baseAddr				 ds.l	1				; offset: $0 (0)		; pointer to pixels
rowBytes				 ds.w	1				; offset: $4 (4)		; offset to next line
bounds					 ds		Rect			; offset: $6 (6)		; encloses bitmap
pmVersion				 ds.w	1				; offset: $E (14)		; pixMap version number
packType				 ds.w	1				; offset: $10 (16)		; defines packing format
packSize				 ds.l	1				; offset: $12 (18)		; length of pixel data
hRes					 ds.l	1				; offset: $16 (22)		; horiz. resolution (ppi)
vRes					 ds.l	1				; offset: $1A (26)		; vert. resolution (ppi)
pixelType				 ds.w	1				; offset: $1E (30)		; defines pixel type
pixelSize				 ds.w	1				; offset: $20 (32)		; # bits in pixel
cmpCount				 ds.w	1				; offset: $22 (34)		; # components in pixel
cmpSize					 ds.w	1				; offset: $24 (36)		; # bits per component
planeBytes				 ds.l	1				; offset: $26 (38)		; offset to next plane
pmTable					 ds.l	1				; offset: $2A (42)		; color map for this pixMap
pmReserved				 ds.l	1				; offset: $2E (46)
sizeof					 EQU *					; size:   $32 (50)
						ENDR
; typedef struct PixMap *				PixMapPtr

; typedef PixMapPtr *					PixMapHandle

PixPat					RECORD 0
patType					 ds.w	1				; offset: $0 (0)		; type of pattern
patMap					 ds.l	1				; offset: $2 (2)		; the pattern's pixMap
patData					 ds.l	1				; offset: $6 (6)		; pixmap's data
patXData				 ds.l	1				; offset: $A (10)		; expanded Pattern data
patXValid				 ds.w	1				; offset: $E (14)		; flags whether expanded Pattern valid
patXMap					 ds.l	1				; offset: $10 (16)		; Handle to expanded Pattern data
pat1Data				 ds		Pattern			; offset: $14 (20)		; old-Style pattern/RGB color
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct PixPat *				PixPatPtr

; typedef PixPatPtr *					PixPatHandle

CCrsr					RECORD 0
crsrType				 ds.w	1				; offset: $0 (0)		; type of cursor
crsrMap					 ds.l	1				; offset: $2 (2)		; the cursor's pixmap
crsrData				 ds.l	1				; offset: $6 (6)		; cursor's data
crsrXData				 ds.l	1				; offset: $A (10)		; expanded cursor data
crsrXValid				 ds.w	1				; offset: $E (14)		; depth of expanded data (0 if none)
crsrXHandle				 ds.l	1				; offset: $10 (16)		; future use
crsr1Data				 ds		Bits16			; offset: $14 (20)		; one-bit cursor
crsrMask				 ds		Bits16			; offset: $34 (52)		; cursor's mask
crsrHotSpot				 ds		Point			; offset: $54 (84)		; cursor's hotspot
crsrXTable				 ds.l	1				; offset: $58 (88)		; private
crsrID					 ds.l	1				; offset: $5C (92)		; private
sizeof					 EQU *					; size:   $60 (96)
						ENDR
; typedef struct CCrsr *				CCrsrPtr

; typedef CCrsrPtr *					CCrsrHandle

	IF OLDROUTINELOCATIONS THEN
CIcon					RECORD 0
iconPMap				 ds		PixMap			; offset: $0 (0)		; the icon's pixMap
iconMask				 ds		BitMap			; offset: $32 (50)		; the icon's mask
iconBMap				 ds		BitMap			; offset: $40 (64)		; the icon's bitMap
iconData				 ds.l	1				; offset: $4E (78)		; the icon's data
iconMaskData			 ds.w	1				; offset: $52 (82) <-- really an array of length one ; icon's mask and BitMap data
sizeof					 EQU *					; size:   $54 (84)
						ENDR
; typedef struct CIcon *				CIconPtr

; typedef CIconPtr *					CIconHandle

	ENDIF	; OLDROUTINELOCATIONS
GammaTbl				RECORD 0
gVersion				 ds.w	1				; offset: $0 (0)		; gamma version number
gType					 ds.w	1				; offset: $2 (2)		; gamma data type
gFormulaSize			 ds.w	1				; offset: $4 (4)		; Formula data size
gChanCnt				 ds.w	1				; offset: $6 (6)		; number of channels of data
gDataCnt				 ds.w	1				; offset: $8 (8)		; number of values/channel
gDataWidth				 ds.w	1				; offset: $A (10)		; bits/corrected value (data packed to next larger byte size)
gFormulaData			 ds.w	1				; offset: $C (12) <-- really an array of length one ; data for formulas followed by gamma values
sizeof					 EQU *					; size:   $E (14)
						ENDR
; typedef struct GammaTbl *				GammaTblPtr

; typedef GammaTblPtr *					GammaTblHandle

ITab					RECORD 0
iTabSeed				 ds.l	1				; offset: $0 (0)		; copy of CTSeed from source CTable
iTabRes					 ds.w	1				; offset: $4 (4)		; bits/channel resolution of iTable
iTTable					 ds.b	1				; offset: $6 (6) <-- really an array of length one ; byte colortable index values
						 ORG 8
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct ITab *					ITabPtr

; typedef ITabPtr *						ITabHandle

SProcRec				RECORD 0
nxtSrch					 ds.l	1				; offset: $0 (0)		; SProcHndl Handle to next SProcRec
srchProc				 ds.l	1				; offset: $4 (4)		; search procedure proc ptr
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct SProcRec *				SProcPtr

; typedef SProcPtr *					SProcHndl

CProcRec				RECORD 0
nxtComp					 ds.l	1				; offset: $0 (0)		; CProcHndl Handle to next CProcRec
compProc				 ds.l	1				; offset: $4 (4)		; complement procedure proc ptr
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct CProcRec *				CProcPtr

; typedef CProcPtr *					CProcHndl

; 
;	QuickTime 3.0 makes GDevice data structure available on non-Mac OS's.
;	In order to implement GDevice in these alternate environments, the GDevice
;	had to be extended. The gdReserved field was changed to gdExt which is
;	a Handle to extra info.  
;

	IF &TYPE('OLDGDEVICESTRUCT') = 'UNDEFINED' THEN
	IF TARGET_OS_MAC THEN
	OLDGDEVICESTRUCT: SET 1
	ELSE
	OLDGDEVICESTRUCT: SET 0
	ENDIF	; TARGET_OS_MAC
	ENDIF
GDevice					RECORD 0
gdRefNum				 ds.w	1				; offset: $0 (0)		; driver's unit number
gdID					 ds.w	1				; offset: $2 (2)		; client ID for search procs
gdType					 ds.w	1				; offset: $4 (4)		; fixed/CLUT/direct
gdITable				 ds.l	1				; offset: $6 (6)		; Handle to inverse lookup table
gdResPref				 ds.w	1				; offset: $A (10)		; preferred resolution of GDITable
gdSearchProc			 ds.l	1				; offset: $C (12)		; search proc list head
gdCompProc				 ds.l	1				; offset: $10 (16)		; complement proc list
gdFlags					 ds.w	1				; offset: $14 (20)		; grafDevice flags word
gdPMap					 ds.l	1				; offset: $16 (22)		; describing pixMap
gdRefCon				 ds.l	1				; offset: $1A (26)		; reference value
gdNextGD				 ds.l	1				; offset: $1E (30)		; GDHandle Handle of next gDevice
gdRect					 ds		Rect			; offset: $22 (34)		;  device's bounds in global coordinates
gdMode					 ds.l	1				; offset: $2A (42)		; device's current mode
gdCCBytes				 ds.w	1				; offset: $2E (46)		; depth of expanded cursor data
gdCCDepth				 ds.w	1				; offset: $30 (48)		; depth of expanded cursor data
gdCCXData				 ds.l	1				; offset: $32 (50)		; Handle to cursor's expanded data
gdCCXMask				 ds.l	1				; offset: $36 (54)		; Handle to cursor's expanded mask
gdReserved				 ds.l	1				; offset: $3A (58)		; future use. MUST BE 0
sizeof					 EQU *					; size:   $3E (62)
						ENDR
; typedef struct GDevice *				GDPtr

; typedef GDPtr *						GDHandle

GrafVars				RECORD 0
rgbOpColor				 ds		RGBColor		; offset: $0 (0)		; color for addPin  subPin and average
rgbHiliteColor			 ds		RGBColor		; offset: $6 (6)		; color for hiliting
pmFgColor				 ds.l	1				; offset: $C (12)		; palette Handle for foreground color
pmFgIndex				 ds.w	1				; offset: $10 (16)		; index value for foreground
pmBkColor				 ds.l	1				; offset: $12 (18)		; palette Handle for background color
pmBkIndex				 ds.w	1				; offset: $16 (22)		; index value for background
pmFlags					 ds.w	1				; offset: $18 (24)		; flags for Palette Manager
sizeof					 EQU *					; size:   $1A (26)
						ENDR
; typedef struct GrafVars *				GVarPtr

; typedef GVarPtr *						GVarHandle

CQDProcs				RECORD 0
textProc				 ds.l	1				; offset: $0 (0)
lineProc				 ds.l	1				; offset: $4 (4)
rectProc				 ds.l	1				; offset: $8 (8)
rRectProc				 ds.l	1				; offset: $C (12)
ovalProc				 ds.l	1				; offset: $10 (16)
arcProc					 ds.l	1				; offset: $14 (20)
polyProc				 ds.l	1				; offset: $18 (24)
rgnProc					 ds.l	1				; offset: $1C (28)
bitsProc				 ds.l	1				; offset: $20 (32)
commentProc				 ds.l	1				; offset: $24 (36)
txMeasProc				 ds.l	1				; offset: $28 (40)
getPicProc				 ds.l	1				; offset: $2C (44)
putPicProc				 ds.l	1				; offset: $30 (48)
opcodeProc				 ds.l	1				; offset: $34 (52)
newProc1				 ds.l	1				; offset: $38 (56)		;  this is the StdPix bottleneck -- see ImageCompression.h 
glyphsProc				 ds.l	1				; offset: $3C (60)		;  was newProc2; now used in Unicode text drawing 
newProc3				 ds.l	1				; offset: $40 (64)
newProc4				 ds.l	1				; offset: $44 (68)
newProc5				 ds.l	1				; offset: $48 (72)
newProc6				 ds.l	1				; offset: $4C (76)
sizeof					 EQU *					; size:   $50 (80)
						ENDR
; typedef struct CQDProcs *				CQDProcsPtr

CGrafPort				RECORD 0
device					 ds.w	1				; offset: $0 (0)
portPixMap				 ds.l	1				; offset: $2 (2)		; port's pixel map
portVersion				 ds.w	1				; offset: $6 (6)		; high 2 bits always set
grafVars				 ds.l	1				; offset: $8 (8)		; Handle to more fields
chExtra					 ds.w	1				; offset: $C (12)		; character extra
pnLocHFrac				 ds.w	1				; offset: $E (14)		; pen fraction
portRect				 ds		Rect			; offset: $10 (16)
visRgn					 ds.l	1				; offset: $18 (24)
clipRgn					 ds.l	1				; offset: $1C (28)
bkPixPat				 ds.l	1				; offset: $20 (32)		; background pattern
rgbFgColor				 ds		RGBColor		; offset: $24 (36)		; RGB components of fg
rgbBkColor				 ds		RGBColor		; offset: $2A (42)		; RGB components of bk
pnLoc					 ds		Point			; offset: $30 (48)
pnSize					 ds		Point			; offset: $34 (52)
pnMode					 ds.w	1				; offset: $38 (56)
pnPixPat				 ds.l	1				; offset: $3A (58)		; pen's pattern
fillPixPat				 ds.l	1				; offset: $3E (62)		; fill pattern
pnVis					 ds.w	1				; offset: $42 (66)
txFont					 ds.w	1				; offset: $44 (68)
txFace					 ds.w	1				; offset: $46 (70)		; StyleField occupies 16-bits, but only first 8-bits are used
txMode					 ds.w	1				; offset: $48 (72)
txSize					 ds.w	1				; offset: $4A (74)
spExtra					 ds.l	1				; offset: $4C (76)
fgColor					 ds.l	1				; offset: $50 (80)
bkColor					 ds.l	1				; offset: $54 (84)
colrBit					 ds.w	1				; offset: $58 (88)
patStretch				 ds.w	1				; offset: $5A (90)
picSave					 ds.l	1				; offset: $5C (92)
rgnSave					 ds.l	1				; offset: $60 (96)
polySave				 ds.l	1				; offset: $64 (100)
grafProcs				 ds.l	1				; offset: $68 (104)
sizeof					 EQU *					; size:   $6C (108)
						ENDR
; typedef struct CGrafPort *			CGrafPtr

; typedef CGrafPtr 						CWindowPtr

ReqListRec				RECORD 0
reqLSize				 ds.w	1				; offset: $0 (0)		; request list size
reqLData				 ds.w	1				; offset: $2 (2) <-- really an array of length one ; request list data
sizeof					 EQU *					; size:   $4 (4)
						ENDR
OpenCPicParams			RECORD 0
srcRect					 ds		Rect			; offset: $0 (0)
hRes					 ds.l	1				; offset: $8 (8)
vRes					 ds.l	1				; offset: $C (12)
version					 ds.w	1				; offset: $10 (16)
reserved1				 ds.w	1				; offset: $12 (18)
reserved2				 ds.l	1				; offset: $14 (20)
sizeof					 EQU *					; size:   $18 (24)
						ENDR

kCursorImageMajorVersion		EQU		$0001
kCursorImageMinorVersion		EQU		$0000
CursorImageRec			RECORD 0
majorVersion			 ds.w	1				; offset: $0 (0)
minorVersion			 ds.w	1				; offset: $2 (2)
cursorPixMap			 ds.l	1				; offset: $4 (4)
cursorBitMask			 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct CursorImageRec *		CursorImagePtr

QDGlobals				RECORD 0
privates				 ds.b	76				; offset: $0 (0)
randSeed				 ds.l	1				; offset: $4C (76)
screenBits				 ds		BitMap			; offset: $50 (80)
arrow					 ds		Cursor			; offset: $5E (94)
dkGray					 ds		Pattern			; offset: $A2 (162)
ltGray					 ds		Pattern			; offset: $AA (170)
gray					 ds		Pattern			; offset: $B2 (178)
black					 ds		Pattern			; offset: $BA (186)
white					 ds		Pattern			; offset: $C2 (194)
thePort					 ds.l	1				; offset: $CA (202)
sizeof					 EQU *					; size:   $CE (206)
						ENDR
; typedef struct QDGlobals *			QDGlobalsPtr

; typedef QDGlobalsPtr *				QDGlobalsHdl


;	Often code written in assembly language is compiled outside of an
;	application environment.  In such cases, the Quickdraw globals
;	cannot be access normally (e.g. qd.black).  This kind of code (e.g.
;	INIT's) usually leaches off the currently install Quickdraw globals
;	by knowing that 0(a5) points to qd.thePort, as set by InitGraf().
;	
;	The record CurrentQDGlobals is defined for use in such circumstances.
;	It is biased so that thePort is at offset 0.  Below is an example
;	of using CurrentQDGlobals vs. the old assembly style:
;	
;	; Get address of Quickdraw global's black into A0
;	
;		Old non-app way:
;				MOVE.L	0(A5),A0
;				LEA		black(A0),A0	; black was EQU'ed to -16 in QuickEqu.a 
;	
;		New non-app way:
;				MOVE.L	0(A5),A0
;				LEA		CurrentQDGlobals.black(A0),A0
;	
;		New app way:
;				LEA		qd.black,A0		; elsewhere: qd  DS	QDGlobals

CurrentQDGlobals 		RECORD	{thePort},INCREMENT
privates				 ds.b   76		; offset: $FF36 (-202)
randSeed				 ds.l   1		; offset: $FF82 (-126)
screenBits				 ds     BitMap	; offset: $FF86 (-122)
arrow					 ds     Cursor	; offset: $FF94 (-108)
dkGray					 ds     Pattern	; offset: $FFD8 (-40)
ltGray					 ds     Pattern	; offset: $FFE0 (-32)
gray					 ds     Pattern	; offset: $FFE8 (-24)
black					 ds     Pattern	; offset: $FFF0 (-16)
white					 ds     Pattern	; offset: $FFF8 (-8)
thePort 				 ds.l   1		; offset: $0000 (0)
sizeof					 EQU    *-CurrentQDGlobals		; size:   $CE   (206)
						ENDR


GrafGlobals   	EQU 		0         				; A5 offset to globptr



;
; pascal void InitGraf(void *globalPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InitGraf:	OPWORD	$A86E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InitGraf
	ENDIF

;
; pascal void OpenPort(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_OpenPort:	OPWORD	$A86F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenPort
	ENDIF

;
; pascal void InitPort(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InitPort:	OPWORD	$A86D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InitPort
	ENDIF

;
; pascal void ClosePort(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ClosePort:	OPWORD	$A87D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClosePort
	ENDIF

	IF ¬ TARGET_OS_MAC THEN
;
; pascal OSErr LockPortBits(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LockPortBits
	ENDIF

;
; pascal OSErr UnlockPortBits(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UnlockPortBits
	ENDIF

;
; pascal OSErr UpdatePort(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UpdatePort
	ENDIF

;
; pascal void *GetPortNativeWindow(GrafPtr macPort)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPortNativeWindow
	ENDIF

;
; pascal GrafPtr GetNativeWindowPort(void *nativeWindow)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetNativeWindowPort
	ENDIF

;
; pascal void *MacRegionToNativeRegion(RgnHandle macRegion)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MacRegionToNativeRegion
	ENDIF

;
; pascal RgnHandle NativeRegionToMacRegion(void *nativeRegion)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NativeRegionToMacRegion
	ENDIF

	IF TARGET_OS_WIN32 THEN
;
; pascal void *GetPortHWND(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPortHWND
	ENDIF

;
; pascal GrafPtr GetHWNDPort(void *theHWND)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetHWNDPort
	ENDIF

;
; pascal void *GetPortHDC(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPortHDC
	ENDIF

;
; pascal void *GetPortHBITMAP(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPortHBITMAP
	ENDIF

;
; pascal void *GetPortHPALETTE(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPortHPALETTE
	ENDIF

;
; pascal void *GetPortHFONT(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPortHFONT
	ENDIF

;
; pascal void *GetDIBFromPICT(PicHandle hPict)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetDIBFromPICT
	ENDIF

;
; pascal PicHandle GetPICTFromDIB(void *h)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPICTFromDIB
	ENDIF

	ENDIF	; TARGET_OS_WIN32
	ENDIF
;
; pascal void SetPort(GrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetPort:	OPWORD	$A873
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetPort
	ENDIF

;
; pascal void GetPort(GrafPtr *port)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetPort:	OPWORD	$A874
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPort
	ENDIF

;
; pascal void GrafDevice(short device)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GrafDevice:	OPWORD	$A872
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GrafDevice
	ENDIF

;
; pascal void SetPortBits(const BitMap *bm)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetPortBits:	OPWORD	$A875
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetPortBits
	ENDIF

;
; pascal void PortSize(short width, short height)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PortSize:	OPWORD	$A876
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PortSize
	ENDIF

;
; pascal void MovePortTo(short leftGlobal, short topGlobal)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_MovePortTo:	OPWORD	$A877
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovePortTo
	ENDIF

;
; pascal void SetOrigin(short h, short v)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetOrigin:	OPWORD	$A878
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetOrigin
	ENDIF

;
; pascal void SetClip(RgnHandle rgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetClip:	OPWORD	$A879
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetClip
	ENDIF

;
; pascal void GetClip(RgnHandle rgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetClip:	OPWORD	$A87A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetClip
	ENDIF

;
; pascal void ClipRect(const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ClipRect:	OPWORD	$A87B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClipRect
	ENDIF

;
; pascal void BackPat(const Pattern *pat)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_BackPat:	OPWORD	$A87C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BackPat
	ENDIF

;
; pascal void InitCursor(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InitCursor:	OPWORD	$A850
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InitCursor
	ENDIF

;
; pascal void SetCursor(const Cursor *crsr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetCursor:	OPWORD	$A851
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetCursor
	ENDIF

;
; pascal void HideCursor(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_HideCursor:	OPWORD	$A852
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HideCursor
	ENDIF

;
; pascal void ShowCursor(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ShowCursor:	OPWORD	$A853
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ShowCursor
	ENDIF

;
; pascal void ObscureCursor(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ObscureCursor:	OPWORD	$A856
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ObscureCursor
	ENDIF

;
; pascal void HidePen(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_HidePen:	OPWORD	$A896
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HidePen
	ENDIF

;
; pascal void ShowPen(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ShowPen:	OPWORD	$A897
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ShowPen
	ENDIF

;
; pascal void GetPen(Point *pt)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetPen:	OPWORD	$A89A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPen
	ENDIF

;
; pascal void GetPenState(PenState *pnState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetPenState:	OPWORD	$A898
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPenState
	ENDIF

;
; pascal void SetPenState(const PenState *pnState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetPenState:	OPWORD	$A899
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetPenState
	ENDIF

;
; pascal void PenSize(short width, short height)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PenSize:	OPWORD	$A89B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PenSize
	ENDIF

;
; pascal void PenMode(short mode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PenMode:	OPWORD	$A89C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PenMode
	ENDIF

;
; pascal void PenPat(const Pattern *pat)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PenPat:	OPWORD	$A89D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PenPat
	ENDIF

;
; pascal void PenNormal(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PenNormal:	OPWORD	$A89E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PenNormal
	ENDIF

;
; pascal void MoveTo(short h, short v)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_MoveTo:	OPWORD	$A893
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MoveTo
	ENDIF

;
; pascal void Move(short dh, short dv)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Move:	OPWORD	$A894
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Move
	ENDIF

;
; pascal void LineTo(short h, short v)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_LineTo:	OPWORD	$A891
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LineTo
	ENDIF

;
; pascal void Line(short dh, short dv)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Line:	OPWORD	$A892
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Line
	ENDIF

;
; pascal void ForeColor(long color)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ForeColor:	OPWORD	$A862
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ForeColor
	ENDIF

;
; pascal void BackColor(long color)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_BackColor:	OPWORD	$A863
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BackColor
	ENDIF

;
; pascal void ColorBit(short whichBit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ColorBit:	OPWORD	$A864
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ColorBit
	ENDIF

;
; pascal void SetRect(Rect *r, short left, short top, short right, short bottom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetRect:	OPWORD	$A8A7
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetRect
	ENDIF

;
; pascal void OffsetRect(Rect *r, short dh, short dv)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_OffsetRect:	OPWORD	$A8A8
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OffsetRect
	ENDIF

;
; pascal void InsetRect(Rect *r, short dh, short dv)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InsetRect:	OPWORD	$A8A9
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InsetRect
	ENDIF

;
; pascal Boolean SectRect(const Rect *src1, const Rect *src2, Rect *dstRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SectRect:	OPWORD	$A8AA
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SectRect
	ENDIF

;
; pascal void UnionRect(const Rect *src1, const Rect *src2, Rect *dstRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_UnionRect:	OPWORD	$A8AB
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UnionRect
	ENDIF

;
; pascal Boolean EqualRect(const Rect *rect1, const Rect *rect2)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_EqualRect:	OPWORD	$A8A6
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EqualRect
	ENDIF

;
; pascal Boolean EmptyRect(const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_EmptyRect:	OPWORD	$A8AE
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EmptyRect
	ENDIF

;
; pascal void FrameRect(const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FrameRect:	OPWORD	$A8A1
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FrameRect
	ENDIF

;
; pascal void PaintRect(const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PaintRect:	OPWORD	$A8A2
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PaintRect
	ENDIF

;
; pascal void EraseRect(const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_EraseRect:	OPWORD	$A8A3
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EraseRect
	ENDIF

;
; pascal void InvertRect(const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InvertRect:	OPWORD	$A8A4
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvertRect
	ENDIF

;
; pascal void FillRect(const Rect *r, const Pattern *pat)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FillRect:	OPWORD	$A8A5
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FillRect
	ENDIF

;
; pascal void FrameOval(const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FrameOval:	OPWORD	$A8B7
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FrameOval
	ENDIF

;
; pascal void PaintOval(const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PaintOval:	OPWORD	$A8B8
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PaintOval
	ENDIF

;
; pascal void EraseOval(const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_EraseOval:	OPWORD	$A8B9
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EraseOval
	ENDIF

;
; pascal void InvertOval(const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InvertOval:	OPWORD	$A8BA
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvertOval
	ENDIF

;
; pascal void FillOval(const Rect *r, const Pattern *pat)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FillOval:	OPWORD	$A8BB
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FillOval
	ENDIF

;
; pascal void FrameRoundRect(const Rect *r, short ovalWidth, short ovalHeight)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FrameRoundRect:	OPWORD	$A8B0
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FrameRoundRect
	ENDIF

;
; pascal void PaintRoundRect(const Rect *r, short ovalWidth, short ovalHeight)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PaintRoundRect:	OPWORD	$A8B1
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PaintRoundRect
	ENDIF

;
; pascal void EraseRoundRect(const Rect *r, short ovalWidth, short ovalHeight)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_EraseRoundRect:	OPWORD	$A8B2
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EraseRoundRect
	ENDIF

;
; pascal void InvertRoundRect(const Rect *r, short ovalWidth, short ovalHeight)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InvertRoundRect:	OPWORD	$A8B3
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvertRoundRect
	ENDIF

;
; pascal void FillRoundRect(const Rect *r, short ovalWidth, short ovalHeight, const Pattern *pat)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FillRoundRect:	OPWORD	$A8B4
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FillRoundRect
	ENDIF

;
; pascal void FrameArc(const Rect *r, short startAngle, short arcAngle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FrameArc:	OPWORD	$A8BE
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FrameArc
	ENDIF

;
; pascal void PaintArc(const Rect *r, short startAngle, short arcAngle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PaintArc:	OPWORD	$A8BF
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PaintArc
	ENDIF

;
; pascal void EraseArc(const Rect *r, short startAngle, short arcAngle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_EraseArc:	OPWORD	$A8C0
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EraseArc
	ENDIF

;
; pascal void InvertArc(const Rect *r, short startAngle, short arcAngle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InvertArc:	OPWORD	$A8C1
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvertArc
	ENDIF

;
; pascal void FillArc(const Rect *r, short startAngle, short arcAngle, const Pattern *pat)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FillArc:	OPWORD	$A8C2
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FillArc
	ENDIF

;
; pascal RgnHandle NewRgn(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_NewRgn:	OPWORD	$A8D8
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewRgn
	ENDIF

;
; pascal void OpenRgn(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_OpenRgn:	OPWORD	$A8DA
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenRgn
	ENDIF

;
; pascal void CloseRgn(RgnHandle dstRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_CloseRgn:	OPWORD	$A8DB
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CloseRgn
	ENDIF

;
; pascal OSErr BitMapToRegion(RgnHandle region, const BitMap *bMap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_BitMapToRegion:	OPWORD	$A8D7
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BitMapToRegion
	ENDIF

;
; pascal void DisposeRgn(RgnHandle rgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposeRgn:	OPWORD	$A8D9
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeRgn
	ENDIF

;
; pascal void CopyRgn(RgnHandle srcRgn, RgnHandle dstRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_CopyRgn:	OPWORD	$A8DC
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyRgn
	ENDIF

;
; pascal void SetEmptyRgn(RgnHandle rgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetEmptyRgn:	OPWORD	$A8DD
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetEmptyRgn
	ENDIF

;
; pascal void SetRectRgn(RgnHandle rgn, short left, short top, short right, short bottom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetRectRgn:	OPWORD	$A8DE
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetRectRgn
	ENDIF

;
; pascal void RectRgn(RgnHandle rgn, const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_RectRgn:	OPWORD	$A8DF
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RectRgn
	ENDIF

;
; pascal void OffsetRgn(RgnHandle rgn, short dh, short dv)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_OffsetRgn:	OPWORD	$A8E0
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OffsetRgn
	ENDIF

;
; pascal void InsetRgn(RgnHandle rgn, short dh, short dv)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InsetRgn:	OPWORD	$A8E1
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InsetRgn
	ENDIF

;
; pascal void SectRgn(RgnHandle srcRgnA, RgnHandle srcRgnB, RgnHandle dstRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SectRgn:	OPWORD	$A8E4
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SectRgn
	ENDIF

;
; pascal void UnionRgn(RgnHandle srcRgnA, RgnHandle srcRgnB, RgnHandle dstRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_UnionRgn:	OPWORD	$A8E5
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UnionRgn
	ENDIF

;
; pascal void DiffRgn(RgnHandle srcRgnA, RgnHandle srcRgnB, RgnHandle dstRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DiffRgn:	OPWORD	$A8E6
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DiffRgn
	ENDIF

;
; pascal void XorRgn(RgnHandle srcRgnA, RgnHandle srcRgnB, RgnHandle dstRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_XorRgn:	OPWORD	$A8E7
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XorRgn
	ENDIF

;
; pascal Boolean RectInRgn(const Rect *r, RgnHandle rgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_RectInRgn:	OPWORD	$A8E9
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RectInRgn
	ENDIF

;
; pascal Boolean EqualRgn(RgnHandle rgnA, RgnHandle rgnB)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_EqualRgn:	OPWORD	$A8E3
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EqualRgn
	ENDIF

;
; pascal Boolean EmptyRgn(RgnHandle rgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_EmptyRgn:	OPWORD	$A8E2
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EmptyRgn
	ENDIF

;
; pascal void FrameRgn(RgnHandle rgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FrameRgn:	OPWORD	$A8D2
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FrameRgn
	ENDIF

;
; pascal void PaintRgn(RgnHandle rgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PaintRgn:	OPWORD	$A8D3
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PaintRgn
	ENDIF

;
; pascal void EraseRgn(RgnHandle rgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_EraseRgn:	OPWORD	$A8D4
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EraseRgn
	ENDIF

;
; pascal void InvertRgn(RgnHandle rgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InvertRgn:	OPWORD	$A8D5
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvertRgn
	ENDIF

;
; pascal void FillRgn(RgnHandle rgn, const Pattern *pat)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FillRgn:	OPWORD	$A8D6
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FillRgn
	ENDIF

;
; pascal void ScrollRect(const Rect *r, short dh, short dv, RgnHandle updateRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ScrollRect:	OPWORD	$A8EF
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ScrollRect
	ENDIF

;
; pascal void CopyBits(const BitMap *srcBits, const BitMap *dstBits, const Rect *srcRect, const Rect *dstRect, short mode, RgnHandle maskRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_CopyBits:	OPWORD	$A8EC
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyBits
	ENDIF

;
; pascal void SeedFill(const void *srcPtr, void *dstPtr, short srcRow, short dstRow, short height, short words, short seedH, short seedV)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SeedFill:	OPWORD	$A839
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SeedFill
	ENDIF

;
; pascal void CalcMask(const void *srcPtr, void *dstPtr, short srcRow, short dstRow, short height, short words)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_CalcMask:	OPWORD	$A838
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CalcMask
	ENDIF

;
; pascal void CopyMask(const BitMap *srcBits, const BitMap *maskBits, const BitMap *dstBits, const Rect *srcRect, const Rect *maskRect, const Rect *dstRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_CopyMask:	OPWORD	$A817
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyMask
	ENDIF

;
; pascal PicHandle OpenPicture(const Rect *picFrame)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_OpenPicture:	OPWORD	$A8F3
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenPicture
	ENDIF

;
; pascal void PicComment(short kind, short dataSize, Handle dataHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PicComment:	OPWORD	$A8F2
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PicComment
	ENDIF

;
; pascal void ClosePicture(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ClosePicture:	OPWORD	$A8F4
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClosePicture
	ENDIF

;
; pascal void DrawPicture(PicHandle myPicture, const Rect *dstRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DrawPicture:	OPWORD	$A8F6
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DrawPicture
	ENDIF

;
; pascal void KillPicture(PicHandle myPicture)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_KillPicture:	OPWORD	$A8F5
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION KillPicture
	ENDIF

;
; pascal PolyHandle OpenPoly(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_OpenPoly:	OPWORD	$A8CB
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenPoly
	ENDIF

;
; pascal void ClosePoly(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ClosePoly:	OPWORD	$A8CC
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClosePoly
	ENDIF

;
; pascal void KillPoly(PolyHandle poly)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_KillPoly:	OPWORD	$A8CD
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION KillPoly
	ENDIF

;
; pascal void OffsetPoly(PolyHandle poly, short dh, short dv)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_OffsetPoly:	OPWORD	$A8CE
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OffsetPoly
	ENDIF

;
; pascal void FramePoly(PolyHandle poly)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FramePoly:	OPWORD	$A8C6
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FramePoly
	ENDIF

;
; pascal void PaintPoly(PolyHandle poly)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PaintPoly:	OPWORD	$A8C7
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PaintPoly
	ENDIF

;
; pascal void ErasePoly(PolyHandle poly)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ErasePoly:	OPWORD	$A8C8
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ErasePoly
	ENDIF

;
; pascal void InvertPoly(PolyHandle poly)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InvertPoly:	OPWORD	$A8C9
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvertPoly
	ENDIF

;
; pascal void FillPoly(PolyHandle poly, const Pattern *pat)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FillPoly:	OPWORD	$A8CA
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FillPoly
	ENDIF

;
; pascal void SetPt(Point *pt, short h, short v)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetPt:	OPWORD	$A880
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetPt
	ENDIF

;
; pascal void LocalToGlobal(Point *pt)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_LocalToGlobal:	OPWORD	$A870
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LocalToGlobal
	ENDIF

;
; pascal void GlobalToLocal(Point *pt)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GlobalToLocal:	OPWORD	$A871
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GlobalToLocal
	ENDIF

;
; pascal short Random(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Random:	OPWORD	$A861
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Random
	ENDIF

;
; pascal void StuffHex(void *thingPtr, ConstStr255Param s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StuffHex:	OPWORD	$A866
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StuffHex
	ENDIF

;
; pascal Boolean GetPixel(short h, short v)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetPixel:	OPWORD	$A865
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPixel
	ENDIF

;
; pascal void ScalePt(Point *pt, const Rect *srcRect, const Rect *dstRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ScalePt:	OPWORD	$A8F8
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ScalePt
	ENDIF

;
; pascal void MapPt(Point *pt, const Rect *srcRect, const Rect *dstRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_MapPt:	OPWORD	$A8F9
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MapPt
	ENDIF

;
; pascal void MapRect(Rect *r, const Rect *srcRect, const Rect *dstRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_MapRect:	OPWORD	$A8FA
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MapRect
	ENDIF

;
; pascal void MapRgn(RgnHandle rgn, const Rect *srcRect, const Rect *dstRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_MapRgn:	OPWORD	$A8FB
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MapRgn
	ENDIF

;
; pascal void MapPoly(PolyHandle poly, const Rect *srcRect, const Rect *dstRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_MapPoly:	OPWORD	$A8FC
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MapPoly
	ENDIF

;
; pascal void SetStdProcs(QDProcs *procs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetStdProcs:	OPWORD	$A8EA
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetStdProcs
	ENDIF

;
; pascal void StdRect(GrafVerb verb, const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StdRect:	OPWORD	$A8A0
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StdRect
	ENDIF

;
; pascal void StdRRect(GrafVerb verb, const Rect *r, short ovalWidth, short ovalHeight)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StdRRect:	OPWORD	$A8AF
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StdRRect
	ENDIF

;
; pascal void StdOval(GrafVerb verb, const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StdOval:	OPWORD	$A8B6
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StdOval
	ENDIF

;
; pascal void StdArc(GrafVerb verb, const Rect *r, short startAngle, short arcAngle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StdArc:	OPWORD	$A8BD
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StdArc
	ENDIF

;
; pascal void StdPoly(GrafVerb verb, PolyHandle poly)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StdPoly:	OPWORD	$A8C5
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StdPoly
	ENDIF

;
; pascal void StdRgn(GrafVerb verb, RgnHandle rgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StdRgn:	OPWORD	$A8D1
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StdRgn
	ENDIF

;
; pascal void StdBits(const BitMap *srcBits, const Rect *srcRect, const Rect *dstRect, short mode, RgnHandle maskRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StdBits:	OPWORD	$A8EB
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StdBits
	ENDIF

;
; pascal void StdComment(short kind, short dataSize, Handle dataHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StdComment:	OPWORD	$A8F1
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StdComment
	ENDIF

;
; pascal void StdGetPic(void *dataPtr, short byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StdGetPic:	OPWORD	$A8EE
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StdGetPic
	ENDIF

;
; pascal void StdPutPic(const void *dataPtr, short byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StdPutPic:	OPWORD	$A8F0
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StdPutPic
	ENDIF

;
; pascal void StdOpcode(const Rect *fromRect, const Rect *toRect, UInt16 opcode, SInt16 version)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StdOpcode:	OPWORD	$ABF8
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StdOpcode
	ENDIF

;
; pascal void AddPt(Point src, Point *dst)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_AddPt:	OPWORD	$A87E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddPt
	ENDIF

;
; pascal Boolean EqualPt(Point pt1, Point pt2)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_EqualPt:	OPWORD	$A881
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EqualPt
	ENDIF

;
; pascal Boolean PtInRect(Point pt, const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PtInRect:	OPWORD	$A8AD
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PtInRect
	ENDIF

;
; pascal void Pt2Rect(Point pt1, Point pt2, Rect *dstRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Pt2Rect:	OPWORD	$A8AC
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Pt2Rect
	ENDIF

;
; pascal void PtToAngle(const Rect *r, Point pt, short *angle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PtToAngle:	OPWORD	$A8C3
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PtToAngle
	ENDIF

;
; pascal void SubPt(Point src, Point *dst)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SubPt:	OPWORD	$A87F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SubPt
	ENDIF

;
; pascal Boolean PtInRgn(Point pt, RgnHandle rgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PtInRgn:	OPWORD	$A8E8
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PtInRgn
	ENDIF

;
; pascal void StdLine(Point newPt)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_StdLine:	OPWORD	$A890
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StdLine
	ENDIF

;
; pascal void OpenCPort(CGrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_OpenCPort:	OPWORD	$AA00
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenCPort
	ENDIF

;
; pascal void InitCPort(CGrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InitCPort:	OPWORD	$AA01
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InitCPort
	ENDIF

;
; pascal void CloseCPort(CGrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_CloseCPort:	OPWORD	$AA02
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CloseCPort
	ENDIF

;
; pascal PixMapHandle NewPixMap(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_NewPixMap:	OPWORD	$AA03
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewPixMap
	ENDIF

;
; pascal void DisposePixMap(PixMapHandle pm)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposePixMap:	OPWORD	$AA04
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposePixMap
	ENDIF

;
; pascal void CopyPixMap(PixMapHandle srcPM, PixMapHandle dstPM)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_CopyPixMap:	OPWORD	$AA05
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyPixMap
	ENDIF

;
; pascal PixPatHandle NewPixPat(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_NewPixPat:	OPWORD	$AA07
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewPixPat
	ENDIF

;
; pascal void DisposePixPat(PixPatHandle pp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposePixPat:	OPWORD	$AA08
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposePixPat
	ENDIF

;
; pascal void CopyPixPat(PixPatHandle srcPP, PixPatHandle dstPP)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_CopyPixPat:	OPWORD	$AA09
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyPixPat
	ENDIF

;
; pascal void PenPixPat(PixPatHandle pp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PenPixPat:	OPWORD	$AA0A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PenPixPat
	ENDIF

;
; pascal void BackPixPat(PixPatHandle pp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_BackPixPat:	OPWORD	$AA0B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BackPixPat
	ENDIF

;
; pascal PixPatHandle GetPixPat(short patID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetPixPat:	OPWORD	$AA0C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPixPat
	ENDIF

;
; pascal void MakeRGBPat(PixPatHandle pp, const RGBColor *myColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_MakeRGBPat:	OPWORD	$AA0D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MakeRGBPat
	ENDIF

;
; pascal void FillCRect(const Rect *r, PixPatHandle pp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FillCRect:	OPWORD	$AA0E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FillCRect
	ENDIF

;
; pascal void FillCOval(const Rect *r, PixPatHandle pp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FillCOval:	OPWORD	$AA0F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FillCOval
	ENDIF

;
; pascal void FillCRoundRect(const Rect *r, short ovalWidth, short ovalHeight, PixPatHandle pp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FillCRoundRect:	OPWORD	$AA10
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FillCRoundRect
	ENDIF

;
; pascal void FillCArc(const Rect *r, short startAngle, short arcAngle, PixPatHandle pp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FillCArc:	OPWORD	$AA11
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FillCArc
	ENDIF

;
; pascal void FillCRgn(RgnHandle rgn, PixPatHandle pp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FillCRgn:	OPWORD	$AA12
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FillCRgn
	ENDIF

;
; pascal void FillCPoly(PolyHandle poly, PixPatHandle pp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FillCPoly:	OPWORD	$AA13
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FillCPoly
	ENDIF

;
; pascal void RGBForeColor(const RGBColor *color)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_RGBForeColor:	OPWORD	$AA14
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RGBForeColor
	ENDIF

;
; pascal void RGBBackColor(const RGBColor *color)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_RGBBackColor:	OPWORD	$AA15
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RGBBackColor
	ENDIF

;
; pascal void SetCPixel(short h, short v, const RGBColor *cPix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetCPixel:	OPWORD	$AA16
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetCPixel
	ENDIF

;
; pascal void SetPortPix(PixMapHandle pm)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetPortPix:	OPWORD	$AA06
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetPortPix
	ENDIF

;
; pascal void GetCPixel(short h, short v, RGBColor *cPix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetCPixel:	OPWORD	$AA17
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCPixel
	ENDIF

;
; pascal void GetForeColor(RGBColor *color)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetForeColor:	OPWORD	$AA19
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetForeColor
	ENDIF

;
; pascal void GetBackColor(RGBColor *color)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetBackColor:	OPWORD	$AA1A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetBackColor
	ENDIF

;
; pascal void SeedCFill(const BitMap *srcBits, const BitMap *dstBits, const Rect *srcRect, const Rect *dstRect, short seedH, short seedV, ColorSearchUPP matchProc, long matchData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SeedCFill:	OPWORD	$AA50
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SeedCFill
	ENDIF

;
; pascal void CalcCMask(const BitMap *srcBits, const BitMap *dstBits, const Rect *srcRect, const Rect *dstRect, const RGBColor *seedRGB, ColorSearchUPP matchProc, long matchData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_CalcCMask:	OPWORD	$AA4F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CalcCMask
	ENDIF

;
; pascal PicHandle OpenCPicture(const OpenCPicParams *newHeader)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_OpenCPicture:	OPWORD	$AA20
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenCPicture
	ENDIF

;
; pascal void OpColor(const RGBColor *color)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_OpColor:	OPWORD	$AA21
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpColor
	ENDIF

;
; pascal void HiliteColor(const RGBColor *color)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_HiliteColor:	OPWORD	$AA22
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HiliteColor
	ENDIF

;
; pascal void DisposeCTable(CTabHandle cTable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposeCTable:	OPWORD	$AA24
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeCTable
	ENDIF

;
; pascal CTabHandle GetCTable(short ctID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetCTable:	OPWORD	$AA18
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCTable
	ENDIF

;
; pascal CCrsrHandle GetCCursor(short crsrID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetCCursor:	OPWORD	$AA1B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCCursor
	ENDIF

;
; pascal void SetCCursor(CCrsrHandle cCrsr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetCCursor:	OPWORD	$AA1C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetCCursor
	ENDIF

;
; pascal void AllocCursor(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_AllocCursor:	OPWORD	$AA1D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AllocCursor
	ENDIF

;
; pascal void DisposeCCursor(CCrsrHandle cCrsr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposeCCursor:	OPWORD	$AA26
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeCCursor
	ENDIF

	IF OLDROUTINELOCATIONS THEN
;
; pascal CIconHandle GetCIcon(short iconID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetCIcon:	OPWORD	$AA1E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCIcon
	ENDIF

;
; pascal void PlotCIcon(const Rect *theRect, CIconHandle theIcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PlotCIcon:	OPWORD	$AA1F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PlotCIcon
	ENDIF

;
; pascal void DisposeCIcon(CIconHandle theIcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposeCIcon:	OPWORD	$AA25
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeCIcon
	ENDIF

	ENDIF	; OLDROUTINELOCATIONS
;
; pascal void SetStdCProcs(CQDProcs *procs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetStdCProcs:	OPWORD	$AA4E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetStdCProcs
	ENDIF

;
; pascal GDHandle GetMaxDevice(const Rect *globalRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetMaxDevice:	OPWORD	$AA27
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMaxDevice
	ENDIF

;
; pascal long GetCTSeed(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetCTSeed:	OPWORD	$AA28
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCTSeed
	ENDIF

;
; pascal GDHandle GetDeviceList(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetDeviceList:	OPWORD	$AA29
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetDeviceList
	ENDIF

;
; pascal GDHandle GetMainDevice(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetMainDevice:	OPWORD	$AA2A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMainDevice
	ENDIF

;
; pascal GDHandle GetNextDevice(GDHandle curDevice)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetNextDevice:	OPWORD	$AA2B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetNextDevice
	ENDIF

;
; pascal Boolean TestDeviceAttribute(GDHandle gdh, short attribute)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_TestDeviceAttribute:	OPWORD	$AA2C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TestDeviceAttribute
	ENDIF

;
; pascal void SetDeviceAttribute(GDHandle gdh, short attribute, Boolean value)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetDeviceAttribute:	OPWORD	$AA2D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetDeviceAttribute
	ENDIF

;
; pascal void InitGDevice(short qdRefNum, long mode, GDHandle gdh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InitGDevice:	OPWORD	$AA2E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InitGDevice
	ENDIF

;
; pascal GDHandle NewGDevice(short refNum, long mode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_NewGDevice:	OPWORD	$AA2F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewGDevice
	ENDIF

;
; pascal void DisposeGDevice(GDHandle gdh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposeGDevice:	OPWORD	$AA30
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeGDevice
	ENDIF

;
; pascal void SetGDevice(GDHandle gd)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetGDevice:	OPWORD	$AA31
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetGDevice
	ENDIF

;
; pascal GDHandle GetGDevice(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetGDevice:	OPWORD	$AA32
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetGDevice
	ENDIF

;
; pascal long Color2Index(const RGBColor *myColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Color2Index:	OPWORD	$AA33
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Color2Index
	ENDIF

;
; pascal void Index2Color(long index, RGBColor *aColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Index2Color:	OPWORD	$AA34
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Index2Color
	ENDIF

;
; pascal void InvertColor(RGBColor *myColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InvertColor:	OPWORD	$AA35
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvertColor
	ENDIF

;
; pascal Boolean RealColor(const RGBColor *color)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_RealColor:	OPWORD	$AA36
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RealColor
	ENDIF

;
; pascal void GetSubTable(CTabHandle myColors, short iTabRes, CTabHandle targetTbl)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetSubTable:	OPWORD	$AA37
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSubTable
	ENDIF

;
; pascal void MakeITable(CTabHandle cTabH, ITabHandle iTabH, short res)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_MakeITable:	OPWORD	$AA39
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MakeITable
	ENDIF

;
; pascal void AddSearch(ColorSearchUPP searchProc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_AddSearch:	OPWORD	$AA3A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddSearch
	ENDIF

;
; pascal void AddComp(ColorComplementUPP compProc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_AddComp:	OPWORD	$AA3B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddComp
	ENDIF

;
; pascal void DelSearch(ColorSearchUPP searchProc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DelSearch:	OPWORD	$AA4C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DelSearch
	ENDIF

;
; pascal void DelComp(ColorComplementUPP compProc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DelComp:	OPWORD	$AA4D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DelComp
	ENDIF

;
; pascal void SetClientID(short id)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetClientID:	OPWORD	$AA3C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetClientID
	ENDIF

;
; pascal void ProtectEntry(short index, Boolean protect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ProtectEntry:	OPWORD	$AA3D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ProtectEntry
	ENDIF

;
; pascal void ReserveEntry(short index, Boolean reserve)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ReserveEntry:	OPWORD	$AA3E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ReserveEntry
	ENDIF

;
; pascal void SetEntries(short start, short count, CSpecArray aTable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SetEntries:	OPWORD	$AA3F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetEntries
	ENDIF

;
; pascal void SaveEntries(CTabHandle srcTable, CTabHandle resultTable, ReqListRec *selection)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SaveEntries:	OPWORD	$AA49
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SaveEntries
	ENDIF

;
; pascal void RestoreEntries(CTabHandle srcTable, CTabHandle dstTable, ReqListRec *selection)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_RestoreEntries:	OPWORD	$AA4A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RestoreEntries
	ENDIF

;
; pascal short QDError(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_QDError:	OPWORD	$AA40
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QDError
	ENDIF

;
; pascal void CopyDeepMask(const BitMap *srcBits, const BitMap *maskBits, const BitMap *dstBits, const Rect *srcRect, const Rect *maskRect, const Rect *dstRect, short mode, RgnHandle maskRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_CopyDeepMask:	OPWORD	$AA51
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyDeepMask
	ENDIF

;
; pascal void DeviceLoop(RgnHandle drawingRgn, DeviceLoopDrawingUPP drawingProc, long userData, DeviceLoopFlags flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DeviceLoop:	OPWORD	$ABCA
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeviceLoop
	ENDIF

;
; pascal Ptr GetMaskTable(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	Ptr             <= A0
		_GetMaskTable:	OPWORD	$A836
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMaskTable
	ENDIF

;
; pascal PatHandle GetPattern(short patternID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetPattern:	OPWORD	$A9B8
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPattern
	ENDIF

;
; pascal CursHandle GetCursor(short cursorID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetCursor:	OPWORD	$A9B9
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCursor
	ENDIF

;
; pascal PicHandle GetPicture(short pictureID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetPicture:	OPWORD	$A9BC
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPicture
	ENDIF

;
; pascal long DeltaPoint(Point ptA, Point ptB)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DeltaPoint:	OPWORD	$A94F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeltaPoint
	ENDIF

;
; pascal void ShieldCursor(const Rect *shieldRect, Point offsetPt)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ShieldCursor:	OPWORD	$A855
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ShieldCursor
	ENDIF

;
; pascal void ScreenRes(short *scrnHRes, short *scrnVRes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ScreenRes
			move.l              (sp)+,A1
			move.w              $0102,(A1)
			move.l              (sp)+,A1
			move.w              $0104,(A1)
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ScreenRes
	ENDIF

	IF OLDROUTINENAMES THEN
;
; pascal void DisposPixMap(PixMapHandle pm)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposPixMap:	OPWORD	$AA04
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposPixMap
	ENDIF

;
; pascal void DisposPixPat(PixPatHandle pp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposPixPat:	OPWORD	$AA08
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposPixPat
	ENDIF

;
; pascal void DisposCTable(CTabHandle cTable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposCTable:	OPWORD	$AA24
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposCTable
	ENDIF

;
; pascal void DisposCCursor(CCrsrHandle cCrsr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposCCursor:	OPWORD	$AA26
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposCCursor
	ENDIF

	IF OLDROUTINELOCATIONS THEN
;
; pascal void DisposCIcon(CIconHandle theIcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposCIcon:	OPWORD	$AA25
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposCIcon
	ENDIF

	ENDIF	; OLDROUTINELOCATIONS
;
; pascal void DisposGDevice(GDHandle gdh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DisposGDevice:	OPWORD	$AA30
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposGDevice
	ENDIF

	IF OLDROUTINELOCATIONS THEN
	ENDIF	; OLDROUTINELOCATIONS
	ENDIF	; OLDROUTINENAMES
; 
;	From ToolUtils.i
;

;
; pascal void PackBits(Ptr *srcPtr, Ptr *dstPtr, short srcBytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PackBits:	OPWORD	$A8CF
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PackBits
	ENDIF

;
; pascal void UnpackBits(Ptr *srcPtr, Ptr *dstPtr, short dstBytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_UnpackBits:	OPWORD	$A8D0
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UnpackBits
	ENDIF

;
; pascal Fixed SlopeFromAngle(short angle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SlopeFromAngle:	OPWORD	$A8BC
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SlopeFromAngle
	ENDIF

;
; pascal short AngleFromSlope(Fixed slope)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_AngleFromSlope:	OPWORD	$A8C4
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AngleFromSlope
	ENDIF












	ENDIF ; __QUICKDRAW__ 


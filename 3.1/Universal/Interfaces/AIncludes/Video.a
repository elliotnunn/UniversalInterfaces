;
;	File:		Video.a
;
;	Contains:	Video Driver Interfaces.
;
;	Version:	Technology:	System 7.5
;				Release:	Universal Interfaces 3.1
;
;	Copyright:	© 1986-1998 by Apple Computer, Inc., all rights reserved
;
;	Bugs?:		Please include the the file and version information (from above) with
;				the problem description.  Developers belonging to one of the Apple
;				developer programs can submit bug reports to:
;
;					devsupport@apple.com
;
;
	IF &TYPE('__VIDEO__') = 'UNDEFINED' THEN
__VIDEO__ SET 1

	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF


mBaseOffset						EQU		1					;Id of mBaseOffset.
mRowBytes						EQU		2					;Video sResource parameter Id's 
mBounds							EQU		3					;Video sResource parameter Id's 
mVersion						EQU		4					;Video sResource parameter Id's 
mHRes							EQU		5					;Video sResource parameter Id's 
mVRes							EQU		6					;Video sResource parameter Id's 
mPixelType						EQU		7					;Video sResource parameter Id's 
mPixelSize						EQU		8					;Video sResource parameter Id's 
mCmpCount						EQU		9					;Video sResource parameter Id's 
mCmpSize						EQU		10					;Video sResource parameter Id's 
mPlaneBytes						EQU		11					;Video sResource parameter Id's 
mVertRefRate					EQU		14					;Video sResource parameter Id's 
mVidParams						EQU		1					;Video parameter block id.
mTable							EQU		2					;Offset to the table.
mPageCnt						EQU		3					;Number of pages
mDevType						EQU		4					;Device Type
oneBitMode						EQU		128					;Id of OneBitMode Parameter list.
twoBitMode						EQU		129					;Id of TwoBitMode Parameter list.
fourBitMode						EQU		130					;Id of FourBitMode Parameter list.
eightBitMode					EQU		131					;Id of EightBitMode Parameter list.

sixteenBitMode					EQU		132					;Id of SixteenBitMode Parameter list.
thirtyTwoBitMode				EQU		133					;Id of ThirtyTwoBitMode Parameter list.
firstVidMode					EQU		128					;The new, better way to do the above. 
secondVidMode					EQU		129					; QuickDraw only supports six video 
thirdVidMode					EQU		130					; at this time.      
fourthVidMode					EQU		131
fifthVidMode					EQU		132
sixthVidMode					EQU		133
spGammaDir						EQU		64
spVidNamesDir					EQU		65

;  csTimingFormat values in VDTimingInfo 
;  look in the declaration rom for timing info 

kDeclROMtables					EQU		'decl'
;  Size of a block of EDID (Extended Display Identification Data) 

kDDCBlockSize					EQU		128
;  ddcBlockType constants

kDDCBlockTypeEDID				EQU		0					; EDID block type. 
;  ddcFlags constants

kDDCForceReadBit				EQU		0					; Force a new read of the EDID. 
kDDCForceReadMask				EQU		$01					; Mask for kddcForceReadBit. 

;  Timing mode constants for Display Manager MultiMode support
;	Corresponding	.h equates are in Video.h
;					.a equates are in Video.a
;					.r equates are in DepVideoEqu.r
;	
;	The second enum is the old names (for compatibility).
;	The first enum is the new names.
;


timingInvalid					EQU		0					;	Unknown timing… force user to confirm. 
timingInvalid_SM_T24			EQU		8					;	Work around bug in SM Thunder24 card.
timingApple_FixedRateLCD		EQU		42					;	Lump all fixed-rate LCDs into one category.
timingApple_512x384_60hz		EQU		130					;  512x384  (60 Hz) Rubik timing. 
timingApple_560x384_60hz		EQU		135					;  560x384  (60 Hz) Rubik-560 timing. 
timingApple_640x480_67hz		EQU		140					;  640x480  (67 Hz) HR timing. 
timingApple_640x400_67hz		EQU		145					;  640x400  (67 Hz) HR-400 timing. 
timingVESA_640x480_60hz			EQU		150					;  640x480  (60 Hz) VGA timing. 
timingVESA_640x480_72hz			EQU		152					;  640x480  (72 Hz) VGA timing. 
timingVESA_640x480_75hz			EQU		154					;  640x480  (75 Hz) VGA timing. 
timingVESA_640x480_85hz			EQU		158					;  640x480  (85 Hz) VGA timing. 
timingGTF_640x480_120hz			EQU		159					;  640x480  (120 Hz) VESA Generalized Timing Formula 
timingApple_640x870_75hz		EQU		160					;  640x870  (75 Hz) FPD timing.
timingApple_640x818_75hz		EQU		165					;  640x818  (75 Hz) FPD-818 timing.
timingApple_832x624_75hz		EQU		170					;  832x624  (75 Hz) GoldFish timing.
timingVESA_800x600_56hz			EQU		180					;  800x600  (56 Hz) SVGA timing. 
timingVESA_800x600_60hz			EQU		182					;  800x600  (60 Hz) SVGA timing. 
timingVESA_800x600_72hz			EQU		184					;  800x600  (72 Hz) SVGA timing. 
timingVESA_800x600_75hz			EQU		186					;  800x600  (75 Hz) SVGA timing. 
timingVESA_800x600_85hz			EQU		188					;  800x600  (85 Hz) SVGA timing. 
timingVESA_1024x768_60hz		EQU		190					; 1024x768  (60 Hz) VESA 1K-60Hz timing. 
timingVESA_1024x768_70hz		EQU		200					; 1024x768  (70 Hz) VESA 1K-70Hz timing. 
timingVESA_1024x768_75hz		EQU		204					; 1024x768  (75 Hz) VESA 1K-75Hz timing (very similar to timingApple_1024x768_75hz). 
timingVESA_1024x768_85hz		EQU		208					; 1024x768  (85 Hz) VESA timing. 
timingApple_1024x768_75hz		EQU		210					; 1024x768  (75 Hz) Apple 19" RGB. 
timingApple_1152x870_75hz		EQU		220					; 1152x870  (75 Hz) Apple 21" RGB. 
timingAppleNTSC_ST				EQU		230					;  512x384  (60 Hz, interlaced, non-convolved). 
timingAppleNTSC_FF				EQU		232					;  640x480  (60 Hz, interlaced, non-convolved). 
timingAppleNTSC_STconv			EQU		234					;  512x384  (60 Hz, interlaced, convolved). 
timingAppleNTSC_FFconv			EQU		236					;  640x480  (60 Hz, interlaced, convolved). 
timingApplePAL_ST				EQU		238					;  640x480  (50 Hz, interlaced, non-convolved). 
timingApplePAL_FF				EQU		240					;  768x576  (50 Hz, interlaced, non-convolved). 
timingApplePAL_STconv			EQU		242					;  640x480  (50 Hz, interlaced, convolved). 
timingApplePAL_FFconv			EQU		244					;  768x576  (50 Hz, interlaced, convolved). 
timingVESA_1280x960_75hz		EQU		250					; 1280x960  (75 Hz) 
timingVESA_1280x960_60hz		EQU		252					; 1280x960  (60 Hz) 
timingVESA_1280x960_85hz		EQU		254					; 1280x960  (85 Hz) 
timingVESA_1280x1024_60hz		EQU		260					; 1280x1024 (60 Hz) 
timingVESA_1280x1024_75hz		EQU		262					; 1280x1024 (75 Hz) 
timingVESA_1280x1024_85hz		EQU		268					; 1280x1024 (85 Hz) 
timingVESA_1600x1200_60hz		EQU		280					; 1600x1200 (60 Hz) VESA timing. 
timingVESA_1600x1200_65hz		EQU		282					; 1600x1200 (65 Hz) VESA timing. 
timingVESA_1600x1200_70hz		EQU		284					; 1600x1200 (70 Hz) VESA timing. 
timingVESA_1600x1200_75hz		EQU		286					; 1600x1200 (75 Hz) VESA timing (pixel clock is 189.2 Mhz dot clock). 
timingVESA_1600x1200_80hz		EQU		288					; 1600x1200 (80 Hz) VESA timing (pixel clock is 216>? Mhz dot clock) - proposed only. 
timingVESA_1600x1200_85hz		EQU		289					; 1600x1200 (85 Hz) VESA timing (pixel clock is 229.5 Mhz dot clock). 
timingSMPTE240M_60hz			EQU		400					; 60Hz V, 33.75KHz H, interlaced timing, 16:9 aspect, typical resolution of 1920x1035. 
timingFilmRate_48hz				EQU		410					; 48Hz V, 25.20KHz H, non-interlaced timing, typical resolution of 640x480. 
timingSony_1600x1024_76hz		EQU		500					; 1600x1024 (76 Hz) Sony timing (pixel clock is 170.447 Mhz dot clock). 
timingSony_1920x1080_60hz		EQU		510					; 1920x1080 (60 Hz) Sony timing (pixel clock is 159.84 Mhz dot clock). 
timingSony_1920x1080_72hz		EQU		520					; 1920x1080 (72 Hz) Sony timing (pixel clock is 216.023 Mhz dot clock). 
timingSony_1900x1200_74hz		EQU		530					; 1900x1200 (74 Hz) Sony timing (pixel clock is 236.25 Mhz dot clock). 
timingSony_1900x1200_76hz		EQU		540					; 1900x1200 (76 Hz) Sony timing (pixel clock is 245.48 Mhz dot clock). 

;  Deprecated timing names.

timingApple12					EQU		130
timingApple12x					EQU		135
timingApple13					EQU		140
timingApple13x					EQU		145
timingAppleVGA					EQU		150
timingApple15					EQU		160
timingApple15x					EQU		165
timingApple16					EQU		170
timingAppleSVGA					EQU		180
timingApple1Ka					EQU		190
timingApple1Kb					EQU		200
timingApple19					EQU		210
timingApple21					EQU		220
;  csConnectFlags values in VDDisplayConnectInfo 

kAllModesValid					EQU		0					; All modes not trimmed by primary init are good close enough to try 
kAllModesSafe					EQU		1					; All modes not trimmed by primary init are know to be safe 
kReportsTagging					EQU		2					; Can detect tagged displays (to identify smart monitors) 
kHasDirectConnection			EQU		3					; True implies that driver can talk directly to device (e.g. serial data link via sense lines) 
kIsMonoDev						EQU		4					; Says whether there’s an RGB (0) or Monochrome (1) connection. 
kUncertainConnection			EQU		5					; There may not be a display (no sense lines?). 
kTaggingInfoNonStandard			EQU		6					; Set when csConnectTaggedType/csConnectTaggedData are non-standard (i.e., not the Apple CRT sense codes). 
kReportsDDCConnection			EQU		7					; Card can do ddc (set kHasDirectConnect && kHasDDCConnect if you actually found a ddc display). 
kHasDDCConnection				EQU		8					; Card has ddc connect now. 
kConnectionInactive				EQU		9					; Set when the connection is NOT currently active (generally used in a multiconnection environment). 
kDependentConnection			EQU		10					; Set when some ascpect of THIS connection depends on another (will generally be set in a kModeSimulscan environment). 
kBuiltInConnection				EQU		11					; Set when connection is KNOWN to be built-in (this is not the same as kHasDirectConnection). 
kOverrideConnection				EQU		12					; Set when the reported connection is not the true one, but is one that has been forced through a SetConnection call 
kFastCheckForDDC				EQU		13					; Set when all 3 are true: 1) sense codes indicate DDC display could be attached 2) attempted fast check 3) DDC failed 

;  csDisplayType values in VDDisplayConnectInfo 

kUnknownConnect					EQU		1					; Not sure how we’ll use this, but seems like a good idea. 
kPanelConnect					EQU		2					; For use with fixed-in-place LCD panels. 
kPanelTFTConnect				EQU		2					; Alias for kPanelConnect 
kFixedModeCRTConnect			EQU		3					;  For use with fixed-mode (i.e., very limited range) displays. 
kMultiModeCRT1Connect			EQU		4					; 320x200 maybe, 12" maybe, 13" (default), 16" certain, 19" maybe, 21" maybe 
kMultiModeCRT2Connect			EQU		5					; 320x200 maybe, 12" maybe, 13" certain, 16" (default), 19" certain, 21" maybe 
kMultiModeCRT3Connect			EQU		6					; 320x200 maybe, 12" maybe, 13" certain, 16" certain, 19" default, 21" certain 
kMultiModeCRT4Connect			EQU		7					; Expansion to large multi mode (not yet used) 
kModelessConnect				EQU		8					; Expansion to modeless model (not yet used) 
kFullPageConnect				EQU		9					; 640x818 (to get 8bpp in 512K case) and 640x870 (these two only) 
kVGAConnect						EQU		10					; 640x480 VGA default -- question everything else 
kNTSCConnect					EQU		11					; NTSC ST (default), FF, STconv, FFconv 
kPALConnect						EQU		12					; PAL ST (default), FF, STconv, FFconv 
kHRConnect						EQU		13					; Straight-6 connect -- 640x480 and 640x400 (to get 8bpp in 256K case) (these two only) 
kPanelFSTNConnect				EQU		14					; For use with fixed-in-place LCD FSTN (aka “Supertwist”) panels 
kMonoTwoPageConnect				EQU		15					; 1152x870 Apple color two-page display 
kColorTwoPageConnect			EQU		16					; 1152x870 Apple B&W two-page display 
kColor16Connect					EQU		17					; 832x624 Apple B&W two-page display 
kColor19Connect					EQU		18					; 1024x768 Apple B&W two-page display 
kGenericCRT						EQU		19					; Indicates nothing except that connection is CRT in nature. 
kGenericLCD						EQU		20					; Indicates nothing except that connection is LCD in nature. 
kDDCConnect						EQU		21					; DDC connection, always set kHasDDCConnection 
;  csTimingFlags values in VDTimingInfoRec 

kModeValid						EQU		0					; Says that this mode should NOT be trimmed. 
kModeSafe						EQU		1					; This mode does not need confirmation 
kModeDefault					EQU		2					; This is the default mode for this type of connection 
kModeShowNow					EQU		3					; This mode should always be shown (even though it may require a confirm) 
kModeNotResize					EQU		4					; This mode should not be used to resize the display (eg. mode selects a different connector on card) 
kModeRequiresPan				EQU		5					; This mode has more pixels than are actually displayed 
kModeInterlaced					EQU		6					; This mode is interlaced (single pixel lines look bad). 
kModeShowNever					EQU		7					; This mode should not be shown in the user interface. 
kModeSimulscan					EQU		8					; Indicates that more than one display connection can be driven from a single framebuffer controller. 
kModeNotPreset					EQU		9					; Indicates that the timing is not a factory preset for the current display (geometry may need correction) 
kModeBuiltIn					EQU		10					; Indicates that the display mode is for the built-in connect only (on multiconnect devices like the PB 3400) Only the driver is quieried 
;  csDepthFlags in VDVideoParametersInfoRec 

kDepthDependent					EQU		0					; Says that this depth mode may cause dependent changes in other framebuffers (and . 
;  csResolutionFlags bit flags for VDResolutionInfoRec 

kResolutionHasMultipleDepthSizes EQU	0					; Says that this mode has different csHorizontalPixels, csVerticalLines at different depths (usually slightly larger at lower depths) 


															;	Power Mode constants for VDPowerStateRec.powerState.  Note the numeric order does not match the power state order 
kAVPowerOff						EQU		0					; Power fully off
kAVPowerStandby					EQU		1
kAVPowerSuspend					EQU		2
kAVPowerOn						EQU		3

															;	Power Mode masks and bits for VDPowerStateRec.powerFlags.	
kPowerStateNeedsRefresh			EQU		0					; When leaving this power mode, a display will need refreshing	
kPowerStateNeedsRefreshMask		EQU		$00000001


															; Control Codes 
cscReset						EQU		0
cscKillIO						EQU		1
cscSetMode						EQU		2
cscSetEntries					EQU		3
cscSetGamma						EQU		4
cscGrayPage						EQU		5
cscGrayScreen					EQU		5
cscSetGray						EQU		6
cscSetInterrupt					EQU		7
cscDirectSetEntries				EQU		8
cscSetDefaultMode				EQU		9
cscSwitchMode					EQU		10
cscSetSync						EQU		11
cscSavePreferredConfiguration	EQU		16
cscSetHardwareCursor			EQU		22
cscDrawHardwareCursor			EQU		23
cscSetConvolution				EQU		24
cscSetPowerState				EQU		25
cscPrivateControlCall			EQU		26					; Takes a VDPrivateSelectorDataRec
cscSetMultiConnect				EQU		28					; From a GDI point of view, this call should be implemented completely in the HAL and not at all in the core.
cscSetClutBehavior				EQU		29					; Takes a VDClutBehavior 
cscUnusedCall					EQU		127					; This call used to expend the scrn resource.  Its imbedded data contains more control info 

															; Status Codes 
cscGetMode						EQU		2
cscGetEntries					EQU		3
cscGetPageCnt					EQU		4
cscGetPages						EQU		4					; This is what C&D 2 calls it. 
cscGetPageBase					EQU		5
cscGetBaseAddr					EQU		5					; This is what C&D 2 calls it. 
cscGetGray						EQU		6
cscGetInterrupt					EQU		7
cscGetGamma						EQU		8
cscGetDefaultMode				EQU		9
cscGetCurMode					EQU		10
cscGetSync						EQU		11
cscGetConnection				EQU		12					; Return information about the connection to the display 
cscGetModeTiming				EQU		13					; Return timing info for a mode 
cscGetModeBaseAddress			EQU		14					; Return base address information about a particular mode 
cscGetScanProc					EQU		15					; QuickTime scan chasing routine 
cscGetPreferredConfiguration	EQU		16
cscGetNextResolution			EQU		17
cscGetVideoParameters			EQU		18
cscGetGammaInfoList				EQU		20
cscRetrieveGammaTable			EQU		21
cscSupportsHardwareCursor		EQU		22
cscGetHardwareCursorDrawState	EQU		23
cscGetConvolution				EQU		24
cscGetPowerState				EQU		25
cscPrivateStatusCall			EQU		26					; Takes a VDPrivateSelectorDataRec
cscGetDDCBlock					EQU		27					; Takes a VDDDCBlockRec  
cscGetMultiConnect				EQU		28					; From a GDI point of view, this call should be implemented completely in the HAL and not at all in the core.
cscGetClutBehavior				EQU		29					; Takes a VDClutBehavior 
;  Bit definitions for the Get/Set Sync call

kDisableHorizontalSyncBit		EQU		0
kDisableVerticalSyncBit			EQU		1
kDisableCompositeSyncBit		EQU		2
kEnableSyncOnBlue				EQU		3
kEnableSyncOnGreen				EQU		4
kEnableSyncOnRed				EQU		5
kNoSeparateSyncControlBit		EQU		6
kTriStateSyncBit				EQU		7
kHorizontalSyncMask				EQU		$01
kVerticalSyncMask				EQU		$02
kCompositeSyncMask				EQU		$04
kDPMSSyncMask					EQU		$07
kTriStateSyncMask				EQU		$80
kSyncOnBlueMask					EQU		$08
kSyncOnGreenMask				EQU		$10
kSyncOnRedMask					EQU		$20
kSyncOnMask						EQU		$38

															;	Power Mode constants for translating DPMS modes to Get/SetSync calls.	
kDPMSSyncOn						EQU		0
kDPMSSyncStandby				EQU		1
kDPMSSyncSuspend				EQU		2
kDPMSSyncOff					EQU		7
;  Bit definitions for the Get/Set Convolution call

kConvolved						EQU		0
kLiveVideoPassThru				EQU		1
kConvolvedMask					EQU		$01
kLiveVideoPassThruMask			EQU		$02

VPBlock					RECORD 0
vpBaseOffset			 ds.l	1				; offset: $0 (0)		; Offset to page zero of video RAM (From minorBaseOS).
vpRowBytes				 ds.w	1				; offset: $4 (4)		; Width of each row of video memory.
vpBounds				 ds		Rect			; offset: $6 (6)		; BoundsRect for the video display (gives dimensions).
vpVersion				 ds.w	1				; offset: $E (14)		; PixelMap version number.
vpPackType				 ds.w	1				; offset: $10 (16)
vpPackSize				 ds.l	1				; offset: $12 (18)
vpHRes					 ds.l	1				; offset: $16 (22)		; Horizontal resolution of the device (pixels per inch).
vpVRes					 ds.l	1				; offset: $1A (26)		; Vertical resolution of the device (pixels per inch).
vpPixelType				 ds.w	1				; offset: $1E (30)		; Defines the pixel type.
vpPixelSize				 ds.w	1				; offset: $20 (32)		; Number of bits in pixel.
vpCmpCount				 ds.w	1				; offset: $22 (34)		; Number of components in pixel.
vpCmpSize				 ds.w	1				; offset: $24 (36)		; Number of bits per component
vpPlaneBytes			 ds.l	1				; offset: $26 (38)		; Offset from one plane to the next.
sizeof					 EQU *					; size:   $2A (42)
						ENDR
; typedef struct VPBlock *				VPBlockPtr

VDEntryRecord			RECORD 0
csTable					 ds.l	1				; offset: $0 (0)		; (long) pointer to color table entry=value, r,g,b:INTEGER
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct VDEntryRecord *		VDEntRecPtr

;  Parm block for SetGray control call 
VDGrayRecord			RECORD 0
csMode					 ds.b	1				; offset: $0 (0)		; Same as GDDevType value (0=color, 1=mono)
filler					 ds.b	1				; offset: $1 (1)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
; typedef struct VDGrayRecord *			VDGrayPtr

;  Parm block for SetInterrupt call 
VDFlagRecord			RECORD 0
csMode					 ds.b	1				; offset: $0 (0)
filler					 ds.b	1				; offset: $1 (1)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
; typedef struct VDFlagRecord *			VDFlagRecPtr

;  Parm block for SetEntries control call 
VDSetEntryRecord		RECORD 0
csTable					 ds.l	1				; offset: $0 (0)		; Pointer to an array of color specs
csStart					 ds.w	1				; offset: $4 (4)		; Which spec in array to start with, or -1
csCount					 ds.w	1				; offset: $6 (6)		; Number of color spec entries to set
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct VDSetEntryRecord *		VDSetEntryPtr

;  Parm block for SetGamma control call 
VDGammaRecord			RECORD 0
csGTable				 ds.l	1				; offset: $0 (0)		; pointer to gamma table
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct VDGammaRecord *		VDGamRecPtr

VDBaseAddressInfoRec	RECORD 0
csDevData				 ds.l	1				; offset: $0 (0)		;  LONGINT - (long) timing mode 
csDevBase				 ds.l	1				; offset: $4 (4)		;  LONGINT - (long) base address of the mode 
csModeReserved			 ds.w	1				; offset: $8 (8)		;  INTEGER - (short) will some day be the depth 
csModeBase				 ds.l	1				; offset: $A (10)		;  LONGINT - (long) reserved 
sizeof					 EQU *					; size:   $E (14)
						ENDR
; typedef struct VDBaseAddressInfoRec *	VDBaseAddressInfoPtr

VDSwitchInfoRec			RECORD 0
csMode					 ds.w	1				; offset: $0 (0)		; (word) mode depth
csData					 ds.l	1				; offset: $2 (2)		; (long) functional sResource of mode
csPage					 ds.w	1				; offset: $6 (6)		; (word) page to switch in
csBaseAddr				 ds.l	1				; offset: $8 (8)		; (long) base address of page (return value)
csReserved				 ds.l	1				; offset: $C (12)		; (long) Reserved (set to 0) 
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct VDSwitchInfoRec *		VDSwitchInfoPtr

VDTimingInfoRec			RECORD 0
csTimingMode			 ds.l	1				; offset: $0 (0)		;  LONGINT - (long) timing mode (a la InitGDevice) 
csTimingReserved		 ds.l	1				; offset: $4 (4)		;  LONGINT - (long) reserved 
csTimingFormat			 ds.l	1				; offset: $8 (8)		;  LONGINT - (long) what format is the timing info 
csTimingData			 ds.l	1				; offset: $C (12)		;  LONGINT - (long) data supplied by driver 
csTimingFlags			 ds.l	1				; offset: $10 (16)		;  LONGINT - (long) mode within device 
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct VDTimingInfoRec *		VDTimingInfoPtr

VDDisplayConnectInfoRec	RECORD 0
csDisplayType			 ds.w	1				; offset: $0 (0)		;  INTEGER - (word) Type of display connected 
csConnectTaggedType		 ds.b	1				; offset: $2 (2)		;  BYTE - type of tagging 
csConnectTaggedData		 ds.b	1				; offset: $3 (3)		;  BYTE - tagging data 
csConnectFlags			 ds.l	1				; offset: $4 (4)		;  LONGINT - (long) tell us about the connection 
csDisplayComponent		 ds.l	1				; offset: $8 (8)		;  LONGINT - (long) if the card has a direct connection to the display, it returns the display component here (FUTURE) 
csConnectReserved		 ds.l	1				; offset: $C (12)		;  LONGINT - (long) reserved 
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct VDDisplayConnectInfoRec * VDDisplayConnectInfoPtr

VDMultiConnectInfoRec	RECORD 0
csDisplayCountOrNumber	 ds.l	1				; offset: $0 (0)		;  For GetMultiConnect, returns count n of 1..n connections; otherwise, indicates the ith connection.
csConnectInfo			 ds		VDDisplayConnectInfoRec ; offset: $4 (4) ;  Standard VDDisplayConnectionInfo for connection i.
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct VDMultiConnectInfoRec * VDMultiConnectInfoPtr

;  RawSenseCode
;	This abstract data type is not exactly abstract.  Rather, it is merely enumerated constants
;	for the possible raw sense code values when 'standard' sense code hardware is implemented.
;
;	For 'standard' sense code hardware, the raw sense is obtained as follows:
;		• Instruct the frame buffer controller NOT to actively drive any of the monitor sense lines
;		• Read the state of the monitor sense lines 2, 1, and 0.  (2 is the MSB, 0 the LSB)
;
;	IMPORTANT Note: 
;	When the 'kTaggingInfoNonStandard' bit of 'csConnectFlags' is FALSE, then these constants 
;	are valid 'csConnectTaggedType' values in 'VDDisplayConnectInfo' 
;
;

; typedef unsigned char 				RawSenseCode


kRSCZero						EQU		0
kRSCOne							EQU		1
kRSCTwo							EQU		2
kRSCThree						EQU		3
kRSCFour						EQU		4
kRSCFive						EQU		5
kRSCSix							EQU		6
kRSCSeven						EQU		7

;  ExtendedSenseCode
;	This abstract data type is not exactly abstract.  Rather, it is merely enumerated constants
;	for the values which are possible when the extended sense algorithm is applied to hardware
;	which implements 'standard' sense code hardware.
;
; 	For 'standard' sense code hardware, the extended sense code algorithm is as follows:
;	(Note:  as described here, sense line 'A' corresponds to '2', 'B' to '1', and 'C' to '0')
;		• Drive sense line 'A' low and read the values of 'B' and 'C'.  
;		• Drive sense line 'B' low and read the values of 'A' and 'C'.
;		• Drive sense line 'C' low and read the values of 'A' and 'B'.
;
;	In this way, a six-bit number of the form BC/AC/AB is generated. 
;
;	IMPORTANT Note: 
;	When the 'kTaggingInfoNonStandard' bit of 'csConnectFlags' is FALSE, then these constants 
;	are valid 'csConnectTaggedData' values in 'VDDisplayConnectInfo' 
;
;

; typedef unsigned char 				ExtendedSenseCode


kESCZero21Inch					EQU		$00					; 21" RGB 								
kESCOnePortraitMono				EQU		$14					; Portrait Monochrome 					
kESCTwo12Inch					EQU		$21					; 12" RGB								
kESCThree21InchRadius			EQU		$31					; 21" RGB (Radius)						
kESCThree21InchMonoRadius		EQU		$34					; 21" Monochrome (Radius) 				
kESCThree21InchMono				EQU		$35					; 21" Monochrome						
kESCFourNTSC					EQU		$0A					; NTSC 								
kESCFivePortrait				EQU		$1E					; Portrait RGB 						
kESCSixMSB1						EQU		$03					; MultiScan Band-1 (12" thru 1Six")	
kESCSixMSB2						EQU		$0B					; MultiScan Band-2 (13" thru 19")		
kESCSixMSB3						EQU		$23					; MultiScan Band-3 (13" thru 21")		
kESCSixStandard					EQU		$2B					; 13"/14" RGB or 12" Monochrome		
kESCSevenPAL					EQU		$00					; PAL									
kESCSevenNTSC					EQU		$14					; NTSC 								
kESCSevenVGA					EQU		$17					; VGA 									
kESCSeven16Inch					EQU		$2D					; 16" RGB (GoldFish) 				 	
kESCSevenPALAlternate			EQU		$30					; PAL (Alternate) 						
kESCSeven19Inch					EQU		$3A					; Third-Party 19”						
kESCSevenNoDisplay				EQU		$3F					; No display connected 				
;  DepthMode
;	This abstract data type is used to to reference RELATIVE pixel depths.
;	Its definition is largely derived from its past usage, analogous to 'xxxVidMode'
;
;	Bits per pixel DOES NOT directly map to 'DepthMode'  For example, on some
;	graphics hardware, 'kDepthMode1' may represent 1 BPP, whereas on other
;	hardware, 'kDepthMode1' may represent 8BPP.
;
;	DepthMode IS considered to be ordinal, i.e., operations such as <, >, ==, etc.
;	behave as expected.  The values of the constants which comprise the set are such
;	that 'kDepthMode4 < kDepthMode6' behaves as expected.
;

; typedef unsigned short 				DepthMode


kDepthMode1						EQU		128
kDepthMode2						EQU		129
kDepthMode3						EQU		130
kDepthMode4						EQU		131
kDepthMode5						EQU		132
kDepthMode6						EQU		133

kFirstDepthMode					EQU		128					; These constants are obsolete, and just included	
kSecondDepthMode				EQU		129					; for clients that have converted to the above		
kThirdDepthMode					EQU		130					; kDepthModeXXX constants.							
kFourthDepthMode				EQU		131
kFifthDepthMode					EQU		132
kSixthDepthMode					EQU		133

VDPageInfo				RECORD 0
csMode					 ds.w	1				; offset: $0 (0)		; (word) mode within device
csData					 ds.l	1				; offset: $2 (2)		; (long) data supplied by driver
csPage					 ds.w	1				; offset: $6 (6)		; (word) page to switch in
csBaseAddr				 ds.l	1				; offset: $8 (8)		; (long) base address of page
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct VDPageInfo *			VDPgInfoPtr

VDSizeInfo				RECORD 0
csHSize					 ds.w	1				; offset: $0 (0)		; (word) desired/returned h size
csHPos					 ds.w	1				; offset: $2 (2)		; (word) desired/returned h position
csVSize					 ds.w	1				; offset: $4 (4)		; (word) desired/returned v size
csVPos					 ds.w	1				; offset: $6 (6)		; (word) desired/returned v position
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct VDSizeInfo *			VDSzInfoPtr

VDSettings				RECORD 0
csParamCnt				 ds.w	1				; offset: $0 (0)		; (word) number of params
csBrightMax				 ds.w	1				; offset: $2 (2)		; (word) max brightness
csBrightDef				 ds.w	1				; offset: $4 (4)		; (word) default brightness
csBrightVal				 ds.w	1				; offset: $6 (6)		; (word) current brightness
csCntrstMax				 ds.w	1				; offset: $8 (8)		; (word) max contrast
csCntrstDef				 ds.w	1				; offset: $A (10)		; (word) default contrast
csCntrstVal				 ds.w	1				; offset: $C (12)		; (word) current contrast
csTintMax				 ds.w	1				; offset: $E (14)		; (word) max tint
csTintDef				 ds.w	1				; offset: $10 (16)		; (word) default tint
csTintVal				 ds.w	1				; offset: $12 (18)		; (word) current tint
csHueMax				 ds.w	1				; offset: $14 (20)		; (word) max hue
csHueDef				 ds.w	1				; offset: $16 (22)		; (word) default hue
csHueVal				 ds.w	1				; offset: $18 (24)		; (word) current hue
csHorizDef				 ds.w	1				; offset: $1A (26)		; (word) default horizontal
csHorizVal				 ds.w	1				; offset: $1C (28)		; (word) current horizontal
csHorizMax				 ds.w	1				; offset: $1E (30)		; (word) max horizontal
csVertDef				 ds.w	1				; offset: $20 (32)		; (word) default vertical
csVertVal				 ds.w	1				; offset: $22 (34)		; (word) current vertical
csVertMax				 ds.w	1				; offset: $24 (36)		; (word) max vertical
sizeof					 EQU *					; size:   $26 (38)
						ENDR
; typedef struct VDSettings *			VDSettingsPtr

VDDefMode				RECORD 0
csID					 ds.b	1				; offset: $0 (0)
filler					 ds.b	1				; offset: $1 (1)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
; typedef struct VDDefMode *			VDDefModePtr

VDSyncInfoRec			RECORD 0
csMode					 ds.b	1				; offset: $0 (0)
csFlags					 ds.b	1				; offset: $1 (1)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
; typedef struct VDSyncInfoRec *		VDSyncInfoPtr

; typedef unsigned long 				DisplayModeID

; typedef unsigned long 				VideoDeviceType

; typedef unsigned long 				GammaTableID

;  Constants for the GetNextResolution call 

kDisplayModeIDCurrent			EQU		$00					; Reference the Current DisplayModeID 
kDisplayModeIDInvalid			EQU		$FFFFFFFF			; A bogus DisplayModeID in all cases 
kDisplayModeIDFindFirstResolution EQU	$FFFFFFFE			; Used in cscGetNextResolution to reset iterator 
kDisplayModeIDNoMoreResolutions	EQU		$FFFFFFFD			; Used in cscGetNextResolution to indicate End Of List 
;  Constants for the GetGammaInfoList call 

kGammaTableIDFindFirst			EQU		$FFFFFFFE			; Get the first gamma table ID 
kGammaTableIDNoMoreTables		EQU		$FFFFFFFD			; Used to indicate end of list 
kGammaTableIDSpecific			EQU		$00					; Return the info for the given table id 
;  Constants for GetMultiConnect call

kGetConnectionCount				EQU		$FFFFFFFF			; Used to get the number of possible connections in a “multi-headed” framebuffer environment.
kActivateConnection				EQU		$00					; Used for activating a connection (csConnectFlags value).
kDeactivateConnection			EQU		$0200				; Used for deactivating a connection (csConnectFlags value.)
VDResolutionInfoRec		RECORD 0
csPreviousDisplayModeID	 ds.l	1				; offset: $0 (0)		;  ID of the previous resolution in a chain 
csDisplayModeID			 ds.l	1				; offset: $4 (4)		;  ID of the next resolution 
csHorizontalPixels		 ds.l	1				; offset: $8 (8)		;  # of pixels in a horizontal line at the max depth 
csVerticalLines			 ds.l	1				; offset: $C (12)		;  # of lines in a screen at the max depth 
csRefreshRate			 ds.l	1				; offset: $10 (16)		;  Vertical Refresh Rate in Hz 
csMaxDepthMode			 ds.w	1				; offset: $14 (20)		;  0x80-based number representing max bit depth 
csResolutionFlags		 ds.l	1				; offset: $16 (22)		;  Reserved - flag bits 
csReserved				 ds.l	1				; offset: $1A (26)		;  Reserved 
sizeof					 EQU *					; size:   $1E (30)
						ENDR
; typedef struct VDResolutionInfoRec *	VDResolutionInfoPtr

VDVideoParametersInfoRec RECORD 0
csDisplayModeID			 ds.l	1				; offset: $0 (0)		;  the ID of the resolution we want info on 
csDepthMode				 ds.w	1				; offset: $4 (4)		;  The bit depth we want the info on (0x80 based) 
csVPBlockPtr			 ds.l	1				; offset: $6 (6)		;  Pointer to a video parameter block 
csPageCount				 ds.l	1				; offset: $A (10)		;  Number of pages supported by the resolution 
csDeviceType			 ds.l	1				; offset: $E (14)		;  Device Type:  Direct, Fixed or CLUT; 
csDepthFlags			 ds.l	1				; offset: $12 (18)		;  Flags 
sizeof					 EQU *					; size:   $16 (22)
						ENDR
; typedef struct VDVideoParametersInfoRec * VDVideoParametersInfoPtr

VDGammaInfoRec			RECORD 0
csLastGammaID			 ds.l	1				; offset: $0 (0)		;  the ID of the previous gamma table 
csNextGammaID			 ds.l	1				; offset: $4 (4)		;  the ID of the next gamma table 
csGammaPtr				 ds.l	1				; offset: $8 (8)		;  Ptr to a gamma table data 
csReserved				 ds.l	1				; offset: $C (12)		;  Reserved 
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct VDGammaInfoRec *		VDGammaInfoPtr

VDGetGammaListRec		RECORD 0
csPreviousGammaTableID	 ds.l	1				; offset: $0 (0)		;  ID of the previous gamma table 
csGammaTableID			 ds.l	1				; offset: $4 (4)		;  ID of the gamma table following csPreviousDisplayModeID 
csGammaTableSize		 ds.l	1				; offset: $8 (8)		;  Size of the gamma table in bytes 
csGammaTableName		 ds.l	1				; offset: $C (12)		;  Gamma table name (c-string) 
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct VDGetGammaListRec *	VDGetGammaListPtr

VDRetrieveGammaRec		RECORD 0
csGammaTableID			 ds.l	1				; offset: $0 (0)		;  ID of gamma table to retrieve 
csGammaTablePtr			 ds.l	1				; offset: $4 (4)		;  Location to copy desired gamma to 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct VDRetrieveGammaRec *	VDRetrieveGammaPtr

VDSetHardwareCursorRec	RECORD 0
csCursorRef				 ds.l	1				; offset: $0 (0)		;  reference to cursor data 
csReserved1				 ds.l	1				; offset: $4 (4)		;  reserved for future use 
csReserved2				 ds.l	1				; offset: $8 (8)		;  should be ignored 
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct VDSetHardwareCursorRec * VDSetHardwareCursorPtr

VDDrawHardwareCursorRec	RECORD 0
csCursorX				 ds.l	1				; offset: $0 (0)		;  x coordinate 
csCursorY				 ds.l	1				; offset: $4 (4)		;  y coordinate 
csCursorVisible			 ds.l	1				; offset: $8 (8)		;  true if cursor is must be visible 
csReserved1				 ds.l	1				; offset: $C (12)		;  reserved for future use 
csReserved2				 ds.l	1				; offset: $10 (16)		;  should be ignored 
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct VDDrawHardwareCursorRec * VDDrawHardwareCursorPtr

VDSupportsHardwareCursorRec RECORD 0
csSupportsHardwareCursor  ds.l	1				; offset: $0 (0)
;  true if hardware cursor is supported 
csReserved1				 ds.l	1				; offset: $4 (4)		;  reserved for future use 
csReserved2				 ds.l	1				; offset: $8 (8)		;  must be zero 
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct VDSupportsHardwareCursorRec * VDSupportsHardwareCursorPtr

VDHardwareCursorDrawStateRec RECORD 0
csCursorX				 ds.l	1				; offset: $0 (0)		;  x coordinate 
csCursorY				 ds.l	1				; offset: $4 (4)		;  y coordinate 
csCursorVisible			 ds.l	1				; offset: $8 (8)		;  true if cursor is visible 
csCursorSet				 ds.l	1				; offset: $C (12)		;  true if cursor successfully set by last set control call 
csReserved1				 ds.l	1				; offset: $10 (16)		;  reserved for future use 
csReserved2				 ds.l	1				; offset: $14 (20)		;  must be zero 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct VDHardwareCursorDrawStateRec * VDHardwareCursorDrawStatePtr

VDConvolutionInfoRec	RECORD 0
csDisplayModeID			 ds.l	1				; offset: $0 (0)		;  the ID of the resolution we want info on 
csDepthMode				 ds.w	1				; offset: $4 (4)		;  The bit depth we want the info on (0x80 based) 
csPage					 ds.l	1				; offset: $6 (6)
csFlags					 ds.l	1				; offset: $A (10)
csReserved				 ds.l	1				; offset: $E (14)
sizeof					 EQU *					; size:   $12 (18)
						ENDR
; typedef struct VDConvolutionInfoRec *	VDConvolutionInfoPtr

VDPowerStateRec			RECORD 0
powerState				 ds.l	1				; offset: $0 (0)
powerFlags				 ds.l	1				; offset: $4 (4)
powerReserved1			 ds.l	1				; offset: $8 (8)
powerReserved2			 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct VDPowerStateRec *		VDPowerStatePtr

; 
;	Private Data to video drivers.
;	
;	In versions of MacOS with multiple address spaces (System 8), the OS 
;	must know the extent of parameters in order to move them between the caller
;	and driver.  The old private-selector model for video drivers does not have
;	this information so:
;	
;	For post-7.x Systems private calls should be implemented using the cscPrivateCall
;

VDPrivateSelectorDataRec RECORD 0
privateParameters		 ds.l	1				; offset: $0 (0)		;  Caller's parameters
privateParametersSize	 ds.l	1				; offset: $4 (4)		;  Size of data sent from caller to driver
privateResults			 ds.l	1				; offset: $8 (8)		;  Caller's return area. Can be nil, or same as privateParameters.
privateResultsSize		 ds.l	1				; offset: $C (12)		;  Size of data driver returns to caller. Can be nil, or same as privateParametersSize.
sizeof					 EQU *					; size:   $10 (16)
						ENDR
VDPrivateSelectorRec	RECORD 0
reserved				 ds.l	1				; offset: $0 (0)		;  Reserved (set to 0). 
data					 ds		VDPrivateSelectorDataRec ; offset: $4 (4) <-- really an array of length one
sizeof					 EQU *					; size:   $14 (20)
						ENDR
VDDDCBlockRec			RECORD 0
ddcBlockNumber			 ds.l	1				; offset: $0 (0)		;  Input -- DDC EDID (Extended Display Identification Data) number (1-based) 
ddcBlockType			 ds.l	1				; offset: $4 (4)		;  Input -- DDC block type (EDID/VDIF) 
ddcFlags				 ds.l	1				; offset: $8 (8)		;  Input -- DDC Flags
ddcReserved				 ds.l	1				; offset: $C (12)		;  Reserved 
ddcBlockData			 ds.b	128				; offset: $10 (16)		;  Output -- DDC EDID/VDIF data (kDDCBlockSize) 
sizeof					 EQU *					; size:   $90 (144)
						ENDR
; typedef struct VDDDCBlockRec *		VDDDCBlockPtr

; typedef UInt32 						VDClutBehavior

; typedef VDClutBehavior *				VDClutBehaviorPtr


kSetClutAtSetEntries			EQU		0					; SetEntries behavior is to update clut during SetEntries call
kSetClutAtVBL					EQU		1					; SetEntries behavior is to upate clut at next vbl

	ENDIF ; __VIDEO__ 


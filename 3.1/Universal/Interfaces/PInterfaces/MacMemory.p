{
 	File:		MacMemory.p
 
 	Contains:	Memory Manager Interfaces.
 
 	Version:	Technology:	System 7.5
 				Release:	Universal Interfaces 3.1
 
 	Copyright:	© 1985-1998 by Apple Computer, Inc., all rights reserved
 
 	Bugs?:		Please include the the file and version information (from above) with
 				the problem description.  Developers belonging to one of the Apple
 				developer programs can submit bug reports to:
 
 					devsupport@apple.com
 
}
{$IFC UNDEFINED UsingIncludes}
{$SETC UsingIncludes := 0}
{$ENDC}

{$IFC NOT UsingIncludes}
 UNIT MacMemory;
 INTERFACE
{$ENDC}

{$IFC UNDEFINED __MACMEMORY__}
{$SETC __MACMEMORY__ := 1}

{$I+}
{$SETC MacMemoryIncludes := UsingIncludes}
{$SETC UsingIncludes := 1}


{$IFC UNDEFINED __MACTYPES__}
{$I MacTypes.p}
{$ENDC}
{$IFC UNDEFINED __MIXEDMODE__}
{$I MixedMode.p}
{$ENDC}


{$PUSH}
{$ALIGN MAC68K}
{$LibExport+}



CONST
	maxSize						= $00800000;					{ Max data block size is 8 megabytes }

	defaultPhysicalEntryCount	= 8;

																{  values returned from the GetPageState function  }
	kPageInMemory				= 0;
	kPageOnDisk					= 1;
	kNotPaged					= 2;

																{  masks for Zone->heapType field  }
	k32BitHeap					= 1;							{  valid in all Memory Managers  }
	kNewStyleHeap				= 2;							{  true if new Heap Manager is present  }
	kNewDebugHeap				= 4;							{  true if new Heap Manager is running in debug mode on this heap  }

{  Note: The type "Size" moved to Types.h  }



TYPE
{$IFC TYPED_FUNCTION_POINTERS}
	GrowZoneProcPtr = FUNCTION(cbNeeded: Size): LONGINT;
{$ELSEC}
	GrowZoneProcPtr = ProcPtr;
{$ENDC}

{$IFC TYPED_FUNCTION_POINTERS}
	PurgeProcPtr = PROCEDURE(blockToPurge: Handle);
{$ELSEC}
	PurgeProcPtr = ProcPtr;
{$ENDC}

{$IFC TYPED_FUNCTION_POINTERS}
	UserFnProcPtr = PROCEDURE(parameter: UNIV Ptr);
{$ELSEC}
	UserFnProcPtr = Register68kProcPtr;
{$ENDC}

	GrowZoneUPP = UniversalProcPtr;
	PurgeUPP = UniversalProcPtr;
	UserFnUPP = UniversalProcPtr;
	ZonePtr = ^Zone;
	Zone = RECORD
		bkLim:					Ptr;
		purgePtr:				Ptr;
		hFstFree:				Ptr;
		zcbFree:				LONGINT;
		gzProc:					GrowZoneUPP;
		moreMast:				INTEGER;
		flags:					INTEGER;
		cntRel:					INTEGER;
		maxRel:					INTEGER;
		cntNRel:				INTEGER;
		heapType:				SInt8;									{  previously "maxNRel", now holds flags (e.g. k32BitHeap) }
		unused:					SInt8;
		cntEmpty:				INTEGER;
		cntHandles:				INTEGER;
		minCBFree:				LONGINT;
		purgeProc:				PurgeUPP;
		sparePtr:				Ptr;
		allocPtr:				Ptr;
		heapData:				INTEGER;
	END;

	THz									= ^Zone;
	MemoryBlockPtr = ^MemoryBlock;
	MemoryBlock = RECORD
		address:				Ptr;
		count:					UInt32;
	END;

	LogicalToPhysicalTablePtr = ^LogicalToPhysicalTable;
	LogicalToPhysicalTable = RECORD
		logical:				MemoryBlock;
		physical:				ARRAY [0..7] OF MemoryBlock;
	END;

	PageState							= INTEGER;
	StatusRegisterContents				= INTEGER;

CONST
	uppGrowZoneProcInfo = $000000F0;
	uppPurgeProcInfo = $000000C0;
	uppUserFnProcInfo = $00009802;

FUNCTION NewGrowZoneProc(userRoutine: GrowZoneProcPtr): GrowZoneUPP;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $2E9F;
	{$ENDC}

FUNCTION NewPurgeProc(userRoutine: PurgeProcPtr): PurgeUPP;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $2E9F;
	{$ENDC}

FUNCTION NewUserFnProc(userRoutine: UserFnProcPtr): UserFnUPP;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $2E9F;
	{$ENDC}

FUNCTION CallGrowZoneProc(cbNeeded: Size; userRoutine: GrowZoneUPP): LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $4E90;
	{$ENDC}

PROCEDURE CallPurgeProc(blockToPurge: Handle; userRoutine: PurgeUPP);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $4E90;
	{$ENDC}

PROCEDURE CallUserFnProc(parameter: UNIV Ptr; userRoutine: UserFnUPP);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	{To be implemented:  Glue to move parameters into registers.}
	{$ENDC}


FUNCTION GetApplLimit: Ptr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $2EB8, $0130;
	{$ENDC}
FUNCTION SystemZone: THz;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $2EB8, $02A6;
	{$ENDC}
FUNCTION ApplicationZone: THz;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $2EB8, $02AA;
	{$ENDC}
FUNCTION GZSaveHnd: Handle;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $2EB8, $0328;
	{$ENDC}
FUNCTION TopMem: Ptr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $2EB8, $0108;
	{$ENDC}
FUNCTION MemError: OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3EB8, $0220;
	{$ENDC}


FUNCTION GetZone: THz;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A11A, $2E88;
	{$ENDC}
FUNCTION NewHandle(byteCount: Size): Handle;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A122, $2E88;
	{$ENDC}
FUNCTION NewHandleSys(byteCount: Size): Handle;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A522, $2E88;
	{$ENDC}
FUNCTION NewHandleClear(byteCount: Size): Handle;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A322, $2E88;
	{$ENDC}
FUNCTION NewHandleSysClear(byteCount: Size): Handle;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A722, $2E88;
	{$ENDC}
FUNCTION HandleZone(h: Handle): THz;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A126, $2E88;
	{$ENDC}
FUNCTION RecoverHandle(p: Ptr): Handle;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A128, $2E88;
	{$ENDC}
FUNCTION RecoverHandleSys(p: Ptr): Handle;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A528, $2E88;
	{$ENDC}
FUNCTION NewPtr(byteCount: Size): Ptr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A11E, $2E88;
	{$ENDC}
FUNCTION NewPtrSys(byteCount: Size): Ptr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A51E, $2E88;
	{$ENDC}
FUNCTION NewPtrClear(byteCount: Size): Ptr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A31E, $2E88;
	{$ENDC}
FUNCTION NewPtrSysClear(byteCount: Size): Ptr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A71E, $2E88;
	{$ENDC}
FUNCTION PtrZone(p: Ptr): THz;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A148, $2E88;
	{$ENDC}
FUNCTION MaxBlock: LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A061, $2E80;
	{$ENDC}
FUNCTION MaxBlockSys: LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A461, $2E80;
	{$ENDC}
FUNCTION StackSpace: LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A065, $2E80;
	{$ENDC}
FUNCTION NewEmptyHandle: Handle;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A166, $2E88;
	{$ENDC}
FUNCTION NewEmptyHandleSys: Handle;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A566, $2E88;
	{$ENDC}
PROCEDURE HLock(h: Handle);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A029;
	{$ENDC}
PROCEDURE HUnlock(h: Handle);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A02A;
	{$ENDC}
PROCEDURE HPurge(h: Handle);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A049;
	{$ENDC}
PROCEDURE HNoPurge(h: Handle);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A04A;
	{$ENDC}
PROCEDURE HLockHi(h: Handle);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A064, $A029;
	{$ENDC}
FUNCTION TempNewHandle(logicalSize: Size; VAR resultCode: OSErr): Handle;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $001D, $A88F;
	{$ENDC}
FUNCTION TempMaxMem(VAR grow: Size): Size;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $0015, $A88F;
	{$ENDC}
FUNCTION TempFreeMem: LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $0018, $A88F;
	{$ENDC}
PROCEDURE InitZone(pgrowZone: GrowZoneUPP; cmoreMasters: INTEGER; limitPtr: UNIV Ptr; startPtr: UNIV Ptr);
PROCEDURE SetZone(hz: THz);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A01B;
	{$ENDC}
FUNCTION CompactMem(cbNeeded: Size): Size;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A04C, $2E80;
	{$ENDC}
FUNCTION CompactMemSys(cbNeeded: Size): Size;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A44C, $2E80;
	{$ENDC}
PROCEDURE PurgeMem(cbNeeded: Size);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A04D;
	{$ENDC}
PROCEDURE PurgeMemSys(cbNeeded: Size);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A44D;
	{$ENDC}
FUNCTION FreeMem: LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A01C, $2E80;
	{$ENDC}
FUNCTION FreeMemSys: LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A41C, $2E80;
	{$ENDC}
PROCEDURE ReserveMem(cbNeeded: Size);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A040;
	{$ENDC}
PROCEDURE ReserveMemSys(cbNeeded: Size);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A440;
	{$ENDC}
FUNCTION MaxMem(VAR grow: Size): Size;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $A11D, $2288, $2E80;
	{$ENDC}
FUNCTION MaxMemSys(VAR grow: Size): Size;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $A51D, $2288, $2E80;
	{$ENDC}
PROCEDURE SetGrowZone(growZone: GrowZoneUPP);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A04B;
	{$ENDC}
PROCEDURE MoveHHi(h: Handle);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A064;
	{$ENDC}
PROCEDURE DisposePtr(p: Ptr);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A01F;
	{$ENDC}
FUNCTION GetPtrSize(p: Ptr): Size;
PROCEDURE SetPtrSize(p: Ptr; newSize: Size);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $205F, $A020;
	{$ENDC}
PROCEDURE DisposeHandle(h: Handle);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A023;
	{$ENDC}
PROCEDURE SetHandleSize(h: Handle; newSize: Size);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $205F, $A024;
	{$ENDC}
{ 
	NOTE
	
	GetHandleSize and GetPtrSize are documented in Inside Mac as returning 0 
	in case of an error, but the traps actually return an error code in D0.
	The glue sets D0 to 0 if an error occured.
}
FUNCTION GetHandleSize(h: Handle): Size;
FUNCTION InlineGetHandleSize(h: Handle): Size;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A025, $2E80;
	{$ENDC}
PROCEDURE ReallocateHandle(h: Handle; byteCount: Size);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $205F, $A027;
	{$ENDC}
PROCEDURE ReallocateHandleSys(h: Handle; byteCount: Size);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $205F, $A427;
	{$ENDC}
PROCEDURE EmptyHandle(h: Handle);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A02B;
	{$ENDC}
PROCEDURE HSetRBit(h: Handle);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A067;
	{$ENDC}
PROCEDURE HClrRBit(h: Handle);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A068;
	{$ENDC}
FUNCTION HGetState(h: Handle): SInt8;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A069, $1E80;
	{$ENDC}
PROCEDURE HSetState(h: Handle; flags: SInt8);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $101F, $205F, $A06A;
	{$ENDC}
PROCEDURE PurgeSpace(VAR total: LONGINT; VAR contig: LONGINT);
{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM }
{
	PurgeSpaceTotal and PurgeSpaceContiguous are currently only implement
	on classic 68K.  The are the same as PurgeSpace() but return just
	one value (either total space purgable or contiguous space purgable).
}
FUNCTION PurgeSpaceTotal: LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A062, $2E88;
	{$ENDC}
FUNCTION PurgeSpaceContiguous: LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A062, $2E80;
	{$ENDC}
FUNCTION PurgeSpaceSysTotal: LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A562, $2E88;
	{$ENDC}
FUNCTION PurgeSpaceSysContiguous: LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A562, $2E80;
	{$ENDC}
{$ENDC}

{****************************************************************************

	The routines: 

		BlockMoveUncached
		BlockMoveDataUncached
		BlockZero
		BlockZeroUncached
	
	are intended for developers writing drivers. They do not exist in 
	“InterfaceLib.” You must link with “DriverServicesLib” to access them.
	
	But since BlockMove and BlockMoveData exist in both “InterfaceLib” and
	“DriverServicesLib”, you cannot link with both libraries.
	
****************************************************************************}
PROCEDURE BlockMove(srcPtr: UNIV Ptr; destPtr: UNIV Ptr; byteCount: Size);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $225F, $205F, $A02E;
	{$ENDC}
PROCEDURE BlockMoveData(srcPtr: UNIV Ptr; destPtr: UNIV Ptr; byteCount: Size);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $225F, $205F, $A22E;
	{$ENDC}
PROCEDURE BlockMoveUncached(srcPtr: UNIV Ptr; destPtr: UNIV Ptr; byteCount: Size); C;
PROCEDURE BlockMoveDataUncached(srcPtr: UNIV Ptr; destPtr: UNIV Ptr; byteCount: Size); C;
PROCEDURE BlockZero(destPtr: UNIV Ptr; byteCount: Size); C;
PROCEDURE BlockZeroUncached(destPtr: UNIV Ptr; byteCount: Size); C;

PROCEDURE MaxApplZone;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A063;
	{$ENDC}
PROCEDURE SetApplBase(startPtr: UNIV Ptr);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A057;
	{$ENDC}
PROCEDURE MoreMasters;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A036;
	{$ENDC}
PROCEDURE SetApplLimit(zoneLimit: UNIV Ptr);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A02D;
	{$ENDC}


PROCEDURE InitApplZone;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $A02C;
	{$ENDC}

{  Temporary Memory routines renamed, but obsolete, in System 7.0 and later.  }
PROCEDURE TempHLock(h: Handle; VAR resultCode: OSErr);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $001E, $A88F;
	{$ENDC}
PROCEDURE TempHUnlock(h: Handle; VAR resultCode: OSErr);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $001F, $A88F;
	{$ENDC}
PROCEDURE TempDisposeHandle(h: Handle; VAR resultCode: OSErr);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $0020, $A88F;
	{$ENDC}
FUNCTION TempTopMem: Ptr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $0016, $A88F;
	{$ENDC}
FUNCTION HoldMemory(address: UNIV Ptr; count: UInt32): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $7000, $A05C, $3E80;
	{$ENDC}
FUNCTION UnholdMemory(address: UNIV Ptr; count: UInt32): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $7001, $A05C, $3E80;
	{$ENDC}
FUNCTION LockMemory(address: UNIV Ptr; count: UInt32): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $7002, $A05C, $3E80;
	{$ENDC}
FUNCTION LockMemoryForOutput(address: UNIV Ptr; count: UInt32): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $700A, $A05C, $3E80;
	{$ENDC}
FUNCTION LockMemoryContiguous(address: UNIV Ptr; count: UInt32): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $7004, $A05C, $3E80;
	{$ENDC}
FUNCTION UnlockMemory(address: UNIV Ptr; count: UInt32): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $7003, $A05C, $3E80;
	{$ENDC}
FUNCTION MakeMemoryResident(address: UNIV Ptr; count: UInt32): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $700B, $A05C, $3E80;
	{$ENDC}
FUNCTION ReleaseMemoryData(address: UNIV Ptr; count: UInt32): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $700C, $A05C, $3E80;
	{$ENDC}
FUNCTION MakeMemoryNonResident(address: UNIV Ptr; count: UInt32): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $700D, $A05C, $3E80;
	{$ENDC}
FUNCTION FlushMemory(address: UNIV Ptr; count: UInt32): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $700E, $A05C, $3E80;
	{$ENDC}
FUNCTION GetPhysical(VAR addresses: LogicalToPhysicalTable; VAR physicalEntryCount: UInt32): OSErr;
FUNCTION DeferUserFn(userFunction: UserFnUPP; argument: UNIV Ptr): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $205F, $A08F, $3E80;
	{$ENDC}
FUNCTION DebuggerGetMax: LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $7000, $A08D, $2E80;
	{$ENDC}
PROCEDURE DebuggerEnter;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $7001, $A08D;
	{$ENDC}
PROCEDURE DebuggerExit;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $7002, $A08D;
	{$ENDC}
PROCEDURE DebuggerPoll;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $7003, $A08D;
	{$ENDC}
FUNCTION GetPageState(address: UNIV Ptr): PageState;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $7004, $A08D, $3E80;
	{$ENDC}
FUNCTION PageFaultFatal: BOOLEAN;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $7005, $A08D, $1E80;
	{$ENDC}
FUNCTION DebuggerLockMemory(address: UNIV Ptr; count: UInt32): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $7006, $A08D, $3E80;
	{$ENDC}
FUNCTION DebuggerUnlockMemory(address: UNIV Ptr; count: UInt32): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $7007, $A08D, $3E80;
	{$ENDC}
FUNCTION EnterSupervisorMode: StatusRegisterContents;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $7008, $A08D, $3E80;
	{$ENDC}

{ 
	StripAddress and Translate24To32 are traps on classic 68K,
	but macro to the identity function on PowerMacs or other OS's.
}
FUNCTION StripAddress(theAddress: UNIV Ptr): Ptr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A055, $2E80;
	{$ENDC}

FUNCTION Translate24To32(addr24: UNIV Ptr): Ptr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A091, $2E80;
	{$ENDC}
FUNCTION HandToHand(VAR theHndl: Handle): OSErr;
FUNCTION PtrToXHand(srcPtr: UNIV Ptr; dstHndl: Handle; size: LONGINT): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $225F, $205F, $A9E2, $3E80;
	{$ENDC}
FUNCTION PtrToHand(srcPtr: UNIV Ptr; VAR dstHndl: Handle; size: LONGINT): OSErr;
FUNCTION HandAndHand(hand1: Handle; hand2: Handle): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $225F, $205F, $A9E4, $3E80;
	{$ENDC}
FUNCTION PtrAndHand(ptr1: UNIV Ptr; hand2: Handle; size: LONGINT): OSErr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $225F, $205F, $A9EF, $3E80;
	{$ENDC}
{$IFC OLDROUTINENAMES }
FUNCTION ApplicZone: THz;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $2EB8, $02AA;
	{$ENDC}
FUNCTION MFTempNewHandle(logicalSize: Size; VAR resultCode: OSErr): Handle;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $001D, $A88F;
	{$ENDC}
FUNCTION MFMaxMem(VAR grow: Size): Size;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $0015, $A88F;
	{$ENDC}
FUNCTION MFFreeMem: LONGINT;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $0018, $A88F;
	{$ENDC}
PROCEDURE MFTempHLock(h: Handle; VAR resultCode: OSErr);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $001E, $A88F;
	{$ENDC}
PROCEDURE MFTempHUnlock(h: Handle; VAR resultCode: OSErr);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $001F, $A88F;
	{$ENDC}
PROCEDURE MFTempDisposHandle(h: Handle; VAR resultCode: OSErr);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $0020, $A88F;
	{$ENDC}
FUNCTION MFTopMem: Ptr;
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $3F3C, $0016, $A88F;
	{$ENDC}
PROCEDURE ResrvMem(cbNeeded: Size);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $A040;
	{$ENDC}
PROCEDURE DisposPtr(p: Ptr);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A01F;
	{$ENDC}
PROCEDURE DisposHandle(h: Handle);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $205F, $A023;
	{$ENDC}
PROCEDURE ReallocHandle(h: Handle; byteCount: Size);
	{$IFC TARGET_OS_MAC AND TARGET_CPU_68K AND NOT TARGET_RT_MAC_CFM}
	INLINE $201F, $205F, $A027;
	{$ENDC}
{$ENDC}  {OLDROUTINENAMES}

{$ALIGN RESET}
{$POP}

{$SETC UsingIncludes := MacMemoryIncludes}

{$ENDC} {__MACMEMORY__}

{$IFC NOT UsingIncludes}
 END.
{$ENDC}

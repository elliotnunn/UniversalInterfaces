;
;	File:		CMApplication.a
;
;	Contains:	ColorSync API
;
;	Version:	Technology:	ColorSync 2.5
;				Release:	Universal Interfaces 3.2
;
;	Copyright:	© 1992-1998 by Apple Computer, Inc., all rights reserved.
;
;	Bugs?:		For bug reports, consult the following page on
;				the World Wide Web:
;
;					http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__CMAPPLICATION__') = 'UNDEFINED' THEN
__CMAPPLICATION__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF
	IF &TYPE('__FILES__') = 'UNDEFINED' THEN
	include 'Files.a'
	ENDIF
	IF &TYPE('__PRINTING__') = 'UNDEFINED' THEN
	include 'Printing.a'
	ENDIF
	IF &TYPE('__CMICCPROFILE__') = 'UNDEFINED' THEN
	include 'CMICCProfile.a'
	ENDIF
	IF &TYPE('__DISPLAYS__') = 'UNDEFINED' THEN
	include 'Displays.a'
	ENDIF


kDefaultCMMSignature			EQU		'appl'
;  Macintosh 68K trap word 

cmTrap							EQU		$ABEE

;  PicComment IDs 

cmBeginProfile					EQU		220
cmEndProfile					EQU		221
cmEnableMatching				EQU		222
cmDisableMatching				EQU		223
cmComment						EQU		224
;  PicComment selectors for cmComment 

cmBeginProfileSel				EQU		0
cmContinueProfileSel			EQU		1
cmEndProfileSel					EQU		2
cmProfileIdentifierSel			EQU		3

;  Defines for version 1.0 CMProfileSearchRecord.fieldMask 

cmMatchCMMType					EQU		$00000001
cmMatchApplProfileVersion		EQU		$00000002
cmMatchDataType					EQU		$00000004
cmMatchDeviceType				EQU		$00000008
cmMatchDeviceManufacturer		EQU		$00000010
cmMatchDeviceModel				EQU		$00000020
cmMatchDeviceAttributes			EQU		$00000040
cmMatchFlags					EQU		$00000080
cmMatchOptions					EQU		$00000100
cmMatchWhite					EQU		$00000200
cmMatchBlack					EQU		$00000400
;  Defines for version 2.0 CMSearchRecord.searchMask 

cmMatchAnyProfile				EQU		$00000000
cmMatchProfileCMMType			EQU		$00000001
cmMatchProfileClass				EQU		$00000002
cmMatchDataColorSpace			EQU		$00000004
cmMatchProfileConnectionSpace	EQU		$00000008
cmMatchManufacturer				EQU		$00000010
cmMatchModel					EQU		$00000020
cmMatchAttributes				EQU		$00000040
cmMatchProfileFlags				EQU		$00000080
;  Result codes 

															; General Errors 
cmProfileError					EQU		-170
cmMethodError					EQU		-171
cmMethodNotFound				EQU		-175				; CMM not present 
cmProfileNotFound				EQU		-176				; Responder error 
cmProfilesIdentical				EQU		-177				; Profiles the same 
cmCantConcatenateError			EQU		-178				; Profile can't be concatenated 
cmCantXYZ						EQU		-179				; CMM cant handle XYZ space 
cmCantDeleteProfile				EQU		-180				; Responder error 
cmUnsupportedDataType			EQU		-181				; Responder error 
cmNoCurrentProfile				EQU		-182				; Responder error 
															; Profile Access Errors 
cmElementTagNotFound			EQU		-4200
cmIndexRangeErr					EQU		-4201				; Tag index out of range 
cmCantDeleteElement				EQU		-4202
cmFatalProfileErr				EQU		-4203
cmInvalidProfile				EQU		-4204				; A Profile must contain a 'cs1 ' tag to be valid 
cmInvalidProfileLocation		EQU		-4205				; Operation not supported for this profile location 
cmCantCopyModifiedV1Profile		EQU		-4215				; Illegal to copy version 1 profiles that have been modified 
															; Profile Search Errors 
cmInvalidSearch					EQU		-4206				; Bad Search Handle 
cmSearchError					EQU		-4207
cmErrIncompatibleProfile		EQU		-4208				; Other ColorSync Errors 
cmInvalidColorSpace				EQU		-4209				; Profile colorspace does not match bitmap type 
cmInvalidSrcMap					EQU		-4210				; Source pix/bit map was invalid 
cmInvalidDstMap					EQU		-4211				; Destination pix/bit map was invalid 
cmNoGDevicesError				EQU		-4212				; Begin/End Matching -- no gdevices available 
cmInvalidProfileComment			EQU		-4213				; Bad Profile comment during drawpicture 
cmRangeOverFlow					EQU		-4214				; Color conversion warning that some output color values over/underflowed and were clipped 
cmNamedColorNotFound			EQU		-4216				; NamedColor not found 
cmCantGamutCheckError			EQU		-4217				; Gammut checking not supported by this ColorWorld 
;  deviceType values for ColorSync 1.0 Device Profile access 

cmSystemDevice					EQU		'sys '
cmGDevice						EQU		'gdev'
;  Commands for CMFlattenUPP(…) 

cmOpenReadSpool					EQU		1
cmOpenWriteSpool				EQU		2
cmReadSpool						EQU		3
cmWriteSpool					EQU		4
cmCloseSpool					EQU		5
;  Flags for PostScript-related functions 

cmPS7bit						EQU		1
cmPS8bit						EQU		2
;  Flags for profile embedding functions 

cmEmbedWholeProfile				EQU		$00000000
cmEmbedProfileIdentifier		EQU		$00000001
;  Commands for CMAccessUPP(…) 

cmOpenReadAccess				EQU		1
cmOpenWriteAccess				EQU		2
cmReadAccess					EQU		3
cmWriteAccess					EQU		4
cmCloseAccess					EQU		5
cmCreateNewAccess				EQU		6
cmAbortWriteAccess				EQU		7
cmBeginAccess					EQU		8
cmEndAccess						EQU		9

;  Abstract data type for memory-based Profile 


;  Abstract data type for Profile search result 


;  Abstract data type for BeginMatching(…) reference 


;  Abstract data type for ColorWorld reference 


;  Caller-supplied flatten function 
;  Caller-supplied progress function for Bitmap & PixMap matching routines 
;  Caller-supplied filter function for Profile search 
;  Caller-supplied function for profile access 
; typedef long 							CMError

;  For 1.0 and 2.0 profile header variants 
;  CMAppleProfileHeader 
CMAppleProfileHeader	RECORD 0
cm1						 ds		CMHeader		; offset: $0 (0)
						 ORG 0
cm2						 ds		CM2Header		; offset: $0 (0)
sizeof					 EQU *					; size:   $80 (128)
						ENDR
;  Param for CWConcatColorWorld(…) 
CMConcatProfileSet		RECORD 0
keyIndex				 ds.w	1				; offset: $0 (0)		;  Zero-based 
count					 ds.w	1				; offset: $2 (2)		;  Min 1 
profileSet				 ds.l	1				; offset: $4 (4) <-- really an array of length one ;  Variable. Ordered from Source -> Dest 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  ColorSync color data types 
CMRGBColor				RECORD 0
red						 ds.w	1				; offset: $0 (0)		;  0..65535 
green					 ds.w	1				; offset: $2 (2)
blue					 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
CMCMYKColor				RECORD 0
cyan					 ds.w	1				; offset: $0 (0)		;  0..65535 
magenta					 ds.w	1				; offset: $2 (2)
yellow					 ds.w	1				; offset: $4 (4)
black					 ds.w	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
CMCMYColor				RECORD 0
cyan					 ds.w	1				; offset: $0 (0)		;  0..65535 
magenta					 ds.w	1				; offset: $2 (2)
yellow					 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
CMHLSColor				RECORD 0
hue						 ds.w	1				; offset: $0 (0)		;  0..65535. Fraction of circle. Red at 0 
lightness				 ds.w	1				; offset: $2 (2)		;  0..65535 
saturation				 ds.w	1				; offset: $4 (4)		;  0..65535 
sizeof					 EQU *					; size:   $6 (6)
						ENDR
CMHSVColor				RECORD 0
hue						 ds.w	1				; offset: $0 (0)		;  0..65535. Fraction of circle. Red at 0 
saturation				 ds.w	1				; offset: $2 (2)		;  0..65535 
value					 ds.w	1				; offset: $4 (4)		;  0..65535 
sizeof					 EQU *					; size:   $6 (6)
						ENDR
CMLabColor				RECORD 0
L						 ds.w	1				; offset: $0 (0)		;  0..65535 maps to 0..100 
a						 ds.w	1				; offset: $2 (2)		;  0..65535 maps to -128..127.996 
b						 ds.w	1				; offset: $4 (4)		;  0..65535 maps to -128..127.996 
sizeof					 EQU *					; size:   $6 (6)
						ENDR
CMLuvColor				RECORD 0
L						 ds.w	1				; offset: $0 (0)		;  0..65535 maps to 0..100 
u						 ds.w	1				; offset: $2 (2)		;  0..65535 maps to -128..127.996 
v						 ds.w	1				; offset: $4 (4)		;  0..65535 maps to -128..127.996 
sizeof					 EQU *					; size:   $6 (6)
						ENDR
CMYxyColor				RECORD 0
capY					 ds.w	1				; offset: $0 (0)		;  0..65535 maps to 0..1 
x						 ds.w	1				; offset: $2 (2)		;  0..65535 maps to 0..1 
y						 ds.w	1				; offset: $4 (4)		;  0..65535 maps to 0..1 
sizeof					 EQU *					; size:   $6 (6)
						ENDR
CMGrayColor				RECORD 0
gray					 ds.w	1				; offset: $0 (0)		;  0..65535 
sizeof					 EQU *					; size:   $2 (2)
						ENDR
CMMultichannel5Color	RECORD 0
components				 ds.b	5				; offset: $0 (0)		;  0..255 
						 ORG 6
sizeof					 EQU *					; size:   $6 (6)
						ENDR
CMMultichannel6Color	RECORD 0
components				 ds.b	6				; offset: $0 (0)		;  0..255 
sizeof					 EQU *					; size:   $6 (6)
						ENDR
CMMultichannel7Color	RECORD 0
components				 ds.b	7				; offset: $0 (0)		;  0..255 
						 ORG 8
sizeof					 EQU *					; size:   $8 (8)
						ENDR
CMMultichannel8Color	RECORD 0
components				 ds.b	8				; offset: $0 (0)		;  0..255 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
CMNamedColor			RECORD 0
namedColorIndex			 ds.l	1				; offset: $0 (0)		;  0..a lot 
sizeof					 EQU *					; size:   $4 (4)
						ENDR
CMColor					RECORD 0
rgb						 ds		CMRGBColor		; offset: $0 (0)
						 ORG 0
hsv						 ds		CMHSVColor		; offset: $0 (0)
						 ORG 0
hls						 ds		CMHLSColor		; offset: $0 (0)
						 ORG 0
XYZ						 ds		CMXYZColor		; offset: $0 (0)
						 ORG 0
Lab						 ds		CMLabColor		; offset: $0 (0)
						 ORG 0
Luv						 ds		CMLuvColor		; offset: $0 (0)
						 ORG 0
Yxy						 ds		CMYxyColor		; offset: $0 (0)
						 ORG 0
cmyk					 ds		CMCMYKColor		; offset: $0 (0)
						 ORG 0
cmy						 ds		CMCMYColor		; offset: $0 (0)
						 ORG 0
gray					 ds		CMGrayColor		; offset: $0 (0)
						 ORG 0
mc5						 ds		CMMultichannel5Color ; offset: $0 (0)
						 ORG 0
mc6						 ds		CMMultichannel6Color ; offset: $0 (0)
						 ORG 0
mc7						 ds		CMMultichannel7Color ; offset: $0 (0)
						 ORG 0
mc8						 ds		CMMultichannel8Color ; offset: $0 (0)
						 ORG 0
namedColor				 ds		CMNamedColor	; offset: $0 (0)
						 ORG 8
sizeof					 EQU *					; size:   $8 (8)
						ENDR
CMProfileSearchRecord	RECORD 0
header					 ds		CMHeader		; offset: $0 (0)
fieldMask				 ds.l	1				; offset: $40 (64)
reserved				 ds.l	2				; offset: $44 (68)
sizeof					 EQU *					; size:   $4C (76)
						ENDR
; typedef struct CMProfileSearchRecord * CMProfileSearchRecordPtr

; typedef CMProfileSearchRecordPtr *	CMProfileSearchRecordHandle

;  Search definition for 2.0 
CMSearchRecord			RECORD 0
CMMType					 ds.l	1				; offset: $0 (0)
profileClass			 ds.l	1				; offset: $4 (4)
dataColorSpace			 ds.l	1				; offset: $8 (8)
profileConnectionSpace	 ds.l	1				; offset: $C (12)
deviceManufacturer		 ds.l	1				; offset: $10 (16)
deviceModel				 ds.l	1				; offset: $14 (20)
deviceAttributes		 ds.l	2				; offset: $18 (24)
profileFlags			 ds.l	1				; offset: $20 (32)
searchMask				 ds.l	1				; offset: $24 (36)
filter					 ds.l	1				; offset: $28 (40)
sizeof					 EQU *					; size:   $2C (44)
						ENDR
;  GetCWInfo structures 
CMMInfoRecord			RECORD 0
CMMType					 ds.l	1				; offset: $0 (0)
CMMVersion				 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
CMCWInfoRecord			RECORD 0
cmmCount				 ds.l	1				; offset: $0 (0)
cmmInfo					 ds.b	2 * CMMInfoRecord.sizeof ; offset: $4 (4)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
;  profile identifier structures 
CMProfileIdentifier		RECORD 0
profileHeader			 ds		CM2Header		; offset: $0 (0)
calibrationDate			 ds		CMDateTime		; offset: $80 (128)
ASCIIProfileDescriptionLen  ds.l 1				; offset: $8C (140)
ASCIIProfileDescription	 ds.b	1				; offset: $90 (144) <-- really an array of length one ;  variable length 
						 ORG 146
sizeof					 EQU *					; size:   $92 (146)
						ENDR
; typedef struct CMProfileIdentifier *	CMProfileIdentifierPtr

;  packing formats 

cmNoColorPacking				EQU		$0000
cmAlphaSpace					EQU		$0080
cmWord5ColorPacking				EQU		$0500
cmLong8ColorPacking				EQU		$0800
cmLong10ColorPacking			EQU		$0A00
cmAlphaFirstPacking				EQU		$1000
cmOneBitDirectPacking			EQU		$0B00
cmAlphaLastPacking				EQU		$0000
cm24_8ColorPacking				EQU		$2100
cm32_8ColorPacking				EQU		$0800
cm40_8ColorPacking				EQU		$2200
cm48_8ColorPacking				EQU		$2300
cm56_8ColorPacking				EQU		$2400
cm64_8ColorPacking				EQU		$2500
cm32_16ColorPacking				EQU		$2600
cm48_16ColorPacking				EQU		$2900
cm64_16ColorPacking				EQU		$2A00
cm32_32ColorPacking				EQU		$2700
;  general colorspaces 

cmNoSpace						EQU		0
cmRGBSpace						EQU		1
cmCMYKSpace						EQU		2
cmHSVSpace						EQU		3
cmHLSSpace						EQU		4
cmYXYSpace						EQU		5
cmXYZSpace						EQU		6
cmLUVSpace						EQU		7
cmLABSpace						EQU		8
cmReservedSpace1				EQU		9
cmGraySpace						EQU		10
cmReservedSpace2				EQU		11
cmGamutResultSpace				EQU		12
cmNamedIndexedSpace				EQU		16
cmMCFiveSpace					EQU		17
cmMCSixSpace					EQU		18
cmMCSevenSpace					EQU		19
cmMCEightSpace					EQU		20
cmRGBASpace						EQU		129
cmGrayASpace					EQU		138
;  supported CMBitmapColorSpaces - each of the following is a 
;  combination of a general colospace and a packing formats 

cmGray16Space					EQU		10
cmGrayA32Space					EQU		138
cmRGB16Space					EQU		$0501
cmRGB24Space					EQU		$2101
cmRGB32Space					EQU		$0801
cmRGB48Space					EQU		$2901
cmARGB32Space					EQU		$1881
cmRGBA32Space					EQU		$0881
cmCMYK32Space					EQU		$0802
cmCMYK64Space					EQU		$2A02
cmHSV32Space					EQU		$0A03
cmHLS32Space					EQU		$0A04
cmYXY32Space					EQU		$0A05
cmXYZ32Space					EQU		$0A06
cmLUV32Space					EQU		$0A07
cmLAB24Space					EQU		$2108
cmLAB32Space					EQU		$0A08
cmLAB48Space					EQU		$2908
cmGamutResult1Space				EQU		$0B0C
cmNamedIndexed32Space			EQU		$2710
cmMCFive8Space					EQU		$2211
cmMCSix8Space					EQU		$2312
cmMCSeven8Space					EQU		$2413
cmMCEight8Space					EQU		$2514

; typedef unsigned long 				CMBitmapColorSpace

CMBitmap				RECORD 0
image					 ds.l	1				; offset: $0 (0)
width					 ds.l	1				; offset: $4 (4)
height					 ds.l	1				; offset: $8 (8)
rowBytes				 ds.l	1				; offset: $C (12)
pixelSize				 ds.l	1				; offset: $10 (16)
space					 ds.l	1				; offset: $14 (20)
user1					 ds.l	1				; offset: $18 (24)
user2					 ds.l	1				; offset: $1C (28)
sizeof					 EQU *					; size:   $20 (32)
						ENDR

;  Classic Print Manager Stuff 

enableColorMatchingOp			EQU		12
registerProfileOp				EQU		13

cmNoProfileBase					EQU		0
cmFileBasedProfile				EQU		1
cmHandleBasedProfile			EQU		2
cmPtrBasedProfile				EQU		3
cmProcedureBasedProfile			EQU		4
CMFileLocation			RECORD 0
spec					 ds		FSSpec			; offset: $0 (0)
sizeof					 EQU *					; size:   $46 (70)
						ENDR
CMHandleLocation		RECORD 0
h						 ds.l	1				; offset: $0 (0)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
CMPtrLocation			RECORD 0
p						 ds.l	1				; offset: $0 (0)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
CMProcedureLocation		RECORD 0
proc					 ds.l	1				; offset: $0 (0)
refCon					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR

CMProfLoc				RECORD 0
fileLoc					 ds		CMFileLocation ; offset: $0 (0)
						 ORG 0
handleLoc				 ds		CMHandleLocation ; offset: $0 (0)
						 ORG 0
ptrLoc					 ds		CMPtrLocation	; offset: $0 (0)
						 ORG 0
procLoc					 ds		CMProcedureLocation ; offset: $0 (0)
						 ORG 70
sizeof					 EQU *					; size:   $46 (70)
						ENDR
CMProfileLocation		RECORD 0
locType					 ds.w	1				; offset: $0 (0)
u						 ds		CMProfLoc		; offset: $2 (2)
sizeof					 EQU *					; size:   $48 (72)
						ENDR

cmOriginalProfileLocationSize	EQU		72
cmCurrentProfileLocationSize	EQU		72

;  Struct and enums used for Profile iteration 

cmProfileIterateDataVersion1	EQU		$00010000
CMProfileIterateData	RECORD 0
dataVersion				 ds.l	1				; offset: $0 (0)		;  cmProfileIterateDataVersion1 
header					 ds		CM2Header		; offset: $4 (4)
code					 ds.w	1				; offset: $84 (132)
name					 ds		Str255			; offset: $86 (134)
location				 ds		CMProfileLocation ; offset: $186 (390)
sizeof					 EQU *					; size:   $1CE (462)
						ENDR
;  Caller-supplied callback function for Profile iteration 
;  Profile file and element access 
;
; pascal CMError CMNewProfile(CMProfileRef *prof, const CMProfileLocation *theProfile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMNewProfile
			move.l              #$0008001B,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMNewProfile
	ENDIF

;
; pascal CMError CMOpenProfile(CMProfileRef *prof, const CMProfileLocation *theProfile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMOpenProfile
			move.l              #$0008001C,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMOpenProfile
	ENDIF

;
; pascal CMError CMCloseProfile(CMProfileRef prof)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMCloseProfile
			move.l              #$0004001D,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMCloseProfile
	ENDIF

;
; pascal CMError CMUpdateProfile(CMProfileRef prof)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMUpdateProfile
			move.l              #$00040034,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMUpdateProfile
	ENDIF

;
; pascal CMError CMCopyProfile(CMProfileRef *targetProf, const CMProfileLocation *targetLocation, CMProfileRef srcProf)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMCopyProfile
			move.l              #$000C0025,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMCopyProfile
	ENDIF

;
; pascal CMError CMValidateProfile(CMProfileRef prof, Boolean *valid, Boolean *preferredCMMnotfound)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMValidateProfile
			move.l              #$000C0026,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMValidateProfile
	ENDIF

;
; pascal CMError CMGetProfileLocation(CMProfileRef prof, CMProfileLocation *theProfile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetProfileLocation
			move.l              #$0008003C,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetProfileLocation
	ENDIF

;
; pascal CMError NCMGetProfileLocation(CMProfileRef prof, CMProfileLocation *theProfile, unsigned long *locationSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NCMGetProfileLocation
			move.l              #$000C0059,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NCMGetProfileLocation
	ENDIF

;
; pascal CMError CMFlattenProfile(CMProfileRef prof, unsigned long flags, CMFlattenUPP proc, void *refCon, Boolean *preferredCMMnotfound)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMFlattenProfile
			move.l              #$00140031,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMFlattenProfile
	ENDIF

;
; pascal CMError CMUnflattenProfile(FSSpec *resultFileSpec, CMFlattenUPP proc, void *refCon, Boolean *preferredCMMnotfound)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMUnflattenProfile
			move.l              #$00100032,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMUnflattenProfile
	ENDIF

;
; pascal CMError CMGetProfileHeader(CMProfileRef prof, CMAppleProfileHeader *header)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetProfileHeader
			move.l              #$00080039,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetProfileHeader
	ENDIF

;
; pascal CMError CMSetProfileHeader(CMProfileRef prof, const CMAppleProfileHeader *header)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMSetProfileHeader
			move.l              #$0008003A,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMSetProfileHeader
	ENDIF

;
; pascal CMError CMProfileElementExists(CMProfileRef prof, OSType tag, Boolean *found)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMProfileElementExists
			move.l              #$000C001E,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMProfileElementExists
	ENDIF

;
; pascal CMError CMCountProfileElements(CMProfileRef prof, unsigned long *elementCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMCountProfileElements
			move.l              #$0008001F,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMCountProfileElements
	ENDIF

;
; pascal CMError CMGetProfileElement(CMProfileRef prof, OSType tag, unsigned long *elementSize, void *elementData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetProfileElement
			move.l              #$00100020,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetProfileElement
	ENDIF

;
; pascal CMError CMSetProfileElement(CMProfileRef prof, OSType tag, unsigned long elementSize, void *elementData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMSetProfileElement
			move.l              #$00100023,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMSetProfileElement
	ENDIF

;
; pascal CMError CMSetProfileElementSize(CMProfileRef prof, OSType tag, unsigned long elementSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMSetProfileElementSize
			move.l              #$000C0038,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMSetProfileElementSize
	ENDIF

;
; pascal CMError CMSetProfileElementReference(CMProfileRef prof, OSType elementTag, OSType referenceTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMSetProfileElementReference
			move.l              #$000C0035,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMSetProfileElementReference
	ENDIF

;
; pascal CMError CMGetPartialProfileElement(CMProfileRef prof, OSType tag, unsigned long offset, unsigned long *byteCount, void *elementData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetPartialProfileElement
			move.l              #$00140036,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetPartialProfileElement
	ENDIF

;
; pascal CMError CMSetPartialProfileElement(CMProfileRef prof, OSType tag, unsigned long offset, unsigned long byteCount, void *elementData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMSetPartialProfileElement
			move.l              #$00140037,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMSetPartialProfileElement
	ENDIF

;
; pascal CMError CMGetIndProfileElementInfo(CMProfileRef prof, unsigned long index, OSType *tag, unsigned long *elementSize, Boolean *refs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetIndProfileElementInfo
			move.l              #$00140021,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetIndProfileElementInfo
	ENDIF

;
; pascal CMError CMGetIndProfileElement(CMProfileRef prof, unsigned long index, unsigned long *elementSize, void *elementData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetIndProfileElement
			move.l              #$00100022,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetIndProfileElement
	ENDIF

;
; pascal CMError CMRemoveProfileElement(CMProfileRef prof, OSType tag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMRemoveProfileElement
			move.l              #$00080024,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMRemoveProfileElement
	ENDIF

;
; pascal CMError CMGetScriptProfileDescription(CMProfileRef prof, Str255 name, ScriptCode *code)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetScriptProfileDescription
			move.l              #$000C003E,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetScriptProfileDescription
	ENDIF

;
; pascal CMError CMCloneProfileRef(CMProfileRef prof)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMCloneProfileRef
			move.l              #$00040042,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMCloneProfileRef
	ENDIF

;
; pascal CMError CMGetProfileRefCount(CMProfileRef prof, long *count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetProfileRefCount
			move.l              #$00080043,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetProfileRefCount
	ENDIF

;
; pascal CMError CMProfileModified(CMProfileRef prof, Boolean *modified)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMProfileModified
			move.l              #$00080044,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMProfileModified
	ENDIF


;  named Color access functions 
;
; pascal CMError CMGetNamedColorInfo(CMProfileRef prof, unsigned long *deviceChannels, OSType *deviceColorSpace, OSType *PCSColorSpace, unsigned long *count, StringPtr prefix, StringPtr suffix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetNamedColorInfo
			move.l              #$001C0046,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetNamedColorInfo
	ENDIF

;
; pascal CMError CMGetNamedColorValue(CMProfileRef prof, StringPtr name, CMColor *deviceColor, CMColor *PCSColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetNamedColorValue
			move.l              #$00100047,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetNamedColorValue
	ENDIF

;
; pascal CMError CMGetIndNamedColorValue(CMProfileRef prof, unsigned long index, CMColor *deviceColor, CMColor *PCSColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetIndNamedColorValue
			move.l              #$00100048,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetIndNamedColorValue
	ENDIF

;
; pascal CMError CMGetNamedColorIndex(CMProfileRef prof, StringPtr name, unsigned long *index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetNamedColorIndex
			move.l              #$000C0049,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetNamedColorIndex
	ENDIF

;
; pascal CMError CMGetNamedColorName(CMProfileRef prof, unsigned long index, StringPtr name)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetNamedColorName
			move.l              #$000C004A,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetNamedColorName
	ENDIF


;  Low-level matching functions 
;
; pascal CMError NCWNewColorWorld(CMWorldRef *cw, CMProfileRef src, CMProfileRef dst)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NCWNewColorWorld
			move.l              #$000C0014,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NCWNewColorWorld
	ENDIF

;
; pascal CMError CWConcatColorWorld(CMWorldRef *cw, CMConcatProfileSet *profileSet)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CWConcatColorWorld
			move.l              #$00080015,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CWConcatColorWorld
	ENDIF

;
; pascal CMError CWNewLinkProfile(CMProfileRef *prof, const CMProfileLocation *targetLocation, CMConcatProfileSet *profileSet)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CWNewLinkProfile
			move.l              #$000C0033,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CWNewLinkProfile
	ENDIF

;
; pascal void CWDisposeColorWorld(CMWorldRef cw)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CWDisposeColorWorld
			move.l              #$00040001,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CWDisposeColorWorld
	ENDIF

;
; pascal CMError CWMatchColors(CMWorldRef cw, CMColor *myColors, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CWMatchColors
			move.l              #$000C0002,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CWMatchColors
	ENDIF

;
; pascal CMError CWCheckColors(CMWorldRef cw, CMColor *myColors, unsigned long count, long *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CWCheckColors
			move.l              #$00100003,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CWCheckColors
	ENDIF


;  Bitmap matching 
;
; pascal CMError CWMatchBitmap(CMWorldRef cw, CMBitmap *bitmap, CMBitmapCallBackUPP progressProc, void *refCon, CMBitmap *matchedBitmap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CWMatchBitmap
			move.l              #$0010002C,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CWMatchBitmap
	ENDIF

;
; pascal CMError CWCheckBitmap(CMWorldRef cw, const CMBitmap *bitmap, CMBitmapCallBackUPP progressProc, void *refCon, CMBitmap *resultBitmap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CWCheckBitmap
			move.l              #$0014002D,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CWCheckBitmap
	ENDIF


;  Quickdraw-specific matching 
;
; pascal CMError CWMatchPixMap(CMWorldRef cw, PixMap *myPixMap, CMBitmapCallBackUPP progressProc, void *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CWMatchPixMap
			move.l              #$00100004,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CWMatchPixMap
	ENDIF

;
; pascal CMError CWCheckPixMap(CMWorldRef cw, PixMap *myPixMap, CMBitmapCallBackUPP progressProc, void *refCon, BitMap *resultBitMap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CWCheckPixMap
			move.l              #$00140007,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CWCheckPixMap
	ENDIF

;
; pascal CMError NCMBeginMatching(CMProfileRef src, CMProfileRef dst, CMMatchRef *myRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NCMBeginMatching
			move.l              #$000C0016,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NCMBeginMatching
	ENDIF

;
; pascal void CMEndMatching(CMMatchRef myRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMEndMatching
			move.l              #$0004000B,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMEndMatching
	ENDIF

;
; pascal void NCMDrawMatchedPicture(PicHandle myPicture, CMProfileRef dst, Rect *myRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NCMDrawMatchedPicture
			move.l              #$000C0017,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NCMDrawMatchedPicture
	ENDIF

;
; pascal void CMEnableMatchingComment(Boolean enableIt)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMEnableMatchingComment
			move.l              #$0002000D,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMEnableMatchingComment
	ENDIF

;
; pascal CMError NCMUseProfileComment(CMProfileRef prof, unsigned long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NCMUseProfileComment
			move.l              #$0008003B,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NCMUseProfileComment
	ENDIF

;
; pascal CMError CMCreateProfileIdentifier(CMProfileRef prof, CMProfileIdentifierPtr ident, unsigned long *size)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMCreateProfileIdentifier
			move.l              #$000C0041,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMCreateProfileIdentifier
	ENDIF


;  System Profile access 
;
; pascal CMError CMGetSystemProfile(CMProfileRef *prof)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetSystemProfile
			move.l              #$00040018,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetSystemProfile
	ENDIF

;
; pascal CMError CMSetSystemProfile(const FSSpec *profileFileSpec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMSetSystemProfile
			move.l              #$00040019,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMSetSystemProfile
	ENDIF

;
; pascal CMError CMGetDefaultProfileBySpace(OSType dataColorSpace, CMProfileRef *prof)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetDefaultProfileBySpace
			move.l              #$0008005A,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetDefaultProfileBySpace
	ENDIF

;
; pascal CMError CMSetDefaultProfileBySpace(OSType dataColorSpace, CMProfileRef prof)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMSetDefaultProfileBySpace
			move.l              #$0008005B,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMSetDefaultProfileBySpace
	ENDIF

;
; pascal CMError CMGetProfileByAVID(AVIDType theAVID, CMProfileRef *prof)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetProfileByAVID
			move.l              #$0008005C,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetProfileByAVID
	ENDIF

;
; pascal CMError CMSetProfileByAVID(AVIDType theAVID, CMProfileRef prof)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMSetProfileByAVID
			move.l              #$0008005D,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMSetProfileByAVID
	ENDIF


;  External Profile Management 
;
; pascal CMError CMNewProfileSearch(CMSearchRecord *searchSpec, void *refCon, unsigned long *count, CMProfileSearchRef *searchResult)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMNewProfileSearch
			move.l              #$00100027,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMNewProfileSearch
	ENDIF

;
; pascal CMError CMUpdateProfileSearch(CMProfileSearchRef search, void *refCon, unsigned long *count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMUpdateProfileSearch
			move.l              #$000C0028,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMUpdateProfileSearch
	ENDIF

;
; pascal void CMDisposeProfileSearch(CMProfileSearchRef search)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMDisposeProfileSearch
			move.l              #$00040029,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMDisposeProfileSearch
	ENDIF

;
; pascal CMError CMSearchGetIndProfile(CMProfileSearchRef search, unsigned long index, CMProfileRef *prof)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMSearchGetIndProfile
			move.l              #$000C002A,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMSearchGetIndProfile
	ENDIF

;
; pascal CMError CMSearchGetIndProfileFileSpec(CMProfileSearchRef search, unsigned long index, FSSpec *profileFile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMSearchGetIndProfileFileSpec
			move.l              #$000C002B,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMSearchGetIndProfileFileSpec
	ENDIF

;
; pascal CMError CMProfileIdentifierFolderSearch(CMProfileIdentifierPtr ident, unsigned long *matchedCount, CMProfileSearchRef *searchResult)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMProfileIdentifierFolderSearch
			move.l              #$000C003F,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMProfileIdentifierFolderSearch
	ENDIF

;
; pascal CMError CMProfileIdentifierListSearch(CMProfileIdentifierPtr ident, CMProfileRef *profileList, unsigned long listSize, unsigned long *matchedCount, CMProfileRef *matchedList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMProfileIdentifierListSearch
			move.l              #$00140040,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMProfileIdentifierListSearch
	ENDIF

;
; pascal CMError CMIterateColorSyncFolder(CMProfileIterateUPP proc, unsigned long *seed, unsigned long *count, void *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMIterateColorSyncFolder
			move.l              #$00100058,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMIterateColorSyncFolder
	ENDIF


;  Utilities 
;
; pascal CMError CMGetColorSyncFolderSpec(short vRefNum, Boolean createFolder, short *foundVRefNum, long *foundDirID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetColorSyncFolderSpec
			move.l              #$000C0011,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetColorSyncFolderSpec
	ENDIF

;
; pascal CMError CMGetCWInfo(CMWorldRef cw, CMCWInfoRecord *info)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetCWInfo
			move.l              #$0008001A,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetCWInfo
	ENDIF

;
; pascal CMError CMConvertProfile2to1(CMProfileRef profv2, CMProfileHandle *profv1)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertProfile2to1
			move.l              #$00080045,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertProfile2to1
	ENDIF

;
; pascal CMError CMGetPreferredCMM(OSType *cmmType, Boolean *preferredCMMnotfound)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetPreferredCMM
			move.l              #$0008005E,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetPreferredCMM
	ENDIF



;  ColorSpace conversion functions 
;
; pascal CMError CMConvertXYZToLab(const CMColor *src, const CMXYZColor *white, CMColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertXYZToLab
			move.l              #$0010004B,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertXYZToLab
	ENDIF

;
; pascal CMError CMConvertLabToXYZ(const CMColor *src, const CMXYZColor *white, CMColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertLabToXYZ
			move.l              #$0010004C,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertLabToXYZ
	ENDIF

;
; pascal CMError CMConvertXYZToLuv(const CMColor *src, const CMXYZColor *white, CMColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertXYZToLuv
			move.l              #$0010004D,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertXYZToLuv
	ENDIF

;
; pascal CMError CMConvertLuvToXYZ(const CMColor *src, const CMXYZColor *white, CMColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertLuvToXYZ
			move.l              #$0010004E,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertLuvToXYZ
	ENDIF

;
; pascal CMError CMConvertXYZToYxy(const CMColor *src, CMColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertXYZToYxy
			move.l              #$000C004F,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertXYZToYxy
	ENDIF

;
; pascal CMError CMConvertYxyToXYZ(const CMColor *src, CMColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertYxyToXYZ
			move.l              #$000C0050,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertYxyToXYZ
	ENDIF

;
; pascal CMError CMConvertRGBToHLS(const CMColor *src, CMColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertRGBToHLS
			move.l              #$000C0051,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertRGBToHLS
	ENDIF

;
; pascal CMError CMConvertHLSToRGB(const CMColor *src, CMColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertHLSToRGB
			move.l              #$000C0052,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertHLSToRGB
	ENDIF

;
; pascal CMError CMConvertRGBToHSV(const CMColor *src, CMColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertRGBToHSV
			move.l              #$000C0053,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertRGBToHSV
	ENDIF

;
; pascal CMError CMConvertHSVToRGB(const CMColor *src, CMColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertHSVToRGB
			move.l              #$000C0054,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertHSVToRGB
	ENDIF

;
; pascal CMError CMConvertRGBToGray(const CMColor *src, CMColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertRGBToGray
			move.l              #$000C0055,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertRGBToGray
	ENDIF

;
; pascal CMError CMConvertXYZToFixedXYZ(const CMXYZColor *src, CMFixedXYZColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertXYZToFixedXYZ
			move.l              #$000C0056,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertXYZToFixedXYZ
	ENDIF

;
; pascal CMError CMConvertFixedXYZToXYZ(const CMFixedXYZColor *src, CMXYZColor *dst, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMConvertFixedXYZToXYZ
			move.l              #$000C0057,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMConvertFixedXYZToXYZ
	ENDIF

;  PS-related 
;
; pascal CMError CMGetPS2ColorSpace(CMProfileRef srcProf, unsigned long flags, CMFlattenUPP proc, void *refCon, Boolean *preferredCMMnotfound)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetPS2ColorSpace
			move.l              #$0014002E,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetPS2ColorSpace
	ENDIF

;
; pascal CMError CMGetPS2ColorRenderingIntent(CMProfileRef srcProf, unsigned long flags, CMFlattenUPP proc, void *refCon, Boolean *preferredCMMnotfound)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetPS2ColorRenderingIntent
			move.l              #$0014002F,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetPS2ColorRenderingIntent
	ENDIF

;
; pascal CMError CMGetPS2ColorRendering(CMProfileRef srcProf, CMProfileRef dstProf, unsigned long flags, CMFlattenUPP proc, void *refCon, Boolean *preferredCMMnotfound)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetPS2ColorRendering
			move.l              #$00180030,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetPS2ColorRendering
	ENDIF

;
; pascal CMError CMGetPS2ColorRenderingVMSize(CMProfileRef srcProf, CMProfileRef dstProf, unsigned long *vmSize, Boolean *preferredCMMnotfound)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetPS2ColorRenderingVMSize
			move.l              #$0010003D,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetPS2ColorRenderingVMSize
	ENDIF


;  ColorSync 1.0 functions which have parallel 2.0 counterparts 
;
; pascal CMError CWNewColorWorld(CMWorldRef *cw, CMProfileHandle src, CMProfileHandle dst)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CWNewColorWorld
			move.l              #$000C0000,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CWNewColorWorld
	ENDIF

;
; pascal CMError ConcatenateProfiles(CMProfileHandle thru, CMProfileHandle dst, CMProfileHandle *newDst)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ConcatenateProfiles
			move.l              #$000C000C,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ConcatenateProfiles
	ENDIF

;
; pascal CMError CMBeginMatching(CMProfileHandle src, CMProfileHandle dst, CMMatchRef *myRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMBeginMatching
			move.l              #$000C000A,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMBeginMatching
	ENDIF

;
; pascal void CMDrawMatchedPicture(PicHandle myPicture, CMProfileHandle dst, Rect *myRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMDrawMatchedPicture
			move.l              #$000C0009,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMDrawMatchedPicture
	ENDIF

;
; pascal CMError CMUseProfileComment(CMProfileHandle profile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMUseProfileComment
			move.l              #$00040008,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMUseProfileComment
	ENDIF

;
; pascal void CMGetProfileName(CMProfileHandle myProfile, CMIString *IStringResult)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetProfileName
			move.l              #$0008000E,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetProfileName
	ENDIF

;
; pascal long CMGetProfileAdditionalDataOffset(CMProfileHandle myProfile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CMGetProfileAdditionalDataOffset
			move.l              #$0004000F,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CMGetProfileAdditionalDataOffset
	ENDIF


;  ProfileResponder functions 
;
; pascal CMError GetProfile(OSType deviceType, long refNum, CMProfileHandle aProfile, CMProfileHandle *returnedProfile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetProfile
			move.l              #$00100005,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetProfile
	ENDIF

;
; pascal CMError SetProfile(OSType deviceType, long refNum, CMProfileHandle newProfile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetProfile
			move.l              #$000C0006,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetProfile
	ENDIF

;
; pascal CMError SetProfileDescription(OSType deviceType, long refNum, long deviceData, CMProfileHandle hProfile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetProfileDescription
			move.l              #$00100010,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetProfileDescription
	ENDIF

;
; pascal CMError GetIndexedProfile(OSType deviceType, long refNum, CMProfileSearchRecordHandle search, CMProfileHandle *returnProfile, long *index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetIndexedProfile
			move.l              #$00140012,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetIndexedProfile
	ENDIF

;
; pascal CMError DeleteDeviceProfile(OSType deviceType, long refNum, CMProfileHandle deleteMe)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DeleteDeviceProfile
			move.l              #$000C0013,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeleteDeviceProfile
	ENDIF


	IF OLDROUTINENAMES THEN
;  constants 

kMatchCMMType					EQU		$00000001
kMatchApplProfileVersion		EQU		$00000002
kMatchDataType					EQU		$00000004
kMatchDeviceType				EQU		$00000008
kMatchDeviceManufacturer		EQU		$00000010
kMatchDeviceModel				EQU		$00000020
kMatchDeviceAttributes			EQU		$00000040
kMatchFlags						EQU		$00000080
kMatchOptions					EQU		$00000100
kMatchWhite						EQU		$00000200
kMatchBlack						EQU		$00000400
;  types 
CMYKColor				RECORD 0
f						 ds		CMCMYKColor
sizeof					 EQU *					; size:   $8 (8)
						ENDR


; typedef CMWorldRef 					CWorld

; typedef long *						CMGamutResult

;  functions 
;
; pascal void EndMatching(CMMatchRef myRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_EndMatching
			move.l              #$0004000B,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EndMatching
	ENDIF

;
; pascal void EnableMatching(Boolean enableIt)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_EnableMatching
			move.l              #$0002000D,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EnableMatching
	ENDIF

;
; pascal CMError GetColorSyncFolderSpec(short vRefNum, Boolean createFolder, short *foundVRefNum, long *foundDirID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetColorSyncFolderSpec
			move.l              #$000C0011,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetColorSyncFolderSpec
	ENDIF

;
; pascal CMError BeginMatching(CMProfileHandle src, CMProfileHandle dst, CMMatchRef *myRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_BeginMatching
			move.l              #$000C000A,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BeginMatching
	ENDIF

;
; pascal void DrawMatchedPicture(PicHandle myPicture, CMProfileHandle dst, Rect *myRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DrawMatchedPicture
			move.l              #$000C0009,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DrawMatchedPicture
	ENDIF

;
; pascal CMError UseProfile(CMProfileHandle profile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UseProfile
			move.l              #$00040008,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UseProfile
	ENDIF

;
; pascal void GetProfileName(CMProfileHandle myProfile, CMIString *IStringResult)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetProfileName
			move.l              #$0008000E,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetProfileName
	ENDIF

;
; pascal long GetProfileAdditionalDataOffset(CMProfileHandle myProfile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetProfileAdditionalDataOffset
			move.l              #$0004000F,D0
			dc.w            	$ABEE
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetProfileAdditionalDataOffset
	ENDIF

	ENDIF	; OLDROUTINENAMES

;  Deprecated stuff

;  PrGeneral parameter blocks 
TEnableColorMatchingBlk	RECORD 0
iOpCode					 ds.w	1				; offset: $0 (0)
iError					 ds.w	1				; offset: $2 (2)
lReserved				 ds.l	1				; offset: $4 (4)
hPrint					 ds.l	1				; offset: $8 (8)
fEnableIt				 ds.b	1				; offset: $C (12)
filler					 ds.b	1				; offset: $D (13)
sizeof					 EQU *					; size:   $E (14)
						ENDR
TRegisterProfileBlk		RECORD 0
iOpCode					 ds.w	1				; offset: $0 (0)
iError					 ds.w	1				; offset: $2 (2)
lReserved				 ds.l	1				; offset: $4 (4)
hPrint					 ds.l	1				; offset: $8 (8)
fRegisterIt				 ds.b	1				; offset: $C (12)
filler					 ds.b	1				; offset: $D (13)
sizeof					 EQU *					; size:   $E (14)
						ENDR
	ENDIF ; __CMAPPLICATION__ 


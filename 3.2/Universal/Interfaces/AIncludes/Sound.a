;
;	File:		Sound.a
;
;	Contains:	Sound Manager Interfaces.
;
;	Version:	Technology:	Sound Manager 3.3
;				Release:	Universal Interfaces 3.2
;
;	Copyright:	© 1986-1998 by Apple Computer, Inc., all rights reserved
;
;	Bugs?:		For bug reports, consult the following page on
;				the World Wide Web:
;
;					http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__SOUND__') = 'UNDEFINED' THEN
__SOUND__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__DIALOGS__') = 'UNDEFINED' THEN
	include 'Dialogs.a'
	ENDIF
	IF &TYPE('__COMPONENTS__') = 'UNDEFINED' THEN
	include 'Components.a'
	ENDIF
	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF
	IF &TYPE('__MOVIES__') = 'UNDEFINED' THEN
	include 'Movies.a'
	ENDIF

; 
;						* * *  N O T E  * * *
;
;	This file has been updated to include Sound Manager 3.3 interfaces.
;
;	Some of the Sound Manager 3.0 interfaces were not put into the InterfaceLib
;	that originally shipped with the PowerMacs. These missing functions and the
;	new 3.3 interfaces have been released in the SoundLib library for PowerPC
;	developers to link with. The runtime library for these functions are
;	installed by the Sound Manager. The following functions are found in SoundLib.
;
;		GetCompressionInfo(), GetSoundPreference(), SetSoundPreference(),
;		UnsignedFixedMulDiv(), SndGetInfo(), SndSetInfo(), GetSoundOutputInfo(),
;		SetSoundOutputInfo(), GetCompressionName(), SoundConverterOpen(),
;		SoundConverterClose(), SoundConverterGetBufferSizes(), SoundConverterBeginConversion(),
;		SoundConverterConvertBuffer(), SoundConverterEndConversion(),
;		AudioGetBass(), AudioGetInfo(), AudioGetMute(), AudioGetOutputDevice(),
;		AudioGetTreble(), AudioGetVolume(), AudioMuteOnEvent(), AudioSetBass(),
;		AudioSetMute(), AudioSetToDefaults(), AudioSetTreble(), AudioSetVolume(),
;		OpenMixerSoundComponent(), CloseMixerSoundComponent(), SoundComponentAddSource(),
;		SoundComponentGetInfo(), SoundComponentGetSource(), SoundComponentGetSourceData(),
;		SoundComponentInitOutputDevice(), SoundComponentPauseSource(),
;		SoundComponentPlaySourceBuffer(), SoundComponentRemoveSource(),
;		SoundComponentSetInfo(), SoundComponentSetOutput(), SoundComponentSetSource(),
;		SoundComponentStartSource(), SoundComponentStopSource(),
;		ParseAIFFHeader(), ParseSndHeader(), SoundConverterGetInfo(), SoundConverterSetInfo()
;

; 
;	Interfaces for Sound Driver, !!! OBSOLETE and NOT SUPPORTED !!!
;
;	These items are no longer defined, but appear here so that someone
;	searching the interfaces might find them. If you are using one of these
;	items, you must change your code to support the Sound Manager.
;
;		swMode, ftMode, ffMode
;		FreeWave, FFSynthRec, Tone, SWSynthRec, Wave, FTSoundRec
;		SndCompletionProcPtr
;		StartSound, StopSound, SoundDone
;


;  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;   constants
;  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



soundListRsrc					EQU		'snd '				;Resource type used by Sound Manager

kSimpleBeepID					EQU		1					;reserved resource ID for Simple Beep

rate48khz						EQU		$BB800000			;48000.00000 in fixed-point
rate44khz						EQU		$AC440000			;44100.00000 in fixed-point
rate22050hz						EQU		$56220000			;22050.00000 in fixed-point
rate22khz						EQU		$56EE8BA3			;22254.54545 in fixed-point
rate11khz						EQU		$2B7745D1			;11127.27273 in fixed-point
rate11025hz						EQU		$2B110000			;11025.00000 in fixed-point

															;synthesizer numbers for SndNewChannel
squareWaveSynth					EQU		1					;square wave synthesizer
waveTableSynth					EQU		3					;wave table synthesizer
sampledSynth					EQU		5					;sampled sound synthesizer
															;old Sound Manager MACE synthesizer numbers
MACE3snthID						EQU		11
MACE6snthID						EQU		13

kMiddleC						EQU		60					;MIDI note value for middle C

kNoVolume						EQU		0					;setting for no sound volume
kFullVolume						EQU		$0100				;1.0, setting for full hardware output volume

stdQLength						EQU		128

dataOffsetFlag					EQU		$8000

kUseOptionalOutputDevice		EQU		-1					;only for Sound Manager 3.0 or later

notCompressed					EQU		0					;compression ID's
fixedCompression				EQU		-1					;compression ID for fixed-sized compression
variableCompression				EQU		-2					;compression ID for variable-sized compression

twoToOne						EQU		1
eightToThree					EQU		2
threeToOne						EQU		3
sixToOne						EQU		4
sixToOnePacketSize				EQU		8
threeToOnePacketSize			EQU		16

stateBlockSize					EQU		64
leftOverBlockSize				EQU		32

firstSoundFormat				EQU		$0001				;general sound format
secondSoundFormat				EQU		$0002				;special sampled sound format (HyperCard)

dbBufferReady					EQU		$00000001			;double buffer is filled
dbLastBuffer					EQU		$00000004			;last double buffer to play

sysBeepDisable					EQU		$0000				;SysBeep() enable flags
sysBeepEnable					EQU		$01
sysBeepSynchronous				EQU		$02					;if bit set, make alert sounds synchronous

unitTypeNoSelection				EQU		$FFFF				;unitTypes for AudioSelection.unitType
unitTypeSeconds					EQU		$0000
; PPCAsm thinks “extSH” is a directive and therefore can't be a constant (?)
; But the 68k Asm needs to have these constants, so wrap them inside TARGET_CPU_68K
	IF TARGET_CPU_68K THEN

stdSH							EQU		$00					;Standard sound header encode value
extSH							EQU		$FF					;Extended sound header encode value
cmpSH							EQU		$FE					;Compressed sound header encode value
	ENDIF	; TARGET_CPU_68K
; command numbers for SndDoCommand and SndDoImmediate

nullCmd							EQU		0
initCmd							EQU		1
freeCmd							EQU		2
quietCmd						EQU		3
flushCmd						EQU		4
reInitCmd						EQU		5
waitCmd							EQU		10
pauseCmd						EQU		11
resumeCmd						EQU		12
callBackCmd						EQU		13
syncCmd							EQU		14
availableCmd					EQU		24
versionCmd						EQU		25
totalLoadCmd					EQU		26
loadCmd							EQU		27
freqDurationCmd					EQU		40
restCmd							EQU		41
freqCmd							EQU		42
ampCmd							EQU		43
timbreCmd						EQU		44
getAmpCmd						EQU		45
volumeCmd						EQU		46					;sound manager 3.0 or later only
getVolumeCmd					EQU		47					;sound manager 3.0 or later only
clockComponentCmd				EQU		50					;sound manager 3.2.1 or later only
getClockComponentCmd			EQU		51					;sound manager 3.2.1 or later only
scheduledSoundCmd				EQU		52					;sound manager 3.3 or later only
linkSoundComponentsCmd			EQU		53					;sound manager 3.3 or later only
waveTableCmd					EQU		60
phaseCmd						EQU		61
soundCmd						EQU		80
bufferCmd						EQU		81
rateCmd							EQU		82
continueCmd						EQU		83
doubleBufferCmd					EQU		84
getRateCmd						EQU		85
rateMultiplierCmd				EQU		86
getRateMultiplierCmd			EQU		87
sizeCmd							EQU		90					;obsolete command
convertCmd						EQU		91					;obsolete MACE command
	IF OLDROUTINENAMES THEN
; channel initialization parameters

waveInitChannelMask				EQU		$07
waveInitChannel0				EQU		$04					;wave table only, Sound Manager 2.0 and earlier
waveInitChannel1				EQU		$05					;wave table only, Sound Manager 2.0 and earlier
waveInitChannel2				EQU		$06					;wave table only, Sound Manager 2.0 and earlier
waveInitChannel3				EQU		$07					;wave table only, Sound Manager 2.0 and earlier
initChan0						EQU		$04					;obsolete spelling
initChan1						EQU		$05					;obsolete spelling
initChan2						EQU		$06					;obsolete spelling
initChan3						EQU		$07					;obsolete spelling

outsideCmpSH					EQU		0					;obsolete MACE constant
insideCmpSH						EQU		1					;obsolete MACE constant
aceSuccess						EQU		0					;obsolete MACE constant
aceMemFull						EQU		1					;obsolete MACE constant
aceNilBlock						EQU		2					;obsolete MACE constant
aceBadComp						EQU		3					;obsolete MACE constant
aceBadEncode					EQU		4					;obsolete MACE constant
aceBadDest						EQU		5					;obsolete MACE constant
aceBadCmd						EQU		6					;obsolete MACE constant
	ENDIF	; OLDROUTINENAMES

initChanLeft					EQU		$0002				;left stereo channel
initChanRight					EQU		$0003				;right stereo channel
initNoInterp					EQU		$0004				;no linear interpolation
initNoDrop						EQU		$0008				;no drop-sample conversion
initMono						EQU		$0080				;monophonic channel
initStereo						EQU		$00C0				;stereo channel
initMACE3						EQU		$0300				;MACE 3:1
initMACE6						EQU		$0400				;MACE 6:1
initPanMask						EQU		$0003				;mask for right/left pan values
initSRateMask					EQU		$0030				;mask for sample rate values
initStereoMask					EQU		$00C0				;mask for mono/stereo values
initCompMask					EQU		$FF00				;mask for compression IDs
; Get&Set Sound Information Selectors

siActiveChannels				EQU		'chac'				;active channels
siActiveLevels					EQU		'lmac'				;active meter levels
siAGCOnOff						EQU		'agc '				;automatic gain control state
siAsync							EQU		'asyn'				;asynchronous capability
siAVDisplayBehavior				EQU		'avdb'
siChannelAvailable				EQU		'chav'				;number of channels available
siCompressionAvailable			EQU		'cmav'				;compression types available
siCompressionChannels			EQU		'cpct'				;compressor's number of channels
siCompressionFactor				EQU		'cmfa'				;current compression factor
siCompressionHeader				EQU		'cmhd'				;return compression header
siCompressionNames				EQU		'cnam'				;compression type names available
siCompressionParams				EQU		'evaw'				;compression parameters
siCompressionSampleRate			EQU		'cprt'				;compressor's sample rate
siCompressionType				EQU		'comp'				;current compression type
siContinuous					EQU		'cont'				;continous recording
siDecompressionParams			EQU		'wave'				;decompression parameters
siDeviceBufferInfo				EQU		'dbin'				;size of interrupt buffer
siDeviceConnected				EQU		'dcon'				;input device connection status
siDeviceIcon					EQU		'icon'				;input device icon
siDeviceName					EQU		'name'				;input device name
siHardwareBalance				EQU		'hbal'
siHardwareBalanceSteps			EQU		'hbls'
siHardwareBass					EQU		'hbas'
siHardwareBassSteps				EQU		'hbst'
siHardwareBusy					EQU		'hwbs'				;sound hardware is in use
siHardwareFormat				EQU		'hwfm'				;get hardware format
siHardwareMute					EQU		'hmut'				;mute state of all hardware
siHardwareTreble				EQU		'htrb'
siHardwareTrebleSteps			EQU		'hwts'
siHardwareVolume				EQU		'hvol'				;volume level of all hardware
siHardwareVolumeSteps			EQU		'hstp'				;number of volume steps for hardware
siHeadphoneMute					EQU		'pmut'				;mute state of headphones
siHeadphoneVolume				EQU		'pvol'				;volume level of headphones
siHeadphoneVolumeSteps			EQU		'hdst'				;number of volume steps for headphones
siInputAvailable				EQU		'inav'				;input sources available
siInputGain						EQU		'gain'				;input gain
siInputSource					EQU		'sour'				;input source selector
siInputSourceNames				EQU		'snam'				;input source names
siLevelMeterOnOff				EQU		'lmet'				;level meter state
siModemGain						EQU		'mgai'				;modem input gain
siMonitorAvailable				EQU		'mnav'
siMonitorSource					EQU		'mons'
siNumberChannels				EQU		'chan'				;current number of channels
siOptionsDialog					EQU		'optd'				;display options dialog
siOSTypeInputSource				EQU		'inpt'				;input source by OSType
siOSTypeInputAvailable			EQU		'inav'				;list of available input source OSTypes
siPlayThruOnOff					EQU		'plth'				;playthrough state
siPostMixerSoundComponent		EQU		'psmx'				;install post-mixer effect
siPreMixerSoundComponent		EQU		'prmx'				;install pre-mixer effect
siQuality						EQU		'qual'				;quality setting
siRateMultiplier				EQU		'rmul'				;throttle rate setting
siRecordingQuality				EQU		'qual'				;recording quality
siSampleRate					EQU		'srat'				;current sample rate
siSampleRateAvailable			EQU		'srav'				;sample rates available
siSampleSize					EQU		'ssiz'				;current sample size
siSampleSizeAvailable			EQU		'ssav'				;sample sizes available
siSetupCDAudio					EQU		'sucd'				;setup sound hardware for CD audio
siSetupModemAudio				EQU		'sumd'				;setup sound hardware for modem audio
siSlopeAndIntercept				EQU		'flap'				;floating point variables for conversion
siSoundClock					EQU		'sclk'
siUseThisSoundClock				EQU		'sclc'				;sdev uses this to tell the mixer to use his sound clock
siSpeakerMute					EQU		'smut'				;mute state of all built-in speaker
siSpeakerVolume					EQU		'svol'				;volume level of built-in speaker
siSSpCPULoadLimit				EQU		'3dll'
siSSpLocalization				EQU		'3dif'
siSSpSpeakerSetup				EQU		'3dst'
siStereoInputGain				EQU		'sgai'				;stereo input gain
siSubwooferMute					EQU		'bmut'				;mute state of sub-woofer
siTwosComplementOnOff			EQU		'twos'				;two's complement state
siVolume						EQU		'volu'				;volume level of source
siVoxRecordInfo					EQU		'voxr'				;VOX record parameters
siVoxStopInfo					EQU		'voxs'				;VOX stop parameters
siWideStereo					EQU		'wide'				;wide stereo setting

siCloseDriver					EQU		'clos'				;reserved for internal use only
siInitializeDriver				EQU		'init'				;reserved for internal use only
siPauseRecording				EQU		'paus'				;reserved for internal use only
siUserInterruptProc				EQU		'user'				;reserved for internal use only
;  input source Types

kInvalidSource					EQU		$FFFFFFFF			;this source may be returned from GetInfo if no other source is the monitored source
kNoSource						EQU		'none'				;no source selection
kCDSource						EQU		'cd  '				;internal CD player input
kExtMicSource					EQU		'emic'				;external mic input
kSoundInSource					EQU		'sinj'				;sound input jack
kRCAInSource					EQU		'irca'				;RCA jack input
kTVFMTunerSource				EQU		'tvfm'
kDAVInSource					EQU		'idav'				;DAV analog input
kIntMicSource					EQU		'imic'				;internal mic input
kMediaBaySource					EQU		'mbay'				;media bay input
kModemSource					EQU		'modm'				;modem input (internal modem on desktops, PCI input on PowerBooks)
kPCCardSource					EQU		'pcm '				;PC Card pwm input
kZoomVideoSource				EQU		'zvpc'				;zoom video input
kDVDSource						EQU		'dvda'				;DVD audio input
; Sound Component Types and Subtypes

kNoSoundComponentType			EQU		'****'
kSoundComponentType				EQU		'sift'				;component type
kSoundComponentPPCType			EQU		'nift'				;component type for PowerPC code
kRate8SubType					EQU		'ratb'				;8-bit rate converter
kRate16SubType					EQU		'ratw'				;16-bit rate converter
kConverterSubType				EQU		'conv'				;sample format converter
kSndSourceSubType				EQU		'sour'				;generic source component
kMixerType						EQU		'mixr'
kMixer8SubType					EQU		'mixb'				;8-bit mixer
kMixer16SubType					EQU		'mixw'				;16-bit mixer
kSoundInputDeviceType			EQU		'sinp'				;sound input component
kWaveInSubType					EQU		'wavi'				;Windows Wave
kSoundOutputDeviceType			EQU		'sdev'				;sound output component
kClassicSubType					EQU		'clas'				;classic hardware, i.e. Mac Plus
kASCSubType						EQU		'asc '				;Apple Sound Chip device
kDSPSubType						EQU		'dsp '				;DSP device
kAwacsSubType					EQU		'awac'				;Another of Will's Audio Chips device
kGCAwacsSubType					EQU		'awgc'				;Awacs audio with Grand Central DMA
kSingerSubType					EQU		'sing'				;Singer (via Whitney) based sound
kSinger2SubType					EQU		'sng2'				;Singer 2 (via Whitney) for Acme
kWhitSubType					EQU		'whit'				;Whit sound component for PrimeTime 3
kSoundBlasterSubType			EQU		'sbls'				;Sound Blaster for CHRP
kWaveOutSubType					EQU		'wavo'				;Windows Wave
kDirectSoundSubType				EQU		'dsnd'				;Direct Sound
kUNIXsdevSubType				EQU		'un1x'				;UNIX base sdev
kSoundCompressor				EQU		'scom'
kSoundDecompressor				EQU		'sdec'
kAudioComponentType				EQU		'adio'				;Audio components and sub-types
kAwacsPhoneSubType				EQU		'hphn'
kAudioVisionSpeakerSubType		EQU		'telc'
kAudioVisionHeadphoneSubType	EQU		'telh'
kPhilipsFaderSubType			EQU		'tvav'
kSGSToneSubType					EQU		'sgs0'
kSoundEffectsType				EQU		'snfx'				;sound effects type
kSSpLocalizationSubType			EQU		'snd3'
; Format Types

kSoundNotCompressed				EQU		'NONE'				;sound is not compressed
k8BitOffsetBinaryFormat			EQU		'raw '				;8-bit offset binary
k16BitBigEndianFormat			EQU		'twos'				;16-bit big endian
k16BitLittleEndianFormat		EQU		'sowt'				;16-bit little endian
kFloat32Format					EQU		'fl32'				;32-bit floating point
kFloat64Format					EQU		'fl64'				;64-bit floating point
k24BitFormat					EQU		'in24'				;24-bit integer
k32BitFormat					EQU		'in32'				;32-bit integer
kMACE3Compression				EQU		'MAC3'				;MACE 3:1
kMACE6Compression				EQU		'MAC6'				;MACE 6:1
kCDXA4Compression				EQU		'cdx4'				;CD/XA 4:1
kCDXA2Compression				EQU		'cdx2'				;CD/XA 2:1
kIMACompression					EQU		'ima4'				;IMA 4:1
kULawCompression				EQU		'ulaw'				;µLaw 2:1
kALawCompression				EQU		'alaw'				;aLaw 2:1
kMicrosoftADPCMFormat			EQU		$6D730002			;Microsoft ADPCM - ACM code 2
kDVIIntelIMAFormat				EQU		$6D730011			;DVI/Intel IMA ADPCM - ACM code 17
kDVAudioFormat					EQU		'dvca'				;DV Audio
kQDesignCompression				EQU		'QDMC'				;QDesign music
kQUALCOMMCompression			EQU		'Qclp'				;QUALCOMM PureVoice
kOffsetBinary					EQU		'raw '				;for compatibility
kTwosComplement					EQU		'twos'				;for compatibility
kLittleEndianFormat				EQU		'sowt'				;for compatibility
	IF TARGET_RT_LITTLE_ENDIAN THEN

k16BitNativeEndianFormat		EQU		'sowt'
k16BitNonNativeEndianFormat		EQU		'twos'
	ELSE

k16BitNativeEndianFormat		EQU		'twos'
k16BitNonNativeEndianFormat		EQU		'sowt'
	ENDIF	; TARGET_RT_LITTLE_ENDIAN
; Features Flags

k8BitRawIn						EQU		$01					;data description
k8BitTwosIn						EQU		$02
k16BitIn						EQU		$04
kStereoIn						EQU		$08
k8BitRawOut						EQU		$0100
k8BitTwosOut					EQU		$0200
k16BitOut						EQU		$0400
kStereoOut						EQU		$0800
kReverse						EQU		$00010000			;  function description
kRateConvert					EQU		$00020000
kCreateSoundSource				EQU		$00040000
kHighQuality					EQU		$00400000			;  performance description
kNonRealTime					EQU		$00800000
; SoundComponentPlaySourceBuffer action flags

kSourcePaused					EQU		$01
kPassThrough					EQU		$00010000
kNoSoundComponentChain			EQU		$00020000
; SoundParamBlock flags, usefull for OpenMixerSoundComponent

kNoMixing						EQU		$01					;don't mix source
kNoSampleRateConversion			EQU		$02					;don't convert sample rate (i.e. 11 kHz -> 22 kHz)
kNoSampleSizeConversion			EQU		$04					;don't convert sample size (i.e. 16 -> 8)
kNoSampleFormatConversion		EQU		$08					;don't convert sample format (i.e. 'twos' -> 'raw ')
kNoChannelConversion			EQU		$10					;don't convert stereo/mono
kNoDecompression				EQU		$20					;don't decompress (i.e. 'MAC3' -> 'raw ')
kNoVolumeConversion				EQU		$40					;don't apply volume
kNoRealtimeProcessing			EQU		$80					;won't run at interrupt time
kScheduledSource				EQU		$0100				;source is scheduled
; SoundParamBlock quality settings

kBestQuality					EQU		$01					;use interpolation in rate conversion
; useful bit masks

kInputMask						EQU		$000000FF			;masks off input bits
kOutputMask						EQU		$0000FF00			;masks off output bits
kOutputShift					EQU		8					;amount output bits are shifted
kActionMask						EQU		$00FF0000			;masks off action bits
kSoundComponentBits				EQU		$00FFFFFF
; audio atom types

kAudioFormatAtomType			EQU		'frma'
kAudioEndianAtomType			EQU		'enda'
kAudioTerminatorAtomType		EQU		0
; siAVDisplayBehavior types

kAVDisplayHeadphoneRemove		EQU		0					; monitor does not have a headphone attached
kAVDisplayHeadphoneInsert		EQU		1					; monitor has a headphone attached
kAVDisplayPlainTalkRemove		EQU		2					; monitor either sending no input through CPU input port or unable to tell if input is coming in
kAVDisplayPlainTalkInsert		EQU		3					; monitor sending PlainTalk level microphone source input through sound input port
; Audio Component constants

															;Values for whichChannel parameter
audioAllChannels				EQU		0					;All channels (usually interpreted as both left and right)
audioLeftChannel				EQU		1					;Left channel
audioRightChannel				EQU		2					;Right channel
															;Values for mute parameter
audioUnmuted					EQU		0					;Device is unmuted
audioMuted						EQU		1					;Device is muted
															;Capabilities flags definitions
audioDoesMono					EQU		$00000001			;Device supports mono output
audioDoesStereo					EQU		$00000002			;Device supports stereo output
audioDoesIndependentChannels	EQU		$00000004			;Device supports independent software control of each channel
; Sound Input Qualities

siCDQuality						EQU		'cd  '				;44.1kHz, stereo, 16 bit
siBestQuality					EQU		'best'				;22kHz, mono, 8 bit
siBetterQuality					EQU		'betr'				;22kHz, mono, MACE 3:1
siGoodQuality					EQU		'good'				;22kHz, mono, MACE 6:1
siNoneQuality					EQU		'none'				;settings don't match any quality for a get call

siDeviceIsConnected				EQU		1					;input device is connected and ready for input
siDeviceNotConnected			EQU		0					;input device is not connected
siDontKnowIfConnected			EQU		-1					;can't tell if input device is connected
siReadPermission				EQU		0					;permission passed to SPBOpenDevice
siWritePermission				EQU		1					;permission passed to SPBOpenDevice

;  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;   typedefs
;  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



SndCommand				RECORD 0
cmd						 ds.w	1				; offset: $0 (0)
param1					 ds.w	1				; offset: $2 (2)
param2					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR


; typedef SndChannel *					SndChannelPtr

SndChannel				RECORD 0
nextChan				 ds.l	1				; offset: $0 (0)
firstMod				 ds.l	1				; offset: $4 (4)		;  reserved for the Sound Manager 
callBack				 ds.l	1				; offset: $8 (8)
userInfo				 ds.l	1				; offset: $C (12)
wait					 ds.l	1				; offset: $10 (16)		;  The following is for internal Sound Manager use only.
cmdInProgress			 ds		SndCommand		; offset: $14 (20)
flags					 ds.w	1				; offset: $1C (28)
qLength					 ds.w	1				; offset: $1E (30)
qHead					 ds.w	1				; offset: $20 (32)
qTail					 ds.w	1				; offset: $22 (34)
queue					 ds.b	128 * SndCommand.sizeof ; offset: $24 (36)
sizeof					 EQU *					; size:   $424 (1060)
						ENDR
; MACE structures
StateBlock				RECORD 0
stateVar				 ds.w	64				; offset: $0 (0)
sizeof					 EQU *					; size:   $80 (128)
						ENDR
; typedef struct StateBlock *			StateBlockPtr

LeftOverBlock			RECORD 0
count					 ds.l	1				; offset: $0 (0)
sampleArea				 ds.b	32				; offset: $4 (4)
sizeof					 EQU *					; size:   $24 (36)
						ENDR
; typedef struct LeftOverBlock *		LeftOverBlockPtr

ModRef					RECORD 0
modNumber				 ds.w	1				; offset: $0 (0)
modInit					 ds.l	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
SndListResource			RECORD 0
format					 ds.w	1				; offset: $0 (0)
numModifiers			 ds.w	1				; offset: $2 (2)
modifierPart			 ds		ModRef			; offset: $4 (4) <-- really an array of length one
numCommands				 ds.w	1				; offset: $A (10)
commandPart				 ds		SndCommand		; offset: $C (12) <-- really an array of length one
dataPart				 ds.b	1				; offset: $14 (20) <-- really an array of length one
						 ORG 22
sizeof					 EQU *					; size:   $16 (22)
						ENDR
; typedef struct SndListResource *		SndListPtr

; typedef SndListPtr *					SndListHandle

; typedef SndListHandle 				SndListHndl

; HyperCard sound resource format
Snd2ListResource		RECORD 0
format					 ds.w	1				; offset: $0 (0)
refCount				 ds.w	1				; offset: $2 (2)
numCommands				 ds.w	1				; offset: $4 (4)
commandPart				 ds		SndCommand		; offset: $6 (6) <-- really an array of length one
dataPart				 ds.b	1				; offset: $E (14) <-- really an array of length one
						 ORG 16
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct Snd2ListResource *		Snd2ListPtr

; typedef Snd2ListPtr *					Snd2ListHandle

; typedef Snd2ListHandle 				Snd2ListHndl

SoundHeader				RECORD 0
samplePtr				 ds.l	1				; offset: $0 (0)		; if NIL then samples are in sampleArea
length					 ds.l	1				; offset: $4 (4)		; length of sound in bytes
sampleRate				 ds.l	1				; offset: $8 (8)		; sample rate for this sound
loopStart				 ds.l	1				; offset: $C (12)		; start of looping portion
loopEnd					 ds.l	1				; offset: $10 (16)		; end of looping portion
encode					 ds.b	1				; offset: $14 (20)		; header encoding
baseFrequency			 ds.b	1				; offset: $15 (21)		; baseFrequency value
sampleArea				 ds.b	1				; offset: $16 (22) <-- really an array of length one ; space for when samples follow directly
						 ORG 24
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct SoundHeader *			SoundHeaderPtr

CmpSoundHeader			RECORD 0
samplePtr				 ds.l	1				; offset: $0 (0)		; if nil then samples are in sample area
numChannels				 ds.l	1				; offset: $4 (4)		; number of channels i.e. mono = 1
sampleRate				 ds.l	1				; offset: $8 (8)		; sample rate in Apples Fixed point representation
loopStart				 ds.l	1				; offset: $C (12)		; loopStart of sound before compression
loopEnd					 ds.l	1				; offset: $10 (16)		; loopEnd of sound before compression
encode					 ds.b	1				; offset: $14 (20)		; data structure used , stdSH, extSH, or cmpSH
baseFrequency			 ds.b	1				; offset: $15 (21)		; same meaning as regular SoundHeader
numFrames				 ds.l	1				; offset: $16 (22)		; length in frames ( packetFrames or sampleFrames )
AIFFSampleRate			 ds		extended80		; offset: $1A (26)		; IEEE sample rate
markerChunk				 ds.l	1				; offset: $24 (36)		; sync track
format					 ds.l	1				; offset: $28 (40)		; data format type, was futureUse1
futureUse2				 ds.l	1				; offset: $2C (44)		; reserved by Apple
stateVars				 ds.l	1				; offset: $30 (48)		; pointer to State Block
leftOverSamples			 ds.l	1				; offset: $34 (52)		; used to save truncated samples between compression calls
compressionID			 ds.w	1				; offset: $38 (56)		; 0 means no compression, non zero means compressionID
packetSize				 ds.w	1				; offset: $3A (58)		; number of bits in compressed sample packet
snthID					 ds.w	1				; offset: $3C (60)		; resource ID of Sound Manager snth that contains NRT C/E
sampleSize				 ds.w	1				; offset: $3E (62)		; number of bits in non-compressed sample
sampleArea				 ds.b	1				; offset: $40 (64) <-- really an array of length one ; space for when samples follow directly
						 ORG 66
sizeof					 EQU *					; size:   $42 (66)
						ENDR
; typedef struct CmpSoundHeader *		CmpSoundHeaderPtr

ExtSoundHeader			RECORD 0
samplePtr				 ds.l	1				; offset: $0 (0)		; if nil then samples are in sample area
numChannels				 ds.l	1				; offset: $4 (4)		; number of channels,  ie mono = 1
sampleRate				 ds.l	1				; offset: $8 (8)		; sample rate in Apples Fixed point representation
loopStart				 ds.l	1				; offset: $C (12)		; same meaning as regular SoundHeader
loopEnd					 ds.l	1				; offset: $10 (16)		; same meaning as regular SoundHeader
encode					 ds.b	1				; offset: $14 (20)		; data structure used , stdSH, extSH, or cmpSH
baseFrequency			 ds.b	1				; offset: $15 (21)		; same meaning as regular SoundHeader
numFrames				 ds.l	1				; offset: $16 (22)		; length in total number of frames
AIFFSampleRate			 ds		extended80		; offset: $1A (26)		; IEEE sample rate
markerChunk				 ds.l	1				; offset: $24 (36)		; sync track
instrumentChunks		 ds.l	1				; offset: $28 (40)		; AIFF instrument chunks
AESRecording			 ds.l	1				; offset: $2C (44)
sampleSize				 ds.w	1				; offset: $30 (48)		; number of bits in sample
futureUse1				 ds.w	1				; offset: $32 (50)		; reserved by Apple
futureUse2				 ds.l	1				; offset: $34 (52)		; reserved by Apple
futureUse3				 ds.l	1				; offset: $38 (56)		; reserved by Apple
futureUse4				 ds.l	1				; offset: $3C (60)		; reserved by Apple
sampleArea				 ds.b	1				; offset: $40 (64) <-- really an array of length one ; space for when samples follow directly
						 ORG 66
sizeof					 EQU *					; size:   $42 (66)
						ENDR
; typedef struct ExtSoundHeader *		ExtSoundHeaderPtr

SoundHeaderUnion		RECORD 0
stdHeader				 ds		SoundHeader		; offset: $0 (0)
						 ORG 0
cmpHeader				 ds		CmpSoundHeader ; offset: $0 (0)
						 ORG 0
extHeader				 ds		ExtSoundHeader ; offset: $0 (0)
sizeof					 EQU *					; size:   $42 (66)
						ENDR
ConversionBlock			RECORD 0
destination				 ds.w	1				; offset: $0 (0)
unused					 ds.w	1				; offset: $2 (2)
inputPtr				 ds.l	1				; offset: $4 (4)
outputPtr				 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct ConversionBlock *		ConversionBlockPtr

;  ScheduledSoundHeader flags

kScheduledSoundDoScheduled		EQU		$01
kScheduledSoundDoCallBack		EQU		$02
ScheduledSoundHeader	RECORD 0
u						 ds		SoundHeaderUnion ; offset: $0 (0)
flags					 ds.l	1				; offset: $42 (66)
reserved				 ds.w	1				; offset: $46 (70)
callBackParam1			 ds.w	1				; offset: $48 (72)
callBackParam2			 ds.l	1				; offset: $4A (74)
startTime				 ds		TimeRecord		; offset: $4E (78)
sizeof					 EQU *					; size:   $5E (94)
						ENDR
; typedef struct ScheduledSoundHeader *	ScheduledSoundHeaderPtr

SMStatus				RECORD 0
smMaxCPULoad			 ds.w	1				; offset: $0 (0)
smNumChannels			 ds.w	1				; offset: $2 (2)
smCurCPULoad			 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct SMStatus *				SMStatusPtr

SCStatus				RECORD 0
scStartTime				 ds.l	1				; offset: $0 (0)
scEndTime				 ds.l	1				; offset: $4 (4)
scCurrentTime			 ds.l	1				; offset: $8 (8)
scChannelBusy			 ds.b	1				; offset: $C (12)
scChannelDisposed		 ds.b	1				; offset: $D (13)
scChannelPaused			 ds.b	1				; offset: $E (14)
scUnused				 ds.b	1				; offset: $F (15)
scChannelAttributes		 ds.l	1				; offset: $10 (16)
scCPULoad				 ds.l	1				; offset: $14 (20)
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct SCStatus *				SCStatusPtr

AudioSelection			RECORD 0
unitType				 ds.l	1				; offset: $0 (0)
selStart				 ds.l	1				; offset: $4 (4)
selEnd					 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct AudioSelection *		AudioSelectionPtr

SndDoubleBuffer			RECORD 0
dbNumFrames				 ds.l	1				; offset: $0 (0)
dbFlags					 ds.l	1				; offset: $4 (4)
dbUserInfo				 ds.l	2				; offset: $8 (8)
dbSoundData				 ds.b	1				; offset: $10 (16) <-- really an array of length one
						 ORG 18
sizeof					 EQU *					; size:   $12 (18)
						ENDR
; typedef struct SndDoubleBuffer *		SndDoubleBufferPtr

SndDoubleBufferHeader	RECORD 0
dbhNumChannels			 ds.w	1				; offset: $0 (0)
dbhSampleSize			 ds.w	1				; offset: $2 (2)
dbhCompressionID		 ds.w	1				; offset: $4 (4)
dbhPacketSize			 ds.w	1				; offset: $6 (6)
dbhSampleRate			 ds.l	1				; offset: $8 (8)
dbhBufferPtr			 ds.l	2				; offset: $C (12)
dbhDoubleBack			 ds.l	1				; offset: $14 (20)
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct SndDoubleBufferHeader * SndDoubleBufferHeaderPtr

SndDoubleBufferHeader2	RECORD 0
dbhNumChannels			 ds.w	1				; offset: $0 (0)
dbhSampleSize			 ds.w	1				; offset: $2 (2)
dbhCompressionID		 ds.w	1				; offset: $4 (4)
dbhPacketSize			 ds.w	1				; offset: $6 (6)
dbhSampleRate			 ds.l	1				; offset: $8 (8)
dbhBufferPtr			 ds.l	2				; offset: $C (12)
dbhDoubleBack			 ds.l	1				; offset: $14 (20)
dbhFormat				 ds.l	1				; offset: $18 (24)
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct SndDoubleBufferHeader2 * SndDoubleBufferHeader2Ptr

SoundInfoList			RECORD 0
count					 ds.w	1				; offset: $0 (0)
infoHandle				 ds.l	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct SoundInfoList *		SoundInfoListPtr

SoundComponentData		RECORD 0
flags					 ds.l	1				; offset: $0 (0)
format					 ds.l	1				; offset: $4 (4)
numChannels				 ds.w	1				; offset: $8 (8)
sampleSize				 ds.w	1				; offset: $A (10)
sampleRate				 ds.l	1				; offset: $C (12)
sampleCount				 ds.l	1				; offset: $10 (16)
buffer					 ds.l	1				; offset: $14 (20)
reserved				 ds.l	1				; offset: $18 (24)
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct SoundComponentData *	SoundComponentDataPtr



; typedef SoundParamBlock *				SoundParamBlockPtr

SoundParamBlock			RECORD 0
recordSize				 ds.l	1				; offset: $0 (0)		; size of this record in bytes
desc					 ds		SoundComponentData ; offset: $4 (4)		; description of sound buffer
rateMultiplier			 ds.l	1				; offset: $20 (32)		; rate multiplier to apply to sound
leftVolume				 ds.w	1				; offset: $24 (36)		; volumes to apply to sound
rightVolume				 ds.w	1				; offset: $26 (38)
quality					 ds.l	1				; offset: $28 (40)		; quality to apply to sound
filter					 ds.l	1				; offset: $2C (44)		; filter to apply to sound
moreRtn					 ds.l	1				; offset: $30 (48)		; routine to call to get more data
completionRtn			 ds.l	1				; offset: $34 (52)		; routine to call when buffer is complete
refCon					 ds.l	1				; offset: $38 (56)		; user refcon
result					 ds.w	1				; offset: $3C (60)		; result
sizeof					 EQU *					; size:   $3E (62)
						ENDR
CompressionInfo			RECORD 0
recordSize				 ds.l	1				; offset: $0 (0)
format					 ds.l	1				; offset: $4 (4)
compressionID			 ds.w	1				; offset: $8 (8)
samplesPerPacket		 ds.w	1				; offset: $A (10)
bytesPerPacket			 ds.w	1				; offset: $C (12)
bytesPerFrame			 ds.w	1				; offset: $E (14)
bytesPerSample			 ds.w	1				; offset: $10 (16)
futureUse1				 ds.w	1				; offset: $12 (18)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct CompressionInfo *		CompressionInfoPtr

; typedef CompressionInfoPtr *			CompressionInfoHandle

; variables for floating point conversion
SoundSlopeAndInterceptRecord RECORD 0
slope					 ds		Float64			; offset: $0 (0)
intercept				 ds		Float64			; offset: $8 (8)
minClip					 ds		Float64			; offset: $10 (16)
maxClip					 ds		Float64			; offset: $18 (24)
sizeof					 EQU *					; size:   $20 (32)
						ENDR
; typedef struct SoundSlopeAndInterceptRecord * SoundSlopeAndInterceptPtr

; private thing to use as a reference to a Sound Converter


; private thing to use as a reference to a Sound Source


; typedef SoundSource *					SoundSourcePtr

SoundComponentLink		RECORD 0
description				 ds		ComponentDescription ; offset: $0 (0)	; Describes the sound component
mixerID					 ds.l	1				; offset: $14 (20)		; Reserved by Apple
linkID					 ds.l	1				; offset: $18 (24)		; Reserved by Apple
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct SoundComponentLink *	SoundComponentLinkPtr

AudioInfo				RECORD 0
capabilitiesFlags		 ds.l	1				; offset: $0 (0)		; Describes device capabilities
reserved				 ds.l	1				; offset: $4 (4)		; Reserved by Apple
numVolumeSteps			 ds.w	1				; offset: $8 (8)		; Number of significant increments between min and max volume
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct AudioInfo *			AudioInfoPtr

AudioFormatAtom			RECORD 0
size					 ds.l	1				; offset: $0 (0)		;  = sizeof(AudioFormatAtom)
atomType				 ds.l	1				; offset: $4 (4)		;  = kAudioFormatAtomType
format					 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct AudioFormatAtom *		AudioFormatAtomPtr

AudioEndianAtom			RECORD 0
size					 ds.l	1				; offset: $0 (0)		;  = sizeof(AudioEndianAtom)
atomType				 ds.l	1				; offset: $4 (4)		;  = kAudioEndianAtomType
littleEndian			 ds.w	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct AudioEndianAtom *		AudioEndianAtomPtr

AudioTerminatorAtom		RECORD 0
size					 ds.l	1				; offset: $0 (0)		;  = sizeof(AudioTerminatorAtom)
atomType				 ds.l	1				; offset: $4 (4)		;  = kAudioTerminatorAtomType
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct AudioTerminatorAtom *	AudioTerminatorAtomPtr

;  Sound Input Structures


; typedef SPB *							SPBPtr

; user procedures called by sound input routines
; Sound Input Parameter Block
SPB						RECORD 0
inRefNum				 ds.l	1				; offset: $0 (0)		; reference number of sound input device
count					 ds.l	1				; offset: $4 (4)		; number of bytes to record
milliseconds			 ds.l	1				; offset: $8 (8)		; number of milliseconds to record
bufferLength			 ds.l	1				; offset: $C (12)		; length of buffer in bytes
bufferPtr				 ds.l	1				; offset: $10 (16)		; buffer to store sound data in
completionRoutine		 ds.l	1				; offset: $14 (20)		; completion routine
interruptRoutine		 ds.l	1				; offset: $18 (24)		; interrupt routine
userLong				 ds.l	1				; offset: $1C (28)		; user-defined field
error					 ds.w	1				; offset: $20 (32)		; error
unused1					 ds.l	1				; offset: $22 (34)		; reserved - must be zero
sizeof					 EQU *					; size:   $26 (38)
						ENDR

;  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;   prototypes
;  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




;   These two routines for Get/SetSoundVol should no longer be used.
;   They were for old Apple Sound Chip machines, and do not support the DSP or PowerMacs.
;   Use Get/SetDefaultOutputVolume instead, if you must change the user's machine.



	IF TARGET_CPU_68K THEN
;
; pascal void SetSoundVol(short level)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSoundVol
	ENDIF


;
; pascal void GetSoundVol(short *level)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	level           => A0
		Macro
		_GetSoundVol
			clr.b               (A0)+
			move.b              $0260,(A0)
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSoundVol
	ENDIF

	ENDIF	; TARGET_CPU_68K
;  Sound Manager routines 
;
; pascal void SysBeep(short duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SysBeep:	OPWORD	$A9C8
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SysBeep
	ENDIF

;
; pascal OSErr SndDoCommand(SndChannelPtr chan, const SndCommand *cmd, Boolean noWait)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SndDoCommand:	OPWORD	$A803
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndDoCommand
	ENDIF

;
; pascal OSErr SndDoImmediate(SndChannelPtr chan, const SndCommand *cmd)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SndDoImmediate:	OPWORD	$A804
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndDoImmediate
	ENDIF

;
; pascal OSErr SndNewChannel(SndChannelPtr *chan, short synth, long init, SndCallBackUPP userRoutine)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SndNewChannel:	OPWORD	$A807
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndNewChannel
	ENDIF

;
; pascal OSErr SndDisposeChannel(SndChannelPtr chan, Boolean quietNow)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SndDisposeChannel:	OPWORD	$A801
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndDisposeChannel
	ENDIF

;
; pascal OSErr SndPlay(SndChannelPtr chan, SndListHandle sndHandle, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SndPlay:	OPWORD	$A805
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndPlay
	ENDIF

	IF OLDROUTINENAMES THEN
;
; pascal OSErr SndAddModifier(SndChannelPtr chan, Ptr modifier, short id, long init)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SndAddModifier:	OPWORD	$A802
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndAddModifier
	ENDIF

	ENDIF	; OLDROUTINENAMES
;
; pascal OSErr SndControl(short id, SndCommand *cmd)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_SndControl:	OPWORD	$A806
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndControl
	ENDIF

;  Sound Manager 2.0 and later, uses _SoundDispatch 
;
; pascal NumVersion SndSoundManagerVersion(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndSoundManagerVersion
			move.l              #$000C0008,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndSoundManagerVersion
	ENDIF

;
; pascal OSErr SndStartFilePlay(SndChannelPtr chan, short fRefNum, short resNum, long bufferSize, void *theBuffer, AudioSelectionPtr theSelection, FilePlayCompletionUPP theCompletion, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndStartFilePlay
			move.l              #$0D000008,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndStartFilePlay
	ENDIF

;
; pascal OSErr SndPauseFilePlay(SndChannelPtr chan)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndPauseFilePlay
			move.l              #$02040008,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndPauseFilePlay
	ENDIF

;
; pascal OSErr SndStopFilePlay(SndChannelPtr chan, Boolean quietNow)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndStopFilePlay
			move.l              #$03080008,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndStopFilePlay
	ENDIF

;
; pascal OSErr SndChannelStatus(SndChannelPtr chan, short theLength, SCStatusPtr theStatus)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndChannelStatus
			move.l              #$05100008,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndChannelStatus
	ENDIF

;
; pascal OSErr SndManagerStatus(short theLength, SMStatusPtr theStatus)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndManagerStatus
			move.l              #$03140008,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndManagerStatus
	ENDIF

;
; pascal void SndGetSysBeepState(short *sysBeepState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndGetSysBeepState
			move.l              #$02180008,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndGetSysBeepState
	ENDIF

;
; pascal OSErr SndSetSysBeepState(short sysBeepState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndSetSysBeepState
			move.l              #$011C0008,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndSetSysBeepState
	ENDIF

;
; pascal OSErr SndPlayDoubleBuffer(SndChannelPtr chan, SndDoubleBufferHeaderPtr theParams)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndPlayDoubleBuffer
			move.l              #$04200008,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndPlayDoubleBuffer
	ENDIF

;  MACE compression routines, uses _SoundDispatch 
;
; pascal NumVersion MACEVersion(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MACEVersion
			move.l              #$00000010,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MACEVersion
	ENDIF

;
; pascal void Comp3to1(const void *inBuffer, void *outBuffer, unsigned long cnt, StateBlockPtr inState, StateBlockPtr outState, unsigned long numChannels, unsigned long whichChannel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Comp3to1
			move.l              #$00040010,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Comp3to1
	ENDIF

;
; pascal void Exp1to3(const void *inBuffer, void *outBuffer, unsigned long cnt, StateBlockPtr inState, StateBlockPtr outState, unsigned long numChannels, unsigned long whichChannel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Exp1to3
			move.l              #$00080010,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Exp1to3
	ENDIF

;
; pascal void Comp6to1(const void *inBuffer, void *outBuffer, unsigned long cnt, StateBlockPtr inState, StateBlockPtr outState, unsigned long numChannels, unsigned long whichChannel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Comp6to1
			move.l              #$000C0010,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Comp6to1
	ENDIF

;
; pascal void Exp1to6(const void *inBuffer, void *outBuffer, unsigned long cnt, StateBlockPtr inState, StateBlockPtr outState, unsigned long numChannels, unsigned long whichChannel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Exp1to6
			move.l              #$00100010,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Exp1to6
	ENDIF

;  Sound Manager 3.0 and later calls, uses _SoundDispatch 
;
; pascal OSErr GetSysBeepVolume(long *level)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetSysBeepVolume
			move.l              #$02240018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSysBeepVolume
	ENDIF

;
; pascal OSErr SetSysBeepVolume(long level)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetSysBeepVolume
			move.l              #$02280018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSysBeepVolume
	ENDIF

;
; pascal OSErr GetDefaultOutputVolume(long *level)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetDefaultOutputVolume
			move.l              #$022C0018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetDefaultOutputVolume
	ENDIF

;
; pascal OSErr SetDefaultOutputVolume(long level)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetDefaultOutputVolume
			move.l              #$02300018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetDefaultOutputVolume
	ENDIF

;
; pascal OSErr GetSoundHeaderOffset(SndListHandle sndHandle, long *offset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetSoundHeaderOffset
			move.l              #$04040018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSoundHeaderOffset
	ENDIF

;
; pascal UnsignedFixed UnsignedFixedMulDiv(UnsignedFixed value, UnsignedFixed multiplier, UnsignedFixed divisor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UnsignedFixedMulDiv
			move.l              #$060C0018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UnsignedFixedMulDiv
	ENDIF

;
; pascal OSErr GetCompressionInfo(short compressionID, OSType format, short numChannels, short sampleSize, CompressionInfoPtr cp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetCompressionInfo
			move.l              #$07100018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCompressionInfo
	ENDIF

;
; pascal OSErr SetSoundPreference(OSType theType, Str255 name, Handle settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetSoundPreference
			move.l              #$06340018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSoundPreference
	ENDIF

;
; pascal OSErr GetSoundPreference(OSType theType, Str255 name, Handle settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetSoundPreference
			move.l              #$06380018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSoundPreference
	ENDIF

;
; pascal OSErr OpenMixerSoundComponent(SoundComponentDataPtr outputDescription, long outputFlags, ComponentInstance *mixerComponent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OpenMixerSoundComponent
			move.l              #$06140018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenMixerSoundComponent
	ENDIF

;
; pascal OSErr CloseMixerSoundComponent(ComponentInstance ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CloseMixerSoundComponent
			move.l              #$02180018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CloseMixerSoundComponent
	ENDIF

;  Sound Manager 3.1 and later calls, uses _SoundDispatch 
;
; pascal OSErr SndGetInfo(SndChannelPtr chan, OSType selector, void *infoPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndGetInfo
			move.l              #$063C0018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndGetInfo
	ENDIF

;
; pascal OSErr SndSetInfo(SndChannelPtr chan, OSType selector, const void *infoPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndSetInfo
			move.l              #$06400018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndSetInfo
	ENDIF

;
; pascal OSErr GetSoundOutputInfo(Component outputDevice, OSType selector, void *infoPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetSoundOutputInfo
			move.l              #$06440018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSoundOutputInfo
	ENDIF

;
; pascal OSErr SetSoundOutputInfo(Component outputDevice, OSType selector, const void *infoPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetSoundOutputInfo
			move.l              #$06480018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSoundOutputInfo
	ENDIF

;  Sound Manager 3.2 and later calls, uses _SoundDispatch 
;
; pascal OSErr GetCompressionName(OSType compressionType, Str255 compressionName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetCompressionName
			move.l              #$044C0018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCompressionName
	ENDIF

;
; pascal OSErr SoundConverterOpen(const SoundComponentData *inputFormat, const SoundComponentData *outputFormat, SoundConverter *sc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundConverterOpen
			move.l              #$06500018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundConverterOpen
	ENDIF

;
; pascal OSErr SoundConverterClose(SoundConverter sc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundConverterClose
			move.l              #$02540018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundConverterClose
	ENDIF

;
; pascal OSErr SoundConverterGetBufferSizes(SoundConverter sc, unsigned long inputBytesTarget, unsigned long *inputFrames, unsigned long *inputBytes, unsigned long *outputBytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundConverterGetBufferSizes
			move.l              #$0A580018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundConverterGetBufferSizes
	ENDIF

;
; pascal OSErr SoundConverterBeginConversion(SoundConverter sc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundConverterBeginConversion
			move.l              #$025C0018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundConverterBeginConversion
	ENDIF

;
; pascal OSErr SoundConverterConvertBuffer(SoundConverter sc, const void *inputPtr, unsigned long inputFrames, void *outputPtr, unsigned long *outputFrames, unsigned long *outputBytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundConverterConvertBuffer
			move.l              #$0C600018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundConverterConvertBuffer
	ENDIF

;
; pascal OSErr SoundConverterEndConversion(SoundConverter sc, void *outputPtr, unsigned long *outputFrames, unsigned long *outputBytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundConverterEndConversion
			move.l              #$08640018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundConverterEndConversion
	ENDIF

;  Sound Manager 3.3 and later calls, uses _SoundDispatch 
;
; pascal OSErr SoundConverterGetInfo(SoundConverter sc, OSType selector, void *infoPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundConverterGetInfo
			move.l              #$06680018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundConverterGetInfo
	ENDIF

;
; pascal OSErr SoundConverterSetInfo(SoundConverter sc, OSType selector, void *infoPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundConverterSetInfo
			move.l              #$066C0018,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundConverterSetInfo
	ENDIF


;  Sound Component Functions
;   basic sound component functions



;
; pascal ComponentResult SoundComponentInitOutputDevice(ComponentInstance ti, long actions)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentInitOutputDevice
			move.l              #$00040001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentInitOutputDevice
	ENDIF

;
; pascal ComponentResult SoundComponentSetSource(ComponentInstance ti, SoundSource sourceID, ComponentInstance source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentSetSource
			move.l              #$00080002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentSetSource
	ENDIF

;
; pascal ComponentResult SoundComponentGetSource(ComponentInstance ti, SoundSource sourceID, ComponentInstance *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentGetSource
			move.l              #$00080003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentGetSource
	ENDIF

;
; pascal ComponentResult SoundComponentGetSourceData(ComponentInstance ti, SoundComponentDataPtr *sourceData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentGetSourceData
			move.l              #$00040004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentGetSourceData
	ENDIF

;
; pascal ComponentResult SoundComponentSetOutput(ComponentInstance ti, SoundComponentDataPtr requested, SoundComponentDataPtr *actual)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentSetOutput
			move.l              #$00080005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentSetOutput
	ENDIF

;  junction methods for the mixer, must be called at non-interrupt level
;
; pascal ComponentResult SoundComponentAddSource(ComponentInstance ti, SoundSource *sourceID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentAddSource
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentAddSource
	ENDIF

;
; pascal ComponentResult SoundComponentRemoveSource(ComponentInstance ti, SoundSource sourceID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentRemoveSource
			move.l              #$00040102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentRemoveSource
	ENDIF

;  info methods
;
; pascal ComponentResult SoundComponentGetInfo(ComponentInstance ti, SoundSource sourceID, OSType selector, void *infoPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentGetInfo
			move.l              #$000C0103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentGetInfo
	ENDIF

;
; pascal ComponentResult SoundComponentSetInfo(ComponentInstance ti, SoundSource sourceID, OSType selector, void *infoPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentSetInfo
			move.l              #$000C0104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentSetInfo
	ENDIF

;  control methods
;
; pascal ComponentResult SoundComponentStartSource(ComponentInstance ti, short count, SoundSource *sources)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentStartSource
			move.l              #$00060105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentStartSource
	ENDIF

;
; pascal ComponentResult SoundComponentStopSource(ComponentInstance ti, short count, SoundSource *sources)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentStopSource
			move.l              #$00060106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentStopSource
	ENDIF

;
; pascal ComponentResult SoundComponentPauseSource(ComponentInstance ti, short count, SoundSource *sources)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentPauseSource
			move.l              #$00060107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentPauseSource
	ENDIF

;
; pascal ComponentResult SoundComponentPlaySourceBuffer(ComponentInstance ti, SoundSource sourceID, SoundParamBlockPtr pb, long actions)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SoundComponentPlaySourceBuffer
			move.l              #$000C0108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SoundComponentPlaySourceBuffer
	ENDIF

; Audio Components
; Volume is described as a value between 0 and 1, with 0 indicating minimum
;  volume and 1 indicating maximum volume; if the device doesn't support
;  software control of volume, then a value of unimpErr is returned, indicating
;  that these functions are not supported by the device

;
; pascal ComponentResult AudioGetVolume(ComponentInstance ac, short whichChannel, ShortFixed *volume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AudioGetVolume
			move.l              #$00060000,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AudioGetVolume
	ENDIF

;
; pascal ComponentResult AudioSetVolume(ComponentInstance ac, short whichChannel, ShortFixed volume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AudioSetVolume
			move.l              #$00040001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AudioSetVolume
	ENDIF

; If the device doesn't support software control of mute, then a value of unimpErr is
;returned, indicating that these functions are not supported by the device.
;
; pascal ComponentResult AudioGetMute(ComponentInstance ac, short whichChannel, short *mute)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AudioGetMute
			move.l              #$00060002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AudioGetMute
	ENDIF

;
; pascal ComponentResult AudioSetMute(ComponentInstance ac, short whichChannel, short mute)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AudioSetMute
			move.l              #$00040003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AudioSetMute
	ENDIF

; AudioSetToDefaults causes the associated device to reset its volume and mute values
;(and perhaps other characteristics, e.g. attenuation) to "factory default" settings
;
; pascal ComponentResult AudioSetToDefaults(ComponentInstance ac)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AudioSetToDefaults
			move.l              #$00000004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AudioSetToDefaults
	ENDIF

; This routine is required; it must be implemented by all audio components

;
; pascal ComponentResult AudioGetInfo(ComponentInstance ac, AudioInfoPtr info)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AudioGetInfo
			move.l              #$00040005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AudioGetInfo
	ENDIF

;
; pascal ComponentResult AudioGetBass(ComponentInstance ac, short whichChannel, short *bass)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AudioGetBass
			move.l              #$00060006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AudioGetBass
	ENDIF

;
; pascal ComponentResult AudioSetBass(ComponentInstance ac, short whichChannel, short bass)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AudioSetBass
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AudioSetBass
	ENDIF

;
; pascal ComponentResult AudioGetTreble(ComponentInstance ac, short whichChannel, short *Treble)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AudioGetTreble
			move.l              #$00060008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AudioGetTreble
	ENDIF

;
; pascal ComponentResult AudioSetTreble(ComponentInstance ac, short whichChannel, short Treble)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AudioSetTreble
			move.l              #$00040009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AudioSetTreble
	ENDIF

;
; pascal ComponentResult AudioGetOutputDevice(ComponentInstance ac, Component *outputDevice)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AudioGetOutputDevice
			move.l              #$0004000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AudioGetOutputDevice
	ENDIF


; This is routine is private to the AudioVision component.  It enables the watching of the mute key.
;
; pascal ComponentResult AudioMuteOnEvent(ComponentInstance ac, short muteOnEvent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AudioMuteOnEvent
			move.l              #$00020081,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AudioMuteOnEvent
	ENDIF


kDelegatedSoundComponentSelectors EQU	$0100
;  Sound Input Manager routines, uses _SoundDispatch 
;
; pascal NumVersion SPBVersion(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBVersion
			move.l              #$00000014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBVersion
	ENDIF

;
; pascal OSErr SndRecord(ModalFilterUPP filterProc, Point corner, OSType quality, SndListHandle *sndHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndRecord
			move.l              #$08040014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndRecord
	ENDIF

;
; pascal OSErr SndRecordToFile(ModalFilterUPP filterProc, Point corner, OSType quality, short fRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndRecordToFile
			move.l              #$07080014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndRecordToFile
	ENDIF

;
; pascal OSErr SPBSignInDevice(short deviceRefNum, ConstStr255Param deviceName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBSignInDevice
			move.l              #$030C0014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBSignInDevice
	ENDIF

;
; pascal OSErr SPBSignOutDevice(short deviceRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBSignOutDevice
			move.l              #$01100014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBSignOutDevice
	ENDIF

;
; pascal OSErr SPBGetIndexedDevice(short count, Str255 deviceName, Handle *deviceIconHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBGetIndexedDevice
			move.l              #$05140014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBGetIndexedDevice
	ENDIF

;
; pascal OSErr SPBOpenDevice(ConstStr255Param deviceName, short permission, long *inRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBOpenDevice
			move.l              #$05180014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBOpenDevice
	ENDIF

;
; pascal OSErr SPBCloseDevice(long inRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBCloseDevice
			move.l              #$021C0014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBCloseDevice
	ENDIF

;
; pascal OSErr SPBRecord(SPBPtr inParamPtr, Boolean asynchFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBRecord
			move.l              #$03200014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBRecord
	ENDIF

;
; pascal OSErr SPBRecordToFile(short fRefNum, SPBPtr inParamPtr, Boolean asynchFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBRecordToFile
			move.l              #$04240014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBRecordToFile
	ENDIF

;
; pascal OSErr SPBPauseRecording(long inRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBPauseRecording
			move.l              #$02280014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBPauseRecording
	ENDIF

;
; pascal OSErr SPBResumeRecording(long inRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBResumeRecording
			move.l              #$022C0014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBResumeRecording
	ENDIF

;
; pascal OSErr SPBStopRecording(long inRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBStopRecording
			move.l              #$02300014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBStopRecording
	ENDIF

;
; pascal OSErr SPBGetRecordingStatus(long inRefNum, short *recordingStatus, short *meterLevel, unsigned long *totalSamplesToRecord, unsigned long *numberOfSamplesRecorded, unsigned long *totalMsecsToRecord, unsigned long *numberOfMsecsRecorded)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBGetRecordingStatus
			move.l              #$0E340014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBGetRecordingStatus
	ENDIF

;
; pascal OSErr SPBGetDeviceInfo(long inRefNum, OSType infoType, void *infoData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBGetDeviceInfo
			move.l              #$06380014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBGetDeviceInfo
	ENDIF

;
; pascal OSErr SPBSetDeviceInfo(long inRefNum, OSType infoType, void *infoData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBSetDeviceInfo
			move.l              #$063C0014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBSetDeviceInfo
	ENDIF

;
; pascal OSErr SPBMillisecondsToBytes(long inRefNum, long *milliseconds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBMillisecondsToBytes
			move.l              #$04400014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBMillisecondsToBytes
	ENDIF

;
; pascal OSErr SPBBytesToMilliseconds(long inRefNum, long *byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SPBBytesToMilliseconds
			move.l              #$04440014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SPBBytesToMilliseconds
	ENDIF

;
; pascal OSErr SetupSndHeader(SndListHandle sndHandle, short numChannels, UnsignedFixed sampleRate, short sampleSize, OSType compressionType, short baseNote, unsigned long numBytes, short *headerLen)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetupSndHeader
			move.l              #$0D480014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetupSndHeader
	ENDIF

;
; pascal OSErr SetupAIFFHeader(short fRefNum, short numChannels, UnsignedFixed sampleRate, short sampleSize, OSType compressionType, unsigned long numBytes, unsigned long numFrames)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetupAIFFHeader
			move.l              #$0B4C0014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetupAIFFHeader
	ENDIF

;  Sound Input Manager 1.1 and later calls, uses _SoundDispatch 
;
; pascal OSErr ParseAIFFHeader(short fRefNum, SoundComponentData *sndInfo, unsigned long *numFrames, unsigned long *dataOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ParseAIFFHeader
			move.l              #$07580014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ParseAIFFHeader
	ENDIF

;
; pascal OSErr ParseSndHeader(SndListHandle sndHandle, SoundComponentData *sndInfo, unsigned long *numFrames, unsigned long *dataOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ParseSndHeader
			move.l              #$085C0014,D0
			dc.w            	$A800
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ParseSndHeader
	ENDIF

	IF ¬ TARGET_OS_MAC THEN
;   Only to be used if you are writing a sound input component; this 
;   is the param block for a read request from the SoundMgr to the   
;   sound input component.  Not to be confused with the SPB struct   
;   above, which is the param block for a read request from an app   
;   to the SoundMgr.                                                 


; typedef SndInputCmpParam *			SndInputCmpParamPtr

SndInputCmpParam		RECORD 0
ioCompletion			 ds.l	1				; offset: $0 (0)		;  completion routine [pointer]
ioInterrupt				 ds.l	1				; offset: $4 (4)		;  interrupt routine [pointer]
ioResult				 ds.w	1				; offset: $8 (8)		;  I/O result code [word]
pad						 ds.w	1				; offset: $A (10)
ioReqCount				 ds.l	1				; offset: $C (12)
ioActCount				 ds.l	1				; offset: $10 (16)
ioBuffer				 ds.l	1				; offset: $14 (20)
ioMisc					 ds.l	1				; offset: $18 (24)
sizeof					 EQU *					; size:   $1C (28)
						ENDR
;
; pascal ComponentResult SndInputReadAsync(ComponentInstance self, SndInputCmpParamPtr SICParmPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndInputReadAsync
			move.l              #$00040001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndInputReadAsync
	ENDIF

;
; pascal ComponentResult SndInputReadSync(ComponentInstance self, SndInputCmpParamPtr SICParmPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndInputReadSync
			move.l              #$00040002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndInputReadSync
	ENDIF

;
; pascal ComponentResult SndInputPauseRecording(ComponentInstance self)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndInputPauseRecording
			move.l              #$00000003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndInputPauseRecording
	ENDIF

;
; pascal ComponentResult SndInputResumeRecording(ComponentInstance self)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndInputResumeRecording
			move.l              #$00000004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndInputResumeRecording
	ENDIF

;
; pascal ComponentResult SndInputStopRecording(ComponentInstance self)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndInputStopRecording
			move.l              #$00000005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndInputStopRecording
	ENDIF

;
; pascal ComponentResult SndInputGetStatus(ComponentInstance self, short *recordingStatus, unsigned long *totalSamplesToRecord, unsigned long *numberOfSamplesRecorded)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndInputGetStatus
			move.l              #$000C0006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndInputGetStatus
	ENDIF

;
; pascal ComponentResult SndInputGetDeviceInfo(ComponentInstance self, OSType infoType, void *infoData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndInputGetDeviceInfo
			move.l              #$00080007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndInputGetDeviceInfo
	ENDIF

;
; pascal ComponentResult SndInputSetDeviceInfo(ComponentInstance self, OSType infoType, void *infoData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndInputSetDeviceInfo
			move.l              #$00080008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndInputSetDeviceInfo
	ENDIF

;
; pascal ComponentResult SndInputInitHardware(ComponentInstance self)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SndInputInitHardware
			move.l              #$00000009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SndInputInitHardware
	ENDIF

	ENDIF

	ENDIF ; __SOUND__ 


;
;    File:       AppleEvents.a
;
;    Contains:   AppleEvent Package Interfaces.
;
;    Version:    Technology: System 7.5
;                Release:    Universal Interfaces 3.3.2
;
;    Copyright:  © 1989-2000 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__APPLEEVENTS__') = 'UNDEFINED' THEN
__APPLEEVENTS__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF
	IF &TYPE('__NOTIFICATION__') = 'UNDEFINED' THEN
	include 'Notification.a'
	ENDIF
	IF &TYPE('__EVENTS__') = 'UNDEFINED' THEN
	include 'Events.a'
	ENDIF
; 
;    Note:   The functions and types for the building and parsing AppleEvent  
;            messages has moved to AEDataModel.h
;

	IF &TYPE('__AEDATAMODEL__') = 'UNDEFINED' THEN
	include 'AEDataModel.a'
	ENDIF


															; Keywords for Apple event parameters 
keyDirectObject					EQU		'----'
keyErrorNumber					EQU		'errn'
keyErrorString					EQU		'errs'
keyProcessSerialNumber			EQU		'psn '				; Keywords for special handlers 
keyPreDispatch					EQU		'phac'				; preHandler accessor call 
keySelectProc					EQU		'selh'				; more selector call 
															; Keyword for recording 
keyAERecorderCount				EQU		'recr'				; available only in vers 1.0.1 and greater 
															; Keyword for version information 
keyAEVersion					EQU		'vers'				; available only in vers 1.0.1 and greater 
;  Event Class 

kCoreEventClass					EQU		'aevt'
;  Event ID’s 

kAEOpenApplication				EQU		'oapp'
kAEOpenDocuments				EQU		'odoc'
kAEPrintDocuments				EQU		'pdoc'
kAEQuitApplication				EQU		'quit'
kAEAnswer						EQU		'ansr'
kAEApplicationDied				EQU		'obit'
;  Constants for recording 

kAEStartRecording				EQU		'reca'				; available only in vers 1.0.1 and greater 
kAEStopRecording				EQU		'recc'				; available only in vers 1.0.1 and greater 
kAENotifyStartRecording			EQU		'rec1'				; available only in vers 1.0.1 and greater 
kAENotifyStopRecording			EQU		'rec0'				; available only in vers 1.0.1 and greater 
kAENotifyRecording				EQU		'recr'				; available only in vers 1.0.1 and greater 

;  parameter to AESend 
; typedef OptionBits 					AESendOptions


kAENeverInteract				EQU		$00000010			; server should not interact with user 
kAECanInteract					EQU		$00000020			; server may try to interact with user 
kAEAlwaysInteract				EQU		$00000030			; server should always interact with user where appropriate 
kAECanSwitchLayer				EQU		$00000040			; interaction may switch layer 
kAEDontRecord					EQU		$00001000			; don't record this event - available only in vers 1.0.1 and greater 
kAEDontExecute					EQU		$00002000			; don't send the event for recording - available only in vers 1.0.1 and greater 
kAEProcessNonReplyEvents		EQU		$00008000			; allow processing of non-reply events while awaiting synchronous AppleEvent reply 
; typedef SInt32 						AESendMode


kAENoReply						EQU		$00000001			; sender doesn't want a reply to event 
kAEQueueReply					EQU		$00000002			; sender wants a reply but won't wait 
kAEWaitReply					EQU		$00000003			; sender wants a reply and will wait 
kAEDontReconnect				EQU		$00000080			; don't reconnect if there is a sessClosedErr from PPCToolbox 
kAEWantReceipt					EQU		$00000200			; (nReturnReceipt) sender wants a receipt of message 

;  Constants for timeout durations 

kAEDefaultTimeout				EQU		-1					; timeout value determined by AEM 
kNoTimeOut						EQU		-2					; wait until reply comes back, however long it takes 

;  priority param of AESend 
; typedef SInt16 						AESendPriority


kAENormalPriority				EQU		$00000000			; post message at the end of the event queue 
kAEHighPriority					EQU		$00000001			; post message at the front of the event queue (same as nAttnMsg) 

; typedef SInt8 						AEEventSource


kAEUnknownSource				EQU		0
kAEDirectCall					EQU		1
kAESameProcess					EQU		2
kAELocalProcess					EQU		3
kAERemoteProcess				EQU		4



; **************************************************************************
;  The next couple of calls are basic routines used to create, send,
;  and process AppleEvents. 
;*************************************************************************

;
; pascal OSErr AESend(const AppleEvent *theAppleEvent, AppleEvent *reply, AESendMode sendMode, AESendPriority sendPriority, long timeOutInTicks, AEIdleUPP idleProc, AEFilterUPP filterProc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AESend
			move.w              #$0D17,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AESend
	ENDIF

;
; pascal OSErr AEProcessAppleEvent(const EventRecord *theEventRecord)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEProcessAppleEvent
			move.w              #$021B,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEProcessAppleEvent
	ENDIF


;  
; Note: during event processing, an event handler may realize that it is likely
; to exceed the client's timeout limit. Passing the reply to this
; routine causes a wait event to be generated that asks the client
; for more time. 
;

;
; pascal OSErr AEResetTimer(const AppleEvent *reply)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEResetTimer
			move.w              #$0219,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEResetTimer
	ENDIF


; **************************************************************************
;  The following three calls are used to allow applications to behave
;  courteously when a user interaction such as a dialog box is needed. 
;*************************************************************************


; typedef SInt8 						AEInteractAllowed


kAEInteractWithSelf				EQU		0
kAEInteractWithLocal			EQU		1
kAEInteractWithAll				EQU		2
;
; pascal OSErr AEGetInteractionAllowed(AEInteractAllowed *level)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetInteractionAllowed
			move.w              #$021D,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetInteractionAllowed
	ENDIF

;
; pascal OSErr AESetInteractionAllowed(AEInteractAllowed level)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AESetInteractionAllowed
			move.w              #$011E,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AESetInteractionAllowed
	ENDIF

;
; pascal OSErr AEInteractWithUser(long timeOutInTicks, NMRecPtr nmReqPtr, AEIdleUPP idleProc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEInteractWithUser
			move.w              #$061C,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEInteractWithUser
	ENDIF


; **************************************************************************
;  These calls are used to set up and modify the event dispatch table.
;*************************************************************************

;
; pascal OSErr AEInstallEventHandler(AEEventClass theAEEventClass, AEEventID theAEEventID, AEEventHandlerUPP handler, long handlerRefcon, Boolean isSysHandler)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEInstallEventHandler
			move.w              #$091F,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEInstallEventHandler
	ENDIF

;
; pascal OSErr AERemoveEventHandler(AEEventClass theAEEventClass, AEEventID theAEEventID, AEEventHandlerUPP handler, Boolean isSysHandler)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AERemoveEventHandler
			move.w              #$0720,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AERemoveEventHandler
	ENDIF

;
; pascal OSErr AEGetEventHandler(AEEventClass theAEEventClass, AEEventID theAEEventID, AEEventHandlerUPP *handler, long *handlerRefcon, Boolean isSysHandler)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetEventHandler
			move.w              #$0921,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetEventHandler
	ENDIF


; **************************************************************************
; The following four calls are available for applications which need more
; sophisticated control over when and how events are processed. Applications
; which implement multi-session servers or which implement their own
; internal event queueing will probably be the major clients of these
; routines. They can be called from within a handler to prevent the AEM from
; disposing of the AppleEvent when the handler returns. They can be used to
; asynchronously process the event (as MacApp does).
;*************************************************************************

;
; pascal OSErr AESuspendTheCurrentEvent(const AppleEvent *theAppleEvent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AESuspendTheCurrentEvent
			move.w              #$022B,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AESuspendTheCurrentEvent
	ENDIF

;  
; Note: The following routine tells the AppleEvent manager that processing
; is either about to resume or has been completed on a previously suspended
; event. The procPtr passed in as the dispatcher parameter will be called to
; attempt to redispatch the event. Several constants for the dispatcher
; parameter allow special behavior. They are:
;    - kAEUseStandardDispatch means redispatch as if the event was just
;      received, using the standard AppleEvent dispatch mechanism.
;    - kAENoDispatch means ignore the parameter.
;      Use this in the case where the event has been handled and no
;      redispatch is needed.
;    - non nil means call the routine which the dispatcher points to.
;

;  Constants for Refcon in AEResumeTheCurrentEvent with kAEUseStandardDispatch 

kAEDoNotIgnoreHandler			EQU		$00000000
kAEIgnoreAppPhacHandler			EQU		$00000001			; available only in vers 1.0.1 and greater 
kAEIgnoreAppEventHandler		EQU		$00000002			; available only in vers 1.0.1 and greater 
kAEIgnoreSysPhacHandler			EQU		$00000004			; available only in vers 1.0.1 and greater 
kAEIgnoreSysEventHandler		EQU		$00000008			; available only in vers 1.0.1 and greater 
kAEIngoreBuiltInEventHandler	EQU		$00000010			; available only in vers 1.0.1 and greater 
kAEDontDisposeOnResume			EQU		$80000000			; available only in vers 1.0.1 and greater 
;  Constants for AEResumeTheCurrentEvent 

kAENoDispatch					EQU		0					; dispatch parameter to AEResumeTheCurrentEvent takes a pointer to a dispatch 
kAEUseStandardDispatch			EQU		$FFFFFFFF			; table, or one of these two constants 
;
; pascal OSErr AEResumeTheCurrentEvent(const AppleEvent *theAppleEvent, const AppleEvent *reply, AEEventHandlerUPP dispatcher, long handlerRefcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEResumeTheCurrentEvent
			move.w              #$0818,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEResumeTheCurrentEvent
	ENDIF

;
; pascal OSErr AEGetTheCurrentEvent(AppleEvent *theAppleEvent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetTheCurrentEvent
			move.w              #$021A,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetTheCurrentEvent
	ENDIF

;
; pascal OSErr AESetTheCurrentEvent(const AppleEvent *theAppleEvent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AESetTheCurrentEvent
			move.w              #$022C,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AESetTheCurrentEvent
	ENDIF


; **************************************************************************
;  These calls are used to set up and modify special hooks into the
;  AppleEvent manager.
;*************************************************************************

;
; pascal OSErr AEInstallSpecialHandler(AEKeyword functionClass, AEEventHandlerUPP handler, Boolean isSysHandler)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEInstallSpecialHandler
			move.w              #$0500,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEInstallSpecialHandler
	ENDIF

;
; pascal OSErr AERemoveSpecialHandler(AEKeyword functionClass, AEEventHandlerUPP handler, Boolean isSysHandler)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AERemoveSpecialHandler
			move.w              #$0501,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AERemoveSpecialHandler
	ENDIF

;
; pascal OSErr AEGetSpecialHandler(AEKeyword functionClass, AEEventHandlerUPP *handler, Boolean isSysHandler)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetSpecialHandler
			move.w              #$052D,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetSpecialHandler
	ENDIF


; **************************************************************************
;  This call was added in version 1.0.1. If called with the keyword
;  keyAERecorderCount ('recr'), the number of recorders that are
;  currently active is returned in 'result'
;  (available only in vers 1.0.1 and greater).
;*************************************************************************

;
; pascal OSErr AEManagerInfo(AEKeyword keyWord, long *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEManagerInfo
			move.w              #$0441,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEManagerInfo
	ENDIF





	ENDIF ; __APPLEEVENTS__ 


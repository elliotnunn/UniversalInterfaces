;
;    File:       FixMath.a
;
;    Contains:   Fixed Math Interfaces.
;
;    Version:    Technology: Mac OS 8
;                Release:    Universal Interfaces 3.3.2
;
;    Copyright:  © 1985-2000 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__FIXMATH__') = 'UNDEFINED' THEN
__FIXMATH__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF



fixed1							EQU		$00010000
fract1							EQU		$40000000
positiveInfinity				EQU		$7FFFFFFF
negativeInfinity				EQU		$80000000
; 
;    FixRatio, FixMul, and FixRound were previously in ToolUtils.h
;

;
; pascal Fixed FixRatio(short numer, short denom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FixRatio:	OPWORD	$A869
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FixRatio
	ENDIF

;
; pascal Fixed FixMul(Fixed a, Fixed b)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FixMul:	OPWORD	$A868
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FixMul
	ENDIF

;
; pascal short FixRound(Fixed x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FixRound:	OPWORD	$A86C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FixRound
	ENDIF

;
; pascal Fract Fix2Frac(Fixed x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Fix2Frac:	OPWORD	$A841
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Fix2Frac
	ENDIF

;
; pascal long Fix2Long(Fixed x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Fix2Long:	OPWORD	$A840
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Fix2Long
	ENDIF

;
; pascal Fixed Long2Fix(long x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Long2Fix:	OPWORD	$A83F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Long2Fix
	ENDIF

;
; pascal Fixed Frac2Fix(Fract x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Frac2Fix:	OPWORD	$A842
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Frac2Fix
	ENDIF

;
; pascal Fract FracMul(Fract x, Fract y)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FracMul:	OPWORD	$A84A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FracMul
	ENDIF

;
; pascal Fixed FixDiv(Fixed x, Fixed y)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FixDiv:	OPWORD	$A84D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FixDiv
	ENDIF

;
; pascal Fract FracDiv(Fract x, Fract y)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FracDiv:	OPWORD	$A84B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FracDiv
	ENDIF

;
; pascal Fract FracSqrt(Fract x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FracSqrt:	OPWORD	$A849
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FracSqrt
	ENDIF

;
; pascal Fract FracSin(Fixed x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FracSin:	OPWORD	$A848
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FracSin
	ENDIF

;
; pascal Fract FracCos(Fixed x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FracCos:	OPWORD	$A847
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FracCos
	ENDIF

;
; pascal Fixed FixATan2(long x, long y)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FixATan2:	OPWORD	$A818
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FixATan2
	ENDIF

; 
;    Frac2X, Fix2X, X2Fix, and X2Frac translate to and from
;    the floating point type "extended" (that's what the X is for).
;    On the original Mac this was 80-bits and the functions could be
;    accessed via A-Traps.  When the 68881 co-processor was added,
;    it used 96-bit floating point types, so the A-Traps could not 
;    be used.  When PowerPC was added, it used 64-bit floating point
;    types, so yet another prototype was added.
;

	IF CALL_NOT_IN_CARBON THEN
;
; pascal extended Frac2X(Fract x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Frac2X:	OPWORD	$A845
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Frac2X
	ENDIF

;
; pascal extended Fix2X(Fixed x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Fix2X:	OPWORD	$A843
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Fix2X
	ENDIF

;
; pascal Fixed X2Fix(extended x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_X2Fix:	OPWORD	$A844
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION X2Fix
	ENDIF

;
; pascal Fract X2Frac(extended x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_X2Frac:	OPWORD	$A846
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION X2Frac
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
;  QuickTime 3.0 makes these Wide routines available on other platforms
	IF TARGET_CPU_PPC ++ ¬ TARGET_OS_MAC THEN
;
; extern short WideCompare(const wide *target, const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideCompare
	ENDIF

;
; extern wide *WideAdd(wide *target, const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideAdd
	ENDIF

;
; extern wide *WideSubtract(wide *target, const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideSubtract
	ENDIF

;
; extern wide *WideNegate(wide *target)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideNegate
	ENDIF

;
; extern wide *WideShift(wide *target, long shift)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideShift
	ENDIF

;
; extern unsigned long WideSquareRoot(const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideSquareRoot
	ENDIF

;
; extern wide *WideMultiply(long multiplicand, long multiplier, wide *target)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideMultiply
	ENDIF

;  returns the quotient 
;
; extern long WideDivide(const wide *dividend, long divisor, long *remainder)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideDivide
	ENDIF

;  quotient replaces dividend 
;
; extern wide *WideWideDivide(wide *dividend, long divisor, long *remainder)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideWideDivide
	ENDIF

;
; extern wide *WideBitShift(wide *src, long shift)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideBitShift
	ENDIF

	ENDIF

	ENDIF ; __FIXMATH__ 


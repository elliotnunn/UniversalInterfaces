;
;    File:       Math64.a
;
;    Contains:   64-bit integer math Interfaces.
;
;    Version:    Technology: System 7.5
;                Release:    Universal Interfaces 3.3.2
;
;    Copyright:  Â© 1994-2000 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__MATH64__') = 'UNDEFINED' THEN
__MATH64__ SET 1

	IF &TYPE('__CONDITIONALMACROS__') = 'UNDEFINED' THEN
	include 'ConditionalMacros.a'
	ENDIF
	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF


; --------------------------------------------------------------------------------
;                These routines are intended to provide C software support for
;                64 bit integer types.  Their behavior should mimic anticipated
;                64 bit hardware. This implementation should replace use of the
;                "wide" type found in PowerPC.
;
;    The following routines are available for performing math on 64-bit integers:
;    
;    S64Max
;                Returns the largest representable SInt64.
;    S64Min
;                Returns the smallest (i.e. most negative) SInt64.  Note: the negative
;                (absolute value) of this number is not representable in an SInt64.
;                That means that S64Negate(S64Min) is not representable (in fact,
;                it returns S64Min).
;    S64Add
;                Adds two integers, producing an integer result.  If an overflow
;                occurs the result is congruent mod (2^64) as if the operands and
;                result were unsigned.  No overflow is signaled.
;    
;    S64Subtract
;                Subtracts two integers, producing an integer result.  If an overflow
;                occurs the result is congruent mod (2^64) as if the operands and
;                result were unsigned.  No overflow is signaled.
;
;    S64Negate
;                Returns the additive inverse of a signed number (i.e. it returns
;                0 - the number).  S64Negate (S64Min) is not representable (in fact,
;                it returns S64Min).
;    
;    S64Absolute
;                Returns the absolute value of the number (i.e. the number if
;                it is positive, or 0 - the number if it is negative).
;                See S64Negate above.
;                
;    S64Multiply
;                Multiplies two signed numbers, producing a signed result.  Overflow
;                is ignored and the low-order part of the product is returned.  The
;                sign of the result is not guaranteed to be correct if the magnitude
;                of the product is not representable.
;                
;    S64Div
;                Divides dividend by divisor, returning the quotient.
;                
;    S64Mod
;                Returns the remainder of divide of dividend by divisor.  The sign of
;                the remainder is the same as the sign of the dividend (i.e., it takes
;                the absolute values of the operands, does the division, then fixes
;                the sign of the quotient and remainder).
;
;    S64Divide
;                Divides dividend by divisor, returning the quotient.  The remainder
;                is returned in *remainder if remainder (the pointer) is non-NULL.
;                The sign of the remainder is the same as the sign of the dividend
;                (i.e. it takes the absolute values of the operands, does the division,
;                then fixes the sign of the quotient and remainder).  If the divisor
;                is zero, then S64Max() will be returned (or S64Min() if the dividend
;                is negative), and the remainder will be the dividend; no error is
;                reported.
;    
;    S64Set
;                Given an SInt32, returns an SInt64 with the same value.  Use this
;                routine instead of coding 64-bit constants (at least when the
;                constant will fit in an SInt32).
;    
;    S64SetU
;                Given a UInt32, returns a SInt64 with the same value.
;                
;    S64Set
;                Given an SInt64, returns an SInt32 by discarding the high-order
;                32 bits.
;    
;    S64Compare
;                Given two signed numbers, left and right, returns an
;                SInt32 that compares with zero the same way left compares with
;                right.  If you wanted to perform a comparison on 64-bit integers
;                of the form:
;                        operand_1 <operation> operand_2
;                then you could use an expression of the form:
;                        xxxS64Compare(operand_1,operand_2) <operation> 0
;                to test for the same condition.
;                
;                CAUTION: DO NOT depend on the exact value returned by this routine.
;                Only the sign (i.e. positive, zero, or negative) of the result is
;                guaranteed.
;
;    S64And, S64Or, S64Eor and S64Not
;    
;                Return Boolean (1 or 0) depending on the outcome of the logical
;                operation.
;
;    S64BitwiseAnd, S64BitwiseOr, S64BitwiseEor and S64BitwiseNot
;    
;                Return the Bitwise result.
;                
;    S64ShiftRight and S64ShiftLeft
;    
;                The lower 7 bits of the shift argument determines the amount of 
;                shifting.  S64ShiftRight is an arithmetic shift while U64ShiftRight
;                is a logical shift.
;
;    SInt64ToLongDouble
;                
;                Converts SInt64 to long double.  Note all SInt64s fit exactly into 
;                long doubles, thus, the binary -> decimal conversion routines
;                in fp.h can be used to achieve SInt64 -> long double -> decimal
;                conversions.
;                
;    LongDoubleToSInt64
;    
;                Converts a long double to a SInt64.  Any decimal string that fits
;                into a SInt64 can be converted exactly into a long double, using the
;                conversion routines found in fp.h.  Then this routine can be used
;                to complete the conversion to SInt64.
;                
;    SInt64ToWide
;    
;                Converts a SInt64 to a wide struct.  If SInt64 is implemented
;                as a typedef of wide, the marco does nothing. If SInt64 is 
;                implememnted as a long long, it casts the long long into a 
;                wide struct.
;    
;    WideToSInt64
;    
;                Converts a wide struct into a SInt64.  If SInt64 is implemented
;                as a typedef of wide, the marco does nothing. If SInt64 is 
;                implememnted as a long long, it reads the struct into a long long.
;    
;    
;    The corresponding UInt64 routines are also included.
;    
;--------------------------------------------------------------------------------


	IF TYPE_LONGLONG THEN
	ELSE
;
; extern SInt64 S64Max(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Max
	ENDIF

;
; extern SInt64 S64Min(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Min
	ENDIF

;
; extern SInt64 S64Add(SInt64 x, SInt64 y)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Add
	ENDIF

;
; extern SInt64 S64Subtract(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Subtract
	ENDIF

;
; extern SInt64 S64Negate(SInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Negate
	ENDIF

;
; extern SInt64 S64Absolute(SInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Absolute
	ENDIF

;
; extern SInt64 S64Multiply(SInt64 xparam, SInt64 yparam)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Multiply
	ENDIF

	IF CALL_NOT_IN_CARBON THEN
;
; extern SInt64 S64Mod(SInt64 dividend, SInt64 divisor)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Mod
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
;
; extern SInt64 S64Divide(SInt64 dividend, SInt64 divisor, SInt64 *remainder)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Divide
	ENDIF

;
; extern SInt64 S64Set(SInt32 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Set
	ENDIF

;
; extern SInt64 S64SetU(UInt32 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64SetU
	ENDIF

;
; extern SInt32 S32Set(SInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S32Set
	ENDIF

;
; extern Boolean S64And(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64And
	ENDIF

;
; extern Boolean S64Or(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Or
	ENDIF

;
; extern Boolean S64Eor(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Eor
	ENDIF

;
; extern Boolean S64Not(SInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Not
	ENDIF

;
; extern SInt64 S64BitwiseAnd(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64BitwiseAnd
	ENDIF

;
; extern SInt64 S64BitwiseOr(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64BitwiseOr
	ENDIF

;
; extern SInt64 S64BitwiseEor(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64BitwiseEor
	ENDIF

;
; extern SInt64 S64BitwiseNot(SInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64BitwiseNot
	ENDIF

;
; extern SInt64 S64ShiftRight(SInt64 value, UInt32 shift)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64ShiftRight
	ENDIF

;
; extern SInt64 S64ShiftLeft(SInt64 value, UInt32 shift)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64ShiftLeft
	ENDIF

;
; extern UInt64 U64Max(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Max
	ENDIF

;
; extern UInt64 U64Add(UInt64 x, UInt64 y)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Add
	ENDIF

;
; extern UInt64 U64Subtract(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Subtract
	ENDIF

;
; extern UInt64 U64Multiply(UInt64 xparam, UInt64 yparam)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Multiply
	ENDIF

	IF CALL_NOT_IN_CARBON THEN
;
; extern UInt64 U64Mod(UInt64 dividend, UInt64 divisor)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Mod
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
;
; extern UInt64 U64Divide(UInt64 dividend, UInt64 divisor, UInt64 *remainder)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Divide
	ENDIF

;
; extern UInt64 U64Set(SInt32 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Set
	ENDIF

;
; extern UInt64 U64SetU(UInt32 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64SetU
	ENDIF

;
; extern UInt32 U32SetU(UInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U32SetU
	ENDIF

;
; extern Boolean U64And(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64And
	ENDIF

;
; extern Boolean U64Or(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Or
	ENDIF

;
; extern Boolean U64Eor(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Eor
	ENDIF

;
; extern Boolean U64Not(UInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Not
	ENDIF

;
; extern UInt64 U64BitwiseAnd(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64BitwiseAnd
	ENDIF

;
; extern UInt64 U64BitwiseOr(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64BitwiseOr
	ENDIF

;
; extern UInt64 U64BitwiseEor(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64BitwiseEor
	ENDIF

;
; extern UInt64 U64BitwiseNot(UInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64BitwiseNot
	ENDIF

;
; extern UInt64 U64ShiftRight(UInt64 value, UInt32 shift)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64ShiftRight
	ENDIF

;
; extern UInt64 U64ShiftLeft(UInt64 value, UInt32 shift)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64ShiftLeft
	ENDIF

;
; extern SInt64 UInt64ToSInt64(UInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UInt64ToSInt64
	ENDIF

;
; extern UInt64 SInt64ToUInt64(SInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SInt64ToUInt64
	ENDIF

	ENDIF	; TYPE_LONGLONG
;
; extern SInt32 S64Compare(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Compare
	ENDIF

;
; extern SInt32 U64Compare(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Compare
	ENDIF



	ENDIF ; __MATH64__ 


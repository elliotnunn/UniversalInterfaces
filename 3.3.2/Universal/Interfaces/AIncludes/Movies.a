;
;    File:       Movies.a
;
;    Contains:   QuickTime Interfaces.
;
;    Version:    Technology: QuickTime 4.1
;                Release:    Universal Interfaces 3.3.2
;
;    Copyright:  © 1990-2000 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__MOVIES__') = 'UNDEFINED' THEN
__MOVIES__ SET 1

	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF
	IF &TYPE('__ALIASES__') = 'UNDEFINED' THEN
	include 'Aliases.a'
	ENDIF
	IF &TYPE('__EVENTS__') = 'UNDEFINED' THEN
	include 'Events.a'
	ENDIF
	IF &TYPE('__MENUS__') = 'UNDEFINED' THEN
	include 'Menus.a'
	ENDIF
	IF &TYPE('__COMPONENTS__') = 'UNDEFINED' THEN
	include 'Components.a'
	ENDIF
	IF &TYPE('__IMAGECOMPRESSION__') = 'UNDEFINED' THEN
	include 'ImageCompression.a'
	ENDIF


;   "kFix1" is defined in FixMath as "fixed1"  
;  error codes are in Errors.[haa] 
;  gestalt codes are in Gestalt.[hpa] 

MovieFileType					EQU		'MooV'
MovieScrapType					EQU		'moov'

MovieResourceType				EQU		'moov'
MovieForwardPointerResourceType	EQU		'fore'
MovieBackwardPointerResourceType EQU	'back'

MovieResourceAtomType			EQU		'moov'
MovieDataAtomType				EQU		'mdat'
FreeAtomType					EQU		'free'
SkipAtomType					EQU		'skip'
WideAtomPlaceholderType			EQU		'wide'

MediaHandlerType				EQU		'mhlr'
DataHandlerType					EQU		'dhlr'

VideoMediaType					EQU		'vide'
SoundMediaType					EQU		'soun'
TextMediaType					EQU		'text'
BaseMediaType					EQU		'gnrc'
MPEGMediaType					EQU		'MPEG'
MusicMediaType					EQU		'musi'
TimeCodeMediaType				EQU		'tmcd'
SpriteMediaType					EQU		'sprt'
FlashMediaType					EQU		'flsh'
MovieMediaType					EQU		'moov'
TweenMediaType					EQU		'twen'
ThreeDeeMediaType				EQU		'qd3d'
HandleDataHandlerSubType		EQU		'hndl'
ResourceDataHandlerSubType		EQU		'rsrc'
URLDataHandlerSubType			EQU		'url '
WiredActionHandlerType			EQU		'wire'

VisualMediaCharacteristic		EQU		'eyes'
AudioMediaCharacteristic		EQU		'ears'
kCharacteristicCanSendVideo		EQU		'vsnd'
kCharacteristicProvidesActions	EQU		'actn'
kCharacteristicNonLinear		EQU		'nonl'
kCharacteristicCanStep			EQU		'step'
kCharacteristicHasNoDuration	EQU		'noti'

kUserDataMovieControllerType	EQU		'ctyp'
kUserDataName					EQU		'name'
kUserDataTextAuthor				EQU		'©aut'
kUserDataTextComment			EQU		'©cmt'
kUserDataTextCopyright			EQU		'©cpy'
kUserDataTextCreationDate		EQU		'©day'
kUserDataTextDescription		EQU		'©des'
kUserDataTextDirector			EQU		'©dir'
kUserDataTextDisclaimer			EQU		'©dis'
kUserDataTextFullName			EQU		'©nam'
kUserDataTextHostComputer		EQU		'©hst'
kUserDataTextInformation		EQU		'©inf'
kUserDataTextKeywords			EQU		'©key'
kUserDataTextMake				EQU		'©mak'
kUserDataTextModel				EQU		'©mod'
kUserDataTextOriginalFormat		EQU		'©fmt'
kUserDataTextOriginalSource		EQU		'©src'
kUserDataTextPerformers			EQU		'©prf'
kUserDataTextProducer			EQU		'©prd'
kUserDataTextProduct			EQU		'©PRD'
kUserDataTextSoftware			EQU		'©swr'
kUserDataTextSpecialPlaybackRequirements EQU '©req'
kUserDataTextWarning			EQU		'©wrn'
kUserDataTextWriter				EQU		'©wrt'
kUserDataTextEditDate1			EQU		'©ed1'
kUserDataTextChapter			EQU		'©chp'

kUserDataUnicodeBit				EQU		$00000080

DoTheRightThing					EQU		0

MovieRecord				RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct MovieRecord *			Movie

; typedef Movie *						MoviePtr

TrackRecord				RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct TrackRecord *			Track

MediaRecord				RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct MediaRecord *			Media

UserDataRecord			RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct UserDataRecord *		UserData

TrackEditStateRecord	RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct TrackEditStateRecord *	TrackEditState

MovieEditStateRecord	RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct MovieEditStateRecord *	MovieEditState

SpriteWorldRecord		RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct SpriteWorldRecord *	SpriteWorld

SpriteRecord			RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct SpriteRecord *			Sprite

QTTweenerRecord			RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct QTTweenerRecord *		QTTweener

SampleDescription		RECORD 0
descSize				 ds.l	1				; offset: $0 (0)
dataFormat				 ds.l	1				; offset: $4 (4)
resvd1					 ds.l	1				; offset: $8 (8)
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct SampleDescription *	SampleDescriptionPtr

; typedef SampleDescriptionPtr *		SampleDescriptionHandle





; typedef Handle 						QTAtomContainer

; typedef long 							QTAtom

; typedef long 							QTAtomType

; typedef long 							QTAtomID

;  QTFloatDouble is the 64-bit IEEE-754 standard
QTFloatDouble			RECORD 0
f						 ds		Float64
sizeof					 EQU *					; size:   $8 (8)
						ENDR


;  QTFloatSingle is the 32-bit IEEE-754 standard
QTFloatSingle			RECORD 0
f						 ds		Float32
sizeof					 EQU *					; size:   $4 (4)
						ENDR




SoundDescription		RECORD 0
descSize				 ds.l	1				; offset: $0 (0)		;  total size of SoundDescription including extra data 
dataFormat				 ds.l	1				; offset: $4 (4)		;  sound format 
resvd1					 ds.l	1				; offset: $8 (8)		;  reserved for apple use. set to zero 
resvd2					 ds.w	1				; offset: $C (12)		;  reserved for apple use. set to zero 
dataRefIndex			 ds.w	1				; offset: $E (14)
version					 ds.w	1				; offset: $10 (16)		;  which version is this data 
revlevel				 ds.w	1				; offset: $12 (18)		;  what version of that codec did this 
vendor					 ds.l	1				; offset: $14 (20)		;  whose  codec compressed this data 
numChannels				 ds.w	1				; offset: $18 (24)		;  number of channels of sound 
sampleSize				 ds.w	1				; offset: $1A (26)		;  number of bits per sample 
compressionID			 ds.w	1				; offset: $1C (28)		;  unused. set to zero. 
packetSize				 ds.w	1				; offset: $1E (30)		;  unused. set to zero. 
sampleRate				 ds.l	1				; offset: $20 (32)		;  sample rate sound is captured at 
sizeof					 EQU *					; size:   $24 (36)
						ENDR
; typedef struct SoundDescription *		SoundDescriptionPtr

; typedef SoundDescriptionPtr *			SoundDescriptionHandle

;  version 1 of the SoundDescription record
SoundDescriptionV1		RECORD 0
;  original fields
desc					 ds		SoundDescription ; offset: $0 (0)
;  fixed compression ratio information
samplesPerPacket		 ds.l	1				; offset: $24 (36)
bytesPerPacket			 ds.l	1				; offset: $28 (40)
bytesPerFrame			 ds.l	1				; offset: $2C (44)
bytesPerSample			 ds.l	1				; offset: $30 (48)
;  additional atom based fields ([long size, long type, some data], repeat)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct SoundDescriptionV1 *	SoundDescriptionV1Ptr

; typedef SoundDescriptionV1Ptr *		SoundDescriptionV1Handle

TextDescription			RECORD 0
descSize				 ds.l	1				; offset: $0 (0)		;  Total size of TextDescription
dataFormat				 ds.l	1				; offset: $4 (4)		;  'text'
resvd1					 ds.l	1				; offset: $8 (8)
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
displayFlags			 ds.l	1				; offset: $10 (16)		;  see enum below for flag values
textJustification		 ds.l	1				; offset: $14 (20)		;  Can be: teCenter,teFlush -Default,-Right,-Left
bgColor					 ds		RGBColor		; offset: $18 (24)		;  Background color
defaultTextBox			 ds		Rect			; offset: $1E (30)		;  Location to place the text within the track bounds
defaultStyle			 ds		ScrpSTElement	; offset: $26 (38)		;  Default style (struct defined in TextEdit.h)
defaultFontName			 ds.b	1				; offset: $3A (58) <-- really an array of length one ;  Font Name (pascal string - struct extended to fit) 
						 ORG 60
sizeof					 EQU *					; size:   $3C (60)
						ENDR
; typedef struct TextDescription *		TextDescriptionPtr

; typedef TextDescriptionPtr *			TextDescriptionHandle

SpriteDescription		RECORD 0
descSize				 ds.l	1				; offset: $0 (0)		;  total size of SpriteDescription including extra data 
dataFormat				 ds.l	1				; offset: $4 (4)		;   
resvd1					 ds.l	1				; offset: $8 (8)		;  reserved for apple use 
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
version					 ds.l	1				; offset: $10 (16)		;  which version is this data 
decompressorType		 ds.l	1				; offset: $14 (20)		;  which decompressor to use, 0 for no decompression 
sampleFlags				 ds.l	1				; offset: $18 (24)		;  how to interpret samples 
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct SpriteDescription *	SpriteDescriptionPtr

; typedef SpriteDescriptionPtr *		SpriteDescriptionHandle

FlashDescription		RECORD 0
descSize				 ds.l	1				; offset: $0 (0)
dataFormat				 ds.l	1				; offset: $4 (4)
resvd1					 ds.l	1				; offset: $8 (8)
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
version					 ds.l	1				; offset: $10 (16)		;  which version is this data 
decompressorType		 ds.l	1				; offset: $14 (20)		;  which decompressor to use, 0 for no decompression 
flags					 ds.l	1				; offset: $18 (24)
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct FlashDescription *		FlashDescriptionPtr

; typedef FlashDescriptionPtr *			FlashDescriptionHandle

ThreeDeeDescription		RECORD 0
descSize				 ds.l	1				; offset: $0 (0)		;  total size of ThreeDeeDescription including extra data 
dataFormat				 ds.l	1				; offset: $4 (4)		;   
resvd1					 ds.l	1				; offset: $8 (8)		;  reserved for apple use 
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
version					 ds.l	1				; offset: $10 (16)		;  which version is this data 
rendererType			 ds.l	1				; offset: $14 (20)		;  which renderer to use, 0 for default 
decompressorType		 ds.l	1				; offset: $18 (24)		;  which decompressor to use, 0 for default 
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct ThreeDeeDescription *	ThreeDeeDescriptionPtr

; typedef ThreeDeeDescriptionPtr *		ThreeDeeDescriptionHandle

DataReferenceRecord		RECORD 0
dataRefType				 ds.l	1				; offset: $0 (0)
dataRef					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct DataReferenceRecord *	DataReferencePtr

; --------------------------
;  Music Sample Description
;--------------------------

MusicDescription		RECORD 0
descSize				 ds.l	1				; offset: $0 (0)
dataFormat				 ds.l	1				; offset: $4 (4)		;  'musi' 
resvd1					 ds.l	1				; offset: $8 (8)
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
musicFlags				 ds.l	1				; offset: $10 (16)
headerData				 ds.l	1				; offset: $14 (20) <-- really an array of length one ;  variable size! 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct MusicDescription *		MusicDescriptionPtr

; typedef MusicDescriptionPtr *			MusicDescriptionHandle


kMusicFlagDontPlay2Soft			EQU		$00000001
kMusicFlagDontSlaveToMovie		EQU		$00000002


dfDontDisplay					EQU		$01					; Don't display the text
dfDontAutoScale					EQU		$02					; Don't scale text as track bounds grows or shrinks
dfClipToTextBox					EQU		$04					; Clip update to the textbox
dfUseMovieBGColor				EQU		$08					; Set text background to movie's background color
dfShrinkTextBoxToFit			EQU		$10					; Compute minimum box to fit the sample
dfScrollIn						EQU		$20					; Scroll text in until last of text is in view 
dfScrollOut						EQU		$40					; Scroll text out until last of text is gone (if both set, scroll in then out)
dfHorizScroll					EQU		$80					; Scroll text horizontally (otherwise it's vertical)
dfReverseScroll					EQU		$0100				; vert: scroll down rather than up; horiz: scroll backwards (justfication dependent)
dfContinuousScroll				EQU		$0200				; new samples cause previous samples to scroll out 
dfFlowHoriz						EQU		$0400				; horiz scroll text flows in textbox rather than extend to right 
dfContinuousKaraoke				EQU		$0800				; ignore begin offset, hilite everything up to the end offset(karaoke)
dfDropShadow					EQU		$1000				; display text with a drop shadow 
dfAntiAlias						EQU		$2000				; attempt to display text anti aliased
dfKeyedText						EQU		$4000				; key the text over background
dfInverseHilite					EQU		$8000				; Use inverse hiliting rather than using hilite color
dfTextColorHilite				EQU		$00010000			; changes text color in place of hiliting. 

searchTextDontGoToFoundTime		EQU		$00010000
searchTextDontHiliteFoundText	EQU		$00020000
searchTextOneTrackOnly			EQU		$00040000
searchTextEnabledTracksOnly		EQU		$00080000
; use these with the text property routines

kTextTextHandle					EQU		1
kTextTextPtr					EQU		2
kTextTEStyle					EQU		3
kTextSetSelection				EQU		4
kTextBackColor					EQU		5
kTextForeColor					EQU		6
kTextFace						EQU		7
kTextFont						EQU		8
kTextSize						EQU		9
kTextAlignment					EQU		10
kTextHilite						EQU		11
kTextDropShadow					EQU		12
kTextDisplayFlags				EQU		13
kTextScroll						EQU		14

k3DMediaRendererEntry			EQU		'rend'
k3DMediaRendererName			EQU		'name'
k3DMediaRendererCode			EQU		'rcod'
;  progress messages 

movieProgressOpen				EQU		0
movieProgressUpdatePercent		EQU		1
movieProgressClose				EQU		2
;  progress operations 

progressOpFlatten				EQU		1
progressOpInsertTrackSegment	EQU		2
progressOpInsertMovieSegment	EQU		3
progressOpPaste					EQU		4
progressOpAddMovieSelection		EQU		5
progressOpCopy					EQU		6
progressOpCut					EQU		7
progressOpLoadMovieIntoRam		EQU		8
progressOpLoadTrackIntoRam		EQU		9
progressOpLoadMediaIntoRam		EQU		10
progressOpImportMovie			EQU		11
progressOpExportMovie			EQU		12

mediaQualityDraft				EQU		$0000
mediaQualityNormal				EQU		$0040
mediaQualityBetter				EQU		$0080
mediaQualityBest				EQU		$00C0
; *****
;    Interactive Sprites Support
;****

QTEventRecord			RECORD 0
version					 ds.l	1				; offset: $0 (0)
eventType				 ds.l	1				; offset: $4 (4)
where					 ds		Point			; offset: $8 (8)
flags					 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct QTEventRecord *		QTEventRecordPtr

QTAtomSpec				RECORD 0
container				 ds.l	1				; offset: $0 (0)
atom					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct QTAtomSpec *			QTAtomSpecPtr

ResolvedQTEventSpec		RECORD 0
actionAtom				 ds		QTAtomSpec		; offset: $0 (0)
targetTrack				 ds.l	1				; offset: $8 (8)
targetRefCon			 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct ResolvedQTEventSpec *	ResolvedQTEventSpecPtr


;  action constants 

kActionMovieSetVolume			EQU		1024				; (short movieVolume) 
kActionMovieSetRate				EQU		1025				; (Fixed rate) 
kActionMovieSetLoopingFlags		EQU		1026				; (long loopingFlags) 
kActionMovieGoToTime			EQU		1027				; (TimeValue time) 
kActionMovieGoToTimeByName		EQU		1028				; (Str255 timeName) 
kActionMovieGoToBeginning		EQU		1029				; no params 
kActionMovieGoToEnd				EQU		1030				; no params 
kActionMovieStepForward			EQU		1031				; no params 
kActionMovieStepBackward		EQU		1032				; no params 
kActionMovieSetSelection		EQU		1033				; (TimeValue startTime, TimeValue endTime) 
kActionMovieSetSelectionByName	EQU		1034				; (Str255 startTimeName, Str255 endTimeName) 
kActionMoviePlaySelection		EQU		1035				; (Boolean selectionOnly) 
kActionMovieSetLanguage			EQU		1036				; (long language) 
kActionMovieChanged				EQU		1037				; no params 
kActionMovieRestartAtTime		EQU		1038				; (TimeValue startTime, Fixed rate) 
kActionTrackSetVolume			EQU		2048				; (short volume) 
kActionTrackSetBalance			EQU		2049				; (short balance) 
kActionTrackSetEnabled			EQU		2050				; (Boolean enabled) 
kActionTrackSetMatrix			EQU		2051				; (MatrixRecord matrix) 
kActionTrackSetLayer			EQU		2052				; (short layer) 
kActionTrackSetClip				EQU		2053				; (RgnHandle clip) 
kActionTrackSetCursor			EQU		2054				; (QTATomID cursorID) 
kActionTrackSetGraphicsMode		EQU		2055				; (ModifierTrackGraphicsModeRecord graphicsMode) 
kActionSpriteSetMatrix			EQU		3072				; (MatrixRecord matrix) 
kActionSpriteSetImageIndex		EQU		3073				; (short imageIndex) 
kActionSpriteSetVisible			EQU		3074				; (short visible) 
kActionSpriteSetLayer			EQU		3075				; (short layer) 
kActionSpriteSetGraphicsMode	EQU		3076				; (ModifierTrackGraphicsModeRecord graphicsMode) 
kActionSpritePassMouseToCodec	EQU		3078				; no params 
kActionSpriteClickOnCodec		EQU		3079				; Point localLoc 
kActionSpriteTranslate			EQU		3080				; (Fixed x, Fixed y, Boolean isAbsolute) 
kActionSpriteScale				EQU		3081				; (Fixed xScale, Fixed yScale) 
kActionSpriteRotate				EQU		3082				; (Fixed degrees) 
kActionSpriteStretch			EQU		3083				; (Fixed p1x, Fixed p1y, Fixed p2x, Fixed p2y, Fixed p3x, Fixed p3y, Fixed p4x, Fixed p4y) 
kActionQTVRSetPanAngle			EQU		4096				; (float panAngle) 
kActionQTVRSetTiltAngle			EQU		4097				; (float tiltAngle) 
kActionQTVRSetFieldOfView		EQU		4098				; (float fieldOfView) 
kActionQTVRShowDefaultView		EQU		4099				; no params 
kActionQTVRGoToNodeID			EQU		4100				; (UInt32 nodeID) 
kActionMusicPlayNote			EQU		5120				; (long sampleDescIndex, long partNumber, long delay, long pitch, long velocity, long duration) 
kActionMusicSetController		EQU		5121				; (long sampleDescIndex, long partNumber, long delay, long controller, long value) 
kActionCase						EQU		6144				; [(CaseStatementActionAtoms)] 
kActionWhile					EQU		6145				; [(WhileStatementActionAtoms)] 
kActionGoToURL					EQU		6146				; (C string urlLink) 
kActionSendQTEventToSprite		EQU		6147				; ([(SpriteTargetAtoms)], QTEventRecord theEvent) 
kActionDebugStr					EQU		6148				; (Str255 theString) 
kActionPushCurrentTime			EQU		6149				; no params 
kActionPushCurrentTimeWithLabel	EQU		6150				; (Str255 theLabel) 
kActionPopAndGotoTopTime		EQU		6151				; no params 
kActionPopAndGotoLabeledTime	EQU		6152				; (Str255 theLabel) 
kActionStatusString				EQU		6153				; (C string theString, long stringTypeFlags) 
kActionSendQTEventToTrackObject	EQU		6154				; ([(TrackObjectTargetAtoms)], QTEventRecord theEvent) 
kActionAddChannelSubscription	EQU		6155				; (Str255 channelName, C string channelsURL, C string channelsPictureURL) 
kActionRemoveChannelSubscription EQU	6156				; (C string channelsURL) 
kActionOpenCustomActionHandler	EQU		6157				; (long handlerID, ComponentDescription handlerDesc) 
kActionDoScript					EQU		6158				; (long scriptTypeFlags, CString command, CString arguments) 
kActionSpriteTrackSetVariable	EQU		7168				; (QTAtomID variableID, float value) 
kActionSpriteTrackNewSprite		EQU		7169				; (QTAtomID spriteID, short imageIndex, MatrixRecord *matrix, short visible, short layer, ModifierTrackGraphicsModeRecord *graphicsMode, QTAtomID actionHandlingSpriteID) 
kActionSpriteTrackDisposeSprite	EQU		7170				; (QTAtomID spriteID) 
kActionSpriteTrackSetVariableToString EQU 7171				; (QTAtomID variableID, C string value) 
kActionSpriteTrackConcatVariables EQU	7172				; (QTAtomID firstVariableID, QTAtomID secondVariableID, QTAtomID resultVariableID ) 
kActionSpriteTrackSetVariableToMovieURL EQU 7173			; (QTAtomID variableID, < optional: [(MovieTargetAtoms)] > ) 
kActionSpriteTrackSetVariableToMovieBaseURL EQU 7174		; (QTAtomID variableID, < optional: [(MovieTargetAtoms)] > ) 
kActionApplicationNumberAndString EQU	8192				; (long aNumber, Str255 aString ) 
kActionQD3DNamedObjectTranslateTo EQU	9216				; (Fixed x, Fixed y, Fixed z ) 
kActionQD3DNamedObjectScaleTo	EQU		9217				; (Fixed xScale, Fixed yScale, Fixed zScale ) 
kActionQD3DNamedObjectRotateTo	EQU		9218				; (Fixed xDegrees, Fixed yDegrees, Fixed zDegrees ) 
kActionFlashTrackSetPan			EQU		10240				; (short xPercent, short yPercent ) 
kActionFlashTrackSetZoom		EQU		10241				; (short zoomFactor ) 
kActionFlashTrackSetZoomRect	EQU		10242				; (long left, long top, long right, long bottom ) 
kActionFlashTrackGotoFrameNumber EQU	10243				; (long frameNumber ) 
kActionFlashTrackGotoFrameLabel	EQU		10244				; (C string frameLabel ) 
kActionMovieTrackAddChildMovie	EQU		11264				; (QTAtomID childMovieID, C string childMovieURL) 
kActionMovieTrackLoadChildMovie	EQU		11265				; (QTAtomID childMovieID) 

kOperandExpression				EQU		1
kOperandConstant				EQU		2
kOperandSubscribedToChannel		EQU		3					; C string channelsURL 
kOperandUniqueCustomActionHandlerID EQU	4
kOperandCustomActionHandlerIDIsOpen EQU	5					; long ID 
kOperandConnectionSpeed			EQU		6
kOperandGMTDay					EQU		7
kOperandGMTMonth				EQU		8
kOperandGMTYear					EQU		9
kOperandGMTHours				EQU		10
kOperandGMTMinutes				EQU		11
kOperandGMTSeconds				EQU		12
kOperandLocalDay				EQU		13
kOperandLocalMonth				EQU		14
kOperandLocalYear				EQU		15
kOperandLocalHours				EQU		16
kOperandLocalMinutes			EQU		17
kOperandLocalSeconds			EQU		18
kOperandRegisteredForQuickTimePro EQU	19
kOperandPlatformRunningOn		EQU		20
kOperandQuickTimeVersion		EQU		21
kOperandComponentVersion		EQU		22					; C string type, C string subType, C string manufacturer 
kOperandOriginalHandlerRefcon	EQU		23
kOperandTicks					EQU		24
kOperandMaxLoadedTimeInMovie	EQU		25
kOperandMovieVolume				EQU		1024
kOperandMovieRate				EQU		1025
kOperandMovieIsLooping			EQU		1026
kOperandMovieLoopIsPalindrome	EQU		1027
kOperandMovieTime				EQU		1028
kOperandTrackVolume				EQU		2048
kOperandTrackBalance			EQU		2049
kOperandTrackEnabled			EQU		2050
kOperandTrackLayer				EQU		2051
kOperandTrackWidth				EQU		2052
kOperandTrackHeight				EQU		2053
kOperandSpriteBoundsLeft		EQU		3072
kOperandSpriteBoundsTop			EQU		3073
kOperandSpriteBoundsRight		EQU		3074
kOperandSpriteBoundsBottom		EQU		3075
kOperandSpriteImageIndex		EQU		3076
kOperandSpriteVisible			EQU		3077
kOperandSpriteLayer				EQU		3078
kOperandSpriteTrackVariable		EQU		3079				; [QTAtomID variableID] 
kOperandSpriteTrackNumSprites	EQU		3080
kOperandSpriteTrackNumImages	EQU		3081
kOperandSpriteID				EQU		3082
kOperandSpriteIndex				EQU		3083
kOperandSpriteFirstCornerX		EQU		3084
kOperandSpriteFirstCornerY		EQU		3085
kOperandSpriteSecondCornerX		EQU		3086
kOperandSpriteSecondCornerY		EQU		3087
kOperandSpriteThirdCornerX		EQU		3088
kOperandSpriteThirdCornerY		EQU		3089
kOperandSpriteFourthCornerX		EQU		3090
kOperandSpriteFourthCornerY		EQU		3091
kOperandSpriteImageRegistrationPointX EQU 3092
kOperandSpriteImageRegistrationPointY EQU 3093
kOperandQTVRPanAngle			EQU		4096
kOperandQTVRTiltAngle			EQU		4097
kOperandQTVRFieldOfView			EQU		4098
kOperandQTVRNodeID				EQU		4099
kOperandMouseLocalHLoc			EQU		5120				; [TargetAtoms aTrack] 
kOperandMouseLocalVLoc			EQU		5121				; [TargetAtoms aTrack] 
kOperandKeyIsDown				EQU		5122				; [short modKeys, char asciiValue] 
kOperandRandom					EQU		5123				; [short min, short max] 

kFirstMovieAction				EQU		1024
kLastMovieAction				EQU		1038
kFirstTrackAction				EQU		2048
kLastTrackAction				EQU		2055
kFirstSpriteAction				EQU		3072
kLastSpriteAction				EQU		3083
kFirstQTVRAction				EQU		4096
kLastQTVRAction					EQU		4100
kFirstMusicAction				EQU		5120
kLastMusicAction				EQU		5121
kFirstSystemAction				EQU		6144
kLastSystemAction				EQU		6158
kFirstSpriteTrackAction			EQU		7168
kLastSpriteTrackAction			EQU		7174
kFirstApplicationAction			EQU		8192
kLastApplicationAction			EQU		8192
kFirstQD3DNamedObjectAction		EQU		9216
kLastQD3DNamedObjectAction		EQU		9218
kFirstFlashTrackAction			EQU		10240
kLastFlashTrackAction			EQU		10244
kFirstMovieTrackAction			EQU		11264
kLastMovieTrackAction			EQU		11265
kFirstAction					EQU		1024
kLastAction						EQU		11265

;  target atom types

kTargetMovie					EQU		'moov'				; no data 
kTargetMovieName				EQU		'mona'				; (PString movieName) 
kTargetMovieID					EQU		'moid'				; (long movieID) 
kTargetRootMovie				EQU		'moro'				; no data 
kTargetParentMovie				EQU		'mopa'				; no data 
kTargetChildMovieTrackName		EQU		'motn'				; (PString childMovieTrackName) 
kTargetChildMovieTrackID		EQU		'moti'				; (long childMovieTrackID) 
kTargetChildMovieTrackIndex		EQU		'motx'				; (long childMovieTrackIndex) 
kTargetChildMovieMovieName		EQU		'momn'				; (PString childMovieName) 
kTargetChildMovieMovieID		EQU		'momi'				; (long childMovieID) 
kTargetTrackName				EQU		'trna'				; (PString trackName) 
kTargetTrackID					EQU		'trid'				; (long trackID) 
kTargetTrackType				EQU		'trty'				; (OSType trackType) 
kTargetTrackIndex				EQU		'trin'				; (long trackIndex) 
kTargetSpriteName				EQU		'spna'				; (PString spriteName) 
kTargetSpriteID					EQU		'spid'				; (QTAtomID spriteID) 
kTargetSpriteIndex				EQU		'spin'				; (short spriteIndex) 
kTargetQD3DNamedObjectName		EQU		'nana'				; (CString objectName) 
;  action container atom types

kQTEventType					EQU		'evnt'
kAction							EQU		'actn'
kWhichAction					EQU		'whic'
kActionParameter				EQU		'parm'
kActionTarget					EQU		'targ'
kActionFlags					EQU		'flag'
kActionParameterMinValue		EQU		'minv'
kActionParameterMaxValue		EQU		'maxv'
kActionListAtomType				EQU		'list'
kExpressionContainerAtomType	EQU		'expr'
kConditionalAtomType			EQU		'test'
kOperatorAtomType				EQU		'oper'
kOperandAtomType				EQU		'oprn'
kCommentAtomType				EQU		'why '
kCustomActionHandler			EQU		'cust'
kCustomHandlerID				EQU		'id  '
kCustomHandlerDesc				EQU		'desc'
kQTEventRecordAtomType			EQU		'erec'
;  QTEvent types 

kQTEventMouseClick				EQU		'clik'
kQTEventMouseClickEnd			EQU		'cend'
kQTEventMouseClickEndTriggerButton EQU	'trig'
kQTEventMouseEnter				EQU		'entr'
kQTEventMouseExit				EQU		'exit'
kQTEventMouseMoved				EQU		'move'
kQTEventFrameLoaded				EQU		'fram'
kQTEventIdle					EQU		'idle'
kQTEventKey						EQU		'key '				; qtevent.where.h = key, qtevent.where.v = modifiers, qtEvent.flags = scanCode 
kQTEventMovieLoaded				EQU		'load'
kQTEventRequestToModifyMovie	EQU		'reqm'
;  flags for the kActionFlags atom 

kActionFlagActionIsDelta		EQU		$00000002
kActionFlagParameterWrapsAround	EQU		$00000004
kActionFlagActionIsToggle		EQU		$00000008
;  flags for stringTypeFlags field of the QTStatusStringRecord 

kStatusStringIsURLLink			EQU		$00000002
kStatusStringIsStreamingStatus	EQU		$00000004
kStatusHasCodeNumber			EQU		$00000008			; high 16 bits of stringTypeFlags is error code number
kStatusIsError					EQU		$00000010
;  flags for scriptTypeFlags field of the QTDoScriptRecord

kScriptIsUnknownType			EQU		$00000001
kScriptIsJavaScript				EQU		$00000002
kScriptIsLingoEvent				EQU		$00000004
kScriptIsVBEvent				EQU		$00000008
kScriptIsProjectorCommand		EQU		$00000010
;  flags for CheckQuickTimeRegistration routine

kQTRegistrationDialogTimeOutFlag EQU	$01
kQTRegistrationDialogShowDialog	EQU		$02
kQTRegistrationDialogForceDialog EQU	$04
;  constants for kOperatorAtomType IDs (operator types)

kOperatorAdd					EQU		'add '
kOperatorSubtract				EQU		'sub '
kOperatorMultiply				EQU		'mult'
kOperatorDivide					EQU		'div '
kOperatorOr						EQU		'or  '
kOperatorAnd					EQU		'and '
kOperatorNot					EQU		'not '
kOperatorLessThan				EQU		'<   '
kOperatorLessThanEqualTo		EQU		'<=  '
kOperatorEqualTo				EQU		'=   '
kOperatorNotEqualTo				EQU		'!=  '
kOperatorGreaterThan			EQU		'>   '
kOperatorGreaterThanEqualTo		EQU		'>=  '
kOperatorModulo					EQU		'mod '
kOperatorIntegerDivide			EQU		'idiv'
kOperatorAbsoluteValue			EQU		'abs '
kOperatorNegate					EQU		'neg '
;  constants for kOperandPlatformRunningOn

kPlatformMacintosh				EQU		1
kPlatformWindows				EQU		2
;  constants for MediaPropertiesAtom

kMediaPropertyNonLinearAtomType	EQU		'nonl'
kMediaPropertyHasActions		EQU		105
; typedef ComponentInstance 			MediaHandler

; typedef ComponentInstance 			DataHandler

; typedef Component 					MediaHandlerComponent

; typedef Component 					DataHandlerComponent

; typedef ComponentResult 				HandlerError

;  TimeBase equates 
; typedef long 							TimeValue

; typedef long 							TimeScale

CompTimeValue			RECORD 0
f						 ds		wide
sizeof					 EQU *					; size:   $8 (8)
						ENDR


TimeValue64				RECORD 0
f						 ds		SInt64
sizeof					 EQU *					; size:   $8 (8)
						ENDR



loopTimeBase					EQU		1
palindromeLoopTimeBase			EQU		2
maintainTimeBaseZero			EQU		4
; typedef unsigned long 				TimeBaseFlags

TimeBaseRecord			RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct TimeBaseRecord *		TimeBase

CallBackRecord			RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct CallBackRecord *		QTCallBack

TimeRecord				RECORD 0
value					 ds		CompTimeValue	; offset: $0 (0)		;  units 
scale					 ds.l	1				; offset: $8 (8)		;  units per second 
base					 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
;  CallBack equates 

triggerTimeFwd					EQU		$0001				; when curTime exceeds triggerTime going forward 
triggerTimeBwd					EQU		$0002				; when curTime exceeds triggerTime going backwards 
triggerTimeEither				EQU		$0003				; when curTime exceeds triggerTime going either direction 
triggerRateLT					EQU		$0004				; when rate changes to less than trigger value 
triggerRateGT					EQU		$0008				; when rate changes to greater than trigger value 
triggerRateEqual				EQU		$0010				; when rate changes to equal trigger value 
triggerRateLTE					EQU		$0014
triggerRateGTE					EQU		$0018
triggerRateNotEqual				EQU		$001C
triggerRateChange				EQU		0
triggerAtStart					EQU		$0001
triggerAtStop					EQU		$0002
; typedef unsigned short 				QTCallBackFlags


timeBaseBeforeStartTime			EQU		1
timeBaseAfterStopTime			EQU		2
; typedef unsigned long 				TimeBaseStatus


callBackAtTime					EQU		1
callBackAtRate					EQU		2
callBackAtTimeJump				EQU		3
callBackAtExtremes				EQU		4
callBackAtTimeBaseDisposed		EQU		5
callBackAtInterrupt				EQU		$8000
callBackAtDeferredTask			EQU		$4000
; typedef unsigned short 				QTCallBackType


qtcbNeedsRateChanges			EQU		1					; wants to know about rate changes 
qtcbNeedsTimeChanges			EQU		2					; wants to know about time changes 
qtcbNeedsStartStopChanges		EQU		4					; wants to know when TimeBase start/stop is changed
QTCallBackHeader		RECORD 0
callBackFlags			 ds.l	1				; offset: $0 (0)
reserved1				 ds.l	1				; offset: $4 (4)
qtPrivate				 ds.b	40				; offset: $8 (8)
sizeof					 EQU *					; size:   $30 (48)
						ENDR
QTSyncTaskRecord		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
proc					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct QTSyncTaskRecord *		QTSyncTaskPtr


keepInRam						EQU		$01					; load and make non-purgable
unkeepInRam						EQU		$02					; mark as purgable
flushFromRam					EQU		$04					; empty those handles
loadForwardTrackEdits			EQU		$08					;    load track edits into ram for playing forward
loadBackwardTrackEdits			EQU		$10					;    load track edits into ram for playing in reverse

newMovieActive					EQU		$01
newMovieDontResolveDataRefs		EQU		$02
newMovieDontAskUnresolvedDataRefs EQU	$04
newMovieDontAutoAlternates		EQU		$08
newMovieDontUpdateForeBackPointers EQU	$10
newMovieDontAutoUpdateClock		EQU		$20
newMovieAsyncOK					EQU		$0100
newMovieIdleImportOK			EQU		$0400
;  track usage bits 

trackUsageInMovie				EQU		$02
trackUsageInPreview				EQU		$04
trackUsageInPoster				EQU		$08
;  Add/GetMediaSample flags 

mediaSampleNotSync				EQU		$01					; sample is not a sync sample (eg. is frame differenced 
mediaSampleShadowSync			EQU		$02					; sample is a shadow sync 

pasteInParallel					EQU		$01
showUserSettingsDialog			EQU		$02
movieToFileOnlyExport			EQU		$04
movieFileSpecValid				EQU		$08

nextTimeMediaSample				EQU		$01
nextTimeMediaEdit				EQU		$02
nextTimeTrackEdit				EQU		$04
nextTimeSyncSample				EQU		$08
nextTimeStep					EQU		$10
nextTimeEdgeOK					EQU		$4000
nextTimeIgnoreActiveSegment		EQU		$8000
; typedef unsigned short 				nextTimeFlagsEnum


createMovieFileDeleteCurFile	EQU		$80000000
createMovieFileDontCreateMovie	EQU		$40000000
createMovieFileDontOpenFile		EQU		$20000000
createMovieFileDontCreateResFile EQU	$10000000
; typedef unsigned long 				createMovieFileFlagsEnum


flattenAddMovieToDataFork		EQU		$00000001
flattenActiveTracksOnly			EQU		$00000004
flattenDontInterleaveFlatten	EQU		$00000008
flattenFSSpecPtrIsDataRefRecordPtr EQU	$00000010
flattenCompressMovieResource	EQU		$00000020
flattenForceMovieResourceBeforeMovieData EQU $00000040
; typedef unsigned long 				movieFlattenFlagsEnum


movieInDataForkResID			EQU		-1					; magic res ID 

mcTopLeftMovie					EQU		$01					; usually centered 
mcScaleMovieToFit				EQU		$02					; usually only scales down 
mcWithBadge						EQU		$04					; give me a badge 
mcNotVisible					EQU		$08					; don't show controller 
mcWithFrame						EQU		$10					; gimme a frame 

movieScrapDontZeroScrap			EQU		$01
movieScrapOnlyPutMovie			EQU		$02

dataRefSelfReference			EQU		$01
dataRefWasNotResolved			EQU		$02
; typedef unsigned long 				dataRefAttributesFlags


kMovieAnchorDataRefIsDefault	EQU		$01					; data ref returned is movie default data ref 

hintsScrubMode					EQU		$01					; mask == && (if flags == scrub on, flags != scrub off) 
hintsLoop						EQU		$02
hintsDontPurge					EQU		$04
hintsUseScreenBuffer			EQU		$20
hintsAllowInterlace				EQU		$40
hintsUseSoundInterp				EQU		$80
hintsHighQuality				EQU		$0100				; slooooow 
hintsPalindrome					EQU		$0200
hintsInactive					EQU		$0800
hintsOffscreen					EQU		$1000
hintsDontDraw					EQU		$2000
hintsAllowBlacklining			EQU		$4000
hintsDontUseVideoOverlaySurface	EQU		$00010000
hintsIgnoreBandwidthRestrictions EQU	$00020000
hintsPlayingEveryFrame			EQU		$00040000
hintsAllowDynamicResize			EQU		$00080000
hintsSingleField				EQU		$00100000
; typedef unsigned long 				playHintsEnum


mediaHandlerFlagBaseClient		EQU		1
; typedef unsigned long 				mediaHandlerFlagsEnum


movieTrackMediaType				EQU		$01
movieTrackCharacteristic		EQU		$02
movieTrackEnabledOnly			EQU		$04
SampleReferenceRecord	RECORD 0
dataOffset				 ds.l	1				; offset: $0 (0)
dataSize				 ds.l	1				; offset: $4 (4)
durationPerSample		 ds.l	1				; offset: $8 (8)
numberOfSamples			 ds.l	1				; offset: $C (12)
sampleFlags				 ds.w	1				; offset: $10 (16)
sizeof					 EQU *					; size:   $12 (18)
						ENDR
; typedef struct SampleReferenceRecord * SampleReferencePtr

SampleReference64Record	RECORD 0
dataOffset				 ds		wide			; offset: $0 (0)
dataSize				 ds.l	1				; offset: $8 (8)
durationPerSample		 ds.l	1				; offset: $C (12)
numberOfSamples			 ds.l	1				; offset: $10 (16)
sampleFlags				 ds.w	1				; offset: $14 (20)
sizeof					 EQU *					; size:   $16 (22)
						ENDR
; typedef struct SampleReference64Record * SampleReference64Ptr


; *************************
;* Initialization Routines 
;*************************

	IF CALL_NOT_IN_CARBON THEN
;
; pascal void CheckQuickTimeRegistration(void *registrationKey, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CheckQuickTimeRegistration
			move.w              #$02DA,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CheckQuickTimeRegistration
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
;
; pascal OSErr EnterMovies(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_EnterMovies
			moveq           	#1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EnterMovies
	ENDIF

;
; pascal void ExitMovies(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ExitMovies
			moveq           	#2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ExitMovies
	ENDIF

; *************************
;* Error Routines 
;*************************


;
; pascal OSErr GetMoviesError(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviesError
			moveq           	#3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviesError
	ENDIF

;
; pascal void ClearMoviesStickyError(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClearMoviesStickyError
			move.w              #$00DE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClearMoviesStickyError
	ENDIF

;
; pascal OSErr GetMoviesStickyError(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviesStickyError
			moveq           	#4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviesStickyError
	ENDIF

;
; pascal void SetMoviesErrorProc(MoviesErrorUPP errProc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviesErrorProc
			move.w              #$00EF,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviesErrorProc
	ENDIF


; *************************
;* Idle Routines 
;*************************

;
; pascal void MoviesTask(Movie theMovie, long maxMilliSecToUse)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MoviesTask
			moveq           	#5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MoviesTask
	ENDIF

;
; pascal OSErr PrerollMovie(Movie theMovie, TimeValue time, Fixed Rate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PrerollMovie
			moveq           	#6,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PrerollMovie
	ENDIF

;
; pascal OSErr PrePrerollMovie(Movie m, TimeValue time, Fixed rate, MoviePrePrerollCompleteUPP proc, void *refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PrePrerollMovie
			move.w              #$02F7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PrePrerollMovie
	ENDIF

;
; pascal void AbortPrePrerollMovie(Movie m, OSErr err)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AbortPrePrerollMovie
			move.w              #$02F8,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AbortPrePrerollMovie
	ENDIF

;
; pascal OSErr LoadMovieIntoRam(Movie theMovie, TimeValue time, TimeValue duration, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LoadMovieIntoRam
			moveq           	#7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LoadMovieIntoRam
	ENDIF

;
; pascal OSErr LoadTrackIntoRam(Track theTrack, TimeValue time, TimeValue duration, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LoadTrackIntoRam
			move.w              #$016E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LoadTrackIntoRam
	ENDIF

;
; pascal OSErr LoadMediaIntoRam(Media theMedia, TimeValue time, TimeValue duration, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LoadMediaIntoRam
			moveq           	#8,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LoadMediaIntoRam
	ENDIF

;
; pascal void SetMovieActive(Movie theMovie, Boolean active)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieActive
			moveq           	#9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieActive
	ENDIF

;
; pascal Boolean GetMovieActive(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieActive
			moveq           	#10,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieActive
	ENDIF

; *************************
;* calls for playing movies, previews, posters
;*************************

;
; pascal void StartMovie(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_StartMovie
			moveq           	#11,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StartMovie
	ENDIF

;
; pascal void StopMovie(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_StopMovie
			moveq           	#12,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StopMovie
	ENDIF

;
; pascal void GoToBeginningOfMovie(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GoToBeginningOfMovie
			moveq           	#13,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GoToBeginningOfMovie
	ENDIF

;
; pascal void GoToEndOfMovie(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GoToEndOfMovie
			moveq           	#14,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GoToEndOfMovie
	ENDIF

;
; pascal Boolean IsMovieDone(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IsMovieDone
			move.w              #$00DD,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsMovieDone
	ENDIF

;
; pascal Boolean GetMoviePreviewMode(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePreviewMode
			moveq           	#15,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePreviewMode
	ENDIF

;
; pascal void SetMoviePreviewMode(Movie theMovie, Boolean usePreview)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePreviewMode
			moveq           	#16,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePreviewMode
	ENDIF

;
; pascal void ShowMoviePoster(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ShowMoviePoster
			moveq           	#17,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ShowMoviePoster
	ENDIF

;
; pascal void PlayMoviePreview(Movie theMovie, MoviePreviewCallOutUPP callOutProc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PlayMoviePreview
			move.w              #$00F2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PlayMoviePreview
	ENDIF

; *************************
;* calls for controlling movies & tracks which are playing
;*************************

;
; pascal TimeBase GetMovieTimeBase(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieTimeBase
			moveq           	#18,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieTimeBase
	ENDIF

;
; pascal void SetMovieMasterTimeBase(Movie theMovie, TimeBase tb, const TimeRecord *slaveZero)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieMasterTimeBase
			move.w              #$0167,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieMasterTimeBase
	ENDIF

;
; pascal void SetMovieMasterClock(Movie theMovie, Component clockMeister, const TimeRecord *slaveZero)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieMasterClock
			move.w              #$0168,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieMasterClock
	ENDIF

;
; pascal void GetMovieGWorld(Movie theMovie, CGrafPtr *port, GDHandle *gdh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieGWorld
			moveq           	#21,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieGWorld
	ENDIF

;
; pascal void SetMovieGWorld(Movie theMovie, CGrafPtr port, GDHandle gdh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieGWorld
			moveq           	#22,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieGWorld
	ENDIF


movieDrawingCallWhenChanged		EQU		0
movieDrawingCallAlways			EQU		1
;
; pascal void SetMovieDrawingCompleteProc(Movie theMovie, long flags, MovieDrawingCompleteUPP proc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieDrawingCompleteProc
			move.w              #$01DE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieDrawingCompleteProc
	ENDIF


;
; pascal void GetMovieNaturalBoundsRect(Movie theMovie, Rect *naturalBounds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieNaturalBoundsRect
			move.w              #$022C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieNaturalBoundsRect
	ENDIF

;
; pascal Track GetNextTrackForCompositing(Movie theMovie, Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetNextTrackForCompositing
			move.w              #$01FA,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetNextTrackForCompositing
	ENDIF

;
; pascal Track GetPrevTrackForCompositing(Movie theMovie, Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetPrevTrackForCompositing
			move.w              #$01FB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPrevTrackForCompositing
	ENDIF

;
; pascal void SetTrackGWorld(Track theTrack, CGrafPtr port, GDHandle gdh, TrackTransferUPP proc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackGWorld
			move.w              #$009D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackGWorld
	ENDIF

;
; pascal PicHandle GetMoviePict(Movie theMovie, TimeValue time)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePict
			moveq           	#29,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePict
	ENDIF

;
; pascal PicHandle GetTrackPict(Track theTrack, TimeValue time)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackPict
			moveq           	#30,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackPict
	ENDIF

;
; pascal PicHandle GetMoviePosterPict(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePosterPict
			move.w              #$00F7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePosterPict
	ENDIF

;  called between Begin & EndUpdate 
;
; pascal OSErr UpdateMovie(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UpdateMovie
			moveq           	#31,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UpdateMovie
	ENDIF

;
; pascal OSErr InvalidateMovieRegion(Movie theMovie, RgnHandle invalidRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InvalidateMovieRegion
			move.w              #$022A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvalidateMovieRegion
	ENDIF

; *** spatial movie routines ***
;
; pascal void GetMovieBox(Movie theMovie, Rect *boxRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieBox
			move.w              #$00F9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieBox
	ENDIF

;
; pascal void SetMovieBox(Movie theMovie, const Rect *boxRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieBox
			move.w              #$00FA,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieBox
	ENDIF

; * movie display clip 
;
; pascal RgnHandle GetMovieDisplayClipRgn(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieDisplayClipRgn
			move.w              #$00FC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieDisplayClipRgn
	ENDIF

;
; pascal void SetMovieDisplayClipRgn(Movie theMovie, RgnHandle theClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieDisplayClipRgn
			move.w              #$00FD,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieDisplayClipRgn
	ENDIF

; * movie src clip 
;
; pascal RgnHandle GetMovieClipRgn(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieClipRgn
			move.w              #$0100,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieClipRgn
	ENDIF

;
; pascal void SetMovieClipRgn(Movie theMovie, RgnHandle theClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieClipRgn
			move.w              #$0101,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieClipRgn
	ENDIF

; * track src clip 
;
; pascal RgnHandle GetTrackClipRgn(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackClipRgn
			move.w              #$0102,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackClipRgn
	ENDIF

;
; pascal void SetTrackClipRgn(Track theTrack, RgnHandle theClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackClipRgn
			move.w              #$0103,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackClipRgn
	ENDIF

; * bounds in display space (not clipped by display clip) 
;
; pascal RgnHandle GetMovieDisplayBoundsRgn(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieDisplayBoundsRgn
			move.w              #$00FB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieDisplayBoundsRgn
	ENDIF

;
; pascal RgnHandle GetTrackDisplayBoundsRgn(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackDisplayBoundsRgn
			move.w              #$0112,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackDisplayBoundsRgn
	ENDIF

; * bounds in movie space 
;
; pascal RgnHandle GetMovieBoundsRgn(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieBoundsRgn
			move.w              #$00FE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieBoundsRgn
	ENDIF

;
; pascal RgnHandle GetTrackMovieBoundsRgn(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackMovieBoundsRgn
			move.w              #$00FF,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackMovieBoundsRgn
	ENDIF

; * bounds in track space 
;
; pascal RgnHandle GetTrackBoundsRgn(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackBoundsRgn
			move.w              #$0111,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackBoundsRgn
	ENDIF

; * mattes - always in track space 
;
; pascal PixMapHandle GetTrackMatte(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackMatte
			move.w              #$0115,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackMatte
	ENDIF

;
; pascal void SetTrackMatte(Track theTrack, PixMapHandle theMatte)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackMatte
			move.w              #$0116,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackMatte
	ENDIF

;
; pascal void DisposeMatte(PixMapHandle theMatte)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeMatte
			move.w              #$014A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeMatte
	ENDIF

; *************************
;* calls for getting/saving movies
;*************************

;
; pascal Movie NewMovie(long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovie
			move.w              #$0187,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovie
	ENDIF

;
; pascal OSErr PutMovieIntoHandle(Movie theMovie, Handle publicMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PutMovieIntoHandle
			moveq           	#34,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutMovieIntoHandle
	ENDIF

;
; pascal OSErr PutMovieIntoDataFork(Movie theMovie, short fRefNum, long offset, long maxSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PutMovieIntoDataFork
			move.w              #$01B4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutMovieIntoDataFork
	ENDIF

;
; pascal OSErr PutMovieIntoDataFork64(Movie theMovie, long fRefNum, const wide *offset, unsigned long maxSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PutMovieIntoDataFork64
			move.w              #$02EA,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutMovieIntoDataFork64
	ENDIF

;
; pascal void DisposeMovie(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeMovie
			moveq           	#35,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeMovie
	ENDIF

; *************************
;* Movie State Routines
;*************************

;
; pascal unsigned long GetMovieCreationTime(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieCreationTime
			moveq           	#38,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieCreationTime
	ENDIF

;
; pascal unsigned long GetMovieModificationTime(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieModificationTime
			moveq           	#39,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieModificationTime
	ENDIF

;
; pascal TimeScale GetMovieTimeScale(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieTimeScale
			moveq           	#41,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieTimeScale
	ENDIF

;
; pascal void SetMovieTimeScale(Movie theMovie, TimeScale timeScale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieTimeScale
			moveq           	#42,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieTimeScale
	ENDIF

;
; pascal TimeValue GetMovieDuration(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieDuration
			moveq           	#43,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieDuration
	ENDIF

;
; pascal Fixed GetMovieRate(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieRate
			moveq           	#44,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieRate
	ENDIF

;
; pascal void SetMovieRate(Movie theMovie, Fixed rate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieRate
			moveq           	#45,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieRate
	ENDIF

;
; pascal Fixed GetMoviePreferredRate(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePreferredRate
			move.w              #$00F3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePreferredRate
	ENDIF

;
; pascal void SetMoviePreferredRate(Movie theMovie, Fixed rate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePreferredRate
			move.w              #$00F4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePreferredRate
	ENDIF

;
; pascal short GetMoviePreferredVolume(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePreferredVolume
			move.w              #$00F5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePreferredVolume
	ENDIF

;
; pascal void SetMoviePreferredVolume(Movie theMovie, short volume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePreferredVolume
			move.w              #$00F6,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePreferredVolume
	ENDIF

;
; pascal short GetMovieVolume(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieVolume
			moveq           	#46,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieVolume
	ENDIF

;
; pascal void SetMovieVolume(Movie theMovie, short volume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieVolume
			moveq           	#47,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieVolume
	ENDIF

;
; pascal void GetMovieMatrix(Movie theMovie, MatrixRecord *matrix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieMatrix
			moveq           	#49,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieMatrix
	ENDIF

;
; pascal void SetMovieMatrix(Movie theMovie, const MatrixRecord *matrix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieMatrix
			moveq           	#50,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieMatrix
	ENDIF

;
; pascal void GetMoviePreviewTime(Movie theMovie, TimeValue *previewTime, TimeValue *previewDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePreviewTime
			moveq           	#51,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePreviewTime
	ENDIF

;
; pascal void SetMoviePreviewTime(Movie theMovie, TimeValue previewTime, TimeValue previewDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePreviewTime
			moveq           	#52,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePreviewTime
	ENDIF

;
; pascal TimeValue GetMoviePosterTime(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePosterTime
			moveq           	#53,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePosterTime
	ENDIF

;
; pascal void SetMoviePosterTime(Movie theMovie, TimeValue posterTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePosterTime
			moveq           	#54,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePosterTime
	ENDIF

;
; pascal void GetMovieSelection(Movie theMovie, TimeValue *selectionTime, TimeValue *selectionDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieSelection
			moveq           	#55,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieSelection
	ENDIF

;
; pascal void SetMovieSelection(Movie theMovie, TimeValue selectionTime, TimeValue selectionDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieSelection
			moveq           	#56,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieSelection
	ENDIF

;
; pascal void SetMovieActiveSegment(Movie theMovie, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieActiveSegment
			move.w              #$015C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieActiveSegment
	ENDIF

;
; pascal void GetMovieActiveSegment(Movie theMovie, TimeValue *startTime, TimeValue *duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieActiveSegment
			move.w              #$015D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieActiveSegment
	ENDIF

;
; pascal TimeValue GetMovieTime(Movie theMovie, TimeRecord *currentTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieTime
			moveq           	#57,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieTime
	ENDIF

;
; pascal void SetMovieTime(Movie theMovie, const TimeRecord *newtime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieTime
			moveq           	#60,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieTime
	ENDIF

;
; pascal void SetMovieTimeValue(Movie theMovie, TimeValue newtime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieTimeValue
			moveq           	#61,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieTimeValue
	ENDIF


;
; pascal UserData GetMovieUserData(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieUserData
			moveq           	#62,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieUserData
	ENDIF


; *************************
;* Track/Media finding routines
;*************************

;
; pascal long GetMovieTrackCount(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieTrackCount
			moveq           	#63,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieTrackCount
	ENDIF

;
; pascal Track GetMovieTrack(Movie theMovie, long trackID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieTrack
			moveq           	#64,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieTrack
	ENDIF

;
; pascal Track GetMovieIndTrack(Movie theMovie, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieIndTrack
			move.w              #$0117,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieIndTrack
	ENDIF

;
; pascal Track GetMovieIndTrackType(Movie theMovie, long index, OSType trackType, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieIndTrackType
			move.w              #$0208,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieIndTrackType
	ENDIF

;
; pascal long GetTrackID(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackID
			move.w              #$0127,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackID
	ENDIF

;
; pascal Movie GetTrackMovie(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackMovie
			move.w              #$00D0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackMovie
	ENDIF

; *************************
;* Track creation routines
;*************************

;
; pascal Track NewMovieTrack(Movie theMovie, Fixed width, Fixed height, short trackVolume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieTrack
			move.w              #$0188,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieTrack
	ENDIF

;
; pascal void DisposeMovieTrack(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeMovieTrack
			moveq           	#66,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeMovieTrack
	ENDIF

; *************************
;* Track State routines
;*************************

;
; pascal unsigned long GetTrackCreationTime(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackCreationTime
			moveq           	#67,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackCreationTime
	ENDIF

;
; pascal unsigned long GetTrackModificationTime(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackModificationTime
			moveq           	#68,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackModificationTime
	ENDIF


;
; pascal Boolean GetTrackEnabled(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackEnabled
			moveq           	#69,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackEnabled
	ENDIF

;
; pascal void SetTrackEnabled(Track theTrack, Boolean isEnabled)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackEnabled
			moveq           	#70,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackEnabled
	ENDIF

;
; pascal long GetTrackUsage(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackUsage
			moveq           	#71,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackUsage
	ENDIF

;
; pascal void SetTrackUsage(Track theTrack, long usage)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackUsage
			moveq           	#72,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackUsage
	ENDIF

;
; pascal TimeValue GetTrackDuration(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackDuration
			moveq           	#75,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackDuration
	ENDIF

;
; pascal TimeValue GetTrackOffset(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackOffset
			moveq           	#76,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackOffset
	ENDIF

;
; pascal void SetTrackOffset(Track theTrack, TimeValue movieOffsetTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackOffset
			moveq           	#77,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackOffset
	ENDIF

;
; pascal short GetTrackLayer(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackLayer
			moveq           	#80,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackLayer
	ENDIF

;
; pascal void SetTrackLayer(Track theTrack, short layer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackLayer
			moveq           	#81,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackLayer
	ENDIF

;
; pascal Track GetTrackAlternate(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackAlternate
			moveq           	#82,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackAlternate
	ENDIF

;
; pascal void SetTrackAlternate(Track theTrack, Track alternateT)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackAlternate
			moveq           	#83,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackAlternate
	ENDIF

;
; pascal void SetAutoTrackAlternatesEnabled(Movie theMovie, Boolean enable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetAutoTrackAlternatesEnabled
			move.w              #$015E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetAutoTrackAlternatesEnabled
	ENDIF

;
; pascal void SelectMovieAlternates(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SelectMovieAlternates
			move.w              #$015F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SelectMovieAlternates
	ENDIF

;
; pascal short GetTrackVolume(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackVolume
			moveq           	#84,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackVolume
	ENDIF

;
; pascal void SetTrackVolume(Track theTrack, short volume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackVolume
			moveq           	#85,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackVolume
	ENDIF

;
; pascal void GetTrackMatrix(Track theTrack, MatrixRecord *matrix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackMatrix
			moveq           	#86,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackMatrix
	ENDIF

;
; pascal void SetTrackMatrix(Track theTrack, const MatrixRecord *matrix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackMatrix
			moveq           	#87,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackMatrix
	ENDIF

;
; pascal void GetTrackDimensions(Track theTrack, Fixed *width, Fixed *height)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackDimensions
			moveq           	#93,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackDimensions
	ENDIF

;
; pascal void SetTrackDimensions(Track theTrack, Fixed width, Fixed height)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackDimensions
			moveq           	#94,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackDimensions
	ENDIF

;
; pascal UserData GetTrackUserData(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackUserData
			moveq           	#95,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackUserData
	ENDIF

;
; pascal OSErr GetTrackDisplayMatrix(Track theTrack, MatrixRecord *matrix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackDisplayMatrix
			move.w              #$0263,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackDisplayMatrix
	ENDIF

;
; pascal OSErr GetTrackSoundLocalizationSettings(Track theTrack, Handle *settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackSoundLocalizationSettings
			move.w              #$0282,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackSoundLocalizationSettings
	ENDIF

;
; pascal OSErr SetTrackSoundLocalizationSettings(Track theTrack, Handle settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackSoundLocalizationSettings
			move.w              #$0283,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackSoundLocalizationSettings
	ENDIF

; *************************
;* get Media routines
;*************************

;
; pascal Media NewTrackMedia(Track theTrack, OSType mediaType, TimeScale timeScale, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewTrackMedia
			move.w              #$018E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewTrackMedia
	ENDIF

;
; pascal void DisposeTrackMedia(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeTrackMedia
			moveq           	#97,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeTrackMedia
	ENDIF

;
; pascal Media GetTrackMedia(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackMedia
			moveq           	#98,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackMedia
	ENDIF

;
; pascal Track GetMediaTrack(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaTrack
			move.w              #$00C5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaTrack
	ENDIF



; *************************
;* Media State routines
;*************************

;
; pascal unsigned long GetMediaCreationTime(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaCreationTime
			moveq           	#102,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaCreationTime
	ENDIF

;
; pascal unsigned long GetMediaModificationTime(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaModificationTime
			moveq           	#103,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaModificationTime
	ENDIF

;
; pascal TimeScale GetMediaTimeScale(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaTimeScale
			moveq           	#104,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaTimeScale
	ENDIF

;
; pascal void SetMediaTimeScale(Media theMedia, TimeScale timeScale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaTimeScale
			moveq           	#105,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaTimeScale
	ENDIF

;
; pascal TimeValue GetMediaDuration(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDuration
			moveq           	#106,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDuration
	ENDIF

;
; pascal short GetMediaLanguage(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaLanguage
			moveq           	#107,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaLanguage
	ENDIF

;
; pascal void SetMediaLanguage(Media theMedia, short language)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaLanguage
			moveq           	#108,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaLanguage
	ENDIF

;
; pascal short GetMediaQuality(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaQuality
			moveq           	#109,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaQuality
	ENDIF

;
; pascal void SetMediaQuality(Media theMedia, short quality)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaQuality
			moveq           	#110,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaQuality
	ENDIF

;
; pascal void GetMediaHandlerDescription(Media theMedia, OSType *mediaType, Str255 creatorName, OSType *creatorManufacturer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaHandlerDescription
			moveq           	#111,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaHandlerDescription
	ENDIF

;
; pascal UserData GetMediaUserData(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaUserData
			moveq           	#112,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaUserData
	ENDIF

;
; pascal OSErr GetMediaInputMap(Media theMedia, QTAtomContainer *inputMap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaInputMap
			move.w              #$0249,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaInputMap
	ENDIF

;
; pascal OSErr SetMediaInputMap(Media theMedia, QTAtomContainer inputMap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaInputMap
			move.w              #$024A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaInputMap
	ENDIF

; *************************
;* Media Handler routines
;*************************

;
; pascal MediaHandler GetMediaHandler(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaHandler
			moveq           	#113,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaHandler
	ENDIF

;
; pascal OSErr SetMediaHandler(Media theMedia, MediaHandlerComponent mH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaHandler
			move.w              #$0190,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaHandler
	ENDIF


; *************************
;* Media's Data routines
;*************************

;
; pascal OSErr BeginMediaEdits(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_BeginMediaEdits
			moveq           	#114,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BeginMediaEdits
	ENDIF

;
; pascal OSErr EndMediaEdits(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_EndMediaEdits
			moveq           	#115,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EndMediaEdits
	ENDIF

;
; pascal OSErr SetMediaDefaultDataRefIndex(Media theMedia, short index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaDefaultDataRefIndex
			move.w              #$01E0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaDefaultDataRefIndex
	ENDIF

;
; pascal void GetMediaDataHandlerDescription(Media theMedia, short index, OSType *dhType, Str255 creatorName, OSType *creatorManufacturer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDataHandlerDescription
			move.w              #$019E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDataHandlerDescription
	ENDIF

;
; pascal DataHandler GetMediaDataHandler(Media theMedia, short index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDataHandler
			move.w              #$019F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDataHandler
	ENDIF

;
; pascal OSErr SetMediaDataHandler(Media theMedia, short index, DataHandlerComponent dataHandler)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaDataHandler
			move.w              #$01A0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaDataHandler
	ENDIF

;
; pascal Component GetDataHandler(Handle dataRef, OSType dataHandlerSubType, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetDataHandler
			move.w              #$01ED,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetDataHandler
	ENDIF

	IF CALL_NOT_IN_CARBON THEN
;
; pascal OSErr OpenADataHandler(Handle dataRef, OSType dataHandlerSubType, Handle anchorDataRef, OSType anchorDataRefType, TimeBase tb, long flags, ComponentInstance *dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OpenADataHandler
			move.w              #$031C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenADataHandler
	ENDIF

; *************************
;* Media Sample Table Routines
;*************************

	ENDIF	; CALL_NOT_IN_CARBON
;
; pascal long GetMediaSampleDescriptionCount(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSampleDescriptionCount
			moveq           	#119,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSampleDescriptionCount
	ENDIF

;
; pascal void GetMediaSampleDescription(Media theMedia, long index, SampleDescriptionHandle descH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSampleDescription
			moveq           	#120,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSampleDescription
	ENDIF

;
; pascal OSErr SetMediaSampleDescription(Media theMedia, long index, SampleDescriptionHandle descH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaSampleDescription
			move.w              #$01D0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaSampleDescription
	ENDIF

;
; pascal long GetMediaSampleCount(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSampleCount
			moveq           	#121,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSampleCount
	ENDIF

;
; pascal long GetMediaSyncSampleCount(Media theMedia)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSyncSampleCount
			move.w              #$02B2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSyncSampleCount
	ENDIF

;
; pascal void SampleNumToMediaTime(Media theMedia, long logicalSampleNum, TimeValue *sampleTime, TimeValue *sampleDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SampleNumToMediaTime
			moveq           	#122,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SampleNumToMediaTime
	ENDIF

;
; pascal void MediaTimeToSampleNum(Media theMedia, TimeValue time, long *sampleNum, TimeValue *sampleTime, TimeValue *sampleDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MediaTimeToSampleNum
			moveq           	#123,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MediaTimeToSampleNum
	ENDIF


;
; pascal OSErr AddMediaSample(Media theMedia, Handle dataIn, long inOffset, unsigned long size, TimeValue durationPerSample, SampleDescriptionHandle sampleDescriptionH, long numberOfSamples, short sampleFlags, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMediaSample
			moveq           	#124,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMediaSample
	ENDIF

;
; pascal OSErr AddMediaSampleReference(Media theMedia, long dataOffset, unsigned long size, TimeValue durationPerSample, SampleDescriptionHandle sampleDescriptionH, long numberOfSamples, short sampleFlags, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMediaSampleReference
			moveq           	#125,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMediaSampleReference
	ENDIF

;
; pascal OSErr AddMediaSampleReferences(Media theMedia, SampleDescriptionHandle sampleDescriptionH, long numberOfSamples, SampleReferencePtr sampleRefs, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMediaSampleReferences
			move.w              #$01F7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMediaSampleReferences
	ENDIF

;
; pascal OSErr AddMediaSampleReferences64(Media theMedia, SampleDescriptionHandle sampleDescriptionH, long numberOfSamples, SampleReference64Ptr sampleRefs, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMediaSampleReferences64
			move.w              #$02E8,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMediaSampleReferences64
	ENDIF

;
; pascal OSErr GetMediaSample(Media theMedia, Handle dataOut, long maxSizeToGrow, long *size, TimeValue time, TimeValue *sampleTime, TimeValue *durationPerSample, SampleDescriptionHandle sampleDescriptionH, long *sampleDescriptionIndex, long maxNumberOfSamples, long *numberOfSamples, short *sampleFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSample
			moveq           	#126,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSample
	ENDIF

;
; pascal OSErr GetMediaSampleReference(Media theMedia, long *dataOffset, long *size, TimeValue time, TimeValue *sampleTime, TimeValue *durationPerSample, SampleDescriptionHandle sampleDescriptionH, long *sampleDescriptionIndex, long maxNumberOfSamples, long *numberOfSamples, short *sampleFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSampleReference
			moveq           	#127,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSampleReference
	ENDIF

;
; pascal OSErr GetMediaSampleReferences(Media theMedia, TimeValue time, TimeValue *sampleTime, SampleDescriptionHandle sampleDescriptionH, long *sampleDescriptionIndex, long maxNumberOfEntries, long *actualNumberofEntries, SampleReferencePtr sampleRefs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSampleReferences
			move.w              #$0235,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSampleReferences
	ENDIF

;
; pascal OSErr GetMediaSampleReferences64(Media theMedia, TimeValue time, TimeValue *sampleTime, SampleDescriptionHandle sampleDescriptionH, long *sampleDescriptionIndex, long maxNumberOfEntries, long *actualNumberofEntries, SampleReference64Ptr sampleRefs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaSampleReferences64
			move.w              #$02E9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaSampleReferences64
	ENDIF

;
; pascal OSErr SetMediaPreferredChunkSize(Media theMedia, long maxChunkSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaPreferredChunkSize
			move.w              #$01F8,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaPreferredChunkSize
	ENDIF

;
; pascal OSErr GetMediaPreferredChunkSize(Media theMedia, long *maxChunkSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaPreferredChunkSize
			move.w              #$01F9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaPreferredChunkSize
	ENDIF

;
; pascal OSErr SetMediaShadowSync(Media theMedia, long frameDiffSampleNum, long syncSampleNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaShadowSync
			move.w              #$0121,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaShadowSync
	ENDIF

;
; pascal OSErr GetMediaShadowSync(Media theMedia, long frameDiffSampleNum, long *syncSampleNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaShadowSync
			move.w              #$0122,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaShadowSync
	ENDIF

; *************************
;* Editing Routines
;*************************

;
; pascal OSErr InsertMediaIntoTrack(Track theTrack, TimeValue trackStart, TimeValue mediaTime, TimeValue mediaDuration, Fixed mediaRate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InsertMediaIntoTrack
			move.w              #$0183,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InsertMediaIntoTrack
	ENDIF

;
; pascal OSErr InsertTrackSegment(Track srcTrack, Track dstTrack, TimeValue srcIn, TimeValue srcDuration, TimeValue dstIn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InsertTrackSegment
			move.w              #$0085,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InsertTrackSegment
	ENDIF

;
; pascal OSErr InsertMovieSegment(Movie srcMovie, Movie dstMovie, TimeValue srcIn, TimeValue srcDuration, TimeValue dstIn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InsertMovieSegment
			move.w              #$0086,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InsertMovieSegment
	ENDIF

;
; pascal OSErr InsertEmptyTrackSegment(Track dstTrack, TimeValue dstIn, TimeValue dstDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InsertEmptyTrackSegment
			move.w              #$0087,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InsertEmptyTrackSegment
	ENDIF

;
; pascal OSErr InsertEmptyMovieSegment(Movie dstMovie, TimeValue dstIn, TimeValue dstDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InsertEmptyMovieSegment
			move.w              #$0088,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InsertEmptyMovieSegment
	ENDIF

;
; pascal OSErr DeleteTrackSegment(Track theTrack, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DeleteTrackSegment
			move.w              #$0089,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeleteTrackSegment
	ENDIF

;
; pascal OSErr DeleteMovieSegment(Movie theMovie, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DeleteMovieSegment
			move.w              #$008A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeleteMovieSegment
	ENDIF

;
; pascal OSErr ScaleTrackSegment(Track theTrack, TimeValue startTime, TimeValue oldDuration, TimeValue newDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ScaleTrackSegment
			move.w              #$008B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ScaleTrackSegment
	ENDIF

;
; pascal OSErr ScaleMovieSegment(Movie theMovie, TimeValue startTime, TimeValue oldDuration, TimeValue newDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ScaleMovieSegment
			move.w              #$008C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ScaleMovieSegment
	ENDIF


; *************************
;* Hi-level Editing Routines
;*************************

;
; pascal Movie CutMovieSelection(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CutMovieSelection
			move.w              #$008D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CutMovieSelection
	ENDIF

;
; pascal Movie CopyMovieSelection(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CopyMovieSelection
			move.w              #$008E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyMovieSelection
	ENDIF

;
; pascal void PasteMovieSelection(Movie theMovie, Movie src)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PasteMovieSelection
			move.w              #$008F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PasteMovieSelection
	ENDIF

;
; pascal void AddMovieSelection(Movie theMovie, Movie src)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMovieSelection
			move.w              #$0152,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMovieSelection
	ENDIF

;
; pascal void ClearMovieSelection(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClearMovieSelection
			move.w              #$00E1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClearMovieSelection
	ENDIF

;
; pascal OSErr PasteHandleIntoMovie(Handle h, OSType handleType, Movie theMovie, long flags, ComponentInstance userComp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PasteHandleIntoMovie
			move.w              #$00CB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PasteHandleIntoMovie
	ENDIF

;
; pascal OSErr PutMovieIntoTypedHandle(Movie theMovie, Track targetTrack, OSType handleType, Handle publicMovie, TimeValue start, TimeValue dur, long flags, ComponentInstance userComp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PutMovieIntoTypedHandle
			move.w              #$01CD,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutMovieIntoTypedHandle
	ENDIF

;
; pascal Component IsScrapMovie(Track targetTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IsScrapMovie
			move.w              #$00CC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsScrapMovie
	ENDIF

; *************************
;* Middle-level Editing Routines
;*************************

;
; pascal OSErr CopyTrackSettings(Track srcTrack, Track dstTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CopyTrackSettings
			move.w              #$0153,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyTrackSettings
	ENDIF

;
; pascal OSErr CopyMovieSettings(Movie srcMovie, Movie dstMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CopyMovieSettings
			move.w              #$0154,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyMovieSettings
	ENDIF

;
; pascal OSErr AddEmptyTrackToMovie(Track srcTrack, Movie dstMovie, Handle dataRef, OSType dataRefType, Track *dstTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddEmptyTrackToMovie
			moveq           	#116,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddEmptyTrackToMovie
	ENDIF

; *************************
;* movie & track edit state routines
;*************************

;
; pascal MovieEditState NewMovieEditState(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieEditState
			move.w              #$0104,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieEditState
	ENDIF

;
; pascal OSErr UseMovieEditState(Movie theMovie, MovieEditState toState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UseMovieEditState
			move.w              #$0105,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UseMovieEditState
	ENDIF

;
; pascal OSErr DisposeMovieEditState(MovieEditState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeMovieEditState
			move.w              #$0106,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeMovieEditState
	ENDIF

;
; pascal TrackEditState NewTrackEditState(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewTrackEditState
			move.w              #$0107,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewTrackEditState
	ENDIF

;
; pascal OSErr UseTrackEditState(Track theTrack, TrackEditState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UseTrackEditState
			move.w              #$0108,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UseTrackEditState
	ENDIF

;
; pascal OSErr DisposeTrackEditState(TrackEditState state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeTrackEditState
			move.w              #$0109,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeTrackEditState
	ENDIF

; *************************
;* track reference routines
;*************************

;
; pascal OSErr AddTrackReference(Track theTrack, Track refTrack, OSType refType, long *addedIndex)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddTrackReference
			move.w              #$01F0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddTrackReference
	ENDIF

;
; pascal OSErr DeleteTrackReference(Track theTrack, OSType refType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DeleteTrackReference
			move.w              #$01F1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeleteTrackReference
	ENDIF

;
; pascal OSErr SetTrackReference(Track theTrack, Track refTrack, OSType refType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackReference
			move.w              #$01F2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackReference
	ENDIF

;
; pascal Track GetTrackReference(Track theTrack, OSType refType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackReference
			move.w              #$01F3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackReference
	ENDIF

;
; pascal OSType GetNextTrackReferenceType(Track theTrack, OSType refType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetNextTrackReferenceType
			move.w              #$01F4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetNextTrackReferenceType
	ENDIF

;
; pascal long GetTrackReferenceCount(Track theTrack, OSType refType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackReferenceCount
			move.w              #$01F5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackReferenceCount
	ENDIF


; *************************
;* high level file conversion routines
;*************************

;
; pascal OSErr ConvertFileToMovieFile(const FSSpec *inputFile, const FSSpec *outputFile, OSType creator, ScriptCode scriptTag, short *resID, long flags, ComponentInstance userComp, MovieProgressUPP proc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ConvertFileToMovieFile
			move.w              #$01CB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ConvertFileToMovieFile
	ENDIF

;
; pascal OSErr ConvertMovieToFile(Movie theMovie, Track onlyTrack, FSSpec *outputFile, OSType fileType, OSType creator, ScriptCode scriptTag, short *resID, long flags, ComponentInstance userComp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ConvertMovieToFile
			move.w              #$01CC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ConvertMovieToFile
	ENDIF


kGetMovieImporterValidateToFind	EQU		$00000001
kGetMovieImporterAllowNewFile	EQU		$00000002
kGetMovieImporterDontConsiderGraphicsImporters EQU $00000004
kGetMovieImporterDontConsiderFileOnlyImporters EQU $00000040
;
; pascal OSErr GetMovieImporterForDataRef(OSType dataRefType, Handle dataRef, long flags, Component *importer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieImporterForDataRef
			move.w              #$02C7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieImporterForDataRef
	ENDIF

; *************************
;* Movie Timebase Conversion Routines
;*************************

;
; pascal TimeValue TrackTimeToMediaTime(TimeValue value, Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TrackTimeToMediaTime
			move.w              #$0096,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TrackTimeToMediaTime
	ENDIF

;
; pascal Fixed GetTrackEditRate(Track theTrack, TimeValue atTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackEditRate
			move.w              #$0123,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackEditRate
	ENDIF


; *************************
;* Miscellaneous Routines
;*************************


;
; pascal long GetMovieDataSize(Movie theMovie, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieDataSize
			move.w              #$0098,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieDataSize
	ENDIF

;
; pascal OSErr GetMovieDataSize64(Movie theMovie, TimeValue startTime, TimeValue duration, wide *dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieDataSize64
			move.w              #$02EB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieDataSize64
	ENDIF

;
; pascal long GetTrackDataSize(Track theTrack, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackDataSize
			move.w              #$0149,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackDataSize
	ENDIF

;
; pascal OSErr GetTrackDataSize64(Track theTrack, TimeValue startTime, TimeValue duration, wide *dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackDataSize64
			move.w              #$02EC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackDataSize64
	ENDIF

;
; pascal long GetMediaDataSize(Media theMedia, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDataSize
			move.w              #$0099,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDataSize
	ENDIF

;
; pascal OSErr GetMediaDataSize64(Media theMedia, TimeValue startTime, TimeValue duration, wide *dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDataSize64
			move.w              #$02ED,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDataSize64
	ENDIF

;
; pascal Boolean PtInMovie(Movie theMovie, Point pt)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PtInMovie
			move.w              #$009A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PtInMovie
	ENDIF

;
; pascal Boolean PtInTrack(Track theTrack, Point pt)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PtInTrack
			move.w              #$009B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PtInTrack
	ENDIF

; *************************
;* Group Selection Routines
;*************************


;
; pascal void SetMovieLanguage(Movie theMovie, long language)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieLanguage
			move.w              #$009C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieLanguage
	ENDIF


; *************************
;* User Data
;*************************


;
; pascal OSErr GetUserData(UserData theUserData, Handle data, OSType udType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetUserData
			move.w              #$009E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetUserData
	ENDIF

;
; pascal OSErr AddUserData(UserData theUserData, Handle data, OSType udType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddUserData
			move.w              #$009F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddUserData
	ENDIF

;
; pascal OSErr RemoveUserData(UserData theUserData, OSType udType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RemoveUserData
			move.w              #$00A0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveUserData
	ENDIF

;
; pascal short CountUserDataType(UserData theUserData, OSType udType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CountUserDataType
			move.w              #$014B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CountUserDataType
	ENDIF

;
; pascal long GetNextUserDataType(UserData theUserData, OSType udType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetNextUserDataType
			move.w              #$01A5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetNextUserDataType
	ENDIF

;
; pascal OSErr GetUserDataItem(UserData theUserData, void *data, long size, OSType udType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetUserDataItem
			move.w              #$0126,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetUserDataItem
	ENDIF

;
; pascal OSErr SetUserDataItem(UserData theUserData, void *data, long size, OSType udType, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetUserDataItem
			move.w              #$012E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetUserDataItem
	ENDIF

;
; pascal OSErr AddUserDataText(UserData theUserData, Handle data, OSType udType, long index, short itlRegionTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddUserDataText
			move.w              #$014C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddUserDataText
	ENDIF

;
; pascal OSErr GetUserDataText(UserData theUserData, Handle data, OSType udType, long index, short itlRegionTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetUserDataText
			move.w              #$014D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetUserDataText
	ENDIF

;
; pascal OSErr RemoveUserDataText(UserData theUserData, OSType udType, long index, short itlRegionTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RemoveUserDataText
			move.w              #$014E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveUserDataText
	ENDIF

;
; pascal OSErr NewUserData(UserData *theUserData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewUserData
			move.w              #$012F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewUserData
	ENDIF

;
; pascal OSErr DisposeUserData(UserData theUserData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeUserData
			move.w              #$0130,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeUserData
	ENDIF

;
; pascal OSErr NewUserDataFromHandle(Handle h, UserData *theUserData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewUserDataFromHandle
			move.w              #$0131,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewUserDataFromHandle
	ENDIF

;
; pascal OSErr PutUserDataIntoHandle(UserData theUserData, Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PutUserDataIntoHandle
			move.w              #$0132,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutUserDataIntoHandle
	ENDIF


	IF CALL_NOT_IN_CARBON THEN
;
; pascal OSErr SetMoviePropertyAtom(Movie theMovie, QTAtomContainer propertyAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePropertyAtom
			move.w              #$0284,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePropertyAtom
	ENDIF

;
; pascal OSErr GetMoviePropertyAtom(Movie theMovie, QTAtomContainer *propertyAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMoviePropertyAtom
			move.w              #$0285,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMoviePropertyAtom
	ENDIF


	ENDIF	; CALL_NOT_IN_CARBON
;
; pascal void GetMediaNextInterestingTime(Media theMedia, short interestingTimeFlags, TimeValue time, Fixed rate, TimeValue *interestingTime, TimeValue *interestingDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaNextInterestingTime
			move.w              #$016D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaNextInterestingTime
	ENDIF

;
; pascal void GetTrackNextInterestingTime(Track theTrack, short interestingTimeFlags, TimeValue time, Fixed rate, TimeValue *interestingTime, TimeValue *interestingDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackNextInterestingTime
			move.w              #$00E2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackNextInterestingTime
	ENDIF

;
; pascal void GetMovieNextInterestingTime(Movie theMovie, short interestingTimeFlags, short numMediaTypes, const OSType *whichMediaTypes, TimeValue time, Fixed rate, TimeValue *interestingTime, TimeValue *interestingDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieNextInterestingTime
			move.w              #$010E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieNextInterestingTime
	ENDIF


;
; pascal OSErr CreateMovieFile(const FSSpec *fileSpec, OSType creator, ScriptCode scriptTag, long createMovieFileFlags, short *resRefNum, Movie *newmovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CreateMovieFile
			move.w              #$0191,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CreateMovieFile
	ENDIF

;
; pascal OSErr OpenMovieFile(const FSSpec *fileSpec, short *resRefNum, SInt8 permission)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OpenMovieFile
			move.w              #$0192,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenMovieFile
	ENDIF

;
; pascal OSErr CloseMovieFile(short resRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CloseMovieFile
			move.w              #$00D5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CloseMovieFile
	ENDIF

;
; pascal OSErr DeleteMovieFile(const FSSpec *fileSpec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DeleteMovieFile
			move.w              #$0175,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeleteMovieFile
	ENDIF

;
; pascal OSErr NewMovieFromFile(Movie *theMovie, short resRefNum, short *resId, StringPtr resName, short newMovieFlags, Boolean *dataRefWasChanged)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromFile
			move.w              #$00F0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromFile
	ENDIF

;
; pascal OSErr NewMovieFromHandle(Movie *theMovie, Handle h, short newMovieFlags, Boolean *dataRefWasChanged)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromHandle
			move.w              #$00F1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromHandle
	ENDIF

;
; pascal OSErr NewMovieFromDataFork(Movie *theMovie, short fRefNum, long fileOffset, short newMovieFlags, Boolean *dataRefWasChanged)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromDataFork
			move.w              #$01B3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromDataFork
	ENDIF

;
; pascal OSErr NewMovieFromDataFork64(Movie *theMovie, long fRefNum, const wide *fileOffset, short newMovieFlags, Boolean *dataRefWasChanged)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromDataFork64
			move.w              #$02EE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromDataFork64
	ENDIF

;
; pascal OSErr NewMovieFromUserProc(Movie *m, short flags, Boolean *dataRefWasChanged, GetMovieUPP getProc, void *refCon, Handle defaultDataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromUserProc
			move.w              #$01EC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromUserProc
	ENDIF

;
; pascal OSErr NewMovieFromDataRef(Movie *m, short flags, short *id, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromDataRef
			move.w              #$0220,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromDataRef
	ENDIF

;
; pascal OSErr AddMovieResource(Movie theMovie, short resRefNum, short *resId, ConstStr255Param resName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMovieResource
			move.w              #$00D7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMovieResource
	ENDIF

;
; pascal OSErr UpdateMovieResource(Movie theMovie, short resRefNum, short resId, ConstStr255Param resName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UpdateMovieResource
			move.w              #$00D8,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UpdateMovieResource
	ENDIF

;
; pascal OSErr RemoveMovieResource(short resRefNum, short resId)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RemoveMovieResource
			move.w              #$0176,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveMovieResource
	ENDIF

;
; pascal Boolean HasMovieChanged(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_HasMovieChanged
			move.w              #$00D9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HasMovieChanged
	ENDIF

;
; pascal void ClearMovieChanged(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClearMovieChanged
			move.w              #$0113,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClearMovieChanged
	ENDIF

;
; pascal OSErr SetMovieDefaultDataRef(Movie theMovie, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieDefaultDataRef
			move.w              #$01C1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieDefaultDataRef
	ENDIF

;
; pascal OSErr GetMovieDefaultDataRef(Movie theMovie, Handle *dataRef, OSType *dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieDefaultDataRef
			move.w              #$01D2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieDefaultDataRef
	ENDIF

	IF CALL_NOT_IN_CARBON THEN
;
; pascal OSErr SetMovieAnchorDataRef(Movie theMovie, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieAnchorDataRef
			move.w              #$0315,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieAnchorDataRef
	ENDIF

;
; pascal OSErr GetMovieAnchorDataRef(Movie theMovie, Handle *dataRef, OSType *dataRefType, long *outFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieAnchorDataRef
			move.w              #$0316,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieAnchorDataRef
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
;
; pascal OSErr SetMovieColorTable(Movie theMovie, CTabHandle ctab)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieColorTable
			move.w              #$0205,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieColorTable
	ENDIF

;
; pascal OSErr GetMovieColorTable(Movie theMovie, CTabHandle *ctab)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieColorTable
			move.w              #$0206,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieColorTable
	ENDIF

;
; pascal void FlattenMovie(Movie theMovie, long movieFlattenFlags, const FSSpec *theFile, OSType creator, ScriptCode scriptTag, long createMovieFileFlags, short *resId, ConstStr255Param resName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlattenMovie
			move.w              #$019B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlattenMovie
	ENDIF

;
; pascal Movie FlattenMovieData(Movie theMovie, long movieFlattenFlags, const FSSpec *theFile, OSType creator, ScriptCode scriptTag, long createMovieFileFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlattenMovieData
			move.w              #$019C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlattenMovieData
	ENDIF

;
; pascal void SetMovieProgressProc(Movie theMovie, MovieProgressUPP p, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieProgressProc
			move.w              #$019A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieProgressProc
	ENDIF

;
; pascal void GetMovieProgressProc(Movie theMovie, MovieProgressUPP *p, long *refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieProgressProc
			move.w              #$0300,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieProgressProc
	ENDIF

;
; pascal OSErr CreateShortcutMovieFile(const FSSpec *fileSpec, OSType creator, ScriptCode scriptTag, long createMovieFileFlags, Handle targetDataRef, OSType targetDataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CreateShortcutMovieFile
			move.w              #$02FA,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CreateShortcutMovieFile
	ENDIF

;
; pascal OSErr MovieSearchText(Movie theMovie, Ptr text, long size, long searchFlags, Track *searchTrack, TimeValue *searchTime, long *searchOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieSearchText
			move.w              #$0207,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieSearchText
	ENDIF

;
; pascal void GetPosterBox(Movie theMovie, Rect *boxRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetPosterBox
			move.w              #$016F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPosterBox
	ENDIF

;
; pascal void SetPosterBox(Movie theMovie, const Rect *boxRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetPosterBox
			move.w              #$0170,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetPosterBox
	ENDIF

;
; pascal RgnHandle GetMovieSegmentDisplayBoundsRgn(Movie theMovie, TimeValue time, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieSegmentDisplayBoundsRgn
			move.w              #$016C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieSegmentDisplayBoundsRgn
	ENDIF

;
; pascal RgnHandle GetTrackSegmentDisplayBoundsRgn(Track theTrack, TimeValue time, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackSegmentDisplayBoundsRgn
			move.w              #$016B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackSegmentDisplayBoundsRgn
	ENDIF

;
; pascal void SetMovieCoverProcs(Movie theMovie, MovieRgnCoverUPP uncoverProc, MovieRgnCoverUPP coverProc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMovieCoverProcs
			move.w              #$0179,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMovieCoverProcs
	ENDIF

;
; pascal OSErr GetMovieCoverProcs(Movie theMovie, MovieRgnCoverUPP *uncoverProc, MovieRgnCoverUPP *coverProc, long *refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieCoverProcs
			move.w              #$01DD,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieCoverProcs
	ENDIF

;
; pascal ComponentResult GetTrackStatus(Track theTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackStatus
			move.w              #$0172,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackStatus
	ENDIF

;
; pascal ComponentResult GetMovieStatus(Movie theMovie, Track *firstProblemTrack)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieStatus
			move.w              #$0173,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieStatus
	ENDIF


kMovieLoadStateError			EQU		-1
kMovieLoadStateLoading			EQU		1000
kMovieLoadStatePlayable			EQU		10000
kMovieLoadStateComplete			EQU		100000
	IF CALL_NOT_IN_CARBON THEN
;
; pascal long GetMovieLoadState(Movie theMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMovieLoadState
			move.w              #$0314,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMovieLoadState
	ENDIF

; ***
;    Movie Controller support routines
;***

	ENDIF	; CALL_NOT_IN_CARBON
;
; pascal ComponentInstance NewMovieController(Movie theMovie, const Rect *movieRect, long someFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieController
			move.w              #$018A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieController
	ENDIF

;
; pascal void DisposeMovieController(ComponentInstance mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeMovieController
			move.w              #$018B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeMovieController
	ENDIF

;
; pascal void ShowMovieInformation(Movie theMovie, ModalFilterUPP filterProc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ShowMovieInformation
			move.w              #$0209,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ShowMovieInformation
	ENDIF


; *****
;    Scrap routines
;****

;
; pascal OSErr PutMovieOnScrap(Movie theMovie, long movieScrapFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PutMovieOnScrap
			move.w              #$018C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutMovieOnScrap
	ENDIF

;
; pascal Movie NewMovieFromScrap(long newMovieFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewMovieFromScrap
			move.w              #$018D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewMovieFromScrap
	ENDIF


; *****
;    DataRef routines
;****


;
; pascal OSErr GetMediaDataRef(Media theMedia, short index, Handle *dataRef, OSType *dataRefType, long *dataRefAttributes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDataRef
			move.w              #$0197,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDataRef
	ENDIF

;
; pascal OSErr SetMediaDataRef(Media theMedia, short index, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaDataRef
			move.w              #$01C9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaDataRef
	ENDIF

;
; pascal OSErr SetMediaDataRefAttributes(Media theMedia, short index, long dataRefAttributes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaDataRefAttributes
			move.w              #$01CA,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaDataRefAttributes
	ENDIF

;
; pascal OSErr AddMediaDataRef(Media theMedia, short *index, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMediaDataRef
			move.w              #$0198,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMediaDataRef
	ENDIF

;
; pascal OSErr GetMediaDataRefCount(Media theMedia, short *count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaDataRefCount
			move.w              #$0199,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaDataRefCount
	ENDIF

;
; pascal OSErr QTNewAlias(const FSSpec *fss, AliasHandle *alias, Boolean minimal)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTNewAlias
			move.w              #$0201,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTNewAlias
	ENDIF

; *****
;    Playback hint routines
;****

;
; pascal void SetMoviePlayHints(Movie theMovie, long flags, long flagsMask)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMoviePlayHints
			move.w              #$01A1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMoviePlayHints
	ENDIF

;
; pascal void SetMediaPlayHints(Media theMedia, long flags, long flagsMask)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaPlayHints
			move.w              #$01A2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaPlayHints
	ENDIF

;
; pascal void GetMediaPlayHints(Media theMedia, long *flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaPlayHints
			move.w              #$02CE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaPlayHints
	ENDIF

; *****
;    Load time track hints
;****


preloadAlways					EQU		$00000001
preloadOnlyIfEnabled			EQU		$00000002
;
; pascal void SetTrackLoadSettings(Track theTrack, TimeValue preloadTime, TimeValue preloadDuration, long preloadFlags, long defaultHints)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTrackLoadSettings
			move.w              #$01E3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTrackLoadSettings
	ENDIF

;
; pascal void GetTrackLoadSettings(Track theTrack, TimeValue *preloadTime, TimeValue *preloadDuration, long *preloadFlags, long *defaultHints)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTrackLoadSettings
			move.w              #$01E4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTrackLoadSettings
	ENDIF

; *****
;    Big screen TV
;****


fullScreenHideCursor			EQU		$00000001
fullScreenAllowEvents			EQU		$00000002
fullScreenDontChangeMenuBar		EQU		$00000004
fullScreenPreflightSize			EQU		$00000008
;
; pascal OSErr BeginFullScreen(Ptr *restoreState, GDHandle whichGD, short *desiredWidth, short *desiredHeight, WindowRef *newWindow, RGBColor *eraseColor, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_BeginFullScreen
			move.w              #$0233,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BeginFullScreen
	ENDIF

;
; pascal OSErr EndFullScreen(Ptr fullState, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_EndFullScreen
			move.w              #$0234,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EndFullScreen
	ENDIF

; *****
;    Wired Actions
;****

;  flags for MovieExecuteWiredActions

movieExecuteWiredActionDontExecute EQU	$00000001
;
; pascal OSErr AddMovieExecuteWiredActionsProc(Movie theMovie, MovieExecuteWiredActionsUPP proc, void *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddMovieExecuteWiredActionsProc
			move.w              #$0302,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddMovieExecuteWiredActionsProc
	ENDIF

;
; pascal OSErr RemoveMovieExecuteWiredActionsProc(Movie theMovie, MovieExecuteWiredActionsUPP proc, void *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RemoveMovieExecuteWiredActionsProc
			move.w              #$0303,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveMovieExecuteWiredActionsProc
	ENDIF

;
; pascal OSErr MovieExecuteWiredActions(Movie theMovie, long flags, QTAtomContainer actions)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExecuteWiredActions
			move.w              #$0304,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExecuteWiredActions
	ENDIF

; *****
;    Sprite Toolbox
;****


kBackgroundSpriteLayerNum		EQU		32767
;   Sprite Properties

kSpritePropertyMatrix			EQU		1
kSpritePropertyImageDescription	EQU		2
kSpritePropertyImageDataPtr		EQU		3
kSpritePropertyVisible			EQU		4
kSpritePropertyLayer			EQU		5
kSpritePropertyGraphicsMode		EQU		6
kSpritePropertyImageDataSize	EQU		7
kSpritePropertyActionHandlingSpriteID EQU 8
kSpritePropertyImageIndex		EQU		100
kSpriteTrackPropertyBackgroundColor EQU	101
kSpriteTrackPropertyOffscreenBitDepth EQU 102
kSpriteTrackPropertySampleFormat EQU	103
kSpriteTrackPropertyScaleSpritesToScaleWorld EQU 104
kSpriteTrackPropertyHasActions	EQU		105
kSpriteTrackPropertyVisible		EQU		106
kSpriteTrackPropertyQTIdleEventsFrequency EQU 107
kSpriteImagePropertyRegistrationPoint EQU 1000
kSpriteImagePropertyGroupID		EQU		1001
;  special value for kSpriteTrackPropertyQTIdleEventsFrequency (the default)

kNoQTIdleEvents					EQU		-1
;  flagsIn for SpriteWorldIdle

kOnlyDrawToSpriteWorld			EQU		$00000001
kSpriteWorldPreflight			EQU		$00000002
;  flagsOut for SpriteWorldIdle

kSpriteWorldDidDraw				EQU		$00000001
kSpriteWorldNeedsToDraw			EQU		$00000002
;  flags for sprite track sample format

kKeyFrameAndSingleOverride		EQU		$00000002
kKeyFrameAndAllOverrides		EQU		$00000004
;  sprite world flags

kScaleSpritesToScaleWorld		EQU		$00000002
kSpriteWorldHighQuality			EQU		$00000004
kSpriteWorldDontAutoInvalidate	EQU		$00000008
kSpriteWorldInvisible			EQU		$00000010
;
; pascal OSErr NewSpriteWorld(SpriteWorld *newSpriteWorld, GWorldPtr destination, GWorldPtr spriteLayer, RGBColor *backgroundColor, GWorldPtr background)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewSpriteWorld
			move.w              #$0239,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewSpriteWorld
	ENDIF

;
; pascal void DisposeSpriteWorld(SpriteWorld theSpriteWorld)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeSpriteWorld
			move.w              #$023A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeSpriteWorld
	ENDIF

;
; pascal OSErr SetSpriteWorldClip(SpriteWorld theSpriteWorld, RgnHandle clipRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetSpriteWorldClip
			move.w              #$023B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSpriteWorldClip
	ENDIF

;
; pascal OSErr SetSpriteWorldMatrix(SpriteWorld theSpriteWorld, const MatrixRecord *matrix)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetSpriteWorldMatrix
			move.w              #$023C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSpriteWorldMatrix
	ENDIF

;
; pascal OSErr SetSpriteWorldGraphicsMode(SpriteWorld theSpriteWorld, long mode, const RGBColor *opColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetSpriteWorldGraphicsMode
			move.w              #$02D9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSpriteWorldGraphicsMode
	ENDIF

;
; pascal OSErr SpriteWorldIdle(SpriteWorld theSpriteWorld, long flagsIn, long *flagsOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteWorldIdle
			move.w              #$023D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteWorldIdle
	ENDIF

;
; pascal OSErr InvalidateSpriteWorld(SpriteWorld theSpriteWorld, Rect *invalidArea)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InvalidateSpriteWorld
			move.w              #$023E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvalidateSpriteWorld
	ENDIF

;
; pascal OSErr SpriteWorldHitTest(SpriteWorld theSpriteWorld, long flags, Point loc, Sprite *spriteHit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteWorldHitTest
			move.w              #$0246,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteWorldHitTest
	ENDIF

;
; pascal OSErr SpriteHitTest(Sprite theSprite, long flags, Point loc, Boolean *wasHit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteHitTest
			move.w              #$0247,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteHitTest
	ENDIF

;
; pascal void DisposeAllSprites(SpriteWorld theSpriteWorld)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeAllSprites
			move.w              #$023F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeAllSprites
	ENDIF

;
; pascal OSErr SetSpriteWorldFlags(SpriteWorld spriteWorld, long flags, long flagsMask)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetSpriteWorldFlags
			move.w              #$02C2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSpriteWorldFlags
	ENDIF

;
; pascal OSErr NewSprite(Sprite *newSprite, SpriteWorld itsSpriteWorld, ImageDescriptionHandle idh, Ptr imageDataPtr, MatrixRecord *matrix, Boolean visible, short layer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewSprite
			move.w              #$0240,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewSprite
	ENDIF

;
; pascal void DisposeSprite(Sprite theSprite)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeSprite
			move.w              #$0241,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeSprite
	ENDIF

;
; pascal void InvalidateSprite(Sprite theSprite)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InvalidateSprite
			move.w              #$0242,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvalidateSprite
	ENDIF

;
; pascal OSErr SetSpriteProperty(Sprite theSprite, long propertyType, void *propertyValue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetSpriteProperty
			move.w              #$0243,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSpriteProperty
	ENDIF

;
; pascal OSErr GetSpriteProperty(Sprite theSprite, long propertyType, void *propertyValue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetSpriteProperty
			move.w              #$0244,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSpriteProperty
	ENDIF

; *****
;    QT Atom Data Support
;****


kParentAtomIsContainer			EQU		0
;  create and dispose QTAtomContainer objects

;
; pascal OSErr QTNewAtomContainer(QTAtomContainer *atomData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTNewAtomContainer
			move.w              #$020C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTNewAtomContainer
	ENDIF

;
; pascal OSErr QTDisposeAtomContainer(QTAtomContainer atomData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTDisposeAtomContainer
			move.w              #$020D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTDisposeAtomContainer
	ENDIF

;  locating nested atoms within QTAtomContainer container

;
; pascal QTAtomType QTGetNextChildType(QTAtomContainer container, QTAtom parentAtom, QTAtomType currentChildType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTGetNextChildType
			move.w              #$020E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTGetNextChildType
	ENDIF

;
; pascal short QTCountChildrenOfType(QTAtomContainer container, QTAtom parentAtom, QTAtomType childType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTCountChildrenOfType
			move.w              #$020F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTCountChildrenOfType
	ENDIF

;
; pascal QTAtom QTFindChildByIndex(QTAtomContainer container, QTAtom parentAtom, QTAtomType atomType, short index, QTAtomID *id)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTFindChildByIndex
			move.w              #$0210,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTFindChildByIndex
	ENDIF

;
; pascal QTAtom QTFindChildByID(QTAtomContainer container, QTAtom parentAtom, QTAtomType atomType, QTAtomID id, short *index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTFindChildByID
			move.w              #$021D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTFindChildByID
	ENDIF

;
; pascal OSErr QTNextChildAnyType(QTAtomContainer container, QTAtom parentAtom, QTAtom currentChild, QTAtom *nextChild)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTNextChildAnyType
			move.w              #$0200,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTNextChildAnyType
	ENDIF

;  set a leaf atom's data
;
; pascal OSErr QTSetAtomData(QTAtomContainer container, QTAtom atom, long dataSize, void *atomData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTSetAtomData
			move.w              #$0211,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTSetAtomData
	ENDIF

;  extracting data
;
; pascal OSErr QTCopyAtomDataToHandle(QTAtomContainer container, QTAtom atom, Handle targetHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTCopyAtomDataToHandle
			move.w              #$0212,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTCopyAtomDataToHandle
	ENDIF

;
; pascal OSErr QTCopyAtomDataToPtr(QTAtomContainer container, QTAtom atom, Boolean sizeOrLessOK, long size, void *targetPtr, long *actualSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTCopyAtomDataToPtr
			move.w              #$0213,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTCopyAtomDataToPtr
	ENDIF

;
; pascal OSErr QTGetAtomTypeAndID(QTAtomContainer container, QTAtom atom, QTAtomType *atomType, QTAtomID *id)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTGetAtomTypeAndID
			move.w              #$0232,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTGetAtomTypeAndID
	ENDIF

;  extract a copy of an atom and all of it's children, caller disposes
;
; pascal OSErr QTCopyAtom(QTAtomContainer container, QTAtom atom, QTAtomContainer *targetContainer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTCopyAtom
			move.w              #$0214,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTCopyAtom
	ENDIF

;  obtaining direct reference to atom data
;
; pascal OSErr QTLockContainer(QTAtomContainer container)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTLockContainer
			move.w              #$0215,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTLockContainer
	ENDIF

;
; pascal OSErr QTGetAtomDataPtr(QTAtomContainer container, QTAtom atom, long *dataSize, Ptr *atomData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTGetAtomDataPtr
			move.w              #$0216,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTGetAtomDataPtr
	ENDIF

;
; pascal OSErr QTUnlockContainer(QTAtomContainer container)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTUnlockContainer
			move.w              #$0217,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTUnlockContainer
	ENDIF


;   building QTAtomContainer trees
;   creates and inserts new atom at specified index, existing atoms at or after index are moved toward end of list
;   used for Top-Down tree creation


;
; pascal OSErr QTInsertChild(QTAtomContainer container, QTAtom parentAtom, QTAtomType atomType, QTAtomID id, short index, long dataSize, void *data, QTAtom *newAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTInsertChild
			move.w              #$0218,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTInsertChild
	ENDIF

;  inserts children from childrenContainer as children of parentAtom
;
; pascal OSErr QTInsertChildren(QTAtomContainer container, QTAtom parentAtom, QTAtomContainer childrenContainer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTInsertChildren
			move.w              #$0219,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTInsertChildren
	ENDIF

;  destruction
;
; pascal OSErr QTRemoveAtom(QTAtomContainer container, QTAtom atom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTRemoveAtom
			move.w              #$021A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTRemoveAtom
	ENDIF

;
; pascal OSErr QTRemoveChildren(QTAtomContainer container, QTAtom atom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTRemoveChildren
			move.w              #$021B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTRemoveChildren
	ENDIF

;  replacement must be same type as target
;
; pascal OSErr QTReplaceAtom(QTAtomContainer targetContainer, QTAtom targetAtom, QTAtomContainer replacementContainer, QTAtom replacementAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTReplaceAtom
			move.w              #$021C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTReplaceAtom
	ENDIF

;
; pascal OSErr QTSwapAtoms(QTAtomContainer container, QTAtom atom1, QTAtom atom2)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTSwapAtoms
			move.w              #$01FF,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTSwapAtoms
	ENDIF

;
; pascal OSErr QTSetAtomID(QTAtomContainer container, QTAtom atom, QTAtomID newID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTSetAtomID
			move.w              #$0231,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTSetAtomID
	ENDIF

;
; pascal QTAtom QTGetAtomParent(QTAtomContainer container, QTAtom childAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTGetAtomParent
			move.w              #$02EF,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTGetAtomParent
	ENDIF

;
; pascal OSErr SetMediaPropertyAtom(Media theMedia, QTAtomContainer propertyAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetMediaPropertyAtom
			move.w              #$022E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetMediaPropertyAtom
	ENDIF

;
; pascal OSErr GetMediaPropertyAtom(Media theMedia, QTAtomContainer *propertyAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMediaPropertyAtom
			move.w              #$022F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMediaPropertyAtom
	ENDIF

; *****
;    Tween Support
;****



TweenRecord				RECORD 0
version					 ds.l	1				; offset: $0 (0)
container				 ds.l	1				; offset: $4 (4)
tweenAtom				 ds.l	1				; offset: $8 (8)
dataAtom				 ds.l	1				; offset: $C (12)
percent					 ds.l	1				; offset: $10 (16)
dataProc				 ds.l	1				; offset: $14 (20)
private1				 ds.l	1				; offset: $18 (24)
private2				 ds.l	1				; offset: $1C (28)
sizeof					 EQU *					; size:   $20 (32)
						ENDR
TweenV1Record			RECORD 0
version					 ds.l	1				; offset: $0 (0)
container				 ds.l	1				; offset: $4 (4)
tweenAtom				 ds.l	1				; offset: $8 (8)
dataAtom				 ds.l	1				; offset: $C (12)
percent					 ds.l	1				; offset: $10 (16)
dataProc				 ds.l	1				; offset: $14 (20)
private1				 ds.l	1				; offset: $18 (24)
private2				 ds.l	1				; offset: $1C (28)
fractPercent			 ds.l	1				; offset: $20 (32)
sizeof					 EQU *					; size:   $24 (36)
						ENDR
;
; pascal OSErr QTNewTween(QTTweener *tween, QTAtomContainer container, QTAtom tweenAtom, TimeValue maxTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTNewTween
			move.w              #$029D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTNewTween
	ENDIF

;
; pascal OSErr QTDisposeTween(QTTweener tween)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTDisposeTween
			move.w              #$029F,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTDisposeTween
	ENDIF

;
; pascal OSErr QTDoTween(QTTweener tween, TimeValue atTime, Handle result, long *resultSize, TweenerDataUPP tweenDataProc, void *tweenDataRefCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTDoTween
			move.w              #$029E,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTDoTween
	ENDIF

; *****
;    Sound Description Manipulations
;****

;
; pascal OSErr AddSoundDescriptionExtension(SoundDescriptionHandle desc, Handle extension, OSType idType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddSoundDescriptionExtension
			move.w              #$02CF,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddSoundDescriptionExtension
	ENDIF

;
; pascal OSErr GetSoundDescriptionExtension(SoundDescriptionHandle desc, Handle *extension, OSType idType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetSoundDescriptionExtension
			move.w              #$02D0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSoundDescriptionExtension
	ENDIF

;
; pascal OSErr RemoveSoundDescriptionExtension(SoundDescriptionHandle desc, OSType idType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RemoveSoundDescriptionExtension
			move.w              #$02D1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveSoundDescriptionExtension
	ENDIF

; *****
;    Preferences
;****

;
; pascal OSErr GetQuickTimePreference(OSType preferenceType, QTAtomContainer *preferenceAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetQuickTimePreference
			move.w              #$02D4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetQuickTimePreference
	ENDIF

;
; pascal OSErr SetQuickTimePreference(OSType preferenceType, QTAtomContainer preferenceAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetQuickTimePreference
			move.w              #$02D5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetQuickTimePreference
	ENDIF

; *****
;    Effects and dialog Support
;****

;  atom types for entries in the effects list

kEffectNameAtom					EQU		'name'				; name of effect 
kEffectTypeAtom					EQU		'type'				; codec sub-type for effect 
kEffectManufacturerAtom			EQU		'manu'				; codec manufacturer for effect 
QTParamPreviewRecord	RECORD 0
sourceID				 ds.l	1				; offset: $0 (0)		;  1 based source identifier
sourcePicture			 ds.l	1				; offset: $4 (4)		;  picture for preview, must not dispose until dialog is disposed
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct QTParamPreviewRecord *	QTParamPreviewPtr

QTParamDialogEventRecord RECORD 0
theEvent				 ds.l	1				; offset: $0 (0)		;  Event received by the dialog 
whichDialog				 ds.l	1				; offset: $4 (4)		;  dialog that event was directed towards 
itemHit					 ds.w	1				; offset: $8 (8)		;  dialog item which was hit 
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct QTParamDialogEventRecord * QTParamDialogEventPtr

QTParamFetchPreviewRecord RECORD 0
theWorld				 ds.l	1				; offset: $0 (0)		;  the world into which to draw the preview 
percentage				 ds.l	1				; offset: $4 (4)		;  frame percentage (from 0.0 - 1.0) to be drawn 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct QTParamFetchPreviewRecord * QTParamFetchPreviePtr


pdActionConfirmDialog			EQU		1					; no param
pdActionSetAppleMenu			EQU		2					; param is MenuRef
pdActionSetEditMenu				EQU		3					; param is MenuRef
pdActionGetDialogValues			EQU		4					; param is QTAtomContainer
pdActionSetPreviewUserItem		EQU		5					; param is long
pdActionSetPreviewPicture		EQU		6					; param is QTParamPreviewPtr;
pdActionSetColorPickerEventProc	EQU		7					; param is UserEventUPP
pdActionSetDialogTitle			EQU		8					; param is StringPtr 
pdActionGetSubPanelMenu			EQU		9					; param is MenuRef* 
pdActionActivateSubPanel		EQU		10					; param is long 
pdActionConductStopAlert		EQU		11					; param is StringPtr 
pdActionModelessCallback		EQU		12					; param is QTParamDialogEventPtr 
pdActionFetchPreview			EQU		13					; param is QTParamFetchPreviewPtr 
; typedef long 							QTParameterDialog


elOptionsIncludeNoneInList		EQU		$00000001			; "None" effect is included in list 
; typedef long 							QTEffectListOptions


pdOptionsCollectOneValue		EQU		$00000001			; should collect a single value only
pdOptionsAllowOptionalInterpolations EQU $00000002			; non-novice interpolation options are shown 
pdOptionsModalDialogBox			EQU		$00000004			; dialog box should be modal 
; typedef long 							QTParameterDialogOptions


effectIsRealtime				EQU		0					; effect can be rendered in real time 
;
; pascal OSErr QTGetEffectsList(QTAtomContainer *returnedList, long minSources, long maxSources, QTEffectListOptions getOptions)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTGetEffectsList
			move.w              #$02C9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTGetEffectsList
	ENDIF

;
; pascal OSErr QTCreateStandardParameterDialog(QTAtomContainer effectList, QTAtomContainer parameters, QTParameterDialogOptions dialogOptions, QTParameterDialog *createdDialog)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTCreateStandardParameterDialog
			move.w              #$02CA,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTCreateStandardParameterDialog
	ENDIF

;
; pascal OSErr QTIsStandardParameterDialogEvent(EventRecord *pEvent, QTParameterDialog createdDialog)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTIsStandardParameterDialogEvent
			move.w              #$02CB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTIsStandardParameterDialogEvent
	ENDIF

;
; pascal OSErr QTDismissStandardParameterDialog(QTParameterDialog createdDialog)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTDismissStandardParameterDialog
			move.w              #$02CC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTDismissStandardParameterDialog
	ENDIF

;
; pascal OSErr QTStandardParameterDialogDoAction(QTParameterDialog createdDialog, long action, void *params)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTStandardParameterDialogDoAction
			move.w              #$02CD,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTStandardParameterDialogDoAction
	ENDIF

;
; pascal OSErr QTGetEffectSpeed(QTAtomContainer parameters, Fixed *pFPS)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTGetEffectSpeed
			move.w              #$02D2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTGetEffectSpeed
	ENDIF

; *****
;    Access Keys
;****


kAccessKeyAtomType				EQU		'acky'

kAccessKeySystemFlag			EQU		$00000001
;
; pascal OSErr QTGetAccessKeys(Str255 accessKeyType, long flags, QTAtomContainer *keys)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTGetAccessKeys
			move.w              #$02B3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTGetAccessKeys
	ENDIF

;
; pascal OSErr QTRegisterAccessKey(Str255 accessKeyType, long flags, Handle accessKey)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTRegisterAccessKey
			move.w              #$02B4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTRegisterAccessKey
	ENDIF

;
; pascal OSErr QTUnregisterAccessKey(Str255 accessKeyType, long flags, Handle accessKey)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTUnregisterAccessKey
			move.w              #$02B5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTUnregisterAccessKey
	ENDIF

; *****
;    Time table
;****

;
; pascal OSErr MakeTrackTimeTable(Track trackH, long **offsets, TimeValue startTime, TimeValue endTime, TimeValue timeIncrement, short firstDataRefIndex, short lastDataRefIndex, long *retdataRefSkew)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MakeTrackTimeTable
			move.w              #$02BE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MakeTrackTimeTable
	ENDIF

;
; pascal OSErr MakeMediaTimeTable(Media theMedia, long **offsets, TimeValue startTime, TimeValue endTime, TimeValue timeIncrement, short firstDataRefIndex, short lastDataRefIndex, long *retdataRefSkew)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MakeMediaTimeTable
			move.w              #$02BF,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MakeMediaTimeTable
	ENDIF

;
; pascal OSErr GetMaxLoadedTimeInMovie(Movie theMovie, TimeValue *time)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetMaxLoadedTimeInMovie
			move.w              #$02C0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMaxLoadedTimeInMovie
	ENDIF

;
; pascal OSErr QTMovieNeedsTimeTable(Movie theMovie, Boolean *needsTimeTable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTMovieNeedsTimeTable
			move.w              #$02C3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTMovieNeedsTimeTable
	ENDIF

;
; pascal OSErr QTGetDataRefMaxFileOffset(Movie movieH, OSType dataRefType, Handle dataRef, long *offset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTGetDataRefMaxFileOffset
			move.w              #$02C6,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTGetDataRefMaxFileOffset
	ENDIF


; *****
;    Bandwidth management support
;****


ConnectionSpeedPrefsType		EQU		'cspd'
BandwidthManagementPrefsType	EQU		'bwmg'

ConnectionSpeedPrefsRecord RECORD 0
connectionSpeed			 ds.l	1				; offset: $0 (0)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct ConnectionSpeedPrefsRecord * ConnectionSpeedPrefsPtr

; typedef ConnectionSpeedPrefsPtr *		ConnectionSpeedPrefsHandle

BandwidthManagementPrefsRecord RECORD 0
overrideConnectionSpeedForBandwidth  ds.b 1		; offset: $0 (0)
						 ORG 2
sizeof					 EQU *					; size:   $2 (2)
						ENDR
; typedef struct BandwidthManagementPrefsRecord * BandwidthManagementPrefsPtr

; typedef BandwidthManagementPrefsPtr *	BandwidthManagementPrefsHandle


kQTIdlePriority					EQU		10
kQTNonRealTimePriority			EQU		20
kQTRealTimeSharedPriority		EQU		25
kQTRealTimePriority				EQU		30

kQTBandwidthNotifyNeedToStop	EQU		$00000001
kQTBandwidthNotifyGoodToGo		EQU		$00000002
kQTBandwidthChangeRequest		EQU		$00000004
kQTBandwidthQueueRequest		EQU		$00000008
kQTBandwidthScheduledRequest	EQU		$00000010
kQTBandwidthVoluntaryRelease	EQU		$00000020
QTScheduledBandwidthRecord RECORD 0
recordSize				 ds.l	1				; offset: $0 (0)		;  total number of bytes in QTScheduledBandwidthRecord
priority				 ds.l	1				; offset: $4 (4)
dataRate				 ds.l	1				; offset: $8 (8)
startTime				 ds		CompTimeValue	; offset: $C (12)		;  bandwidth usage start time
duration				 ds		CompTimeValue	; offset: $14 (20)		;  duration of bandwidth usage(0 if unknown)
prerollDuration			 ds		CompTimeValue	; offset: $1C (28)		;  time for negotiation before startTime(0 if unknown)
scale					 ds.l	1				; offset: $24 (36)		;  timescale of value/duration/prerollDuration fields
base					 ds.l	1				; offset: $28 (40)		;  timebase
sizeof					 EQU *					; size:   $2C (44)
						ENDR
; typedef struct QTScheduledBandwidthRecord * QTScheduledBandwidthPtr

; typedef QTScheduledBandwidthPtr *		QTScheduledBandwidthHandle

;
; pascal OSErr QTBandwidthRequest(long priority, QTBandwidthNotificationUPP callback, const void *refcon, QTBandwidthReference *bwRef, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTBandwidthRequest
			move.w              #$02F5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTBandwidthRequest
	ENDIF

	IF CALL_NOT_IN_CARBON THEN
;
; pascal OSErr QTBandwidthRequestForTimeBase(TimeBase tb, long priority, QTBandwidthNotificationUPP callback, const void *refcon, QTBandwidthReference *bwRef, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTBandwidthRequestForTimeBase
			move.w              #$0318,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTBandwidthRequestForTimeBase
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
;
; pascal OSErr QTBandwidthRelease(QTBandwidthReference bwRef, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTBandwidthRelease
			move.w              #$02F6,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTBandwidthRelease
	ENDIF

	IF CALL_NOT_IN_CARBON THEN
;
; pascal OSErr QTScheduledBandwidthRequest(QTScheduledBandwidthPtr scheduleRec, QTBandwidthNotificationUPP notificationCallback, void *refcon, QTScheduledBandwidthReference *sbwRef, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTScheduledBandwidthRequest
			move.w              #$0310,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTScheduledBandwidthRequest
	ENDIF

;
; pascal OSErr QTScheduledBandwidthRelease(QTScheduledBandwidthReference sbwRef, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTScheduledBandwidthRelease
			move.w              #$0311,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTScheduledBandwidthRelease
	ENDIF

; *****
;    QT International Text Atom Support
;****

	ENDIF	; CALL_NOT_IN_CARBON

kITextRemoveEverythingBut		EQU		$00
kITextRemoveLeaveSuggestedAlternate EQU	$02

kITextAtomType					EQU		'itxt'
kITextStringAtomType			EQU		'text'
;
; pascal OSErr ITextAddString(QTAtomContainer container, QTAtom parentAtom, RegionCode theRegionCode, ConstStr255Param theString)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ITextAddString
			move.w              #$027A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ITextAddString
	ENDIF

;
; pascal OSErr ITextRemoveString(QTAtomContainer container, QTAtom parentAtom, RegionCode theRegionCode, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ITextRemoveString
			move.w              #$027B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ITextRemoveString
	ENDIF

;
; pascal OSErr ITextGetString(QTAtomContainer container, QTAtom parentAtom, RegionCode requestedRegion, RegionCode *foundRegion, StringPtr theString)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ITextGetString
			move.w              #$027C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ITextGetString
	ENDIF

;
; pascal OSErr QTTextToNativeText(Handle theText, long encoding, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTTextToNativeText
			move.w              #$02DB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTTextToNativeText
	ENDIF

;  QTParseTextHREF inContainer atoms

kQTParseTextHREFText			EQU		'text'				; string
kQTParseTextHREFBaseURL			EQU		'burl'				; string
kQTParseTextHREFClickPoint		EQU		'clik'				; Point; if present, QTParseTextHREF will expand URLs to support server-side image maps
kQTParseTextHREFUseAltDelim		EQU		'altd'				; boolean; if no kQTParseTextHREFDelimiter, delim is ':'
kQTParseTextHREFDelimiter		EQU		'delm'				; character
kQTParseTextHREFRecomposeHREF	EQU		'rhrf'				; Boolean; if true, QTParseTextHREF returns recomposed HREF with URL expanded as appropriate
;  QTParseTextHREF outContainer atoms

kQTParseTextHREFURL				EQU		'url '				; string
kQTParseTextHREFTarget			EQU		'targ'				; string
kQTParseTextHREFIsAutoHREF		EQU		'auto'				; Boolean
kQTParseTextHREFIsServerMap		EQU		'smap'				; boolean
kQTParseTextHREFHREF			EQU		'href'				; string; recomposed HREF with URL expanded as appropriate, suitable for mcActionLinkToURL
	IF CALL_NOT_IN_CARBON THEN
;
; pascal OSErr QTParseTextHREF(char *href, SInt32 hrefLen, QTAtomContainer inContainer, QTAtomContainer *outContainer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTParseTextHREF
			move.w              #$0319,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTParseTextHREF
	ENDIF

; *************************
;* track reference types
;*************************

	ENDIF	; CALL_NOT_IN_CARBON

kTrackReferenceChapterList		EQU		'chap'
kTrackReferenceTimeCode			EQU		'tmcd'
kTrackReferenceModifier			EQU		'ssrc'
; *************************
;* modifier track types
;*************************


kTrackModifierInput				EQU		$696E				; is really 'in'
kTrackModifierType				EQU		$7479				; is really 'ty'
kTrackModifierReference			EQU		'ssrc'
kTrackModifierObjectID			EQU		'obid'
kTrackModifierInputName			EQU		'name'

kInputMapSubInputID				EQU		'subi'

kTrackModifierTypeMatrix		EQU		1
kTrackModifierTypeClip			EQU		2
kTrackModifierTypeGraphicsMode	EQU		5
kTrackModifierTypeVolume		EQU		3
kTrackModifierTypeBalance		EQU		4
kTrackModifierTypeImage			EQU		'vide'				; was kTrackModifierTypeSpriteImage
kTrackModifierObjectMatrix		EQU		6
kTrackModifierObjectGraphicsMode EQU	7
kTrackModifierType3d4x4Matrix	EQU		8
kTrackModifierCameraData		EQU		9
kTrackModifierSoundLocalizationData EQU	10
kTrackModifierObjectImageIndex	EQU		11
kTrackModifierObjectLayer		EQU		12
kTrackModifierObjectVisible		EQU		13
kTrackModifierAngleAspectCamera	EQU		14
kTrackModifierPanAngle			EQU		'pan '
kTrackModifierTiltAngle			EQU		'tilt'
kTrackModifierVerticalFieldOfViewAngle EQU 'fov '
kTrackModifierObjectQTEventSend	EQU		'evnt'
ModifierTrackGraphicsModeRecord RECORD 0
graphicsMode			 ds.l	1				; offset: $0 (0)
opColor					 ds		RGBColor		; offset: $4 (4)
sizeof					 EQU *					; size:   $A (10)
						ENDR

; *************************
;* tween track types
;*************************


kTweenTypeShort					EQU		1
kTweenTypeLong					EQU		2
kTweenTypeFixed					EQU		3
kTweenTypePoint					EQU		4
kTweenTypeQDRect				EQU		5
kTweenTypeQDRegion				EQU		6
kTweenTypeMatrix				EQU		7
kTweenTypeRGBColor				EQU		8
kTweenTypeGraphicsModeWithRGBColor EQU	9
kTweenTypeQTFloatSingle			EQU		10
kTweenTypeQTFloatDouble			EQU		11
kTweenTypeFixedPoint			EQU		12
kTweenType3dScale				EQU		'3sca'
kTweenType3dTranslate			EQU		'3tra'
kTweenType3dRotate				EQU		'3rot'
kTweenType3dRotateAboutPoint	EQU		'3rap'
kTweenType3dRotateAboutAxis		EQU		'3rax'
kTweenType3dRotateAboutVector	EQU		'3rvc'
kTweenType3dQuaternion			EQU		'3qua'
kTweenType3dMatrix				EQU		'3mat'
kTweenType3dCameraData			EQU		'3cam'
kTweenType3dAngleAspectCameraData EQU	'3caa'
kTweenType3dSoundLocalizationData EQU	'3slc'
kTweenTypePathToMatrixTranslation EQU	'gxmt'
kTweenTypePathToMatrixRotation	EQU		'gxpr'
kTweenTypePathToMatrixTranslationAndRotation EQU 'gxmr'
kTweenTypePathToFixedPoint		EQU		'gxfp'
kTweenTypePathXtoY				EQU		'gxxy'
kTweenTypePathYtoX				EQU		'gxyx'
kTweenTypeAtomList				EQU		'atom'
kTweenTypePolygon				EQU		'poly'
kTweenTypeMultiMatrix			EQU		'mulm'
kTweenTypeSpin					EQU		'spin'
kTweenType3dMatrixNonLinear		EQU		'3nlr'
kTweenType3dVRObject			EQU		'3vro'

kTweenEntry						EQU		'twen'
kTweenData						EQU		'data'
kTweenType						EQU		'twnt'
kTweenStartOffset				EQU		'twst'
kTweenDuration					EQU		'twdu'
kTweenFlags						EQU		'flag'
kTweenOutputMin					EQU		'omin'
kTweenOutputMax					EQU		'omax'
kTweenSequenceElement			EQU		'seqe'
kTween3dInitialCondition		EQU		'icnd'
kTweenInterpolationID			EQU		'intr'
kTweenRegionData				EQU		'qdrg'
kTweenPictureData				EQU		'PICT'
kListElementType				EQU		'type'
kListElementDataType			EQU		'daty'
kNameAtom						EQU		'name'
kInitialRotationAtom			EQU		'inro'
kNonLinearTweenHeader			EQU		'nlth'
;  kTweenFlags

kTweenReturnDelta				EQU		$00000001
TweenSequenceEntryRecord RECORD 0
endPercent				 ds.l	1				; offset: $0 (0)
tweenAtomID				 ds.l	1				; offset: $4 (4)
dataAtomID				 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR



; *************************
;* Video Media routines
;*************************




videoFlagDontLeanAhead			EQU		$00000001



;  use these five routines at your own peril
;
; pascal ComponentResult VideoMediaResetStatistics(MediaHandler mh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VideoMediaResetStatistics
			move.l              #$00000105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VideoMediaResetStatistics
	ENDIF

;
; pascal ComponentResult VideoMediaGetStatistics(MediaHandler mh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VideoMediaGetStatistics
			move.l              #$00000106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VideoMediaGetStatistics
	ENDIF


;
; pascal ComponentResult VideoMediaGetStallCount(MediaHandler mh, unsigned long *stalls)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VideoMediaGetStallCount
			move.l              #$0004010E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VideoMediaGetStallCount
	ENDIF


;
; pascal ComponentResult VideoMediaSetCodecParameter(MediaHandler mh, CodecType cType, OSType parameterID, long parameterChangeSeed, void *dataPtr, long dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VideoMediaSetCodecParameter
			move.l              #$0014010F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VideoMediaSetCodecParameter
	ENDIF

;
; pascal ComponentResult VideoMediaGetCodecParameter(MediaHandler mh, CodecType cType, OSType parameterID, Handle outParameterData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VideoMediaGetCodecParameter
			move.l              #$000C0110,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VideoMediaGetCodecParameter
	ENDIF




; *************************
;* Text Media routines
;*************************




;  Return displayFlags for TextProc 

txtProcDefaultDisplay			EQU		0					;    Use the media's default
txtProcDontDisplay				EQU		1					;    Don't display the text
txtProcDoDisplay				EQU		2					;    Do display the text
;
; pascal ComponentResult TextMediaSetTextProc(MediaHandler mh, TextMediaUPP TextProc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaSetTextProc
			move.l              #$00080101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaSetTextProc
	ENDIF

;
; pascal ComponentResult TextMediaAddTextSample(MediaHandler mh, Ptr text, unsigned long size, short fontNumber, short fontSize, Style textFace, RGBColor *textColor, RGBColor *backColor, short textJustification, Rect *textBox, long displayFlags, TimeValue scrollDelay, short hiliteStart, short hiliteEnd, RGBColor *rgbHiliteColor, TimeValue duration, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaAddTextSample
			move.l              #$00340102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaAddTextSample
	ENDIF

;
; pascal ComponentResult TextMediaAddTESample(MediaHandler mh, TEHandle hTE, RGBColor *backColor, short textJustification, Rect *textBox, long displayFlags, TimeValue scrollDelay, short hiliteStart, short hiliteEnd, RGBColor *rgbHiliteColor, TimeValue duration, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaAddTESample
			move.l              #$00260103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaAddTESample
	ENDIF

;
; pascal ComponentResult TextMediaAddHiliteSample(MediaHandler mh, short hiliteStart, short hiliteEnd, RGBColor *rgbHiliteColor, TimeValue duration, TimeValue *sampleTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaAddHiliteSample
			move.l              #$00100104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaAddHiliteSample
	ENDIF

;
; pascal ComponentResult TextMediaDrawRaw(MediaHandler mh, GWorldPtr gw, GDHandle gd, void *data, long dataSize, TextDescriptionHandle tdh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaDrawRaw
			move.l              #$00140109,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaDrawRaw
	ENDIF

;
; pascal ComponentResult TextMediaSetTextProperty(MediaHandler mh, TimeValue atMediaTime, long propertyType, void *data, long dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaSetTextProperty
			move.l              #$0010010A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaSetTextProperty
	ENDIF

;
; pascal ComponentResult TextMediaRawSetup(MediaHandler mh, GWorldPtr gw, GDHandle gd, void *data, long dataSize, TextDescriptionHandle tdh, TimeValue sampleDuration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaRawSetup
			move.l              #$0018010B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaRawSetup
	ENDIF

;
; pascal ComponentResult TextMediaRawIdle(MediaHandler mh, GWorldPtr gw, GDHandle gd, TimeValue sampleTime, long flagsIn, long *flagsOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaRawIdle
			move.l              #$0014010C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaRawIdle
	ENDIF



findTextEdgeOK					EQU		$01					; Okay to find text at specified sample time
findTextCaseSensitive			EQU		$02					; Case sensitive search
findTextReverseSearch			EQU		$04					; Search from sampleTime backwards
findTextWrapAround				EQU		$08					; Wrap search when beginning or end of movie is hit
findTextUseOffset				EQU		$10					; Begin search at the given character offset into sample rather than edge
;
; pascal ComponentResult TextMediaFindNextText(MediaHandler mh, Ptr text, long size, short findFlags, TimeValue startTime, TimeValue *foundTime, TimeValue *foundDuration, long *offset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaFindNextText
			move.l              #$001A0105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaFindNextText
	ENDIF

;
; pascal ComponentResult TextMediaHiliteTextSample(MediaHandler mh, TimeValue sampleTime, short hiliteStart, short hiliteEnd, RGBColor *rgbHiliteColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaHiliteTextSample
			move.l              #$000C0106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaHiliteTextSample
	ENDIF


dropShadowOffsetType			EQU		'drpo'
dropShadowTranslucencyType		EQU		'drpt'
;
; pascal ComponentResult TextMediaSetTextSampleData(MediaHandler mh, void *data, OSType dataType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextMediaSetTextSampleData
			move.l              #$00080107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextMediaSetTextSampleData
	ENDIF





; *************************
;* Sprite Media routines
;*************************

;  flags for sprite hit test routines 

spriteHitTestBounds				EQU		$00000001			;    point must only be within sprite's bounding box
spriteHitTestImage				EQU		$00000002			;  point must be within the shape of the sprite's image
spriteHitTestInvisibleSprites	EQU		$00000004			;  invisible sprites may be hit tested
spriteHitTestIsClick			EQU		$00000008			;  for codecs that want mouse events
spriteHitTestLocInDisplayCoordinates EQU $00000010			;    set if you want to pass a display coordiate point to SpriteHitTest
;  atom types for sprite media 

kSpriteAtomType					EQU		'sprt'
kSpriteImagesContainerAtomType	EQU		'imct'
kSpriteImageAtomType			EQU		'imag'
kSpriteImageDataAtomType		EQU		'imda'
kSpriteImageDataRefAtomType		EQU		'imre'
kSpriteImageDataRefTypeAtomType	EQU		'imrt'
kSpriteImageGroupIDAtomType		EQU		'imgr'
kSpriteImageRegistrationAtomType EQU	'imrg'
kSpriteImageDefaultImageIndexAtomType EQU 'defi'
kSpriteSharedDataAtomType		EQU		'dflt'
kSpriteNameAtomType				EQU		'name'
kSpriteImageNameAtomType		EQU		'name'
kSpriteUsesImageIDsAtomType		EQU		'uses'				; leaf data is an array of QTAtomID's, one per image used
kSpriteBehaviorsAtomType		EQU		'beha'
kSpriteImageBehaviorAtomType	EQU		'imag'
kSpriteCursorBehaviorAtomType	EQU		'crsr'
kSpriteStatusStringsBehaviorAtomType EQU 'sstr'
kSpriteVariablesContainerAtomType EQU	'vars'
kSpriteStringVariableAtomType	EQU		'strv'
kSpriteFloatingPointVariableAtomType EQU 'flov'
QTRuntimeSpriteDescStruct RECORD 0
version					 ds.l	1				; offset: $0 (0)		;  set to zero
spriteID				 ds.l	1				; offset: $4 (4)
imageIndex				 ds.w	1				; offset: $8 (8)
matrix					 ds		MatrixRecord	; offset: $A (10)
visible					 ds.w	1				; offset: $2E (46)
layer					 ds.w	1				; offset: $30 (48)
graphicsMode			 ds		ModifierTrackGraphicsModeRecord ; offset: $32 (50)
actionHandlingSpriteID	 ds.l	1				; offset: $3C (60)
sizeof					 EQU *					; size:   $40 (64)
						ENDR
; typedef struct QTRuntimeSpriteDescStruct * QTRuntimeSpriteDescPtr


;   when filling in QTSpriteButtonBehaviorStruct values -1 may be used to indicate that
;   the state transition does not change the property


QTSpriteButtonBehaviorStruct RECORD 0
notOverNotPressedStateID  ds.l	1				; offset: $0 (0)
overNotPressedStateID	 ds.l	1				; offset: $4 (4)
overPressedStateID		 ds.l	1				; offset: $8 (8)
notOverPressedStateID	 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct QTSpriteButtonBehaviorStruct * QTSpriteButtonBehaviorPtr

;
; pascal ComponentResult SpriteMediaSetProperty(MediaHandler mh, short spriteIndex, long propertyType, void *propertyValue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaSetProperty
			move.l              #$000A0101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaSetProperty
	ENDIF

;
; pascal ComponentResult SpriteMediaGetProperty(MediaHandler mh, short spriteIndex, long propertyType, void *propertyValue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetProperty
			move.l              #$000A0102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetProperty
	ENDIF

;
; pascal ComponentResult SpriteMediaHitTestSprites(MediaHandler mh, long flags, Point loc, short *spriteHitIndex)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaHitTestSprites
			move.l              #$000C0103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaHitTestSprites
	ENDIF

;
; pascal ComponentResult SpriteMediaCountSprites(MediaHandler mh, short *numSprites)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaCountSprites
			move.l              #$00040104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaCountSprites
	ENDIF

;
; pascal ComponentResult SpriteMediaCountImages(MediaHandler mh, short *numImages)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaCountImages
			move.l              #$00040105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaCountImages
	ENDIF

;
; pascal ComponentResult SpriteMediaGetIndImageDescription(MediaHandler mh, short imageIndex, ImageDescriptionHandle imageDescription)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetIndImageDescription
			move.l              #$00060106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetIndImageDescription
	ENDIF

;
; pascal ComponentResult SpriteMediaGetDisplayedSampleNumber(MediaHandler mh, long *sampleNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetDisplayedSampleNumber
			move.l              #$00040107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetDisplayedSampleNumber
	ENDIF

;
; pascal ComponentResult SpriteMediaGetSpriteName(MediaHandler mh, QTAtomID spriteID, Str255 spriteName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetSpriteName
			move.l              #$00080108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetSpriteName
	ENDIF

;
; pascal ComponentResult SpriteMediaGetImageName(MediaHandler mh, short imageIndex, Str255 imageName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetImageName
			move.l              #$00060109,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetImageName
	ENDIF

;
; pascal ComponentResult SpriteMediaSetSpriteProperty(MediaHandler mh, QTAtomID spriteID, long propertyType, void *propertyValue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaSetSpriteProperty
			move.l              #$000C010A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaSetSpriteProperty
	ENDIF

;
; pascal ComponentResult SpriteMediaGetSpriteProperty(MediaHandler mh, QTAtomID spriteID, long propertyType, void *propertyValue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetSpriteProperty
			move.l              #$000C010B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetSpriteProperty
	ENDIF

;
; pascal ComponentResult SpriteMediaHitTestAllSprites(MediaHandler mh, long flags, Point loc, QTAtomID *spriteHitID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaHitTestAllSprites
			move.l              #$000C010C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaHitTestAllSprites
	ENDIF

;
; pascal ComponentResult SpriteMediaHitTestOneSprite(MediaHandler mh, QTAtomID spriteID, long flags, Point loc, Boolean *wasHit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaHitTestOneSprite
			move.l              #$0010010D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaHitTestOneSprite
	ENDIF

;
; pascal ComponentResult SpriteMediaSpriteIndexToID(MediaHandler mh, short spriteIndex, QTAtomID *spriteID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaSpriteIndexToID
			move.l              #$0006010E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaSpriteIndexToID
	ENDIF

;
; pascal ComponentResult SpriteMediaSpriteIDToIndex(MediaHandler mh, QTAtomID spriteID, short *spriteIndex)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaSpriteIDToIndex
			move.l              #$0008010F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaSpriteIDToIndex
	ENDIF

;
; pascal ComponentResult SpriteMediaGetSpriteActionsForQTEvent(MediaHandler mh, QTEventRecordPtr event, QTAtomID spriteID, QTAtomContainer *container, QTAtom *atom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetSpriteActionsForQTEvent
			move.l              #$00100110,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetSpriteActionsForQTEvent
	ENDIF

;
; pascal ComponentResult SpriteMediaSetActionVariable(MediaHandler mh, QTAtomID variableID, const float *value)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaSetActionVariable
			move.l              #$00080111,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaSetActionVariable
	ENDIF

;
; pascal ComponentResult SpriteMediaGetActionVariable(MediaHandler mh, QTAtomID variableID, float *value)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetActionVariable
			move.l              #$00080112,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetActionVariable
	ENDIF

	IF CALL_NOT_IN_CARBON THEN
;
; pascal ComponentResult SpriteMediaGetIndImageProperty(MediaHandler mh, short imageIndex, long imagePropertyType, void *imagePropertyValue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetIndImageProperty
			move.l              #$000A0113,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetIndImageProperty
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
;
; pascal ComponentResult SpriteMediaNewSprite(MediaHandler mh, QTRuntimeSpriteDescPtr newSpriteDesc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaNewSprite
			move.l              #$00040114,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaNewSprite
	ENDIF

;
; pascal ComponentResult SpriteMediaDisposeSprite(MediaHandler mh, QTAtomID spriteID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaDisposeSprite
			move.l              #$00040115,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaDisposeSprite
	ENDIF

;
; pascal ComponentResult SpriteMediaSetActionVariableToString(MediaHandler mh, QTAtomID variableID, Ptr theCString)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaSetActionVariableToString
			move.l              #$00080116,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaSetActionVariableToString
	ENDIF

;
; pascal ComponentResult SpriteMediaGetActionVariableAsString(MediaHandler mh, QTAtomID variableID, Handle *theCString)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SpriteMediaGetActionVariableAsString
			move.l              #$00080117,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SpriteMediaGetActionVariableAsString
	ENDIF



; *************************
;* Flash Media routines
;*************************


;
; pascal ComponentResult FlashMediaSetPan(MediaHandler mh, short xPercent, short yPercent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlashMediaSetPan
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlashMediaSetPan
	ENDIF

;
; pascal ComponentResult FlashMediaSetZoom(MediaHandler mh, short factor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlashMediaSetZoom
			move.l              #$00020102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlashMediaSetZoom
	ENDIF

;
; pascal ComponentResult FlashMediaSetZoomRect(MediaHandler mh, long left, long top, long right, long bottom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlashMediaSetZoomRect
			move.l              #$00100103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlashMediaSetZoomRect
	ENDIF

;
; pascal ComponentResult FlashMediaGetRefConBounds(MediaHandler mh, long refCon, long *left, long *top, long *right, long *bottom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlashMediaGetRefConBounds
			move.l              #$00140104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlashMediaGetRefConBounds
	ENDIF

;
; pascal ComponentResult FlashMediaGetRefConID(MediaHandler mh, long refCon, long *refConID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlashMediaGetRefConID
			move.l              #$00080105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlashMediaGetRefConID
	ENDIF

;
; pascal ComponentResult FlashMediaIDToRefCon(MediaHandler mh, long refConID, long *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlashMediaIDToRefCon
			move.l              #$00080106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlashMediaIDToRefCon
	ENDIF

;
; pascal ComponentResult FlashMediaGetDisplayedFrameNumber(MediaHandler mh, long *flashFrameNumber)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlashMediaGetDisplayedFrameNumber
			move.l              #$00040107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlashMediaGetDisplayedFrameNumber
	ENDIF

;
; pascal ComponentResult FlashMediaFrameNumberToMovieTime(MediaHandler mh, long flashFrameNumber, TimeValue *movieTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlashMediaFrameNumberToMovieTime
			move.l              #$00080108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlashMediaFrameNumberToMovieTime
	ENDIF

;
; pascal ComponentResult FlashMediaFrameLabelToMovieTime(MediaHandler mh, Ptr theLabel, TimeValue *movieTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FlashMediaFrameLabelToMovieTime
			move.l              #$00080109,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlashMediaFrameLabelToMovieTime
	ENDIF



;  sample format atoms

kMovieMediaDataReference		EQU		'mmdr'				; data reference
kMovieMediaDefaultDataReferenceID EQU	'ddri'				; atom id
kMovieMediaSlaveTime			EQU		'slti'				; boolean
kMovieMediaSlaveAudio			EQU		'slau'				; boolean
kMovieMediaSlaveGraphicsMode	EQU		'slgr'				; boolean
kMovieMediaAutoPlay				EQU		'play'				; boolean
kMovieMediaLoop					EQU		'loop'				; UInt8 (0=no loop, 1=loop, 2=palindrome loop)
kMovieMediaUseMIMEType			EQU		'mime'				; string indicating the MIME type to use for the dataref (usually not required)
kMovieMediaTitle				EQU		'titl'				; string of the media's title (tooltips)
kMovieMediaAltText				EQU		'altt'				; string of alternate text if media isn't loaded
kMovieMediaClipBegin			EQU		'clpb'				; MovieMediaTimeRecord of start time of embedded media
kMovieMediaClipDuration			EQU		'clpd'				; MovieMediaTimeRecord of duration of embedded media
kMovieMediaRegionAtom			EQU		'regi'				; contains subatoms that describe layout
kMovieMediaSlaveTrackDuration	EQU		'sltr'				; Boolean indicating that media handler should adjust track and media based on actual embedded movie duration
kMovieMediaEnableFrameStepping	EQU		'enfs'				; boolean. if true stepping on external movie steps frames within embedded movie.
kMovieMediaBackgroundColor		EQU		'bkcl'				; RGBColor.
;  fit types

kMovieMediaFitNone				EQU		0
kMovieMediaFitScroll			EQU		'scro'
kMovieMediaFitClipIfNecessary	EQU		'hidd'
kMovieMediaFitFill				EQU		'fill'
kMovieMediaFitMeet				EQU		'meet'
kMovieMediaFitSlice				EQU		'slic'
;  sub atoms for region atom

kMovieMediaSpatialAdjustment	EQU		'fit '				; OSType from kMovieMediaFit*
kMovieMediaRectangleAtom		EQU		'rect'
kMovieMediaTop					EQU		'top '
kMovieMediaLeft					EQU		'left'
kMovieMediaWidth				EQU		'wd  '
kMovieMediaHeight				EQU		'ht  '
;  contained movie properties

kMoviePropertyDuration			EQU		'dura'				; TimeValue *
kMoviePropertyTimeScale			EQU		'tims'				; TimeValue *
kMoviePropertyTime				EQU		'timv'				; TimeValue *
kMoviePropertyNaturalBounds		EQU		'natb'				; Rect *
kMoviePropertyMatrix			EQU		'mtrx'				; Matrix *
kMoviePropertyTrackList			EQU		'tlst'				; long ***


kTrackPropertyMediaType			EQU		'mtyp'				; OSType
kTrackPropertyInstantiation		EQU		'inst'				; MovieMediaInstantiationInfoRecord
MovieMediaTimeRecord	RECORD 0
time					 ds		wide			; offset: $0 (0)
scale					 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
MovieMediaInstantiationInfoRecord RECORD 0
immediately				 ds.b	1				; offset: $0 (0)
pad						 ds.b	1				; offset: $1 (1)
bitRate					 ds.l	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; *************************
;* Movie Media routines
;*************************



	IF CALL_NOT_IN_CARBON THEN
;
; pascal ComponentResult MovieMediaGetChildDoMCActionCallback(MediaHandler mh, DoMCActionUPP *doMCActionCallbackProc, long *refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieMediaGetChildDoMCActionCallback
			move.l              #$00080102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieMediaGetChildDoMCActionCallback
	ENDIF

;
; pascal ComponentResult MovieMediaGetDoMCActionCallback(MediaHandler mh, DoMCActionUPP *doMCActionCallbackProc, long *refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieMediaGetDoMCActionCallback
			move.l              #$00080103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieMediaGetDoMCActionCallback
	ENDIF

;
; pascal ComponentResult MovieMediaGetCurrentMovieProperty(MediaHandler mh, OSType whichProperty, void *value)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieMediaGetCurrentMovieProperty
			move.l              #$00080104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieMediaGetCurrentMovieProperty
	ENDIF

;
; pascal ComponentResult MovieMediaGetCurrentTrackProperty(MediaHandler mh, long trackID, OSType whichProperty, void *value)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieMediaGetCurrentTrackProperty
			move.l              #$000C0105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieMediaGetCurrentTrackProperty
	ENDIF

;
; pascal ComponentResult MovieMediaGetChildMovieDataReference(MediaHandler mh, QTAtomID dataRefID, short dataRefIndex, OSType *dataRefType, Handle *dataRef, QTAtomID *dataRefIDOut, short *dataRefIndexOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieMediaGetChildMovieDataReference
			move.l              #$00160106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieMediaGetChildMovieDataReference
	ENDIF

;
; pascal ComponentResult MovieMediaSetChildMovieDataReference(MediaHandler mh, QTAtomID dataRefID, OSType dataRefType, Handle dataRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieMediaSetChildMovieDataReference
			move.l              #$000C0107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieMediaSetChildMovieDataReference
	ENDIF

;
; pascal ComponentResult MovieMediaLoadChildMovieFromDataReference(MediaHandler mh, QTAtomID dataRefID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieMediaLoadChildMovieFromDataReference
			move.l              #$00040108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieMediaLoadChildMovieFromDataReference
	ENDIF


	ENDIF	; CALL_NOT_IN_CARBON

; *************************
;* 3D Media routines
;*************************

;
; pascal ComponentResult Media3DGetNamedObjectList(MediaHandler mh, QTAtomContainer *objectList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DGetNamedObjectList
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DGetNamedObjectList
	ENDIF

;
; pascal ComponentResult Media3DGetRendererList(MediaHandler mh, QTAtomContainer *rendererList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DGetRendererList
			move.l              #$00040102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DGetRendererList
	ENDIF

;
; pascal ComponentResult Media3DGetCurrentGroup(MediaHandler mh, void *group)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DGetCurrentGroup
			move.l              #$00040103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DGetCurrentGroup
	ENDIF

;
; pascal ComponentResult Media3DTranslateNamedObjectTo(MediaHandler mh, char *objectName, Fixed x, Fixed y, Fixed z)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DTranslateNamedObjectTo
			move.l              #$00100104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DTranslateNamedObjectTo
	ENDIF

;
; pascal ComponentResult Media3DScaleNamedObjectTo(MediaHandler mh, char *objectName, Fixed xScale, Fixed yScale, Fixed zScale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DScaleNamedObjectTo
			move.l              #$00100105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DScaleNamedObjectTo
	ENDIF

;
; pascal ComponentResult Media3DRotateNamedObjectTo(MediaHandler mh, char *objectName, Fixed xDegrees, Fixed yDegrees, Fixed zDegrees)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DRotateNamedObjectTo
			move.l              #$00100106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DRotateNamedObjectTo
	ENDIF

;
; pascal ComponentResult Media3DSetCameraData(MediaHandler mh, void *cameraData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DSetCameraData
			move.l              #$00040107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DSetCameraData
	ENDIF

;
; pascal ComponentResult Media3DGetCameraData(MediaHandler mh, void *cameraData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DGetCameraData
			move.l              #$00040108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DGetCameraData
	ENDIF

;
; pascal ComponentResult Media3DSetCameraAngleAspect(MediaHandler mh, QTFloatSingle fov, QTFloatSingle aspectRatioXToY)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DSetCameraAngleAspect
			move.l              #$00080109,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DSetCameraAngleAspect
	ENDIF

;
; pascal ComponentResult Media3DGetCameraAngleAspect(MediaHandler mh, QTFloatSingle *fov, QTFloatSingle *aspectRatioXToY)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DGetCameraAngleAspect
			move.l              #$0008010A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DGetCameraAngleAspect
	ENDIF


;
; pascal ComponentResult Media3DSetCameraRange(MediaHandler mh, void *tQ3CameraRange)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DSetCameraRange
			move.l              #$0004010D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DSetCameraRange
	ENDIF

;
; pascal ComponentResult Media3DGetCameraRange(MediaHandler mh, void *tQ3CameraRange)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DGetCameraRange
			move.l              #$0004010E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DGetCameraRange
	ENDIF

	IF CALL_NOT_IN_CARBON THEN
;
; pascal ComponentResult Media3DGetViewObject(MediaHandler mh, void *tq3viewObject)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Media3DGetViewObject
			move.l              #$0004010F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Media3DGetViewObject
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON


; ****************************************
;*                                       *
;*   M O V I E   C O N T R O L L E R     *
;*                                       *
;***************************************


MovieControllerComponentType	EQU		'play'


kMovieControllerQTVRFlag		EQU		$01
kMovieControllerDontDisplayToUser EQU	$02
; typedef ComponentInstance 			MovieController

; typedef MovieController *				MovieControllerPtr


mcActionIdle					EQU		1					; no param
mcActionDraw					EQU		2					; param is WindowRef
mcActionActivate				EQU		3					; no param
mcActionDeactivate				EQU		4					; no param
mcActionMouseDown				EQU		5					; param is pointer to EventRecord
mcActionKey						EQU		6					; param is pointer to EventRecord
mcActionPlay					EQU		8					; param is Fixed, play rate
mcActionGoToTime				EQU		12					; param is TimeRecord
mcActionSetVolume				EQU		14					; param is a short
mcActionGetVolume				EQU		15					; param is pointer to a short
mcActionStep					EQU		18					; param is number of steps (short)
mcActionSetLooping				EQU		21					; param is Boolean
mcActionGetLooping				EQU		22					; param is pointer to a Boolean
mcActionSetLoopIsPalindrome		EQU		23					; param is Boolean
mcActionGetLoopIsPalindrome		EQU		24					; param is pointer to a Boolean
mcActionSetGrowBoxBounds		EQU		25					; param is a Rect
mcActionControllerSizeChanged	EQU		26					; no param
mcActionSetSelectionBegin		EQU		29					; param is TimeRecord
mcActionSetSelectionDuration	EQU		30					; param is TimeRecord, action only taken on set-duration
mcActionSetKeysEnabled			EQU		32					; param is Boolean
mcActionGetKeysEnabled			EQU		33					; param is pointer to Boolean
mcActionSetPlaySelection		EQU		34					; param is Boolean
mcActionGetPlaySelection		EQU		35					; param is pointer to Boolean
mcActionSetUseBadge				EQU		36					; param is Boolean
mcActionGetUseBadge				EQU		37					; param is pointer to Boolean
mcActionSetFlags				EQU		38					; param is long of flags
mcActionGetFlags				EQU		39					; param is pointer to a long of flags
mcActionSetPlayEveryFrame		EQU		40					; param is Boolean
mcActionGetPlayEveryFrame		EQU		41					; param is pointer to Boolean
mcActionGetPlayRate				EQU		42					; param is pointer to Fixed
mcActionShowBalloon				EQU		43					; param is a pointer to a boolean. set to false to stop balloon
mcActionBadgeClick				EQU		44					; param is pointer to Boolean. set to false to ignore click
mcActionMovieClick				EQU		45					; param is pointer to event record. change "what" to nullEvt to kill click
mcActionSuspend					EQU		46					; no param
mcActionResume					EQU		47					; no param
mcActionSetControllerKeysEnabled EQU	48					; param is Boolean
mcActionGetTimeSliderRect		EQU		49					; param is pointer to rect
mcActionMovieEdited				EQU		50					; no param
mcActionGetDragEnabled			EQU		51					; param is pointer to Boolean
mcActionSetDragEnabled			EQU		52					; param is Boolean
mcActionGetSelectionBegin		EQU		53					; param is TimeRecord
mcActionGetSelectionDuration	EQU		54					; param is TimeRecord
mcActionPrerollAndPlay			EQU		55					; param is Fixed, play rate
mcActionGetCursorSettingEnabled	EQU		56					; param is pointer to Boolean
mcActionSetCursorSettingEnabled	EQU		57					; param is Boolean
mcActionSetColorTable			EQU		58					; param is CTabHandle
mcActionLinkToURL				EQU		59					; param is Handle to URL
mcActionCustomButtonClick		EQU		60					; param is pointer to EventRecord
mcActionForceTimeTableUpdate	EQU		61					; no param
mcActionSetControllerTimeLimits	EQU		62					; param is pointer to 2 time values min/max. do no send this message to controller. used internally only.
mcActionExecuteAllActionsForQTEvent EQU	63					; param is ResolvedQTEventSpecPtr
mcActionExecuteOneActionForQTEvent EQU	64					; param is ResolvedQTEventSpecPtr
mcActionAdjustCursor			EQU		65					; param is pointer to EventRecord (WindowRef is in message parameter)
mcActionUseTrackForTimeTable	EQU		66					; param is pointer to {long trackID; Boolean useIt}. do not send this message to controller. 
mcActionClickAndHoldPoint		EQU		67					; param is point (local coordinates). return true if point has click & hold action (e.g., VR object movie autorotate spot)
mcActionShowMessageString		EQU		68					; param is a StringPtr
mcActionShowStatusString		EQU		69					; param is a QTStatusStringPtr
mcActionGetExternalMovie		EQU		70					; param is a QTGetExternalMoviePtr
mcActionGetChapterTime			EQU		71					; param is a QTGetChapterTimePtr
mcActionPerformActionList		EQU		72					; param is a QTAtomSpecPtr
mcActionEvaluateExpression		EQU		73					; param is a QTEvaluateExpressionPtr
mcActionFetchParameterAs		EQU		74					; param is a QTFetchParameterAsPtr
mcActionGetCursorByID			EQU		75					; param is a QTGetCursorByIDPtr
mcActionGetNextURL				EQU		76					; param is a Handle to URL
mcActionMovieChanged			EQU		77
mcActionDoScript				EQU		78					; param is QTDoScriptPtr
mcActionRestartAtTime			EQU		79					; param is QTResartAtTimePtr
mcActionGetIndChapter			EQU		80					; param is QTChapterInfoPtr
mcActionLinkToURLExtended		EQU		81					; param is QTAtomContainer as used by QTParseHREF
; typedef short 						mcAction


mcFlagSuppressMovieFrame		EQU		$01
mcFlagSuppressStepButtons		EQU		$02
mcFlagSuppressSpeakerButton		EQU		$04
mcFlagsUseWindowPalette			EQU		$08
mcFlagsDontInvalidate			EQU		$10
mcFlagsUseCustomButton			EQU		$20


mcPositionDontInvalidate		EQU		$20
; typedef unsigned long 				mcFlags


kMCIEEnabledButtonPicture		EQU		1
kMCIEDisabledButtonPicture		EQU		2
kMCIEDepressedButtonPicture		EQU		3
kMCIEEnabledSizeBoxPicture		EQU		4
kMCIEDisabledSizeBoxPicture		EQU		5
kMCIEEnabledUnavailableButtonPicture EQU 6
kMCIEDisabledUnavailableButtonPicture EQU 7
kMCIESoundSlider				EQU		128
kMCIESoundThumb					EQU		129
kMCIEColorTable					EQU		256
kMCIEIsFlatAppearance			EQU		257
kMCIEDoButtonIconsDropOnDepress	EQU		258
; typedef unsigned long 				MCInterfaceElement

; 
;    menu related stuff
;


mcInfoUndoAvailable				EQU		$01
mcInfoCutAvailable				EQU		$02
mcInfoCopyAvailable				EQU		$04
mcInfoPasteAvailable			EQU		$08
mcInfoClearAvailable			EQU		$10
mcInfoHasSound					EQU		$20
mcInfoIsPlaying					EQU		$40
mcInfoIsLooping					EQU		$80
mcInfoIsInPalindrome			EQU		$0100
mcInfoEditingEnabled			EQU		$0200
mcInfoMovieIsInteractive		EQU		$0400
;  menu item codes

mcMenuUndo						EQU		1
mcMenuCut						EQU		3
mcMenuCopy						EQU		4
mcMenuPaste						EQU		5
mcMenuClear						EQU		6
;  structures used as mcActionFilterProc params
QTStatusStringRecord	RECORD 0
stringTypeFlags			 ds.l	1				; offset: $0 (0)
statusString			 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct QTStatusStringRecord *	QTStatusStringPtr

QTGetExternalMovieRecord RECORD 0
targetType				 ds.l	1				; offset: $0 (0)		;  set to kTargetMovieName or kTargetMovieID
movieName				 ds.l	1				; offset: $4 (4)
movieID					 ds.l	1				; offset: $8 (8)
theMovie				 ds.l	1				; offset: $C (12)
theController			 ds.l	1				; offset: $10 (16)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct QTGetExternalMovieRecord * QTGetExternalMoviePtr

QTGetChapterTimeRecord	RECORD 0
chapterName				 ds.l	1				; offset: $0 (0)
chapterTime				 ds		TimeRecord		; offset: $4 (4)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct QTGetChapterTimeRecord * QTGetChapterTimePtr

QTChapterInfoRecord		RECORD 0
index					 ds.l	1				; offset: $0 (0)		;  first chapter has index of 1
time					 ds.l	1				; offset: $4 (4)		;  -1 if no more chapters available
name					 ds		Str255			; offset: $8 (8)
sizeof					 EQU *					; size:   $108 (264)
						ENDR
; typedef struct QTChapterInfoRecord *	QTChapterInfoPtr

QTEvaluateExpressionRecord RECORD 0
expressionSpec			 ds		QTAtomSpec		; offset: $0 (0)
expressionResult		 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct QTEvaluateExpressionRecord * QTEvaluateExpressionPtr

QTFetchParameterAsRecord RECORD 0
paramListSpec			 ds		QTAtomSpec		; offset: $0 (0)
paramIndex				 ds.l	1				; offset: $8 (8)
paramType				 ds.l	1				; offset: $C (12)
allowedFlags			 ds.l	1				; offset: $10 (16)
min						 ds.l	1				; offset: $14 (20)
max						 ds.l	1				; offset: $18 (24)
currentValue			 ds.l	1				; offset: $1C (28)
newValue				 ds.l	1				; offset: $20 (32)
isUnsignedValue			 ds.b	1				; offset: $24 (36)
						 ORG 38
sizeof					 EQU *					; size:   $26 (38)
						ENDR
; typedef struct QTFetchParameterAsRecord * QTFetchParameterAsPtr

QTGetCursorByIDRecord	RECORD 0
cursorID				 ds.w	1				; offset: $0 (0)
colorCursorData			 ds.l	1				; offset: $2 (2)
reserved1				 ds.l	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct QTGetCursorByIDRecord * QTGetCursorByIDPtr

QTDoScriptRecord		RECORD 0
scriptTypeFlags			 ds.l	1				; offset: $0 (0)
command					 ds.l	1				; offset: $4 (4)
arguments				 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct QTDoScriptRecord *		QTDoScriptPtr

QTRestartAtTimeRecord	RECORD 0
startTime				 ds.l	1				; offset: $0 (0)		;  time scale is the movie timescale
rate					 ds.l	1				; offset: $4 (4)		;  if rate is zero, the movie's current rate is maintained
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct QTRestartAtTimeRecord * QTRestartAtTimePtr

;  values for paramType field of QTFetchParameterAsRecord

kFetchAsBooleanPtr				EQU		1
kFetchAsShortPtr				EQU		2
kFetchAsLongPtr					EQU		3
kFetchAsMatrixRecordPtr			EQU		4
kFetchAsModifierTrackGraphicsModeRecord EQU 5
kFetchAsHandle					EQU		6
kFetchAsStr255					EQU		7
kFetchAsFloatPtr				EQU		8
kFetchAsPointPtr				EQU		9
kFetchAsNewAtomContainer		EQU		10
kFetchAsQTEventRecordPtr		EQU		11
kFetchAsFixedPtr				EQU		12
kFetchAsSetControllerValuePtr	EQU		13
kFetchAsRgnHandle				EQU		14					; flipped to native
kFetchAsComponentDescriptionPtr	EQU		15
kFetchAsCString					EQU		16

kQTCursorOpenHand				EQU		-19183
kQTCursorClosedHand				EQU		-19182
kQTCursorPointingHand			EQU		-19181
kQTCursorRightArrow				EQU		-19180
kQTCursorLeftArrow				EQU		-19179
kQTCursorDownArrow				EQU		-19178
kQTCursorUpArrow				EQU		-19177
kQTCursorIBeam					EQU		-19176





;  target management 
;
; pascal ComponentResult MCSetMovie(MovieController mc, Movie theMovie, WindowRef movieWindow, Point where)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetMovie
			move.l              #$000C0002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetMovie
	ENDIF

;
; pascal Movie MCGetIndMovie(MovieController mc, short index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetIndMovie
			move.l              #$00020005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetIndMovie
	ENDIF


;
; pascal ComponentResult MCRemoveAllMovies(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCRemoveAllMovies
			move.l              #$00000006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCRemoveAllMovies
	ENDIF

;
; pascal ComponentResult MCRemoveAMovie(MovieController mc, Movie m)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCRemoveAMovie
			move.l              #$00040003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCRemoveAMovie
	ENDIF

;
; pascal ComponentResult MCRemoveMovie(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCRemoveMovie
			move.l              #$00000006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCRemoveMovie
	ENDIF

;  event handling etc. 
;
; pascal ComponentResult MCIsPlayerEvent(MovieController mc, const EventRecord *e)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCIsPlayerEvent
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCIsPlayerEvent
	ENDIF

;  obsolete. use MCSetActionFilterWithRefCon instead. 
;
; pascal ComponentResult MCSetActionFilter(MovieController mc, MCActionFilterUPP blob)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetActionFilter
			move.l              #$00040008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetActionFilter
	ENDIF

; 
;    proc is of the form:
;        Boolean userPlayerFilter(MovieController mc, short *action, void *params) =
;    proc returns TRUE if it handles the action, FALSE if not
;    action is passed as a VAR so that it could be changed by filter
;    this is consistent with the current dialog manager stuff
;    params is any potential parameters that go with the action
;        such as set playback rate to xxx.
;

;
; pascal ComponentResult MCDoAction(MovieController mc, short action, void *params)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCDoAction
			move.l              #$00060009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCDoAction
	ENDIF

;  state type things 
;
; pascal ComponentResult MCSetControllerAttached(MovieController mc, Boolean attach)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetControllerAttached
			move.l              #$0002000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetControllerAttached
	ENDIF

;
; pascal ComponentResult MCIsControllerAttached(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCIsControllerAttached
			move.l              #$0000000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCIsControllerAttached
	ENDIF

;
; pascal ComponentResult MCSetControllerPort(MovieController mc, CGrafPtr gp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetControllerPort
			move.l              #$0004000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetControllerPort
	ENDIF

;
; pascal CGrafPtr MCGetControllerPort(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetControllerPort
			move.l              #$0000000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetControllerPort
	ENDIF

;
; pascal ComponentResult MCSetVisible(MovieController mc, Boolean visible)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetVisible
			move.l              #$0002000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetVisible
	ENDIF

;
; pascal ComponentResult MCGetVisible(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetVisible
			move.l              #$0000000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetVisible
	ENDIF

;
; pascal ComponentResult MCGetControllerBoundsRect(MovieController mc, Rect *bounds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetControllerBoundsRect
			move.l              #$00040010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetControllerBoundsRect
	ENDIF

;
; pascal ComponentResult MCSetControllerBoundsRect(MovieController mc, const Rect *bounds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetControllerBoundsRect
			move.l              #$00040011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetControllerBoundsRect
	ENDIF

;
; pascal RgnHandle MCGetControllerBoundsRgn(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetControllerBoundsRgn
			move.l              #$00000012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetControllerBoundsRgn
	ENDIF

;
; pascal RgnHandle MCGetWindowRgn(MovieController mc, WindowRef w)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetWindowRgn
			move.l              #$00040013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetWindowRgn
	ENDIF


;  other stuff 
;
; pascal ComponentResult MCMovieChanged(MovieController mc, Movie m)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCMovieChanged
			move.l              #$00040014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCMovieChanged
	ENDIF


; 
;    called when the app has changed thing about the movie (like bounding rect) or rate. So that we
;        can update our graphical (and internal) state accordingly.
;

;
; pascal ComponentResult MCSetDuration(MovieController mc, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetDuration
			move.l              #$00040015,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetDuration
	ENDIF

; 
;    duration to use for time slider -- will be reset next time MCMovieChanged is called
;        or MCSetMovie is called
;

;
; pascal TimeValue MCGetCurrentTime(MovieController mc, TimeScale *scale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetCurrentTime
			move.l              #$00040016,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetCurrentTime
	ENDIF

; 
;    returns the time value and the time scale it is on. if there are no movies, the
;        time scale is passed back as 0. scale is an optional parameter
;
;

;
; pascal ComponentResult MCNewAttachedController(MovieController mc, Movie theMovie, WindowRef w, Point where)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCNewAttachedController
			move.l              #$000C0017,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCNewAttachedController
	ENDIF

; 
;    makes theMovie the only movie attached to the controller. makes the controller visible.
;    the window and where parameters are passed a long to MCSetMovie and behave as
;    described there
;

;
; pascal ComponentResult MCDraw(MovieController mc, WindowRef w)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCDraw
			move.l              #$00040018,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCDraw
	ENDIF

;
; pascal ComponentResult MCActivate(MovieController mc, WindowRef w, Boolean activate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCActivate
			move.l              #$00060019,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCActivate
	ENDIF

;
; pascal ComponentResult MCIdle(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCIdle
			move.l              #$0000001A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCIdle
	ENDIF

;
; pascal ComponentResult MCKey(MovieController mc, SInt8 key, long modifiers)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCKey
			move.l              #$0006001B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCKey
	ENDIF

;
; pascal ComponentResult MCClick(MovieController mc, WindowRef w, Point where, long when, long modifiers)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCClick
			move.l              #$0010001C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCClick
	ENDIF


; 
;    calls for editing
;

;
; pascal ComponentResult MCEnableEditing(MovieController mc, Boolean enabled)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCEnableEditing
			move.l              #$0002001D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCEnableEditing
	ENDIF

;
; pascal long MCIsEditingEnabled(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCIsEditingEnabled
			move.l              #$0000001E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCIsEditingEnabled
	ENDIF

;
; pascal Movie MCCopy(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCCopy
			move.l              #$0000001F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCCopy
	ENDIF

;
; pascal Movie MCCut(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCCut
			move.l              #$00000020,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCCut
	ENDIF

;
; pascal ComponentResult MCPaste(MovieController mc, Movie srcMovie)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCPaste
			move.l              #$00040021,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCPaste
	ENDIF

;
; pascal ComponentResult MCClear(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCClear
			move.l              #$00000022,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCClear
	ENDIF

;
; pascal ComponentResult MCUndo(MovieController mc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCUndo
			move.l              #$00000023,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCUndo
	ENDIF


; 
; *  somewhat special stuff
; 

;
; pascal ComponentResult MCPositionController(MovieController mc, const Rect *movieRect, const Rect *controllerRect, long someFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCPositionController
			move.l              #$000C0024,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCPositionController
	ENDIF


;
; pascal ComponentResult MCGetControllerInfo(MovieController mc, long *someFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetControllerInfo
			move.l              #$00040025,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetControllerInfo
	ENDIF



;
; pascal ComponentResult MCSetClip(MovieController mc, RgnHandle theClip, RgnHandle movieClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetClip
			move.l              #$00080028,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetClip
	ENDIF

;
; pascal ComponentResult MCGetClip(MovieController mc, RgnHandle *theClip, RgnHandle *movieClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetClip
			move.l              #$00080029,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetClip
	ENDIF


;
; pascal ComponentResult MCDrawBadge(MovieController mc, RgnHandle movieRgn, RgnHandle *badgeRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCDrawBadge
			move.l              #$0008002A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCDrawBadge
	ENDIF

;
; pascal ComponentResult MCSetUpEditMenu(MovieController mc, long modifiers, MenuRef mh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetUpEditMenu
			move.l              #$0008002B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetUpEditMenu
	ENDIF

;
; pascal ComponentResult MCGetMenuString(MovieController mc, long modifiers, short item, Str255 aString)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetMenuString
			move.l              #$000A002C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetMenuString
	ENDIF

;
; pascal ComponentResult MCSetActionFilterWithRefCon(MovieController mc, MCActionFilterWithRefConUPP blob, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCSetActionFilterWithRefCon
			move.l              #$0008002D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCSetActionFilterWithRefCon
	ENDIF

;
; pascal ComponentResult MCPtInController(MovieController mc, Point thePt, Boolean *inController)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCPtInController
			move.l              #$0008002E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCPtInController
	ENDIF

;
; pascal ComponentResult MCInvalidate(MovieController mc, WindowRef w, RgnHandle invalidRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCInvalidate
			move.l              #$0008002F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCInvalidate
	ENDIF

;
; pascal ComponentResult MCAdjustCursor(MovieController mc, WindowRef w, Point where, long modifiers)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCAdjustCursor
			move.l              #$000C0030,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCAdjustCursor
	ENDIF

;
; pascal ComponentResult MCGetInterfaceElement(MovieController mc, MCInterfaceElement whichElement, void *element)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetInterfaceElement
			move.l              #$00080031,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetInterfaceElement
	ENDIF

;
; pascal ComponentResult MCGetDoActionsProc(MovieController mc, DoMCActionUPP *doMCActionProc, long *doMCActionRefCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MCGetDoActionsProc
			move.l              #$00080032,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MCGetDoActionsProc
	ENDIF





; ****************************************
;*                                       *
;*       T  I  M  E  B  A  S  E          *
;*                                       *
;***************************************

;
; pascal TimeBase NewTimeBase(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewTimeBase
			move.w              #$00A5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewTimeBase
	ENDIF

;
; pascal void DisposeTimeBase(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeTimeBase
			move.w              #$00B6,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeTimeBase
	ENDIF

;
; pascal TimeValue GetTimeBaseTime(TimeBase tb, TimeScale s, TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseTime
			move.w              #$00A6,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseTime
	ENDIF

;
; pascal void SetTimeBaseTime(TimeBase tb, const TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseTime
			move.w              #$00A7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseTime
	ENDIF

;
; pascal void SetTimeBaseValue(TimeBase tb, TimeValue t, TimeScale s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseValue
			move.w              #$00A8,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseValue
	ENDIF

;
; pascal Fixed GetTimeBaseRate(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseRate
			move.w              #$00A9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseRate
	ENDIF

;
; pascal void SetTimeBaseRate(TimeBase tb, Fixed r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseRate
			move.w              #$00AA,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseRate
	ENDIF

;
; pascal TimeValue GetTimeBaseStartTime(TimeBase tb, TimeScale s, TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseStartTime
			move.w              #$00AB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseStartTime
	ENDIF

;
; pascal void SetTimeBaseStartTime(TimeBase tb, const TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseStartTime
			move.w              #$00AC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseStartTime
	ENDIF

;
; pascal TimeValue GetTimeBaseStopTime(TimeBase tb, TimeScale s, TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseStopTime
			move.w              #$00AD,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseStopTime
	ENDIF

;
; pascal void SetTimeBaseStopTime(TimeBase tb, const TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseStopTime
			move.w              #$00AE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseStopTime
	ENDIF

;
; pascal long GetTimeBaseFlags(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseFlags
			move.w              #$00B1,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseFlags
	ENDIF

;
; pascal void SetTimeBaseFlags(TimeBase tb, long timeBaseFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseFlags
			move.w              #$00B2,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseFlags
	ENDIF

;
; pascal void SetTimeBaseMasterTimeBase(TimeBase slave, TimeBase master, const TimeRecord *slaveZero)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseMasterTimeBase
			move.w              #$00B4,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseMasterTimeBase
	ENDIF

;
; pascal TimeBase GetTimeBaseMasterTimeBase(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseMasterTimeBase
			move.w              #$00AF,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseMasterTimeBase
	ENDIF

;
; pascal void SetTimeBaseMasterClock(TimeBase slave, Component clockMeister, const TimeRecord *slaveZero)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseMasterClock
			move.w              #$00B3,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseMasterClock
	ENDIF

;
; pascal ComponentInstance GetTimeBaseMasterClock(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseMasterClock
			move.w              #$00B0,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseMasterClock
	ENDIF

;
; pascal void ConvertTime(TimeRecord *inout, TimeBase newBase)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ConvertTime
			move.w              #$00B5,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ConvertTime
	ENDIF

;
; pascal void ConvertTimeScale(TimeRecord *inout, TimeScale newScale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ConvertTimeScale
			move.w              #$00B7,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ConvertTimeScale
	ENDIF

;
; pascal void AddTime(TimeRecord *dst, const TimeRecord *src)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddTime
			move.w              #$010C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddTime
	ENDIF

;
; pascal void SubtractTime(TimeRecord *dst, const TimeRecord *src)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SubtractTime
			move.w              #$010D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SubtractTime
	ENDIF

;
; pascal long GetTimeBaseStatus(TimeBase tb, TimeRecord *unpinnedTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseStatus
			move.w              #$010B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseStatus
	ENDIF

;
; pascal void SetTimeBaseZero(TimeBase tb, TimeRecord *zero)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeBaseZero
			move.w              #$0128,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeBaseZero
	ENDIF

;
; pascal Fixed GetTimeBaseEffectiveRate(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeBaseEffectiveRate
			move.w              #$0124,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeBaseEffectiveRate
	ENDIF


; ****************************************
;*                                       *
;*       C  A  L  L  B  A  C  K          *
;*                                       *
;***************************************

;
; pascal QTCallBack NewCallBack(TimeBase tb, short cbType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewCallBack
			move.w              #$00EB,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewCallBack
	ENDIF

;
; pascal void DisposeCallBack(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeCallBack
			move.w              #$00EC,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeCallBack
	ENDIF

;
; pascal short GetCallBackType(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetCallBackType
			move.w              #$00ED,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCallBackType
	ENDIF

;
; pascal TimeBase GetCallBackTimeBase(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetCallBackTimeBase
			move.w              #$00EE,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCallBackTimeBase
	ENDIF

;
; pascal OSErr CallMeWhen(QTCallBack cb, QTCallBackUPP callBackProc, long refCon, long param1, long param2, long param3)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CallMeWhen
			move.w              #$00B8,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CallMeWhen
	ENDIF

;
; pascal void CancelCallBack(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CancelCallBack
			move.w              #$00B9,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CancelCallBack
	ENDIF


; ****************************************
;*                                       *
;*       C L O C K   C A L L B A C K     *
;*             S U P P O R T             *
;*                                       *
;***************************************

;
; pascal OSErr AddCallBackToTimeBase(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AddCallBackToTimeBase
			move.w              #$0129,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AddCallBackToTimeBase
	ENDIF

;
; pascal OSErr RemoveCallBackFromTimeBase(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RemoveCallBackFromTimeBase
			move.w              #$012A,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveCallBackFromTimeBase
	ENDIF

;
; pascal QTCallBack GetFirstCallBack(TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetFirstCallBack
			move.w              #$012B,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetFirstCallBack
	ENDIF

;
; pascal QTCallBack GetNextCallBack(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetNextCallBack
			move.w              #$012C,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetNextCallBack
	ENDIF

;
; pascal void ExecuteCallBack(QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ExecuteCallBack
			move.w              #$012D,D0
			dc.w            	$AAAA
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ExecuteCallBack
	ENDIF





;
; pascal ComponentResult MusicMediaGetIndexedTunePlayer(ComponentInstance ti, long sampleDescIndex, ComponentInstance *tp)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MusicMediaGetIndexedTunePlayer
			move.l              #$00080101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MusicMediaGetIndexedTunePlayer
	ENDIF



;  UPP call backs 

	ENDIF ; __MOVIES__ 


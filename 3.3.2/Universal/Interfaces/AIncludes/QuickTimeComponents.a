;
;    File:       QuickTimeComponents.a
;
;    Contains:   QuickTime Interfaces.
;
;    Version:    Technology: QuickTime 4.1
;                Release:    Universal Interfaces 3.3.2
;
;    Copyright:  © 1990-2000 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__QUICKTIMECOMPONENTS__') = 'UNDEFINED' THEN
__QUICKTIMECOMPONENTS__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF
	IF &TYPE('__COMPONENTS__') = 'UNDEFINED' THEN
	include 'Components.a'
	ENDIF
	IF &TYPE('__IMAGECOMPRESSION__') = 'UNDEFINED' THEN
	include 'ImageCompression.a'
	ENDIF
	IF &TYPE('__MOVIES__') = 'UNDEFINED' THEN
	include 'Movies.a'
	ENDIF
	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF
	IF &TYPE('__VIDEO__') = 'UNDEFINED' THEN
	include 'Video.a'
	ENDIF
	IF &TYPE('__SOUND__') = 'UNDEFINED' THEN
	include 'Sound.a'
	ENDIF
	IF &TYPE('__QUICKTIMEMUSIC__') = 'UNDEFINED' THEN
	include 'QuickTimeMusic.a'
	ENDIF


clockComponentType				EQU		'clok'
systemTickClock					EQU		'tick'				; subtype: 60ths since boot   
systemSecondClock				EQU		'seco'				; subtype: seconds since 1904       
systemMillisecondClock			EQU		'mill'				; subtype: 1000ths since boot       
systemMicrosecondClock			EQU		'micr'				; subtype: 1000000ths since boot 

kClockRateIsLinear				EQU		1
kClockImplementsCallBacks		EQU		2
kClockCanHandleIntermittentSound EQU	4					; sound clocks only 
; * These are Clock procedures *
;
; pascal ComponentResult ClockGetTime(ComponentInstance aClock, TimeRecord *out)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockGetTime
			move.l              #$00040001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockGetTime
	ENDIF


;
; pascal QTCallBack ClockNewCallBack(ComponentInstance aClock, TimeBase tb, short callBackType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockNewCallBack
			move.l              #$00060002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockNewCallBack
	ENDIF

;
; pascal ComponentResult ClockDisposeCallBack(ComponentInstance aClock, QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockDisposeCallBack
			move.l              #$00040003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockDisposeCallBack
	ENDIF

;
; pascal ComponentResult ClockCallMeWhen(ComponentInstance aClock, QTCallBack cb, long param1, long param2, long param3)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockCallMeWhen
			move.l              #$00100004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockCallMeWhen
	ENDIF

;
; pascal ComponentResult ClockCancelCallBack(ComponentInstance aClock, QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockCancelCallBack
			move.l              #$00040005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockCancelCallBack
	ENDIF

;
; pascal ComponentResult ClockRateChanged(ComponentInstance aClock, QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockRateChanged
			move.l              #$00040006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockRateChanged
	ENDIF

;
; pascal ComponentResult ClockTimeChanged(ComponentInstance aClock, QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockTimeChanged
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockTimeChanged
	ENDIF

;
; pascal ComponentResult ClockSetTimeBase(ComponentInstance aClock, TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockSetTimeBase
			move.l              #$00040008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockSetTimeBase
	ENDIF

;
; pascal ComponentResult ClockStartStopChanged(ComponentInstance aClock, QTCallBack cb, Boolean startChanged, Boolean stopChanged)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockStartStopChanged
			move.l              #$00080009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockStartStopChanged
	ENDIF

;
; pascal ComponentResult ClockGetRate(ComponentInstance aClock, Fixed *rate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockGetRate
			move.l              #$0004000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockGetRate
	ENDIF





StandardCompressionType			EQU		'scdi'
StandardCompressionSubType		EQU		'imag'
StandardCompressionSubTypeSound	EQU		'soun'

;   Preference flags.

scListEveryCodec				EQU		$00000002
scAllowZeroFrameRate			EQU		$00000004
scAllowZeroKeyFrameRate			EQU		$00000008
scShowBestDepth					EQU		$00000010
scUseMovableModal				EQU		$00000020
scDisableFrameRateItem			EQU		$00000040

;   Possible test flags for setting test image.

scPreferCropping				EQU		$01
scPreferScaling					EQU		$02
scPreferScalingAndCropping		EQU		$03
scDontDetermineSettingsFromTestImage EQU $04

;   Dimensions of the image preview box.

scTestImageWidth				EQU		80
scTestImageHeight				EQU		80
;   Possible items returned by hookProc.

scOKItem						EQU		1
scCancelItem					EQU		2
scCustomItem					EQU		3
;   Result returned when user cancelled.

scUserCancelled					EQU		1


;   Get/SetInfo structures.

SCSpatialSettings		RECORD 0
codecType				 ds.l	1				; offset: $0 (0)
codec					 ds.l	1				; offset: $4 (4)
depth					 ds.w	1				; offset: $8 (8)
spatialQuality			 ds.l	1				; offset: $A (10)
sizeof					 EQU *					; size:   $E (14)
						ENDR
SCTemporalSettings		RECORD 0
temporalQuality			 ds.l	1				; offset: $0 (0)
frameRate				 ds.l	1				; offset: $4 (4)
keyFrameRate			 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
SCDataRateSettings		RECORD 0
dataRate				 ds.l	1				; offset: $0 (0)
frameDuration			 ds.l	1				; offset: $4 (4)
minSpatialQuality		 ds.l	1				; offset: $8 (8)
minTemporalQuality		 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
SCExtendedProcs			RECORD 0
filterProc				 ds.l	1				; offset: $0 (0)
hookProc				 ds.l	1				; offset: $4 (4)
refcon					 ds.l	1				; offset: $8 (8)
customName				 ds		Str31			; offset: $C (12)
sizeof					 EQU *					; size:   $2C (44)
						ENDR
;   Get/SetInfo selectors

scSpatialSettingsType			EQU		'sptl'				; pointer to SCSpatialSettings struct
scTemporalSettingsType			EQU		'tprl'				; pointer to SCTemporalSettings struct
scDataRateSettingsType			EQU		'drat'				; pointer to SCDataRateSettings struct
scColorTableType				EQU		'clut'				; pointer to CTabHandle
scProgressProcType				EQU		'prog'				; pointer to ProgressRecord struct
scExtendedProcsType				EQU		'xprc'				; pointer to SCExtendedProcs struct
scPreferenceFlagsType			EQU		'pref'				; pointer to long
scSettingsStateType				EQU		'ssta'				; pointer to Handle
scSequenceIDType				EQU		'sequ'				; pointer to ImageSequence
scWindowPositionType			EQU		'wndw'				; pointer to Point
scCodecFlagsType				EQU		'cflg'				; pointer to CodecFlags
scCodecSettingsType				EQU		'cdec'				; pointer to Handle
scForceKeyValueType				EQU		'ksim'				; pointer to long
scSoundSampleRateType			EQU		'ssrt'				; pointer to UnsignedFixed
scSoundSampleSizeType			EQU		'ssss'				; pointer to short
scSoundChannelCountType			EQU		'sscc'				; pointer to short
scSoundCompressionType			EQU		'ssct'				; pointer to OSType
scCompressionListType			EQU		'ctyl'				; pointer to OSType Handle
;   scTypeNotFoundErr returned by Get/SetInfo when type cannot be found.


SCParams				RECORD 0
flags					 ds.l	1				; offset: $0 (0)
theCodecType			 ds.l	1				; offset: $4 (4)
theCodec				 ds.l	1				; offset: $8 (8)
spatialQuality			 ds.l	1				; offset: $C (12)
temporalQuality			 ds.l	1				; offset: $10 (16)
depth					 ds.w	1				; offset: $14 (20)
frameRate				 ds.l	1				; offset: $16 (22)
keyFrameRate			 ds.l	1				; offset: $1A (26)
reserved1				 ds.l	1				; offset: $1E (30)
reserved2				 ds.l	1				; offset: $22 (34)
sizeof					 EQU *					; size:   $26 (38)
						ENDR

scGetCompression				EQU		1
scShowMotionSettings			EQU		$00000001
scSettingsChangedItem			EQU		-1

scCompressFlagIgnoreIdenticalFrames EQU	1
;  QTAtomTypes for atoms found in settings atom containers

kQTSettingsVideo				EQU		'vide'				; Container for video/image compression related atoms (Get/SetInfo selectors)
kQTSettingsSound				EQU		'soun'				; Container for sound compression related atoms (Get/SetInfo selectors)
kQTSettingsComponentVersion		EQU		'vers'				; . Version of component that wrote settings (QTSettingsVersionAtomRecord)
;  Format of 'vers' atom found in settings atom containers
QTSettingsVersionAtomRecord RECORD 0
componentVersion		 ds.l	1				; offset: $0 (0)		;  standard compression component version
flags					 ds.w	1				; offset: $4 (4)		;  low bit is 1 if little endian platform, 0 if big endian platform
reserved				 ds.w	1				; offset: $6 (6)		;  should be 0
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; * These are Progress procedures *
;
; pascal ComponentResult SCGetCompressionExtended(ComponentInstance ci, SCParams *params, Point where, SCModalFilterUPP filterProc, SCModalHookUPP hookProc, long refcon, StringPtr customName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCGetCompressionExtended
			move.l              #$00180001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCGetCompressionExtended
	ENDIF

;
; pascal ComponentResult SCPositionRect(ComponentInstance ci, Rect *rp, Point *where)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCPositionRect
			move.l              #$00080002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCPositionRect
	ENDIF

;
; pascal ComponentResult SCPositionDialog(ComponentInstance ci, short id, Point *where)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCPositionDialog
			move.l              #$00060003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCPositionDialog
	ENDIF

;
; pascal ComponentResult SCSetTestImagePictHandle(ComponentInstance ci, PicHandle testPict, Rect *testRect, short testFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSetTestImagePictHandle
			move.l              #$000A0004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSetTestImagePictHandle
	ENDIF

;
; pascal ComponentResult SCSetTestImagePictFile(ComponentInstance ci, short testFileRef, Rect *testRect, short testFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSetTestImagePictFile
			move.l              #$00080005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSetTestImagePictFile
	ENDIF

;
; pascal ComponentResult SCSetTestImagePixMap(ComponentInstance ci, PixMapHandle testPixMap, Rect *testRect, short testFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSetTestImagePixMap
			move.l              #$000A0006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSetTestImagePixMap
	ENDIF

;
; pascal ComponentResult SCGetBestDeviceRect(ComponentInstance ci, Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCGetBestDeviceRect
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCGetBestDeviceRect
	ENDIF


;
; pascal ComponentResult SCRequestImageSettings(ComponentInstance ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCRequestImageSettings
			move.l              #$0000000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCRequestImageSettings
	ENDIF

;
; pascal ComponentResult SCCompressImage(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, ImageDescriptionHandle *desc, Handle *data)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressImage
			move.l              #$0010000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressImage
	ENDIF

;
; pascal ComponentResult SCCompressPicture(ComponentInstance ci, PicHandle srcPicture, PicHandle dstPicture)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressPicture
			move.l              #$0008000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressPicture
	ENDIF

;
; pascal ComponentResult SCCompressPictureFile(ComponentInstance ci, short srcRefNum, short dstRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressPictureFile
			move.l              #$0004000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressPictureFile
	ENDIF

;
; pascal ComponentResult SCRequestSequenceSettings(ComponentInstance ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCRequestSequenceSettings
			move.l              #$0000000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCRequestSequenceSettings
	ENDIF

;
; pascal ComponentResult SCCompressSequenceBegin(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, ImageDescriptionHandle *desc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressSequenceBegin
			move.l              #$000C000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressSequenceBegin
	ENDIF

;
; pascal ComponentResult SCCompressSequenceFrame(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, Handle *data, long *dataSize, short *notSyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressSequenceFrame
			move.l              #$00140010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressSequenceFrame
	ENDIF

;
; pascal ComponentResult SCCompressSequenceEnd(ComponentInstance ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressSequenceEnd
			move.l              #$00000011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressSequenceEnd
	ENDIF

;
; pascal ComponentResult SCDefaultPictHandleSettings(ComponentInstance ci, PicHandle srcPicture, short motion)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCDefaultPictHandleSettings
			move.l              #$00060012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCDefaultPictHandleSettings
	ENDIF

;
; pascal ComponentResult SCDefaultPictFileSettings(ComponentInstance ci, short srcRef, short motion)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCDefaultPictFileSettings
			move.l              #$00040013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCDefaultPictFileSettings
	ENDIF

;
; pascal ComponentResult SCDefaultPixMapSettings(ComponentInstance ci, PixMapHandle src, short motion)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCDefaultPixMapSettings
			move.l              #$00060014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCDefaultPixMapSettings
	ENDIF

;
; pascal ComponentResult SCGetInfo(ComponentInstance ci, OSType infoType, void *info)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCGetInfo
			move.l              #$00080015,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCGetInfo
	ENDIF

;
; pascal ComponentResult SCSetInfo(ComponentInstance ci, OSType infoType, void *info)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSetInfo
			move.l              #$00080016,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSetInfo
	ENDIF

;
; pascal ComponentResult SCNewGWorld(ComponentInstance ci, GWorldPtr *gwp, Rect *rp, GWorldFlags flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCNewGWorld
			move.l              #$000C0017,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCNewGWorld
	ENDIF

;
; pascal ComponentResult SCSetCompressFlags(ComponentInstance ci, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSetCompressFlags
			move.l              #$00040018,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSetCompressFlags
	ENDIF

;
; pascal ComponentResult SCGetCompressFlags(ComponentInstance ci, long *flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCGetCompressFlags
			move.l              #$00040019,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCGetCompressFlags
	ENDIF

;
; pascal ComponentResult SCGetSettingsAsText(ComponentInstance ci, Handle *text)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCGetSettingsAsText
			move.l              #$0004001A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCGetSettingsAsText
	ENDIF

;
; pascal ComponentResult SCGetSettingsAsAtomContainer(ComponentInstance ci, QTAtomContainer *settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCGetSettingsAsAtomContainer
			move.l              #$0004001B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCGetSettingsAsAtomContainer
	ENDIF

;
; pascal ComponentResult SCSetSettingsFromAtomContainer(ComponentInstance ci, QTAtomContainer settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSetSettingsFromAtomContainer
			move.l              #$0004001C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSetSettingsFromAtomContainer
	ENDIF





TweenComponentType				EQU		'twen'
; typedef ComponentInstance 			TweenerComponent

;
; pascal ComponentResult TweenerInitialize(TweenerComponent tc, QTAtomContainer container, QTAtom tweenAtom, QTAtom dataAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TweenerInitialize
			move.l              #$000C0001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TweenerInitialize
	ENDIF

;
; pascal ComponentResult TweenerDoTween(TweenerComponent tc, TweenRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TweenerDoTween
			move.l              #$00040002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TweenerDoTween
	ENDIF

;
; pascal ComponentResult TweenerReset(TweenerComponent tc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TweenerReset
			move.l              #$00000003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TweenerReset
	ENDIF




TCSourceRefNameType				EQU		'name'

tcDropFrame						EQU		$01
tc24HourMax						EQU		$02
tcNegTimesOK					EQU		$04
tcCounter						EQU		$08
TimeCodeDef				RECORD 0
flags					 ds.l	1				; offset: $0 (0)		;  drop-frame, etc.
fTimeScale				 ds.l	1				; offset: $4 (4)		;  time scale of frameDuration (eg. 2997)
frameDuration			 ds.l	1				; offset: $8 (8)		;  duration of each frame (eg. 100)
numFrames				 ds.b	1				; offset: $C (12)		;  frames/sec for timecode (eg. 30) OR frames/tick for counter mode
padding					 ds.b	1				; offset: $D (13)		;  unused padding byte
sizeof					 EQU *					; size:   $E (14)
						ENDR

tctNegFlag						EQU		$80					; negative bit is in minutes
TimeCodeTime			RECORD 0
hours					 ds.b	1				; offset: $0 (0)
minutes					 ds.b	1				; offset: $1 (1)
seconds					 ds.b	1				; offset: $2 (2)
frames					 ds.b	1				; offset: $3 (3)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
TimeCodeCounter			RECORD 0
counter					 ds.l	1				; offset: $0 (0)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
TimeCodeDescription		RECORD 0
descSize				 ds.l	1				; offset: $0 (0)		;  standard sample description header
dataFormat				 ds.l	1				; offset: $4 (4)
resvd1					 ds.l	1				; offset: $8 (8)
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
flags					 ds.l	1				; offset: $10 (16)		;  timecode specific stuff
timeCodeDef				 ds		TimeCodeDef		; offset: $14 (20)
srcRef					 ds.l	1				; offset: $22 (34) <-- really an array of length one
sizeof					 EQU *					; size:   $26 (38)
						ENDR
; typedef struct TimeCodeDescription *	TimeCodeDescriptionPtr

; typedef TimeCodeDescriptionPtr *		TimeCodeDescriptionHandle


tcdfShowTimeCode				EQU		$01

TCTextOptions			RECORD 0
txFont					 ds.w	1				; offset: $0 (0)
txFace					 ds.w	1				; offset: $2 (2)
txSize					 ds.w	1				; offset: $4 (4)
pad						 ds.w	1				; offset: $6 (6)		;  let's make it longword aligned - thanks.. 
foreColor				 ds		RGBColor		; offset: $8 (8)
backColor				 ds		RGBColor		; offset: $E (14)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct TCTextOptions *		TCTextOptionsPtr

;
; pascal HandlerError TCGetCurrentTimeCode(MediaHandler mh, long *frameNum, TimeCodeDef *tcdef, TimeCodeRecord *tcrec, UserData *srcRefH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCGetCurrentTimeCode
			move.l              #$00100101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCGetCurrentTimeCode
	ENDIF

;
; pascal HandlerError TCGetTimeCodeAtTime(MediaHandler mh, TimeValue mediaTime, long *frameNum, TimeCodeDef *tcdef, TimeCodeRecord *tcdata, UserData *srcRefH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCGetTimeCodeAtTime
			move.l              #$00140102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCGetTimeCodeAtTime
	ENDIF

;
; pascal HandlerError TCTimeCodeToString(MediaHandler mh, TimeCodeDef *tcdef, TimeCodeRecord *tcrec, StringPtr tcStr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCTimeCodeToString
			move.l              #$000C0103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCTimeCodeToString
	ENDIF

;
; pascal HandlerError TCTimeCodeToFrameNumber(MediaHandler mh, TimeCodeDef *tcdef, TimeCodeRecord *tcrec, long *frameNumber)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCTimeCodeToFrameNumber
			move.l              #$000C0104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCTimeCodeToFrameNumber
	ENDIF

;
; pascal HandlerError TCFrameNumberToTimeCode(MediaHandler mh, long frameNumber, TimeCodeDef *tcdef, TimeCodeRecord *tcrec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCFrameNumberToTimeCode
			move.l              #$000C0105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCFrameNumberToTimeCode
	ENDIF

;
; pascal HandlerError TCGetSourceRef(MediaHandler mh, TimeCodeDescriptionHandle tcdH, UserData *srefH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCGetSourceRef
			move.l              #$00080106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCGetSourceRef
	ENDIF

;
; pascal HandlerError TCSetSourceRef(MediaHandler mh, TimeCodeDescriptionHandle tcdH, UserData srefH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCSetSourceRef
			move.l              #$00080107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCSetSourceRef
	ENDIF

;
; pascal HandlerError TCSetTimeCodeFlags(MediaHandler mh, long flags, long flagsMask)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCSetTimeCodeFlags
			move.l              #$00080108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCSetTimeCodeFlags
	ENDIF

;
; pascal HandlerError TCGetTimeCodeFlags(MediaHandler mh, long *flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCGetTimeCodeFlags
			move.l              #$00040109,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCGetTimeCodeFlags
	ENDIF

;
; pascal HandlerError TCSetDisplayOptions(MediaHandler mh, TCTextOptionsPtr textOptions)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCSetDisplayOptions
			move.l              #$0004010A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCSetDisplayOptions
	ENDIF

;
; pascal HandlerError TCGetDisplayOptions(MediaHandler mh, TCTextOptionsPtr textOptions)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCGetDisplayOptions
			move.l              #$0004010B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCGetDisplayOptions
	ENDIF



; typedef ComponentInstance 			MovieImportComponent

; typedef ComponentInstance 			MovieExportComponent


MovieImportType					EQU		'eat '
MovieExportType					EQU		'spit'

canMovieImportHandles			EQU		$01
canMovieImportFiles				EQU		$02
hasMovieImportUserInterface		EQU		$04
canMovieExportHandles			EQU		$08
canMovieExportFiles				EQU		$10
hasMovieExportUserInterface		EQU		$20
dontAutoFileMovieImport			EQU		$40
canMovieExportAuxDataHandle		EQU		$80
canMovieImportValidateHandles	EQU		$0100
canMovieImportValidateFile		EQU		$0200
dontRegisterWithEasyOpen		EQU		$0400
canMovieImportInPlace			EQU		$0800
movieImportSubTypeIsFileExtension EQU	$1000
canMovieImportPartial			EQU		$2000
hasMovieImportMIMEList			EQU		$4000
canMovieExportFromProcedures	EQU		$8000
canMovieExportValidateMovie		EQU		$00010000
movieExportNeedsResourceFork	EQU		$00020000
canMovieImportDataReferences	EQU		$00040000
movieExportMustGetSourceMediaType EQU	$00080000
canMovieImportWithIdle			EQU		$00100000
canMovieImportValidateDataReferences EQU $00200000
reservedForUseByGraphicsImporters EQU	$00800000

movieImportCreateTrack			EQU		1
movieImportInParallel			EQU		2
movieImportMustUseTrack			EQU		4
movieImportWithIdle				EQU		16

movieImportResultUsedMultipleTracks EQU	8
movieImportResultNeedIdles		EQU		32
movieImportResultComplete		EQU		64

kMovieExportTextOnly			EQU		0
kMovieExportAbsoluteTime		EQU		1
kMovieExportRelativeTime		EQU		2

kMIDIImportSilenceBefore		EQU		$01
kMIDIImportSilenceAfter			EQU		$02
kMIDIImport20Playable			EQU		$04
kMIDIImportWantLyrics			EQU		$08

kMimeInfoMimeTypeTag			EQU		'mime'
kMimeInfoFileExtensionTag		EQU		'ext '
kMimeInfoDescriptionTag			EQU		'desc'
kMimeInfoGroupTag				EQU		'grop'
kMimeInfoDoNotOverrideExistingFileTypeAssociation EQU 'nofa'

kQTFileTypeAIFF					EQU		'AIFF'
kQTFileTypeAIFC					EQU		'AIFC'
kQTFileTypeDVC					EQU		'dvc!'
kQTFileTypeMIDI					EQU		'Midi'
kQTFileTypePicture				EQU		'PICT'
kQTFileTypeMovie				EQU		'MooV'
kQTFileTypeText					EQU		'TEXT'
kQTFileTypeWave					EQU		'WAVE'
kQTFileTypeSystemSevenSound		EQU		'sfil'
kQTFileTypeMuLaw				EQU		'ULAW'
kQTFileTypeAVI					EQU		'VfW '
kQTFileTypeSoundDesignerII		EQU		'Sd2f'
kQTFileTypeAudioCDTrack			EQU		'trak'
kQTFileTypePICS					EQU		'PICS'
kQTFileTypeGIF					EQU		'GIFf'
kQTFileTypePNG					EQU		'PNGf'
kQTFileTypeTIFF					EQU		'TIFF'
kQTFileTypePhotoShop			EQU		'8BPS'
kQTFileTypeSGIImage				EQU		'.SGI'
kQTFileTypeBMP					EQU		'BMPf'
kQTFileTypeJPEG					EQU		'JPEG'
kQTFileTypeJFIF					EQU		'JPEG'
kQTFileTypeMacPaint				EQU		'PNTG'
kQTFileTypeTargaImage			EQU		'TPIC'
kQTFileTypeQuickDrawGXPicture	EQU		'qdgx'
kQTFileTypeQuickTimeImage		EQU		'qtif'
kQTFileType3DMF					EQU		'3DMF'
kQTFileTypeFLC					EQU		'FLC '
kQTFileTypeFlash				EQU		'SWFL'
kQTFileTypeFlashPix				EQU		'FPix'
;  QTAtomTypes for atoms in import/export settings containers

kQTSettingsDVExportNTSC			EQU		'dvcv'				; True is export as NTSC, false is export as PAL. (Boolean)
kQTSettingsDVExportLockedAudio	EQU		'lock'				; True if audio locked to video. (Boolean)
kQTSettingsEffect				EQU		'effe'				; Parent atom whose contents are atoms of an effects description
kQTSettingsGraphicsFileImportSequence EQU 'sequ'			; Parent atom of graphic file movie import component
kQTSettingsGraphicsFileImportSequenceEnabled EQU 'enab'		; . If true, import numbered image sequence (Boolean)
kQTSettingsMovieExportEnableVideo EQU	'envi'				; Enable exporting of video track (Boolean)
kQTSettingsMovieExportEnableSound EQU	'enso'				; Enable exporting of sound track (Boolean)
kQTSettingsMovieExportSaveOptions EQU	'save'				; Parent atom of save options
kQTSettingsMovieExportSaveForInternet EQU 'fast'			; . Save for Internet
kQTSettingsMovieExportSaveCompressedMovie EQU 'cmpm'		; . Save compressed movie resource
kQTSettingsMIDI					EQU		'MIDI'				; MIDI import related container
kQTSettingsMIDISettingFlags		EQU		'sttg'				; . MIDI import settings (UInt32)
kQTSettingsText					EQU		'text'				; Text related container
kQTSettingsTextDescription		EQU		'desc'				; . Text import settings (TextDescription record)
kQTSettingsTextSize				EQU		'size'				; . Width/height to create during import (FixedPoint)
kQTSettingsTextSettingFlags		EQU		'sttg'				; . Text export settings (UInt32)
kQTSettingsTextTimeFraction		EQU		'timf'				; . Movie time fraction for export (UInt32)
kQTSettingsTime					EQU		'time'				; Time related container
kQTSettingsTimeDuration			EQU		'dura'				; . Time related container
kQTSettingsAudioCDTrack			EQU		'trak'				; Audio CD track related container
kQTSettingsAudioCDTrackRateShift EQU	'rshf'				; . Rate shift to be performed (SInt16)



MovieExportGetDataParams RECORD 0
recordSize				 ds.l	1				; offset: $0 (0)
trackID					 ds.l	1				; offset: $4 (4)
sourceTimeScale			 ds.l	1				; offset: $8 (8)
requestedTime			 ds.l	1				; offset: $C (12)
actualTime				 ds.l	1				; offset: $10 (16)
dataPtr					 ds.l	1				; offset: $14 (20)
dataSize				 ds.l	1				; offset: $18 (24)
desc					 ds.l	1				; offset: $1C (28)
descType				 ds.l	1				; offset: $20 (32)
descSeed				 ds.l	1				; offset: $24 (36)
requestedSampleCount	 ds.l	1				; offset: $28 (40)
actualSampleCount		 ds.l	1				; offset: $2C (44)
durationPerSample		 ds.l	1				; offset: $30 (48)
sampleFlags				 ds.l	1				; offset: $34 (52)
sizeof					 EQU *					; size:   $38 (56)
						ENDR

kQTPresetsListResourceType		EQU		'stg#'
kQTPresetsPlatformListResourceType EQU	'stgp'

kQTPresetInfoIsDivider			EQU		1
QTPresetInfo			RECORD 0
presetKey				 ds.l	1				; offset: $0 (0)		;  unique key for this preset in presetsArray 
presetFlags				 ds.l	1				; offset: $4 (4)		;  flags about this preset 
settingsResourceType	 ds.l	1				; offset: $8 (8)		;  resource type of settings resource 
settingsResourceID		 ds.w	1				; offset: $C (12)		;  resource id of settings resource 
padding1				 ds.w	1				; offset: $E (14)
nameStringListID		 ds.w	1				; offset: $10 (16)		;  name string list resource id 
nameStringIndex			 ds.w	1				; offset: $12 (18)		;  name string index 
infoStringListID		 ds.w	1				; offset: $14 (20)		;  info string list resource id 
infoStringIndex			 ds.w	1				; offset: $16 (22)		;  info string index 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
QTPresetListRecord		RECORD 0
flags					 ds.l	1				; offset: $0 (0)		;  flags for whole list 
count					 ds.l	1				; offset: $4 (4)		;  number of elements in presetsArray 
reserved				 ds.l	1				; offset: $8 (8)
presetsArray			 ds		QTPresetInfo	; offset: $C (12) <-- really an array of length one ;  info about each preset 
sizeof					 EQU *					; size:   $24 (36)
						ENDR

kQTMovieExportSourceInfoResourceType EQU 'src#'
kQTMovieExportSourceInfoIsMediaType EQU	$00000001
kQTMovieExportSourceInfoIsMediaCharacteristic EQU $00000002
kQTMovieExportSourceInfoIsSourceType EQU $00000004
QTMovieExportSourceInfo	RECORD 0
mediaType				 ds.l	1				; offset: $0 (0)		;  Media type of source 
minCount				 ds.w	1				; offset: $4 (4)		;  min number of sources of this kind required, zero if none required 
maxCount				 ds.w	1				; offset: $6 (6)		;  max number of sources of this kind allowed, -1 if unlimited allowed 
flags					 ds.l	1				; offset: $8 (8)		;  reserved for flags 
sizeof					 EQU *					; size:   $C (12)
						ENDR
QTMovieExportSourceRecord RECORD 0
count					 ds.l	1				; offset: $0 (0)
reserved				 ds.l	1				; offset: $4 (4)
sourceArray				 ds		QTMovieExportSourceInfo ; offset: $8 (8) <-- really an array of length one
sizeof					 EQU *					; size:   $14 (20)
						ENDR
;
; pascal ComponentResult MovieImportHandle(MovieImportComponent ci, Handle dataH, Movie theMovie, Track targetTrack, Track *usedTrack, TimeValue atTime, TimeValue *addedDuration, long inFlags, long *outFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportHandle
			move.l              #$00200001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportHandle
	ENDIF

;
; pascal ComponentResult MovieImportFile(MovieImportComponent ci, const FSSpec *theFile, Movie theMovie, Track targetTrack, Track *usedTrack, TimeValue atTime, TimeValue *addedDuration, long inFlags, long *outFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportFile
			move.l              #$00200002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportFile
	ENDIF

;
; pascal ComponentResult MovieImportSetSampleDuration(MovieImportComponent ci, TimeValue duration, TimeScale scale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetSampleDuration
			move.l              #$00080003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetSampleDuration
	ENDIF

;
; pascal ComponentResult MovieImportSetSampleDescription(MovieImportComponent ci, SampleDescriptionHandle desc, OSType mediaType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetSampleDescription
			move.l              #$00080004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetSampleDescription
	ENDIF

;
; pascal ComponentResult MovieImportSetMediaFile(MovieImportComponent ci, AliasHandle alias)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetMediaFile
			move.l              #$00040005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetMediaFile
	ENDIF

;
; pascal ComponentResult MovieImportSetDimensions(MovieImportComponent ci, Fixed width, Fixed height)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetDimensions
			move.l              #$00080006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetDimensions
	ENDIF

;
; pascal ComponentResult MovieImportSetChunkSize(MovieImportComponent ci, long chunkSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetChunkSize
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetChunkSize
	ENDIF

;
; pascal ComponentResult MovieImportSetProgressProc(MovieImportComponent ci, MovieProgressUPP proc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetProgressProc
			move.l              #$00080008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetProgressProc
	ENDIF

;
; pascal ComponentResult MovieImportSetAuxiliaryData(MovieImportComponent ci, Handle data, OSType handleType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetAuxiliaryData
			move.l              #$00080009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetAuxiliaryData
	ENDIF

;
; pascal ComponentResult MovieImportSetFromScrap(MovieImportComponent ci, Boolean fromScrap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetFromScrap
			move.l              #$0002000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetFromScrap
	ENDIF

;
; pascal ComponentResult MovieImportDoUserDialog(MovieImportComponent ci, const FSSpec *theFile, Handle theData, Boolean *canceled)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportDoUserDialog
			move.l              #$000C000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportDoUserDialog
	ENDIF

;
; pascal ComponentResult MovieImportSetDuration(MovieImportComponent ci, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetDuration
			move.l              #$0004000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetDuration
	ENDIF

;
; pascal ComponentResult MovieImportGetAuxiliaryDataType(MovieImportComponent ci, OSType *auxType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetAuxiliaryDataType
			move.l              #$0004000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetAuxiliaryDataType
	ENDIF

;
; pascal ComponentResult MovieImportValidate(MovieImportComponent ci, const FSSpec *theFile, Handle theData, Boolean *valid)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportValidate
			move.l              #$000C000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportValidate
	ENDIF

;
; pascal ComponentResult MovieImportGetFileType(MovieImportComponent ci, OSType *fileType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetFileType
			move.l              #$0004000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetFileType
	ENDIF

;
; pascal ComponentResult MovieImportDataRef(MovieImportComponent ci, Handle dataRef, OSType dataRefType, Movie theMovie, Track targetTrack, Track *usedTrack, TimeValue atTime, TimeValue *addedDuration, long inFlags, long *outFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportDataRef
			move.l              #$00240010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportDataRef
	ENDIF

;
; pascal ComponentResult MovieImportGetSampleDescription(MovieImportComponent ci, SampleDescriptionHandle *desc, OSType *mediaType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetSampleDescription
			move.l              #$00080011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetSampleDescription
	ENDIF

;
; pascal ComponentResult MovieImportGetMIMETypeList(MovieImportComponent ci, QTAtomContainer *mimeInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetMIMETypeList
			move.l              #$00040012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetMIMETypeList
	ENDIF

;
; pascal ComponentResult MovieImportSetOffsetAndLimit(MovieImportComponent ci, unsigned long offset, unsigned long limit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetOffsetAndLimit
			move.l              #$00080013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetOffsetAndLimit
	ENDIF

;
; pascal ComponentResult MovieImportGetSettingsAsAtomContainer(MovieImportComponent ci, QTAtomContainer *settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetSettingsAsAtomContainer
			move.l              #$00040014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetSettingsAsAtomContainer
	ENDIF

;
; pascal ComponentResult MovieImportSetSettingsFromAtomContainer(MovieImportComponent ci, QTAtomContainer settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetSettingsFromAtomContainer
			move.l              #$00040015,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetSettingsFromAtomContainer
	ENDIF

;
; pascal ComponentResult MovieImportSetOffsetAndLimit64(MovieImportComponent ci, const wide *offset, const wide *limit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetOffsetAndLimit64
			move.l              #$00080016,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetOffsetAndLimit64
	ENDIF

;
; pascal ComponentResult MovieImportIdle(MovieImportComponent ci, long inFlags, long *outFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportIdle
			move.l              #$00080017,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportIdle
	ENDIF

;
; pascal ComponentResult MovieImportValidateDataRef(MovieImportComponent ci, Handle dataRef, OSType dataRefType, UInt8 *valid)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportValidateDataRef
			move.l              #$000C0018,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportValidateDataRef
	ENDIF

	IF CALL_NOT_IN_CARBON THEN
;
; pascal ComponentResult MovieImportGetLoadState(MovieImportComponent ci, long *importerLoadState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetLoadState
			move.l              #$00040019,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetLoadState
	ENDIF

;
; pascal ComponentResult MovieImportGetMaxLoadedTime(MovieImportComponent ci, TimeValue *time)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetMaxLoadedTime
			move.l              #$0004001A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetMaxLoadedTime
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
;
; pascal ComponentResult MovieExportToHandle(MovieExportComponent ci, Handle dataH, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportToHandle
			move.l              #$00140080,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportToHandle
	ENDIF

;
; pascal ComponentResult MovieExportToFile(MovieExportComponent ci, const FSSpec *theFile, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportToFile
			move.l              #$00140081,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportToFile
	ENDIF

;
; pascal ComponentResult MovieExportGetAuxiliaryData(MovieExportComponent ci, Handle dataH, OSType *handleType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportGetAuxiliaryData
			move.l              #$00080083,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportGetAuxiliaryData
	ENDIF

;
; pascal ComponentResult MovieExportSetProgressProc(MovieExportComponent ci, MovieProgressUPP proc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportSetProgressProc
			move.l              #$00080084,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportSetProgressProc
	ENDIF

;
; pascal ComponentResult MovieExportSetSampleDescription(MovieExportComponent ci, SampleDescriptionHandle desc, OSType mediaType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportSetSampleDescription
			move.l              #$00080085,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportSetSampleDescription
	ENDIF

;
; pascal ComponentResult MovieExportDoUserDialog(MovieExportComponent ci, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration, Boolean *canceled)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportDoUserDialog
			move.l              #$00140086,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportDoUserDialog
	ENDIF

;
; pascal ComponentResult MovieExportGetCreatorType(MovieExportComponent ci, OSType *creator)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportGetCreatorType
			move.l              #$00040087,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportGetCreatorType
	ENDIF

;
; pascal ComponentResult MovieExportToDataRef(MovieExportComponent ci, Handle dataRef, OSType dataRefType, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportToDataRef
			move.l              #$00180088,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportToDataRef
	ENDIF

;
; pascal ComponentResult MovieExportFromProceduresToDataRef(MovieExportComponent ci, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportFromProceduresToDataRef
			move.l              #$00080089,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportFromProceduresToDataRef
	ENDIF

;
; pascal ComponentResult MovieExportAddDataSource(MovieExportComponent ci, OSType trackType, TimeScale scale, long *trackID, MovieExportGetPropertyUPP getPropertyProc, MovieExportGetDataUPP getDataProc, void *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportAddDataSource
			move.l              #$0018008A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportAddDataSource
	ENDIF

;
; pascal ComponentResult MovieExportValidate(MovieExportComponent ci, Movie theMovie, Track onlyThisTrack, Boolean *valid)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportValidate
			move.l              #$000C008B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportValidate
	ENDIF

;
; pascal ComponentResult MovieExportGetSettingsAsAtomContainer(MovieExportComponent ci, QTAtomContainer *settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportGetSettingsAsAtomContainer
			move.l              #$0004008C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportGetSettingsAsAtomContainer
	ENDIF

;
; pascal ComponentResult MovieExportSetSettingsFromAtomContainer(MovieExportComponent ci, QTAtomContainer settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportSetSettingsFromAtomContainer
			move.l              #$0004008D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportSetSettingsFromAtomContainer
	ENDIF

;
; pascal ComponentResult MovieExportGetFileNameExtension(MovieExportComponent ci, OSType *extension)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportGetFileNameExtension
			move.l              #$0004008E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportGetFileNameExtension
	ENDIF

;
; pascal ComponentResult MovieExportGetShortFileTypeString(MovieExportComponent ci, Str255 typeString)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportGetShortFileTypeString
			move.l              #$0004008F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportGetShortFileTypeString
	ENDIF

;
; pascal ComponentResult MovieExportGetSourceMediaType(MovieExportComponent ci, OSType *mediaType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportGetSourceMediaType
			move.l              #$00040090,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportGetSourceMediaType
	ENDIF

;
; pascal ComponentResult MovieExportSetGetMoviePropertyProc(MovieExportComponent ci, MovieExportGetPropertyUPP getPropertyProc, void *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportSetGetMoviePropertyProc
			move.l              #$00080091,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportSetGetMoviePropertyProc
	ENDIF

     IF ¬ TARGET_CPU_PPC THEN 
;  Text Export Display Info data structure
TextDisplayData			RECORD 0
displayFlags			 ds.l	1				; offset: $0 (0)
textJustification		 ds.l	1				; offset: $4 (4)
bgColor					 ds		RGBColor		; offset: $8 (8)
textBox					 ds		Rect			; offset: $E (14)
beginHilite				 ds.w	1				; offset: $16 (22)
endHilite				 ds.w	1				; offset: $18 (24)
hiliteColor				 ds		RGBColor		; offset: $1A (26)
doHiliteColor			 ds.b	1				; offset: $20 (32)
filler					 ds.b	1				; offset: $21 (33)
scrollDelayDur			 ds.l	1				; offset: $22 (34)
dropShadowOffset		 ds		Point			; offset: $26 (38)
dropShadowTransparency	 ds.w	1				; offset: $2A (42)
sizeof					 EQU *					; size:   $2C (44)
						ENDR
    ENDIF
; typedef ComponentInstance 			TextExportComponent

; typedef ComponentInstance 			GraphicImageMovieImportComponent

;
; pascal ComponentResult TextExportGetDisplayData(TextExportComponent ci, TextDisplayData *textDisplay)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextExportGetDisplayData
			move.l              #$00040100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextExportGetDisplayData
	ENDIF

;
; pascal ComponentResult TextExportGetTimeFraction(TextExportComponent ci, long *movieTimeFraction)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextExportGetTimeFraction
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextExportGetTimeFraction
	ENDIF

;
; pascal ComponentResult TextExportSetTimeFraction(TextExportComponent ci, long movieTimeFraction)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextExportSetTimeFraction
			move.l              #$00040102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextExportSetTimeFraction
	ENDIF

;
; pascal ComponentResult TextExportGetSettings(TextExportComponent ci, long *setting)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextExportGetSettings
			move.l              #$00040103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextExportGetSettings
	ENDIF

;
; pascal ComponentResult TextExportSetSettings(TextExportComponent ci, long setting)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextExportSetSettings
			move.l              #$00040104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextExportSetSettings
	ENDIF


;
; pascal ComponentResult MIDIImportGetSettings(TextExportComponent ci, long *setting)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MIDIImportGetSettings
			move.l              #$00040100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MIDIImportGetSettings
	ENDIF

;
; pascal ComponentResult MIDIImportSetSettings(TextExportComponent ci, long setting)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MIDIImportSetSettings
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MIDIImportSetSettings
	ENDIF

;
; pascal ComponentResult MovieExportNewGetDataAndPropertiesProcs(MovieExportComponent ci, OSType trackType, TimeScale *scale, Movie theMovie, Track theTrack, TimeValue startTime, TimeValue duration, MovieExportGetPropertyUPP *getPropertyProc, MovieExportGetDataUPP *getDataProc, void **refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportNewGetDataAndPropertiesProcs
			move.l              #$00240100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportNewGetDataAndPropertiesProcs
	ENDIF

;
; pascal ComponentResult MovieExportDisposeGetDataAndPropertiesProcs(MovieExportComponent ci, MovieExportGetPropertyUPP getPropertyProc, MovieExportGetDataUPP getDataProc, void *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportDisposeGetDataAndPropertiesProcs
			move.l              #$000C0101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportDisposeGetDataAndPropertiesProcs
	ENDIF


movieExportUseConfiguredSettings EQU	'ucfg'				; pointer to Boolean
movieExportWidth				EQU		'wdth'				; pointer to Fixed
movieExportHeight				EQU		'hegt'				; pointer to Fixed
movieExportDuration				EQU		'dura'				; pointer to TimeRecord
movieExportVideoFilter			EQU		'iflt'				; pointer to QTAtomContainer
movieExportTimeScale			EQU		'tmsc'				; pointer to TimeScale
;
; pascal ComponentResult GraphicsImageImportSetSequenceEnabled(GraphicImageMovieImportComponent ci, Boolean enable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GraphicsImageImportSetSequenceEnabled
			move.l              #$00020100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GraphicsImageImportSetSequenceEnabled
	ENDIF

;
; pascal ComponentResult GraphicsImageImportGetSequenceEnabled(GraphicImageMovieImportComponent ci, Boolean *enable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GraphicsImageImportGetSequenceEnabled
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GraphicsImageImportGetSequenceEnabled
	ENDIF








; ***************
;
;    File Preview Components
;
;**************

; typedef ComponentInstance 			pnotComponent


pnotComponentWantsEvents		EQU		1
pnotComponentNeedsNoCache		EQU		2

ShowFilePreviewComponentType	EQU		'pnot'
CreateFilePreviewComponentType	EQU		'pmak'
;
; pascal ComponentResult PreviewShowData(pnotComponent p, OSType dataType, Handle data, const Rect *inHere)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PreviewShowData
			move.l              #$000C0001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PreviewShowData
	ENDIF

;
; pascal ComponentResult PreviewMakePreview(pnotComponent p, OSType *previewType, Handle *previewResult, const FSSpec *sourceFile, ICMProgressProcRecordPtr progress)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PreviewMakePreview
			move.l              #$00100002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PreviewMakePreview
	ENDIF

;
; pascal ComponentResult PreviewMakePreviewReference(pnotComponent p, OSType *previewType, short *resID, const FSSpec *sourceFile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PreviewMakePreviewReference
			move.l              #$000C0003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PreviewMakePreviewReference
	ENDIF

;
; pascal ComponentResult PreviewEvent(pnotComponent p, EventRecord *e, Boolean *handledEvent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PreviewEvent
			move.l              #$00080004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PreviewEvent
	ENDIF



; typedef ComponentInstance 			DataCompressorComponent

; typedef ComponentInstance 			DataDecompressorComponent

; typedef ComponentInstance 			DataCodecComponent


DataCompressorComponentType		EQU		'dcom'
DataDecompressorComponentType	EQU		'ddec'
AppleDataCompressorSubType		EQU		'adec'
zlibDataCompressorSubType		EQU		'zlib'

; * These are DataCodec procedures *
;
; pascal ComponentResult DataCodecDecompress(DataCodecComponent dc, void *srcData, UInt32 srcSize, void *dstData, UInt32 dstBufferSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecDecompress
			move.l              #$00100001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecDecompress
	ENDIF

;
; pascal ComponentResult DataCodecGetCompressBufferSize(DataCodecComponent dc, UInt32 srcSize, UInt32 *dstSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecGetCompressBufferSize
			move.l              #$00080002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecGetCompressBufferSize
	ENDIF

;
; pascal ComponentResult DataCodecCompress(DataCodecComponent dc, void *srcData, UInt32 srcSize, void *dstData, UInt32 dstBufferSize, UInt32 *actualDstSize, UInt32 *decompressSlop)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecCompress
			move.l              #$00180003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecCompress
	ENDIF

;
; pascal ComponentResult DataCodecBeginInterruptSafe(DataCodecComponent dc, unsigned long maxSrcSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecBeginInterruptSafe
			move.l              #$00040004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecBeginInterruptSafe
	ENDIF

;
; pascal ComponentResult DataCodecEndInterruptSafe(DataCodecComponent dc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecEndInterruptSafe
			move.l              #$00000005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecEndInterruptSafe
	ENDIF

;
; pascal ComponentResult DataCodecDecompressPartial(DataCodecComponent dc, void **next_in, unsigned long *avail_in, unsigned long *total_in, void **next_out, unsigned long *avail_out, unsigned long *total_out, Boolean *didFinish)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecDecompressPartial
			move.l              #$001C0006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecDecompressPartial
	ENDIF

;
; pascal ComponentResult DataCodecCompressPartial(DataCodecComponent dc, void **next_in, unsigned long *avail_in, unsigned long *total_in, void **next_out, unsigned long *avail_out, unsigned long *total_out, Boolean tryToFinish, Boolean *didFinish)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecCompressPartial
			move.l              #$001E0007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecCompressPartial
	ENDIF






kDataHCanRead					EQU		$00000001
kDataHSpecialRead				EQU		$00000002
kDataHSpecialReadFile			EQU		$00000004
kDataHCanWrite					EQU		$00000008
kDataHSpecialWrite				EQU		$10
kDataHSpecialWriteFile			EQU		$20
kDataHCanStreamingWrite			EQU		$40
kDataHMustCheckDataRef			EQU		$80
;  Data reference extensions

kDataRefExtensionChokeSpeed		EQU		'chok'
kDataRefExtensionMIMEType		EQU		'mime'
kDataRefExtensionMacOSFileType	EQU		'ftyp'
kDataRefExtensionInitializationData EQU	'data'


kDataHChokeToMovieDataRate		EQU		$01					; param is 0
kDataHChokeToParam				EQU		$02					; param is bytes per second
DataHChokeAtomRecord	RECORD 0
flags					 ds.l	1				; offset: $0 (0)		;  one of kDataHChokeTo constants
param					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR

DataHVolumeListRecord	RECORD 0
vRefNum					 ds.w	1				; offset: $0 (0)
flags					 ds.l	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct DataHVolumeListRecord * DataHVolumeListPtr

; typedef DataHVolumeListPtr *			DataHVolumeList


kDataHExtendedSchedule			EQU		'xtnd'
DataHScheduleRecord		RECORD 0
timeNeededBy			 ds		TimeRecord		; offset: $0 (0)
extendedID				 ds.l	1				; offset: $10 (16)		;  always is kDataHExtendedSchedule
extendedVers			 ds.l	1				; offset: $14 (20)		;  always set to 0
priority				 ds.l	1				; offset: $18 (24)		;  100.0 or more means must have. lower numbers…
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct DataHScheduleRecord *	DataHSchedulePtr

;  Flags for DataHGetInfoFlags

kDataHInfoFlagNeverStreams		EQU		$01					; set if this data handler doesn't stream
kDataHInfoFlagCanUpdateDataRefs	EQU		$02					; set if this data handler might update data reference
kDataHInfoFlagNeedsNetworkBandwidth EQU	$04					; set if this data handler may need to occupy the network



;
; pascal ComponentResult DataHGetData(DataHandler dh, Handle h, long hOffset, long offset, long size)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetData
			move.l              #$00100002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetData
	ENDIF

;
; pascal ComponentResult DataHPutData(DataHandler dh, Handle h, long hOffset, long *offset, long size)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHPutData
			move.l              #$00100003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHPutData
	ENDIF

;
; pascal ComponentResult DataHFlushData(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHFlushData
			move.l              #$00000004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHFlushData
	ENDIF

;
; pascal ComponentResult DataHOpenForWrite(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHOpenForWrite
			move.l              #$00000005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHOpenForWrite
	ENDIF

;
; pascal ComponentResult DataHCloseForWrite(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHCloseForWrite
			move.l              #$00000006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHCloseForWrite
	ENDIF


;
; pascal ComponentResult DataHOpenForRead(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHOpenForRead
			move.l              #$00000008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHOpenForRead
	ENDIF

;
; pascal ComponentResult DataHCloseForRead(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHCloseForRead
			move.l              #$00000009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHCloseForRead
	ENDIF

;
; pascal ComponentResult DataHSetDataRef(DataHandler dh, Handle dataRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetDataRef
			move.l              #$0004000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetDataRef
	ENDIF

;
; pascal ComponentResult DataHGetDataRef(DataHandler dh, Handle *dataRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataRef
			move.l              #$0004000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataRef
	ENDIF

;
; pascal ComponentResult DataHCompareDataRef(DataHandler dh, Handle dataRef, Boolean *equal)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHCompareDataRef
			move.l              #$0008000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHCompareDataRef
	ENDIF

;
; pascal ComponentResult DataHTask(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHTask
			move.l              #$0000000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHTask
	ENDIF

;
; pascal ComponentResult DataHScheduleData(DataHandler dh, Ptr PlaceToPutDataPtr, long FileOffset, long DataSize, long RefCon, DataHSchedulePtr scheduleRec, DataHCompletionUPP CompletionRtn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHScheduleData
			move.l              #$0018000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHScheduleData
	ENDIF

;
; pascal ComponentResult DataHFinishData(DataHandler dh, Ptr PlaceToPutDataPtr, Boolean Cancel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHFinishData
			move.l              #$0006000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHFinishData
	ENDIF

;
; pascal ComponentResult DataHFlushCache(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHFlushCache
			move.l              #$00000010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHFlushCache
	ENDIF

;
; pascal ComponentResult DataHResolveDataRef(DataHandler dh, Handle theDataRef, Boolean *wasChanged, Boolean userInterfaceAllowed)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHResolveDataRef
			move.l              #$000A0011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHResolveDataRef
	ENDIF

;
; pascal ComponentResult DataHGetFileSize(DataHandler dh, long *fileSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFileSize
			move.l              #$00040012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFileSize
	ENDIF

;
; pascal ComponentResult DataHCanUseDataRef(DataHandler dh, Handle dataRef, long *useFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHCanUseDataRef
			move.l              #$00080013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHCanUseDataRef
	ENDIF

;
; pascal ComponentResult DataHGetVolumeList(DataHandler dh, DataHVolumeList *volumeList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetVolumeList
			move.l              #$00040014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetVolumeList
	ENDIF

;
; pascal ComponentResult DataHWrite(DataHandler dh, Ptr data, long offset, long size, DataHCompletionUPP completion, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHWrite
			move.l              #$00140015,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHWrite
	ENDIF

;
; pascal ComponentResult DataHPreextend(DataHandler dh, unsigned long maxToAdd, unsigned long *spaceAdded)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHPreextend
			move.l              #$00080016,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHPreextend
	ENDIF

;
; pascal ComponentResult DataHSetFileSize(DataHandler dh, long fileSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetFileSize
			move.l              #$00040017,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetFileSize
	ENDIF

;
; pascal ComponentResult DataHGetFreeSpace(DataHandler dh, unsigned long *freeSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFreeSpace
			move.l              #$00040018,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFreeSpace
	ENDIF

;
; pascal ComponentResult DataHCreateFile(DataHandler dh, OSType creator, Boolean deleteExisting)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHCreateFile
			move.l              #$00060019,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHCreateFile
	ENDIF

;
; pascal ComponentResult DataHGetPreferredBlockSize(DataHandler dh, long *blockSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetPreferredBlockSize
			move.l              #$0004001A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetPreferredBlockSize
	ENDIF

;
; pascal ComponentResult DataHGetDeviceIndex(DataHandler dh, long *deviceIndex)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDeviceIndex
			move.l              #$0004001B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDeviceIndex
	ENDIF

;
; pascal ComponentResult DataHIsStreamingDataHandler(DataHandler dh, Boolean *yes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHIsStreamingDataHandler
			move.l              #$0004001C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHIsStreamingDataHandler
	ENDIF

;
; pascal ComponentResult DataHGetDataInBuffer(DataHandler dh, long startOffset, long *size)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataInBuffer
			move.l              #$0008001D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataInBuffer
	ENDIF

;
; pascal ComponentResult DataHGetScheduleAheadTime(DataHandler dh, long *millisecs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetScheduleAheadTime
			move.l              #$0004001E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetScheduleAheadTime
	ENDIF

;
; pascal ComponentResult DataHSetCacheSizeLimit(DataHandler dh, Size cacheSizeLimit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetCacheSizeLimit
			move.l              #$0004001F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetCacheSizeLimit
	ENDIF

;
; pascal ComponentResult DataHGetCacheSizeLimit(DataHandler dh, Size *cacheSizeLimit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetCacheSizeLimit
			move.l              #$00040020,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetCacheSizeLimit
	ENDIF

;
; pascal ComponentResult DataHGetMovie(DataHandler dh, Movie *theMovie, short *id)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetMovie
			move.l              #$00080021,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetMovie
	ENDIF

;
; pascal ComponentResult DataHAddMovie(DataHandler dh, Movie theMovie, short *id)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHAddMovie
			move.l              #$00080022,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHAddMovie
	ENDIF

;
; pascal ComponentResult DataHUpdateMovie(DataHandler dh, Movie theMovie, short id)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHUpdateMovie
			move.l              #$00060023,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHUpdateMovie
	ENDIF

;
; pascal ComponentResult DataHDoesBuffer(DataHandler dh, Boolean *buffersReads, Boolean *buffersWrites)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHDoesBuffer
			move.l              #$00080024,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHDoesBuffer
	ENDIF

;
; pascal ComponentResult DataHGetFileName(DataHandler dh, Str255 str)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFileName
			move.l              #$00040025,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFileName
	ENDIF

;
; pascal ComponentResult DataHGetAvailableFileSize(DataHandler dh, long *fileSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetAvailableFileSize
			move.l              #$00040026,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetAvailableFileSize
	ENDIF

;
; pascal ComponentResult DataHGetMacOSFileType(DataHandler dh, OSType *fileType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetMacOSFileType
			move.l              #$00040027,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetMacOSFileType
	ENDIF

;
; pascal ComponentResult DataHGetMIMEType(DataHandler dh, Str255 mimeType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetMIMEType
			move.l              #$00040028,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetMIMEType
	ENDIF

;
; pascal ComponentResult DataHSetDataRefWithAnchor(DataHandler dh, Handle anchorDataRef, OSType dataRefType, Handle dataRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetDataRefWithAnchor
			move.l              #$000C0029,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetDataRefWithAnchor
	ENDIF

;
; pascal ComponentResult DataHGetDataRefWithAnchor(DataHandler dh, Handle anchorDataRef, OSType dataRefType, Handle *dataRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataRefWithAnchor
			move.l              #$000C002A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataRefWithAnchor
	ENDIF

;
; pascal ComponentResult DataHSetMacOSFileType(DataHandler dh, OSType fileType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetMacOSFileType
			move.l              #$0004002B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetMacOSFileType
	ENDIF

;
; pascal ComponentResult DataHSetTimeBase(DataHandler dh, TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetTimeBase
			move.l              #$0004002C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetTimeBase
	ENDIF

;
; pascal ComponentResult DataHGetInfoFlags(DataHandler dh, UInt32 *flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetInfoFlags
			move.l              #$0004002D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetInfoFlags
	ENDIF

;
; pascal ComponentResult DataHScheduleData64(DataHandler dh, Ptr PlaceToPutDataPtr, const wide *FileOffset, long DataSize, long RefCon, DataHSchedulePtr scheduleRec, DataHCompletionUPP CompletionRtn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHScheduleData64
			move.l              #$0018002E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHScheduleData64
	ENDIF

;
; pascal ComponentResult DataHWrite64(DataHandler dh, Ptr data, const wide *offset, long size, DataHCompletionUPP completion, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHWrite64
			move.l              #$0014002F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHWrite64
	ENDIF

;
; pascal ComponentResult DataHGetFileSize64(DataHandler dh, wide *fileSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFileSize64
			move.l              #$00040030,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFileSize64
	ENDIF

;
; pascal ComponentResult DataHPreextend64(DataHandler dh, const wide *maxToAdd, wide *spaceAdded)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHPreextend64
			move.l              #$00080031,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHPreextend64
	ENDIF

;
; pascal ComponentResult DataHSetFileSize64(DataHandler dh, const wide *fileSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetFileSize64
			move.l              #$00040032,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetFileSize64
	ENDIF

;
; pascal ComponentResult DataHGetFreeSpace64(DataHandler dh, wide *freeSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFreeSpace64
			move.l              #$00040033,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFreeSpace64
	ENDIF

;
; pascal ComponentResult DataHAppend64(DataHandler dh, void *data, wide *fileOffset, unsigned long size)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHAppend64
			move.l              #$000C0034,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHAppend64
	ENDIF

;
; pascal ComponentResult DataHReadAsync(DataHandler dh, void *dataPtr, UInt32 dataSize, const wide *dataOffset, DataHCompletionUPP completion, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHReadAsync
			move.l              #$00140035,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHReadAsync
	ENDIF

;
; pascal ComponentResult DataHPollRead(DataHandler dh, void *dataPtr, UInt32 *dataSizeSoFar)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHPollRead
			move.l              #$00080036,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHPollRead
	ENDIF

;
; pascal ComponentResult DataHGetDataAvailability(DataHandler dh, long offset, long len, long *missing_offset, long *missing_len)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataAvailability
			move.l              #$00100037,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataAvailability
	ENDIF

;
; pascal ComponentResult DataHGetFileSizeAsync(DataHandler dh, wide *fileSize, DataHCompletionUPP completionRtn, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFileSizeAsync
			move.l              #$000C003A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFileSizeAsync
	ENDIF


	IF CALL_NOT_IN_CARBON THEN
;
; pascal ComponentResult DataHGetDataRefAsType(DataHandler dh, OSType requestedType, Handle *dataRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataRefAsType
			move.l              #$0008003B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataRefAsType
	ENDIF

;
; pascal ComponentResult DataHSetDataRefExtension(DataHandler dh, Handle extension, OSType idType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetDataRefExtension
			move.l              #$0008003C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetDataRefExtension
	ENDIF

;
; pascal ComponentResult DataHGetDataRefExtension(DataHandler dh, Handle *extension, OSType idType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataRefExtension
			move.l              #$0008003D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataRefExtension
	ENDIF

;
; pascal ComponentResult DataHGetMovieWithFlags(DataHandler dh, Movie *theMovie, short *id, short flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetMovieWithFlags
			move.l              #$000A003E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetMovieWithFlags
	ENDIF


	ENDIF	; CALL_NOT_IN_CARBON
;
; pascal ComponentResult DataHPlaybackHints(DataHandler dh, long flags, unsigned long minFileOffset, unsigned long maxFileOffset, long bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHPlaybackHints
			move.l              #$00100103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHPlaybackHints
	ENDIF


	IF CALL_NOT_IN_CARBON THEN
;
; pascal ComponentResult DataHPlaybackHints64(DataHandler dh, long flags, const wide *minFileOffset, const wide *maxFileOffset, long bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHPlaybackHints64
			move.l              #$0010010E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHPlaybackHints64
	ENDIF




	ENDIF	; CALL_NOT_IN_CARBON


;  Standard type for video digitizers 

videoDigitizerComponentType		EQU		'vdig'
vdigInterfaceRev				EQU		2
;  Input Format Standards 

ntscIn							EQU		0					; current input format 
currentIn						EQU		0					; ntsc input format 
palIn							EQU		1					; pal input format 
secamIn							EQU		2					; secam input format 
ntscReallyIn					EQU		3					; ntsc input format 
;  Input Formats 

compositeIn						EQU		0					; input is composite format 
sVideoIn						EQU		1					; input is sVideo format 
rgbComponentIn					EQU		2					; input is rgb component format 
rgbComponentSyncIn				EQU		3					; input is rgb component format (sync on green?)
yuvComponentIn					EQU		4					; input is yuv component format 
yuvComponentSyncIn				EQU		5					; input is yuv component format (sync on green?) 
tvTunerIn						EQU		6
sdiIn							EQU		7

;  Video Digitizer PlayThru States 

vdPlayThruOff					EQU		0
vdPlayThruOn					EQU		1
;  Input Color Space Modes 

vdDigitizerBW					EQU		0					; black and white 
vdDigitizerRGB					EQU		1					; rgb color 
;  Phase Lock Loop Modes 

vdBroadcastMode					EQU		0					; Broadcast / Laser Disk video mode 
vdVTRMode						EQU		1					; VCR / Magnetic media mode 
;  Field Select Options 

vdUseAnyField					EQU		0					; Digitizers choice on field use 
vdUseOddField					EQU		1					; Use odd field for half size vert and smaller 
vdUseEvenField					EQU		2					; Use even field for half size vert and smaller 
;  vdig types 

vdTypeBasic						EQU		0					; basic, no clipping 
vdTypeAlpha						EQU		1					; supports clipping with alpha channel 
vdTypeMask						EQU		2					; supports clipping with mask plane 
vdTypeKey						EQU		3					; supports clipping with key color(s) 


;  Digitizer Input Capability/Current Flags 

digiInDoesNTSC					EQU		$00000001			; digitizer supports NTSC input format 
digiInDoesPAL					EQU		$00000002			; digitizer supports PAL input format 
digiInDoesSECAM					EQU		$00000004			; digitizer supports SECAM input format 
digiInDoesGenLock				EQU		$00000080			; digitizer does genlock 
digiInDoesComposite				EQU		$00000100			; digitizer supports composite input type 
digiInDoesSVideo				EQU		$00000200			; digitizer supports S-Video input type 
digiInDoesComponent				EQU		$00000400			; digitizer supports component = rgb, input type 
digiInVTR_Broadcast				EQU		$00000800			; digitizer can differentiate between the two 
digiInDoesColor					EQU		$00001000			; digitizer supports color 
digiInDoesBW					EQU		$00002000			; digitizer supports black & white 
															; Digitizer Input Current Flags = these are valid only during active operating conditions,   
digiInSignalLock				EQU		$80000000			; digitizer detects input signal is locked, this bit = horiz lock || vertical lock 

;  Digitizer Output Capability/Current Flags 

digiOutDoes1					EQU		$00000001			; digitizer supports 1 bit pixels 
digiOutDoes2					EQU		$00000002			; digitizer supports 2 bit pixels 
digiOutDoes4					EQU		$00000004			; digitizer supports 4 bit pixels 
digiOutDoes8					EQU		$00000008			; digitizer supports 8 bit pixels 
digiOutDoes16					EQU		$00000010			; digitizer supports 16 bit pixels 
digiOutDoes32					EQU		$00000020			; digitizer supports 32 bit pixels 
digiOutDoesDither				EQU		$00000040			; digitizer dithers in indexed modes 
digiOutDoesStretch				EQU		$00000080			; digitizer can arbitrarily stretch 
digiOutDoesShrink				EQU		$00000100			; digitizer can arbitrarily shrink 
digiOutDoesMask					EQU		$00000200			; digitizer can mask to clipping regions 
digiOutDoesDouble				EQU		$00000800			; digitizer can stretch to exactly double size 
digiOutDoesQuad					EQU		$00001000			; digitizer can stretch exactly quadruple size 
digiOutDoesQuarter				EQU		$00002000			; digitizer can shrink to exactly quarter size 
digiOutDoesSixteenth			EQU		$00004000			; digitizer can shrink to exactly sixteenth size 
digiOutDoesRotate				EQU		$00008000			; digitizer supports rotate transformations 
digiOutDoesHorizFlip			EQU		$00010000			; digitizer supports horizontal flips Sx < 0 
digiOutDoesVertFlip				EQU		$00020000			; digitizer supports vertical flips Sy < 0 
digiOutDoesSkew					EQU		$00040000			; digitizer supports skew = shear,twist, 
digiOutDoesBlend				EQU		$00080000
digiOutDoesWarp					EQU		$00100000
digiOutDoesHW_DMA				EQU		$00200000			; digitizer not constrained to local device 
digiOutDoesHWPlayThru			EQU		$00400000			; digitizer doesn't need time to play thru 
digiOutDoesILUT					EQU		$00800000			; digitizer does inverse LUT for index modes 
digiOutDoesKeyColor				EQU		$01000000			; digitizer does key color functions too 
digiOutDoesAsyncGrabs			EQU		$02000000			; digitizer supports async grabs 
digiOutDoesUnreadableScreenBits	EQU		$04000000			; playthru doesn't generate readable bits on screen
digiOutDoesCompress				EQU		$08000000			; supports alternate output data types 
digiOutDoesCompressOnly			EQU		$10000000			; can't provide raw frames anywhere 
digiOutDoesPlayThruDuringCompress EQU	$20000000			; digi can do playthru while providing compressed data 
digiOutDoesCompressPartiallyVisible EQU	$40000000			; digi doesn't need all bits visible on screen to do hardware compress 
;  Types 
; typedef ComponentInstance 			VideoDigitizerComponent

; typedef ComponentResult 				VideoDigitizerError

DigitizerInfo			RECORD 0
vdigType				 ds.w	1				; offset: $0 (0)
inputCapabilityFlags	 ds.l	1				; offset: $2 (2)
outputCapabilityFlags	 ds.l	1				; offset: $6 (6)
inputCurrentFlags		 ds.l	1				; offset: $A (10)
outputCurrentFlags		 ds.l	1				; offset: $E (14)
slot					 ds.w	1				; offset: $12 (18)		;  temporary for connection purposes 
gdh						 ds.l	1				; offset: $14 (20)		;  temporary for digitizers that have preferred screen 
maskgdh					 ds.l	1				; offset: $18 (24)		;  temporary for digitizers that have mask planes 
minDestHeight			 ds.w	1				; offset: $1C (28)		;  Smallest resizable height 
minDestWidth			 ds.w	1				; offset: $1E (30)		;  Smallest resizable width 
maxDestHeight			 ds.w	1				; offset: $20 (32)		;  Largest resizable height 
maxDestWidth			 ds.w	1				; offset: $22 (34)		;  Largest resizable width 
blendLevels				 ds.w	1				; offset: $24 (36)		;  Number of blend levels supported (2 if 1 bit mask) 
reserved				 ds.l	1				; offset: $26 (38)		;  reserved 
sizeof					 EQU *					; size:   $2A (42)
						ENDR
VdigType				RECORD 0
digType					 ds.l	1				; offset: $0 (0)
reserved				 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
VdigTypeList			RECORD 0
count					 ds.w	1				; offset: $0 (0)
list					 ds		VdigType		; offset: $2 (2) <-- really an array of length one
sizeof					 EQU *					; size:   $A (10)
						ENDR
VdigBufferRec			RECORD 0
dest					 ds.l	1				; offset: $0 (0)
location				 ds		Point			; offset: $4 (4)
reserved				 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
VdigBufferRecList		RECORD 0
count					 ds.w	1				; offset: $0 (0)
matrix					 ds.l	1				; offset: $2 (2)
mask					 ds.l	1				; offset: $6 (6)
list					 ds		VdigBufferRec	; offset: $A (10) <-- really an array of length one
sizeof					 EQU *					; size:   $16 (22)
						ENDR
; typedef struct VdigBufferRecList *	VdigBufferRecListPtr

; typedef VdigBufferRecListPtr *		VdigBufferRecListHandle

VDCompressionList		RECORD 0
codec					 ds.l	1				; offset: $0 (0)
cType					 ds.l	1				; offset: $4 (4)
typeName				 ds		Str63			; offset: $8 (8)
name					 ds		Str63			; offset: $48 (72)
formatFlags				 ds.l	1				; offset: $88 (136)
compressFlags			 ds.l	1				; offset: $8C (140)
reserved				 ds.l	1				; offset: $90 (144)
sizeof					 EQU *					; size:   $94 (148)
						ENDR
; typedef struct VDCompressionList *	VDCompressionListPtr

; typedef VDCompressionListPtr *		VDCompressionListHandle


dmaDepth1						EQU		1
dmaDepth2						EQU		2
dmaDepth4						EQU		4
dmaDepth8						EQU		8
dmaDepth16						EQU		16
dmaDepth32						EQU		32
dmaDepth2Gray					EQU		64
dmaDepth4Gray					EQU		128
dmaDepth8Gray					EQU		256

kVDIGControlledFrameRate		EQU		-1

;
; pascal VideoDigitizerError VDGetMaxSrcRect(VideoDigitizerComponent ci, short inputStd, Rect *maxSrcRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetMaxSrcRect
			move.l              #$00060001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetMaxSrcRect
	ENDIF

;
; pascal VideoDigitizerError VDGetActiveSrcRect(VideoDigitizerComponent ci, short inputStd, Rect *activeSrcRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetActiveSrcRect
			move.l              #$00060002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetActiveSrcRect
	ENDIF

;
; pascal VideoDigitizerError VDSetDigitizerRect(VideoDigitizerComponent ci, Rect *digitizerRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetDigitizerRect
			move.l              #$00040003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetDigitizerRect
	ENDIF

;
; pascal VideoDigitizerError VDGetDigitizerRect(VideoDigitizerComponent ci, Rect *digitizerRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetDigitizerRect
			move.l              #$00040004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetDigitizerRect
	ENDIF

;
; pascal VideoDigitizerError VDGetVBlankRect(VideoDigitizerComponent ci, short inputStd, Rect *vBlankRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetVBlankRect
			move.l              #$00060005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetVBlankRect
	ENDIF

;
; pascal VideoDigitizerError VDGetMaskPixMap(VideoDigitizerComponent ci, PixMapHandle maskPixMap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetMaskPixMap
			move.l              #$00040006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetMaskPixMap
	ENDIF

;
; pascal VideoDigitizerError VDGetPlayThruDestination(VideoDigitizerComponent ci, PixMapHandle *dest, Rect *destRect, MatrixRecord *m, RgnHandle *mask)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetPlayThruDestination
			move.l              #$00100008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetPlayThruDestination
	ENDIF

;
; pascal VideoDigitizerError VDUseThisCLUT(VideoDigitizerComponent ci, CTabHandle colorTableHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDUseThisCLUT
			move.l              #$00040009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDUseThisCLUT
	ENDIF

;
; pascal VideoDigitizerError VDSetInputGammaValue(VideoDigitizerComponent ci, Fixed channel1, Fixed channel2, Fixed channel3)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetInputGammaValue
			move.l              #$000C000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetInputGammaValue
	ENDIF

;
; pascal VideoDigitizerError VDGetInputGammaValue(VideoDigitizerComponent ci, Fixed *channel1, Fixed *channel2, Fixed *channel3)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetInputGammaValue
			move.l              #$000C000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetInputGammaValue
	ENDIF

;
; pascal VideoDigitizerError VDSetBrightness(VideoDigitizerComponent ci, unsigned short *brightness)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetBrightness
			move.l              #$0004000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetBrightness
	ENDIF

;
; pascal VideoDigitizerError VDGetBrightness(VideoDigitizerComponent ci, unsigned short *brightness)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetBrightness
			move.l              #$0004000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetBrightness
	ENDIF

;
; pascal VideoDigitizerError VDSetContrast(VideoDigitizerComponent ci, unsigned short *contrast)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetContrast
			move.l              #$0004000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetContrast
	ENDIF

;
; pascal VideoDigitizerError VDSetHue(VideoDigitizerComponent ci, unsigned short *hue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetHue
			move.l              #$0004000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetHue
	ENDIF

;
; pascal VideoDigitizerError VDSetSharpness(VideoDigitizerComponent ci, unsigned short *sharpness)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetSharpness
			move.l              #$00040010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetSharpness
	ENDIF

;
; pascal VideoDigitizerError VDSetSaturation(VideoDigitizerComponent ci, unsigned short *saturation)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetSaturation
			move.l              #$00040011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetSaturation
	ENDIF

;
; pascal VideoDigitizerError VDGetContrast(VideoDigitizerComponent ci, unsigned short *contrast)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetContrast
			move.l              #$00040012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetContrast
	ENDIF

;
; pascal VideoDigitizerError VDGetHue(VideoDigitizerComponent ci, unsigned short *hue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetHue
			move.l              #$00040013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetHue
	ENDIF

;
; pascal VideoDigitizerError VDGetSharpness(VideoDigitizerComponent ci, unsigned short *sharpness)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetSharpness
			move.l              #$00040014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetSharpness
	ENDIF

;
; pascal VideoDigitizerError VDGetSaturation(VideoDigitizerComponent ci, unsigned short *saturation)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetSaturation
			move.l              #$00040015,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetSaturation
	ENDIF

;
; pascal VideoDigitizerError VDGrabOneFrame(VideoDigitizerComponent ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGrabOneFrame
			move.l              #$00000016,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGrabOneFrame
	ENDIF

;
; pascal VideoDigitizerError VDGetMaxAuxBuffer(VideoDigitizerComponent ci, PixMapHandle *pm, Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetMaxAuxBuffer
			move.l              #$00080017,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetMaxAuxBuffer
	ENDIF

;
; pascal VideoDigitizerError VDGetDigitizerInfo(VideoDigitizerComponent ci, DigitizerInfo *info)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetDigitizerInfo
			move.l              #$00040019,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetDigitizerInfo
	ENDIF

;
; pascal VideoDigitizerError VDGetCurrentFlags(VideoDigitizerComponent ci, long *inputCurrentFlag, long *outputCurrentFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetCurrentFlags
			move.l              #$0008001A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetCurrentFlags
	ENDIF

;
; pascal VideoDigitizerError VDSetKeyColor(VideoDigitizerComponent ci, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetKeyColor
			move.l              #$0004001B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetKeyColor
	ENDIF

;
; pascal VideoDigitizerError VDGetKeyColor(VideoDigitizerComponent ci, long *index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetKeyColor
			move.l              #$0004001C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetKeyColor
	ENDIF

;
; pascal VideoDigitizerError VDAddKeyColor(VideoDigitizerComponent ci, long *index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDAddKeyColor
			move.l              #$0004001D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDAddKeyColor
	ENDIF

;
; pascal VideoDigitizerError VDGetNextKeyColor(VideoDigitizerComponent ci, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetNextKeyColor
			move.l              #$0004001E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetNextKeyColor
	ENDIF

;
; pascal VideoDigitizerError VDSetKeyColorRange(VideoDigitizerComponent ci, RGBColor *minRGB, RGBColor *maxRGB)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetKeyColorRange
			move.l              #$0008001F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetKeyColorRange
	ENDIF

;
; pascal VideoDigitizerError VDGetKeyColorRange(VideoDigitizerComponent ci, RGBColor *minRGB, RGBColor *maxRGB)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetKeyColorRange
			move.l              #$00080020,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetKeyColorRange
	ENDIF

;
; pascal VideoDigitizerError VDSetDigitizerUserInterrupt(VideoDigitizerComponent ci, long flags, VdigIntUPP userInterruptProc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetDigitizerUserInterrupt
			move.l              #$000C0021,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetDigitizerUserInterrupt
	ENDIF

;
; pascal VideoDigitizerError VDSetInputColorSpaceMode(VideoDigitizerComponent ci, short colorSpaceMode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetInputColorSpaceMode
			move.l              #$00020022,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetInputColorSpaceMode
	ENDIF

;
; pascal VideoDigitizerError VDGetInputColorSpaceMode(VideoDigitizerComponent ci, short *colorSpaceMode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetInputColorSpaceMode
			move.l              #$00040023,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetInputColorSpaceMode
	ENDIF

;
; pascal VideoDigitizerError VDSetClipState(VideoDigitizerComponent ci, short clipEnable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetClipState
			move.l              #$00020024,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetClipState
	ENDIF

;
; pascal VideoDigitizerError VDGetClipState(VideoDigitizerComponent ci, short *clipEnable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetClipState
			move.l              #$00040025,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetClipState
	ENDIF

;
; pascal VideoDigitizerError VDSetClipRgn(VideoDigitizerComponent ci, RgnHandle clipRegion)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetClipRgn
			move.l              #$00040026,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetClipRgn
	ENDIF

;
; pascal VideoDigitizerError VDClearClipRgn(VideoDigitizerComponent ci, RgnHandle clipRegion)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDClearClipRgn
			move.l              #$00040027,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDClearClipRgn
	ENDIF

;
; pascal VideoDigitizerError VDGetCLUTInUse(VideoDigitizerComponent ci, CTabHandle *colorTableHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetCLUTInUse
			move.l              #$00040028,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetCLUTInUse
	ENDIF

;
; pascal VideoDigitizerError VDSetPLLFilterType(VideoDigitizerComponent ci, short pllType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetPLLFilterType
			move.l              #$00020029,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetPLLFilterType
	ENDIF

;
; pascal VideoDigitizerError VDGetPLLFilterType(VideoDigitizerComponent ci, short *pllType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetPLLFilterType
			move.l              #$0004002A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetPLLFilterType
	ENDIF

;
; pascal VideoDigitizerError VDGetMaskandValue(VideoDigitizerComponent ci, unsigned short blendLevel, long *mask, long *value)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetMaskandValue
			move.l              #$000A002B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetMaskandValue
	ENDIF

;
; pascal VideoDigitizerError VDSetMasterBlendLevel(VideoDigitizerComponent ci, unsigned short *blendLevel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetMasterBlendLevel
			move.l              #$0004002C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetMasterBlendLevel
	ENDIF

;
; pascal VideoDigitizerError VDSetPlayThruDestination(VideoDigitizerComponent ci, PixMapHandle dest, RectPtr destRect, MatrixRecordPtr m, RgnHandle mask)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetPlayThruDestination
			move.l              #$0010002D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetPlayThruDestination
	ENDIF

;
; pascal VideoDigitizerError VDSetPlayThruOnOff(VideoDigitizerComponent ci, short state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetPlayThruOnOff
			move.l              #$0002002E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetPlayThruOnOff
	ENDIF

;
; pascal VideoDigitizerError VDSetFieldPreference(VideoDigitizerComponent ci, short fieldFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetFieldPreference
			move.l              #$0002002F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetFieldPreference
	ENDIF

;
; pascal VideoDigitizerError VDGetFieldPreference(VideoDigitizerComponent ci, short *fieldFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetFieldPreference
			move.l              #$00040030,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetFieldPreference
	ENDIF

;
; pascal VideoDigitizerError VDPreflightDestination(VideoDigitizerComponent ci, Rect *digitizerRect, PixMap **dest, RectPtr destRect, MatrixRecordPtr m)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDPreflightDestination
			move.l              #$00100032,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDPreflightDestination
	ENDIF

;
; pascal VideoDigitizerError VDPreflightGlobalRect(VideoDigitizerComponent ci, GrafPtr theWindow, Rect *globalRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDPreflightGlobalRect
			move.l              #$00080033,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDPreflightGlobalRect
	ENDIF

;
; pascal VideoDigitizerError VDSetPlayThruGlobalRect(VideoDigitizerComponent ci, GrafPtr theWindow, Rect *globalRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetPlayThruGlobalRect
			move.l              #$00080034,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetPlayThruGlobalRect
	ENDIF

;
; pascal VideoDigitizerError VDSetInputGammaRecord(VideoDigitizerComponent ci, VDGamRecPtr inputGammaPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetInputGammaRecord
			move.l              #$00040035,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetInputGammaRecord
	ENDIF

;
; pascal VideoDigitizerError VDGetInputGammaRecord(VideoDigitizerComponent ci, VDGamRecPtr *inputGammaPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetInputGammaRecord
			move.l              #$00040036,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetInputGammaRecord
	ENDIF

;
; pascal VideoDigitizerError VDSetBlackLevelValue(VideoDigitizerComponent ci, unsigned short *blackLevel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetBlackLevelValue
			move.l              #$00040037,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetBlackLevelValue
	ENDIF

;
; pascal VideoDigitizerError VDGetBlackLevelValue(VideoDigitizerComponent ci, unsigned short *blackLevel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetBlackLevelValue
			move.l              #$00040038,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetBlackLevelValue
	ENDIF

;
; pascal VideoDigitizerError VDSetWhiteLevelValue(VideoDigitizerComponent ci, unsigned short *whiteLevel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetWhiteLevelValue
			move.l              #$00040039,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetWhiteLevelValue
	ENDIF

;
; pascal VideoDigitizerError VDGetWhiteLevelValue(VideoDigitizerComponent ci, unsigned short *whiteLevel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetWhiteLevelValue
			move.l              #$0004003A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetWhiteLevelValue
	ENDIF

;
; pascal VideoDigitizerError VDGetVideoDefaults(VideoDigitizerComponent ci, unsigned short *blackLevel, unsigned short *whiteLevel, unsigned short *brightness, unsigned short *hue, unsigned short *saturation, unsigned short *contrast, unsigned short *sharpness)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetVideoDefaults
			move.l              #$001C003B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetVideoDefaults
	ENDIF

;
; pascal VideoDigitizerError VDGetNumberOfInputs(VideoDigitizerComponent ci, short *inputs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetNumberOfInputs
			move.l              #$0004003C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetNumberOfInputs
	ENDIF

;
; pascal VideoDigitizerError VDGetInputFormat(VideoDigitizerComponent ci, short input, short *format)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetInputFormat
			move.l              #$0006003D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetInputFormat
	ENDIF

;
; pascal VideoDigitizerError VDSetInput(VideoDigitizerComponent ci, short input)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetInput
			move.l              #$0002003E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetInput
	ENDIF

;
; pascal VideoDigitizerError VDGetInput(VideoDigitizerComponent ci, short *input)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetInput
			move.l              #$0004003F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetInput
	ENDIF

;
; pascal VideoDigitizerError VDSetInputStandard(VideoDigitizerComponent ci, short inputStandard)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetInputStandard
			move.l              #$00020040,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetInputStandard
	ENDIF

;
; pascal VideoDigitizerError VDSetupBuffers(VideoDigitizerComponent ci, VdigBufferRecListHandle bufferList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetupBuffers
			move.l              #$00040041,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetupBuffers
	ENDIF

;
; pascal VideoDigitizerError VDGrabOneFrameAsync(VideoDigitizerComponent ci, short buffer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGrabOneFrameAsync
			move.l              #$00020042,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGrabOneFrameAsync
	ENDIF

;
; pascal VideoDigitizerError VDDone(VideoDigitizerComponent ci, short buffer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDDone
			move.l              #$00020043,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDDone
	ENDIF

;
; pascal VideoDigitizerError VDSetCompression(VideoDigitizerComponent ci, OSType compressType, short depth, Rect *bounds, CodecQ spatialQuality, CodecQ temporalQuality, long keyFrameRate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetCompression
			move.l              #$00160044,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetCompression
	ENDIF

;
; pascal VideoDigitizerError VDCompressOneFrameAsync(VideoDigitizerComponent ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDCompressOneFrameAsync
			move.l              #$00000045,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDCompressOneFrameAsync
	ENDIF

;
; pascal VideoDigitizerError VDCompressDone(VideoDigitizerComponent ci, Boolean *done, Ptr *theData, long *dataSize, UInt8 *similarity, TimeRecord *t)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDCompressDone
			move.l              #$00140046,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDCompressDone
	ENDIF

;
; pascal VideoDigitizerError VDReleaseCompressBuffer(VideoDigitizerComponent ci, Ptr bufferAddr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDReleaseCompressBuffer
			move.l              #$00040047,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDReleaseCompressBuffer
	ENDIF

;
; pascal VideoDigitizerError VDGetImageDescription(VideoDigitizerComponent ci, ImageDescriptionHandle desc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetImageDescription
			move.l              #$00040048,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetImageDescription
	ENDIF

;
; pascal VideoDigitizerError VDResetCompressSequence(VideoDigitizerComponent ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDResetCompressSequence
			move.l              #$00000049,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDResetCompressSequence
	ENDIF

;
; pascal VideoDigitizerError VDSetCompressionOnOff(VideoDigitizerComponent ci, Boolean state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetCompressionOnOff
			move.l              #$0002004A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetCompressionOnOff
	ENDIF

;
; pascal VideoDigitizerError VDGetCompressionTypes(VideoDigitizerComponent ci, VDCompressionListHandle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetCompressionTypes
			move.l              #$0004004B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetCompressionTypes
	ENDIF

;
; pascal VideoDigitizerError VDSetTimeBase(VideoDigitizerComponent ci, TimeBase t)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetTimeBase
			move.l              #$0004004C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetTimeBase
	ENDIF

;
; pascal VideoDigitizerError VDSetFrameRate(VideoDigitizerComponent ci, Fixed framesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetFrameRate
			move.l              #$0004004D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetFrameRate
	ENDIF

;
; pascal VideoDigitizerError VDGetDataRate(VideoDigitizerComponent ci, long *milliSecPerFrame, Fixed *framesPerSecond, long *bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetDataRate
			move.l              #$000C004E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetDataRate
	ENDIF

;
; pascal VideoDigitizerError VDGetSoundInputDriver(VideoDigitizerComponent ci, Str255 soundDriverName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetSoundInputDriver
			move.l              #$0004004F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetSoundInputDriver
	ENDIF

;
; pascal VideoDigitizerError VDGetDMADepths(VideoDigitizerComponent ci, long *depthArray, long *preferredDepth)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetDMADepths
			move.l              #$00080050,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetDMADepths
	ENDIF

;
; pascal VideoDigitizerError VDGetPreferredTimeScale(VideoDigitizerComponent ci, TimeScale *preferred)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetPreferredTimeScale
			move.l              #$00040051,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetPreferredTimeScale
	ENDIF

;
; pascal VideoDigitizerError VDReleaseAsyncBuffers(VideoDigitizerComponent ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDReleaseAsyncBuffers
			move.l              #$00000052,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDReleaseAsyncBuffers
	ENDIF

;  83 is reserved for compatibility reasons 
;
; pascal VideoDigitizerError VDSetDataRate(VideoDigitizerComponent ci, long bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetDataRate
			move.l              #$00040054,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetDataRate
	ENDIF

;
; pascal VideoDigitizerError VDGetTimeCode(VideoDigitizerComponent ci, TimeRecord *atTime, void *timeCodeFormat, void *timeCodeTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetTimeCode
			move.l              #$000C0055,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetTimeCode
	ENDIF

;
; pascal VideoDigitizerError VDUseSafeBuffers(VideoDigitizerComponent ci, Boolean useSafeBuffers)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDUseSafeBuffers
			move.l              #$00020056,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDUseSafeBuffers
	ENDIF

;
; pascal VideoDigitizerError VDGetSoundInputSource(VideoDigitizerComponent ci, long videoInput, long *soundInput)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetSoundInputSource
			move.l              #$00080057,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetSoundInputSource
	ENDIF

;
; pascal VideoDigitizerError VDGetCompressionTime(VideoDigitizerComponent ci, OSType compressionType, short depth, Rect *srcRect, CodecQ *spatialQuality, CodecQ *temporalQuality, unsigned long *compressTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetCompressionTime
			move.l              #$00160058,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetCompressionTime
	ENDIF

;
; pascal VideoDigitizerError VDSetPreferredPacketSize(VideoDigitizerComponent ci, long preferredPacketSizeInBytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetPreferredPacketSize
			move.l              #$00040059,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetPreferredPacketSize
	ENDIF

;
; pascal VideoDigitizerError VDSetPreferredImageDimensions(VideoDigitizerComponent ci, long width, long height)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetPreferredImageDimensions
			move.l              #$0008005A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetPreferredImageDimensions
	ENDIF

;
; pascal VideoDigitizerError VDGetPreferredImageDimensions(VideoDigitizerComponent ci, long *width, long *height)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetPreferredImageDimensions
			move.l              #$0008005B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetPreferredImageDimensions
	ENDIF

;
; pascal VideoDigitizerError VDGetInputName(VideoDigitizerComponent ci, long videoInput, Str255 name)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetInputName
			move.l              #$0008005C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetInputName
	ENDIF

	IF CALL_NOT_IN_CARBON THEN
;
; pascal VideoDigitizerError VDSetDestinationPort(VideoDigitizerComponent ci, CGrafPtr destPort)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetDestinationPort
			move.l              #$0004005D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetDestinationPort
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON



; 
;    General Sequence Grab stuff
;

; typedef ComponentInstance 			SeqGrabComponent

; typedef ComponentInstance 			SGChannel


SeqGrabComponentType			EQU		'barg'
SeqGrabChannelType				EQU		'sgch'
SeqGrabPanelType				EQU		'sgpn'
SeqGrabCompressionPanelType		EQU		'cmpr'
SeqGrabSourcePanelType			EQU		'sour'

seqGrabToDisk					EQU		1
seqGrabToMemory					EQU		2
seqGrabDontUseTempMemory		EQU		4
seqGrabAppendToFile				EQU		8
seqGrabDontAddMovieResource		EQU		16
seqGrabDontMakeMovie			EQU		32
seqGrabPreExtendFile			EQU		64
seqGrabDataProcIsInterruptSafe	EQU		128
seqGrabDataProcDoesOverlappingReads EQU	256
; typedef unsigned long 				SeqGrabDataOutputEnum


seqGrabRecord					EQU		1
seqGrabPreview					EQU		2
seqGrabPlayDuringRecord			EQU		4
; typedef unsigned long 				SeqGrabUsageEnum


seqGrabHasBounds				EQU		1
seqGrabHasVolume				EQU		2
seqGrabHasDiscreteSamples		EQU		4
; typedef unsigned long 				SeqGrabChannelInfoEnum

SGOutputRecord			RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct SGOutputRecord *		SGOutput

SeqGrabFrameInfo		RECORD 0
frameOffset				 ds.l	1				; offset: $0 (0)
frameTime				 ds.l	1				; offset: $4 (4)
frameSize				 ds.l	1				; offset: $8 (8)
frameChannel			 ds.l	1				; offset: $C (12)
frameRefCon				 ds.l	1				; offset: $10 (16)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct SeqGrabFrameInfo *		SeqGrabFrameInfoPtr

SeqGrabExtendedFrameInfo RECORD 0
frameOffset				 ds		wide			; offset: $0 (0)
frameTime				 ds.l	1				; offset: $8 (8)
frameSize				 ds.l	1				; offset: $C (12)
frameChannel			 ds.l	1				; offset: $10 (16)
frameRefCon				 ds.l	1				; offset: $14 (20)
frameOutput				 ds.l	1				; offset: $18 (24)
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct SeqGrabExtendedFrameInfo * SeqGrabExtendedFrameInfoPtr


grabPictOffScreen				EQU		1
grabPictIgnoreClip				EQU		2
grabPictCurrentImage			EQU		4

sgFlagControlledGrab			EQU		$01
sgFlagAllowNonRGBPixMaps		EQU		$02
SGDeviceName			RECORD 0
name					 ds		Str63			; offset: $0 (0)
icon					 ds.l	1				; offset: $40 (64)
flags					 ds.l	1				; offset: $44 (68)
refCon					 ds.l	1				; offset: $48 (72)
reserved				 ds.l	1				; offset: $4C (76)		;  zero
sizeof					 EQU *					; size:   $50 (80)
						ENDR

sgDeviceNameFlagDeviceUnavailable EQU	$01
SGDeviceListRecord		RECORD 0
count					 ds.w	1				; offset: $0 (0)
selectedIndex			 ds.w	1				; offset: $2 (2)
reserved				 ds.l	1				; offset: $4 (4)		;  zero
entry					 ds		SGDeviceName	; offset: $8 (8) <-- really an array of length one
sizeof					 EQU *					; size:   $58 (88)
						ENDR
; typedef struct SGDeviceListRecord *	SGDeviceListPtr

; typedef SGDeviceListPtr *				SGDeviceList


sgDeviceListWithIcons			EQU		$01
sgDeviceListDontCheckAvailability EQU	$02

seqGrabWriteAppend				EQU		0
seqGrabWriteReserve				EQU		1
seqGrabWriteFill				EQU		2

seqGrabUnpause					EQU		0
seqGrabPause					EQU		1
seqGrabPauseForMenu				EQU		3

channelFlagDontOpenResFile		EQU		2
channelFlagHasDependency		EQU		4

sgPanelFlagForPanel				EQU		1

seqGrabSettingsPreviewOnly		EQU		1

channelPlayNormal				EQU		0
channelPlayFast					EQU		1
channelPlayHighQuality			EQU		2
channelPlayAllData				EQU		4

;
; pascal ComponentResult SGInitialize(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGInitialize
			move.l              #$00000001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGInitialize
	ENDIF

;
; pascal ComponentResult SGSetDataOutput(SeqGrabComponent s, const FSSpec *movieFile, long whereFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetDataOutput
			move.l              #$00080002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetDataOutput
	ENDIF

;
; pascal ComponentResult SGGetDataOutput(SeqGrabComponent s, FSSpec *movieFile, long *whereFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetDataOutput
			move.l              #$00080003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetDataOutput
	ENDIF

;
; pascal ComponentResult SGSetGWorld(SeqGrabComponent s, CGrafPtr gp, GDHandle gd)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetGWorld
			move.l              #$00080004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetGWorld
	ENDIF

;
; pascal ComponentResult SGGetGWorld(SeqGrabComponent s, CGrafPtr *gp, GDHandle *gd)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetGWorld
			move.l              #$00080005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetGWorld
	ENDIF

;
; pascal ComponentResult SGNewChannel(SeqGrabComponent s, OSType channelType, SGChannel *ref)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGNewChannel
			move.l              #$00080006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGNewChannel
	ENDIF

;
; pascal ComponentResult SGDisposeChannel(SeqGrabComponent s, SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGDisposeChannel
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGDisposeChannel
	ENDIF

;
; pascal ComponentResult SGStartPreview(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGStartPreview
			move.l              #$00000010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGStartPreview
	ENDIF

;
; pascal ComponentResult SGStartRecord(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGStartRecord
			move.l              #$00000011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGStartRecord
	ENDIF

;
; pascal ComponentResult SGIdle(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGIdle
			move.l              #$00000012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGIdle
	ENDIF

;
; pascal ComponentResult SGStop(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGStop
			move.l              #$00000013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGStop
	ENDIF

;
; pascal ComponentResult SGPause(SeqGrabComponent s, Byte pause)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPause
			move.l              #$00020014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPause
	ENDIF

;
; pascal ComponentResult SGPrepare(SeqGrabComponent s, Boolean prepareForPreview, Boolean prepareForRecord)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPrepare
			move.l              #$00040015,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPrepare
	ENDIF

;
; pascal ComponentResult SGRelease(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGRelease
			move.l              #$00000016,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGRelease
	ENDIF

;
; pascal Movie SGGetMovie(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetMovie
			move.l              #$00000017,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetMovie
	ENDIF

;
; pascal ComponentResult SGSetMaximumRecordTime(SeqGrabComponent s, unsigned long ticks)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetMaximumRecordTime
			move.l              #$00040018,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetMaximumRecordTime
	ENDIF

;
; pascal ComponentResult SGGetMaximumRecordTime(SeqGrabComponent s, unsigned long *ticks)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetMaximumRecordTime
			move.l              #$00040019,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetMaximumRecordTime
	ENDIF

;
; pascal ComponentResult SGGetStorageSpaceRemaining(SeqGrabComponent s, unsigned long *bytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetStorageSpaceRemaining
			move.l              #$0004001A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetStorageSpaceRemaining
	ENDIF

;
; pascal ComponentResult SGGetTimeRemaining(SeqGrabComponent s, long *ticksLeft)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetTimeRemaining
			move.l              #$0004001B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetTimeRemaining
	ENDIF

;
; pascal ComponentResult SGGrabPict(SeqGrabComponent s, PicHandle *p, const Rect *bounds, short offscreenDepth, long grabPictFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGrabPict
			move.l              #$000E001C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGrabPict
	ENDIF

;
; pascal ComponentResult SGGetLastMovieResID(SeqGrabComponent s, short *resID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetLastMovieResID
			move.l              #$0004001D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetLastMovieResID
	ENDIF

;
; pascal ComponentResult SGSetFlags(SeqGrabComponent s, long sgFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetFlags
			move.l              #$0004001E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetFlags
	ENDIF

;
; pascal ComponentResult SGGetFlags(SeqGrabComponent s, long *sgFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetFlags
			move.l              #$0004001F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetFlags
	ENDIF

;
; pascal ComponentResult SGSetDataProc(SeqGrabComponent s, SGDataUPP proc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetDataProc
			move.l              #$00080020,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetDataProc
	ENDIF

;
; pascal ComponentResult SGNewChannelFromComponent(SeqGrabComponent s, SGChannel *newChannel, Component sgChannelComponent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGNewChannelFromComponent
			move.l              #$00080021,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGNewChannelFromComponent
	ENDIF

;
; pascal ComponentResult SGDisposeDeviceList(SeqGrabComponent s, SGDeviceList list)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGDisposeDeviceList
			move.l              #$00040022,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGDisposeDeviceList
	ENDIF

;
; pascal ComponentResult SGAppendDeviceListToMenu(SeqGrabComponent s, SGDeviceList list, MenuRef mh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAppendDeviceListToMenu
			move.l              #$00080023,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAppendDeviceListToMenu
	ENDIF

;
; pascal ComponentResult SGSetSettings(SeqGrabComponent s, UserData ud, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetSettings
			move.l              #$00080024,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetSettings
	ENDIF

;
; pascal ComponentResult SGGetSettings(SeqGrabComponent s, UserData *ud, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetSettings
			move.l              #$00080025,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetSettings
	ENDIF

;
; pascal ComponentResult SGGetIndChannel(SeqGrabComponent s, short index, SGChannel *ref, OSType *chanType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetIndChannel
			move.l              #$000A0026,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetIndChannel
	ENDIF

;
; pascal ComponentResult SGUpdate(SeqGrabComponent s, RgnHandle updateRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGUpdate
			move.l              #$00040027,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGUpdate
	ENDIF

;
; pascal ComponentResult SGGetPause(SeqGrabComponent s, Byte *paused)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetPause
			move.l              #$00040028,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetPause
	ENDIF

; typedef const Component *				ConstComponentListPtr

;
; pascal ComponentResult SGSettingsDialog(SeqGrabComponent s, SGChannel c, short numPanels, ConstComponentListPtr panelList, long flags, SGModalFilterUPP proc, long procRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSettingsDialog
			move.l              #$00160029,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSettingsDialog
	ENDIF

;
; pascal ComponentResult SGGetAlignmentProc(SeqGrabComponent s, ICMAlignmentProcRecordPtr alignmentProc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetAlignmentProc
			move.l              #$0004002A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetAlignmentProc
	ENDIF

;
; pascal ComponentResult SGSetChannelSettings(SeqGrabComponent s, SGChannel c, UserData ud, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelSettings
			move.l              #$000C002B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelSettings
	ENDIF

;
; pascal ComponentResult SGGetChannelSettings(SeqGrabComponent s, SGChannel c, UserData *ud, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelSettings
			move.l              #$000C002C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelSettings
	ENDIF

;
; pascal ComponentResult SGGetMode(SeqGrabComponent s, Boolean *previewMode, Boolean *recordMode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetMode
			move.l              #$0008002D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetMode
	ENDIF

;
; pascal ComponentResult SGSetDataRef(SeqGrabComponent s, Handle dataRef, OSType dataRefType, long whereFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetDataRef
			move.l              #$000C002E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetDataRef
	ENDIF

;
; pascal ComponentResult SGGetDataRef(SeqGrabComponent s, Handle *dataRef, OSType *dataRefType, long *whereFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetDataRef
			move.l              #$000C002F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetDataRef
	ENDIF

;
; pascal ComponentResult SGNewOutput(SeqGrabComponent s, Handle dataRef, OSType dataRefType, long whereFlags, SGOutput *sgOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGNewOutput
			move.l              #$00100030,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGNewOutput
	ENDIF

;
; pascal ComponentResult SGDisposeOutput(SeqGrabComponent s, SGOutput sgOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGDisposeOutput
			move.l              #$00040031,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGDisposeOutput
	ENDIF

;
; pascal ComponentResult SGSetOutputFlags(SeqGrabComponent s, SGOutput sgOut, long whereFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetOutputFlags
			move.l              #$00080032,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetOutputFlags
	ENDIF

;
; pascal ComponentResult SGSetChannelOutput(SeqGrabComponent s, SGChannel c, SGOutput sgOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelOutput
			move.l              #$00080033,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelOutput
	ENDIF

;
; pascal ComponentResult SGGetDataOutputStorageSpaceRemaining(SeqGrabComponent s, SGOutput sgOut, unsigned long *space)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetDataOutputStorageSpaceRemaining
			move.l              #$00080034,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetDataOutputStorageSpaceRemaining
	ENDIF

;
; pascal ComponentResult SGHandleUpdateEvent(SeqGrabComponent s, const EventRecord *event, Boolean *handled)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGHandleUpdateEvent
			move.l              #$00080035,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGHandleUpdateEvent
	ENDIF

;
; pascal ComponentResult SGSetOutputNextOutput(SeqGrabComponent s, SGOutput sgOut, SGOutput nextOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetOutputNextOutput
			move.l              #$00080036,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetOutputNextOutput
	ENDIF

;
; pascal ComponentResult SGGetOutputNextOutput(SeqGrabComponent s, SGOutput sgOut, SGOutput *nextOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetOutputNextOutput
			move.l              #$00080037,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetOutputNextOutput
	ENDIF

;
; pascal ComponentResult SGSetOutputMaximumOffset(SeqGrabComponent s, SGOutput sgOut, const wide *maxOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetOutputMaximumOffset
			move.l              #$00080038,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetOutputMaximumOffset
	ENDIF

;
; pascal ComponentResult SGGetOutputMaximumOffset(SeqGrabComponent s, SGOutput sgOut, wide *maxOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetOutputMaximumOffset
			move.l              #$00080039,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetOutputMaximumOffset
	ENDIF

;
; pascal ComponentResult SGGetOutputDataReference(SeqGrabComponent s, SGOutput sgOut, Handle *dataRef, OSType *dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetOutputDataReference
			move.l              #$000C003A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetOutputDataReference
	ENDIF

;
; pascal ComponentResult SGWriteExtendedMovieData(SeqGrabComponent s, SGChannel c, Ptr p, long len, wide *offset, SGOutput *sgOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGWriteExtendedMovieData
			move.l              #$0014003B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGWriteExtendedMovieData
	ENDIF

;
; pascal ComponentResult SGGetStorageSpaceRemaining64(SeqGrabComponent s, wide *bytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetStorageSpaceRemaining64
			move.l              #$0004003C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetStorageSpaceRemaining64
	ENDIF

; 
;    calls from Channel to seqGrab
;

;
; pascal ComponentResult SGWriteMovieData(SeqGrabComponent s, SGChannel c, Ptr p, long len, long *offset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGWriteMovieData
			move.l              #$00100100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGWriteMovieData
	ENDIF

;
; pascal ComponentResult SGAddFrameReference(SeqGrabComponent s, SeqGrabFrameInfoPtr frameInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAddFrameReference
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAddFrameReference
	ENDIF

;
; pascal ComponentResult SGGetNextFrameReference(SeqGrabComponent s, SeqGrabFrameInfoPtr frameInfo, TimeValue *frameDuration, long *frameNumber)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetNextFrameReference
			move.l              #$000C0102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetNextFrameReference
	ENDIF

;
; pascal ComponentResult SGGetTimeBase(SeqGrabComponent s, TimeBase *tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetTimeBase
			move.l              #$00040103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetTimeBase
	ENDIF

;
; pascal ComponentResult SGSortDeviceList(SeqGrabComponent s, SGDeviceList list)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSortDeviceList
			move.l              #$00040104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSortDeviceList
	ENDIF

;
; pascal ComponentResult SGAddMovieData(SeqGrabComponent s, SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAddMovieData
			move.l              #$001A0105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAddMovieData
	ENDIF

;
; pascal ComponentResult SGChangedSource(SeqGrabComponent s, SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChangedSource
			move.l              #$00040106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChangedSource
	ENDIF

;
; pascal ComponentResult SGAddExtendedFrameReference(SeqGrabComponent s, SeqGrabExtendedFrameInfoPtr frameInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAddExtendedFrameReference
			move.l              #$00040107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAddExtendedFrameReference
	ENDIF

;
; pascal ComponentResult SGGetNextExtendedFrameReference(SeqGrabComponent s, SeqGrabExtendedFrameInfoPtr frameInfo, TimeValue *frameDuration, long *frameNumber)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetNextExtendedFrameReference
			move.l              #$000C0108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetNextExtendedFrameReference
	ENDIF

;
; pascal ComponentResult SGAddExtendedMovieData(SeqGrabComponent s, SGChannel c, Ptr p, long len, wide *offset, long chRefCon, TimeValue time, short writeType, SGOutput *whichOutput)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAddExtendedMovieData
			move.l              #$001E0109,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAddExtendedMovieData
	ENDIF

;
; pascal ComponentResult SGAddOutputDataRefToMedia(SeqGrabComponent s, SGOutput sgOut, Media theMedia, SampleDescriptionHandle desc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAddOutputDataRefToMedia
			move.l              #$000C010A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAddOutputDataRefToMedia
	ENDIF



; ** Sequence Grab CHANNEL Component Stuff **

;
; pascal ComponentResult SGSetChannelUsage(SGChannel c, long usage)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelUsage
			move.l              #$00040080,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelUsage
	ENDIF

;
; pascal ComponentResult SGGetChannelUsage(SGChannel c, long *usage)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelUsage
			move.l              #$00040081,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelUsage
	ENDIF

;
; pascal ComponentResult SGSetChannelBounds(SGChannel c, const Rect *bounds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelBounds
			move.l              #$00040082,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelBounds
	ENDIF

;
; pascal ComponentResult SGGetChannelBounds(SGChannel c, Rect *bounds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelBounds
			move.l              #$00040083,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelBounds
	ENDIF

;
; pascal ComponentResult SGSetChannelVolume(SGChannel c, short volume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelVolume
			move.l              #$00020084,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelVolume
	ENDIF

;
; pascal ComponentResult SGGetChannelVolume(SGChannel c, short *volume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelVolume
			move.l              #$00040085,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelVolume
	ENDIF

;
; pascal ComponentResult SGGetChannelInfo(SGChannel c, long *channelInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelInfo
			move.l              #$00040086,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelInfo
	ENDIF

;
; pascal ComponentResult SGSetChannelPlayFlags(SGChannel c, long playFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelPlayFlags
			move.l              #$00040087,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelPlayFlags
	ENDIF

;
; pascal ComponentResult SGGetChannelPlayFlags(SGChannel c, long *playFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelPlayFlags
			move.l              #$00040088,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelPlayFlags
	ENDIF

;
; pascal ComponentResult SGSetChannelMaxFrames(SGChannel c, long frameCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelMaxFrames
			move.l              #$00040089,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelMaxFrames
	ENDIF

;
; pascal ComponentResult SGGetChannelMaxFrames(SGChannel c, long *frameCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelMaxFrames
			move.l              #$0004008A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelMaxFrames
	ENDIF

;
; pascal ComponentResult SGSetChannelRefCon(SGChannel c, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelRefCon
			move.l              #$0004008B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelRefCon
	ENDIF

;
; pascal ComponentResult SGSetChannelClip(SGChannel c, RgnHandle theClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelClip
			move.l              #$0004008C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelClip
	ENDIF

;
; pascal ComponentResult SGGetChannelClip(SGChannel c, RgnHandle *theClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelClip
			move.l              #$0004008D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelClip
	ENDIF

;
; pascal ComponentResult SGGetChannelSampleDescription(SGChannel c, Handle sampleDesc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelSampleDescription
			move.l              #$0004008E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelSampleDescription
	ENDIF

;
; pascal ComponentResult SGGetChannelDeviceList(SGChannel c, long selectionFlags, SGDeviceList *list)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelDeviceList
			move.l              #$0008008F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelDeviceList
	ENDIF

;
; pascal ComponentResult SGSetChannelDevice(SGChannel c, StringPtr name)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelDevice
			move.l              #$00040090,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelDevice
	ENDIF

;
; pascal ComponentResult SGSetChannelMatrix(SGChannel c, const MatrixRecord *m)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelMatrix
			move.l              #$00040091,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelMatrix
	ENDIF

;
; pascal ComponentResult SGGetChannelMatrix(SGChannel c, MatrixRecord *m)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelMatrix
			move.l              #$00040092,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelMatrix
	ENDIF

;
; pascal ComponentResult SGGetChannelTimeScale(SGChannel c, TimeScale *scale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelTimeScale
			move.l              #$00040093,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelTimeScale
	ENDIF

;
; pascal ComponentResult SGChannelPutPicture(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelPutPicture
			move.l              #$00000094,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelPutPicture
	ENDIF

;
; pascal ComponentResult SGChannelSetRequestedDataRate(SGChannel c, long bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelSetRequestedDataRate
			move.l              #$00040095,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelSetRequestedDataRate
	ENDIF

;
; pascal ComponentResult SGChannelGetRequestedDataRate(SGChannel c, long *bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelGetRequestedDataRate
			move.l              #$00040096,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelGetRequestedDataRate
	ENDIF

;
; pascal ComponentResult SGChannelSetDataSourceName(SGChannel c, ConstStr255Param name, ScriptCode scriptTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelSetDataSourceName
			move.l              #$00060097,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelSetDataSourceName
	ENDIF

;
; pascal ComponentResult SGChannelGetDataSourceName(SGChannel c, Str255 name, ScriptCode *scriptTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelGetDataSourceName
			move.l              #$00080098,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelGetDataSourceName
	ENDIF

;
; pascal ComponentResult SGChannelSetCodecSettings(SGChannel c, Handle settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelSetCodecSettings
			move.l              #$00040099,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelSetCodecSettings
	ENDIF

;
; pascal ComponentResult SGChannelGetCodecSettings(SGChannel c, Handle *settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelGetCodecSettings
			move.l              #$0004009A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelGetCodecSettings
	ENDIF

;
; pascal ComponentResult SGGetChannelTimeBase(SGChannel c, TimeBase *tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelTimeBase
			move.l              #$0004009B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelTimeBase
	ENDIF

; 
;    calls from seqGrab to Channel
;

;
; pascal ComponentResult SGInitChannel(SGChannel c, SeqGrabComponent owner)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGInitChannel
			move.l              #$00040180,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGInitChannel
	ENDIF

;
; pascal ComponentResult SGWriteSamples(SGChannel c, Movie m, AliasHandle theFile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGWriteSamples
			move.l              #$00080181,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGWriteSamples
	ENDIF

;
; pascal ComponentResult SGGetDataRate(SGChannel c, long *bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetDataRate
			move.l              #$00040182,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetDataRate
	ENDIF

;
; pascal ComponentResult SGAlignChannelRect(SGChannel c, Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAlignChannelRect
			move.l              #$00040183,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAlignChannelRect
	ENDIF

; 
;    Dorky dialog panel calls
;

;
; pascal ComponentResult SGPanelGetDitl(SeqGrabComponent s, Handle *ditl)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelGetDitl
			move.l              #$00040200,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelGetDitl
	ENDIF

;
; pascal ComponentResult SGPanelGetTitle(SeqGrabComponent s, Str255 title)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelGetTitle
			move.l              #$00040201,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelGetTitle
	ENDIF

;
; pascal ComponentResult SGPanelCanRun(SeqGrabComponent s, SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelCanRun
			move.l              #$00040202,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelCanRun
	ENDIF

;
; pascal ComponentResult SGPanelInstall(SeqGrabComponent s, SGChannel c, DialogRef d, short itemOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelInstall
			move.l              #$000A0203,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelInstall
	ENDIF

;
; pascal ComponentResult SGPanelEvent(SeqGrabComponent s, SGChannel c, DialogRef d, short itemOffset, const EventRecord *theEvent, short *itemHit, Boolean *handled)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelEvent
			move.l              #$00160204,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelEvent
	ENDIF

;
; pascal ComponentResult SGPanelItem(SeqGrabComponent s, SGChannel c, DialogRef d, short itemOffset, short itemNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelItem
			move.l              #$000C0205,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelItem
	ENDIF

;
; pascal ComponentResult SGPanelRemove(SeqGrabComponent s, SGChannel c, DialogRef d, short itemOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelRemove
			move.l              #$000A0206,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelRemove
	ENDIF

;
; pascal ComponentResult SGPanelSetGrabber(SeqGrabComponent s, SeqGrabComponent sg)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelSetGrabber
			move.l              #$00040207,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelSetGrabber
	ENDIF

;
; pascal ComponentResult SGPanelSetResFile(SeqGrabComponent s, short resRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelSetResFile
			move.l              #$00020208,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelSetResFile
	ENDIF

;
; pascal ComponentResult SGPanelGetSettings(SeqGrabComponent s, SGChannel c, UserData *ud, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelGetSettings
			move.l              #$000C0209,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelGetSettings
	ENDIF

;
; pascal ComponentResult SGPanelSetSettings(SeqGrabComponent s, SGChannel c, UserData ud, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelSetSettings
			move.l              #$000C020A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelSetSettings
	ENDIF

;
; pascal ComponentResult SGPanelValidateInput(SeqGrabComponent s, Boolean *ok)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelValidateInput
			move.l              #$0004020B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelValidateInput
	ENDIF

;
; pascal ComponentResult SGPanelSetEventFilter(SeqGrabComponent s, SGModalFilterUPP proc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelSetEventFilter
			move.l              #$0008020C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelSetEventFilter
	ENDIF


; ** Sequence Grab VIDEO CHANNEL Component Stuff **
; 
;    Video stuff
;

SGCompressInfo			RECORD 0
buffer					 ds.l	1				; offset: $0 (0)
bufferSize				 ds.l	1				; offset: $4 (4)
similarity				 ds.b	1				; offset: $8 (8)
reserved				 ds.b	1				; offset: $9 (9)
sizeof					 EQU *					; size:   $A (10)
						ENDR
VideoBottles			RECORD 0
procCount				 ds.w	1				; offset: $0 (0)
grabProc				 ds.l	1				; offset: $2 (2)
grabCompleteProc		 ds.l	1				; offset: $6 (6)
displayProc				 ds.l	1				; offset: $A (10)
compressProc			 ds.l	1				; offset: $E (14)
compressCompleteProc	 ds.l	1				; offset: $12 (18)
addFrameProc			 ds.l	1				; offset: $16 (22)
transferFrameProc		 ds.l	1				; offset: $1A (26)
grabCompressCompleteProc  ds.l	1				; offset: $1E (30)
displayCompressProc		 ds.l	1				; offset: $22 (34)
sizeof					 EQU *					; size:   $26 (38)
						ENDR
;
; pascal ComponentResult SGGetSrcVideoBounds(SGChannel c, Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetSrcVideoBounds
			move.l              #$00040100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetSrcVideoBounds
	ENDIF

;
; pascal ComponentResult SGSetVideoRect(SGChannel c, const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetVideoRect
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetVideoRect
	ENDIF

;
; pascal ComponentResult SGGetVideoRect(SGChannel c, Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetVideoRect
			move.l              #$00040102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetVideoRect
	ENDIF

;
; pascal ComponentResult SGGetVideoCompressorType(SGChannel c, OSType *compressorType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetVideoCompressorType
			move.l              #$00040103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetVideoCompressorType
	ENDIF

;
; pascal ComponentResult SGSetVideoCompressorType(SGChannel c, OSType compressorType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetVideoCompressorType
			move.l              #$00040104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetVideoCompressorType
	ENDIF

;
; pascal ComponentResult SGSetVideoCompressor(SGChannel c, short depth, CompressorComponent compressor, CodecQ spatialQuality, CodecQ temporalQuality, long keyFrameRate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetVideoCompressor
			move.l              #$00120105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetVideoCompressor
	ENDIF

;
; pascal ComponentResult SGGetVideoCompressor(SGChannel c, short *depth, CompressorComponent *compressor, CodecQ *spatialQuality, CodecQ *temporalQuality, long *keyFrameRate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetVideoCompressor
			move.l              #$00140106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetVideoCompressor
	ENDIF

;
; pascal ComponentInstance SGGetVideoDigitizerComponent(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetVideoDigitizerComponent
			move.l              #$00000107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetVideoDigitizerComponent
	ENDIF

;
; pascal ComponentResult SGSetVideoDigitizerComponent(SGChannel c, ComponentInstance vdig)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetVideoDigitizerComponent
			move.l              #$00040108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetVideoDigitizerComponent
	ENDIF

;
; pascal ComponentResult SGVideoDigitizerChanged(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGVideoDigitizerChanged
			move.l              #$00000109,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGVideoDigitizerChanged
	ENDIF

;
; pascal ComponentResult SGSetVideoBottlenecks(SGChannel c, VideoBottles *vb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetVideoBottlenecks
			move.l              #$0004010A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetVideoBottlenecks
	ENDIF

;
; pascal ComponentResult SGGetVideoBottlenecks(SGChannel c, VideoBottles *vb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetVideoBottlenecks
			move.l              #$0004010B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetVideoBottlenecks
	ENDIF

;
; pascal ComponentResult SGGrabFrame(SGChannel c, short bufferNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGrabFrame
			move.l              #$0002010C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGrabFrame
	ENDIF

;
; pascal ComponentResult SGGrabFrameComplete(SGChannel c, short bufferNum, Boolean *done)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGrabFrameComplete
			move.l              #$0006010D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGrabFrameComplete
	ENDIF

;
; pascal ComponentResult SGDisplayFrame(SGChannel c, short bufferNum, const MatrixRecord *mp, RgnHandle clipRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGDisplayFrame
			move.l              #$000A010E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGDisplayFrame
	ENDIF

;
; pascal ComponentResult SGCompressFrame(SGChannel c, short bufferNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGCompressFrame
			move.l              #$0002010F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGCompressFrame
	ENDIF

;
; pascal ComponentResult SGCompressFrameComplete(SGChannel c, short bufferNum, Boolean *done, SGCompressInfo *ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGCompressFrameComplete
			move.l              #$000A0110,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGCompressFrameComplete
	ENDIF

;
; pascal ComponentResult SGAddFrame(SGChannel c, short bufferNum, TimeValue atTime, TimeScale scale, const SGCompressInfo *ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAddFrame
			move.l              #$000E0111,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAddFrame
	ENDIF

;
; pascal ComponentResult SGTransferFrameForCompress(SGChannel c, short bufferNum, const MatrixRecord *mp, RgnHandle clipRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGTransferFrameForCompress
			move.l              #$000A0112,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGTransferFrameForCompress
	ENDIF

;
; pascal ComponentResult SGSetCompressBuffer(SGChannel c, short depth, const Rect *compressSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetCompressBuffer
			move.l              #$00060113,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetCompressBuffer
	ENDIF

;
; pascal ComponentResult SGGetCompressBuffer(SGChannel c, short *depth, Rect *compressSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetCompressBuffer
			move.l              #$00080114,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetCompressBuffer
	ENDIF

;
; pascal ComponentResult SGGetBufferInfo(SGChannel c, short bufferNum, PixMapHandle *bufferPM, Rect *bufferRect, GWorldPtr *compressBuffer, Rect *compressBufferRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetBufferInfo
			move.l              #$00120115,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetBufferInfo
	ENDIF

;
; pascal ComponentResult SGSetUseScreenBuffer(SGChannel c, Boolean useScreenBuffer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetUseScreenBuffer
			move.l              #$00020116,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetUseScreenBuffer
	ENDIF

;
; pascal ComponentResult SGGetUseScreenBuffer(SGChannel c, Boolean *useScreenBuffer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetUseScreenBuffer
			move.l              #$00040117,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetUseScreenBuffer
	ENDIF

;
; pascal ComponentResult SGGrabCompressComplete(SGChannel c, Boolean *done, SGCompressInfo *ci, TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGrabCompressComplete
			move.l              #$000C0118,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGrabCompressComplete
	ENDIF

;
; pascal ComponentResult SGDisplayCompress(SGChannel c, Ptr dataPtr, ImageDescriptionHandle desc, MatrixRecord *mp, RgnHandle clipRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGDisplayCompress
			move.l              #$00100119,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGDisplayCompress
	ENDIF

;
; pascal ComponentResult SGSetFrameRate(SGChannel c, Fixed frameRate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetFrameRate
			move.l              #$0004011A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetFrameRate
	ENDIF

;
; pascal ComponentResult SGGetFrameRate(SGChannel c, Fixed *frameRate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetFrameRate
			move.l              #$0004011B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetFrameRate
	ENDIF


;
; pascal ComponentResult SGSetPreferredPacketSize(SGChannel c, long preferredPacketSizeInBytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetPreferredPacketSize
			move.l              #$00040121,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetPreferredPacketSize
	ENDIF

;
; pascal ComponentResult SGGetPreferredPacketSize(SGChannel c, long *preferredPacketSizeInBytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetPreferredPacketSize
			move.l              #$00040122,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetPreferredPacketSize
	ENDIF

;
; pascal ComponentResult SGSetUserVideoCompressorList(SGChannel c, Handle compressorTypes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetUserVideoCompressorList
			move.l              #$00040123,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetUserVideoCompressorList
	ENDIF

;
; pascal ComponentResult SGGetUserVideoCompressorList(SGChannel c, Handle *compressorTypes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetUserVideoCompressorList
			move.l              #$00040124,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetUserVideoCompressorList
	ENDIF

; ** Sequence Grab SOUND CHANNEL Component Stuff **

; 
;    Sound stuff
;

;
; pascal ComponentResult SGSetSoundInputDriver(SGChannel c, ConstStr255Param driverName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetSoundInputDriver
			move.l              #$00040100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetSoundInputDriver
	ENDIF

;
; pascal long SGGetSoundInputDriver(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetSoundInputDriver
			move.l              #$00000101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetSoundInputDriver
	ENDIF

;
; pascal ComponentResult SGSoundInputDriverChanged(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSoundInputDriverChanged
			move.l              #$00000102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSoundInputDriverChanged
	ENDIF

;
; pascal ComponentResult SGSetSoundRecordChunkSize(SGChannel c, long seconds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetSoundRecordChunkSize
			move.l              #$00040103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetSoundRecordChunkSize
	ENDIF

;
; pascal long SGGetSoundRecordChunkSize(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetSoundRecordChunkSize
			move.l              #$00000104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetSoundRecordChunkSize
	ENDIF

;
; pascal ComponentResult SGSetSoundInputRate(SGChannel c, Fixed rate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetSoundInputRate
			move.l              #$00040105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetSoundInputRate
	ENDIF

;
; pascal Fixed SGGetSoundInputRate(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetSoundInputRate
			move.l              #$00000106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetSoundInputRate
	ENDIF

;
; pascal ComponentResult SGSetSoundInputParameters(SGChannel c, short sampleSize, short numChannels, OSType compressionType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetSoundInputParameters
			move.l              #$00080107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetSoundInputParameters
	ENDIF

;
; pascal ComponentResult SGGetSoundInputParameters(SGChannel c, short *sampleSize, short *numChannels, OSType *compressionType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetSoundInputParameters
			move.l              #$000C0108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetSoundInputParameters
	ENDIF

;
; pascal ComponentResult SGSetAdditionalSoundRates(SGChannel c, Handle rates)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetAdditionalSoundRates
			move.l              #$00040109,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetAdditionalSoundRates
	ENDIF

;
; pascal ComponentResult SGGetAdditionalSoundRates(SGChannel c, Handle *rates)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetAdditionalSoundRates
			move.l              #$0004010A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetAdditionalSoundRates
	ENDIF

; 
;    Text stuff
;

;
; pascal ComponentResult SGSetFontName(SGChannel c, StringPtr pstr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetFontName
			move.l              #$00040100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetFontName
	ENDIF

;
; pascal ComponentResult SGSetFontSize(SGChannel c, short fontSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetFontSize
			move.l              #$00020101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetFontSize
	ENDIF

;
; pascal ComponentResult SGSetTextForeColor(SGChannel c, RGBColor *theColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetTextForeColor
			move.l              #$00040102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetTextForeColor
	ENDIF

;
; pascal ComponentResult SGSetTextBackColor(SGChannel c, RGBColor *theColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetTextBackColor
			move.l              #$00040103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetTextBackColor
	ENDIF

;
; pascal ComponentResult SGSetJustification(SGChannel c, short just)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetJustification
			move.l              #$00020104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetJustification
	ENDIF

;
; pascal ComponentResult SGGetTextReturnToSpaceValue(SGChannel c, short *rettospace)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetTextReturnToSpaceValue
			move.l              #$00040105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetTextReturnToSpaceValue
	ENDIF

;
; pascal ComponentResult SGSetTextReturnToSpaceValue(SGChannel c, short rettospace)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetTextReturnToSpaceValue
			move.l              #$00020106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetTextReturnToSpaceValue
	ENDIF

; 
;    Music stuff
;

;
; pascal ComponentResult SGGetInstrument(SGChannel c, ToneDescription *td)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetInstrument
			move.l              #$00040100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetInstrument
	ENDIF

;
; pascal ComponentResult SGSetInstrument(SGChannel c, ToneDescription *td)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetInstrument
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetInstrument
	ENDIF



sgChannelAtom					EQU		'chan'
sgChannelSettingsAtom			EQU		'ctom'
sgChannelDescription			EQU		'cdsc'
sgChannelSettings				EQU		'cset'

sgDeviceNameType				EQU		'name'
sgUsageType						EQU		'use '
sgPlayFlagsType					EQU		'plyf'
sgClipType						EQU		'clip'
sgMatrixType					EQU		'mtrx'
sgVolumeType					EQU		'volu'

sgPanelSettingsAtom				EQU		'ptom'
sgPanelDescription				EQU		'pdsc'
sgPanelSettings					EQU		'pset'

sgcSoundCompressionType			EQU		'scmp'
sgcSoundSampleRateType			EQU		'srat'
sgcSoundChannelCountType		EQU		'schn'
sgcSoundSampleSizeType			EQU		'ssiz'
sgcSoundInputType				EQU		'sinp'
sgcSoundGainType				EQU		'gain'

sgcVideoHueType					EQU		'hue '
sgcVideoSaturationType			EQU		'satr'
sgcVideoContrastType			EQU		'trst'
sgcVideoSharpnessType			EQU		'shrp'
sgcVideoBrigtnessType			EQU		'brit'
sgcVideoBlackLevelType			EQU		'blkl'
sgcVideoWhiteLevelType			EQU		'whtl'
sgcVideoInputType				EQU		'vinp'
sgcVideoFormatType				EQU		'vstd'
sgcVideoFilterType				EQU		'vflt'
sgcVideoRectType				EQU		'vrct'
sgcVideoDigitizerType			EQU		'vdig'



; typedef ComponentInstance 			QTVideoOutputComponent

;  Component type and subtype enumerations

QTVideoOutputComponentType		EQU		'vout'
QTVideoOutputComponentBaseSubType EQU	'base'

;  QTVideoOutput Component flags


kQTVideoOutputDontDisplayToUser	EQU		$00000001
;  Display mode atom types


kQTVODisplayModeItem			EQU		'qdmi'
kQTVODimensions					EQU		'dimn'				; atom contains two longs - pixel count - width, height
kQTVOResolution					EQU		'resl'				; atom contains two Fixed - hRes, vRes in dpi
kQTVORefreshRate				EQU		'refr'				; atom contains one Fixed - refresh rate in Hz
kQTVOPixelType					EQU		'pixl'				; atom contains one OSType - pixel format of mode
kQTVOName						EQU		'name'				; atom contains string (no length byte) - name of mode for display to user
kQTVODecompressors				EQU		'deco'				; atom contains other atoms indicating supported decompressors
															; kQTVODecompressors sub-atoms
kQTVODecompressorType			EQU		'dety'				; atom contains one OSType - decompressor type code
kQTVODecompressorContinuous		EQU		'cont'				; atom contains one Boolean - true if this type is displayed continuously
kQTVODecompressorComponent		EQU		'cmpt'				; atom contains one Component - component id of decompressor
; * These are QTVideoOutput procedures *
;
; pascal ComponentResult QTVideoOutputGetDisplayModeList(QTVideoOutputComponent vo, QTAtomContainer *outputs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetDisplayModeList
			move.l              #$00040001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetDisplayModeList
	ENDIF

;
; pascal ComponentResult QTVideoOutputGetCurrentClientName(QTVideoOutputComponent vo, Str255 str)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetCurrentClientName
			move.l              #$00040002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetCurrentClientName
	ENDIF

;
; pascal ComponentResult QTVideoOutputSetClientName(QTVideoOutputComponent vo, ConstStr255Param str)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputSetClientName
			move.l              #$00040003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputSetClientName
	ENDIF

;
; pascal ComponentResult QTVideoOutputGetClientName(QTVideoOutputComponent vo, Str255 str)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetClientName
			move.l              #$00040004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetClientName
	ENDIF

;
; pascal ComponentResult QTVideoOutputBegin(QTVideoOutputComponent vo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputBegin
			move.l              #$00000005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputBegin
	ENDIF

;
; pascal ComponentResult QTVideoOutputEnd(QTVideoOutputComponent vo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputEnd
			move.l              #$00000006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputEnd
	ENDIF

;
; pascal ComponentResult QTVideoOutputSetDisplayMode(QTVideoOutputComponent vo, long displayModeID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputSetDisplayMode
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputSetDisplayMode
	ENDIF

;
; pascal ComponentResult QTVideoOutputGetDisplayMode(QTVideoOutputComponent vo, long *displayModeID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetDisplayMode
			move.l              #$00040008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetDisplayMode
	ENDIF

;
; pascal ComponentResult QTVideoOutputCustomConfigureDisplay(QTVideoOutputComponent vo, ModalFilterUPP filter)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputCustomConfigureDisplay
			move.l              #$00040009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputCustomConfigureDisplay
	ENDIF

;
; pascal ComponentResult QTVideoOutputSaveState(QTVideoOutputComponent vo, QTAtomContainer *state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputSaveState
			move.l              #$0004000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputSaveState
	ENDIF

;
; pascal ComponentResult QTVideoOutputRestoreState(QTVideoOutputComponent vo, QTAtomContainer state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputRestoreState
			move.l              #$0004000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputRestoreState
	ENDIF

;
; pascal ComponentResult QTVideoOutputGetGWorld(QTVideoOutputComponent vo, GWorldPtr *gw)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetGWorld
			move.l              #$0004000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetGWorld
	ENDIF

;
; pascal ComponentResult QTVideoOutputGetGWorldParameters(QTVideoOutputComponent vo, Ptr *baseAddr, long *rowBytes, CTabHandle *colorTable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetGWorldParameters
			move.l              #$000C000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetGWorldParameters
	ENDIF

;
; pascal ComponentResult QTVideoOutputGetIndSoundOutput(QTVideoOutputComponent vo, long index, Component *outputComponent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetIndSoundOutput
			move.l              #$0008000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetIndSoundOutput
	ENDIF

;
; pascal ComponentResult QTVideoOutputGetClock(QTVideoOutputComponent vo, ComponentInstance *clock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetClock
			move.l              #$0004000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetClock
	ENDIF

;
; pascal ComponentResult QTVideoOutputSetEchoPort(QTVideoOutputComponent vo, CGrafPtr echoPort)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputSetEchoPort
			move.l              #$00040010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputSetEchoPort
	ENDIF

;  UPP call backs 

	ENDIF ; __QUICKTIMECOMPONENTS__ 


;
;	File:		Lists.a
;
;	Contains:	List Manager Interfaces.
;
;	Version:	Technology:	Mac OS 8
;				Release:	Universal Interfaces 3.3a1
;
;	Copyright:	© 1985-1999 by Apple Computer, Inc., all rights reserved
;
;	Bugs?:		For bug reports, consult the following page on
;				the World Wide Web:
;
;					http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__LISTS__') = 'UNDEFINED' THEN
__LISTS__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__CONTROLS__') = 'UNDEFINED' THEN
	include 'Controls.a'
	ENDIF

Cell					RECORD 0
v						 ds.w	1				; offset: $0 (0)
h						 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
ListBounds				RECORD 0
top						 ds.w	1				; offset: $0 (0)
left					 ds.w	1				; offset: $2 (2)
bottom					 ds.w	1				; offset: $4 (4)
right					 ds.w	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
DataArray				RECORD 0
elements				 ds.b	32001
						 ORG 32002
sizeof					 EQU *					; size:   $7D02 (32002)
						ENDR


; typedef DataArray *					DataPtr

; typedef DataPtr *						DataHandle

	IF ¬ TARGET_OS_MAC THEN
;  QuickTime 3.0 
; typedef long 							ListNotification


listNotifyNothing				EQU		'nada'				; No (null) notification
listNotifyClick					EQU		'clik'				; Control was clicked
listNotifyDoubleClick			EQU		'dblc'				; Control was double-clicked
listNotifyPreClick				EQU		'pclk'				; Control about to be clicked
	ENDIF
ListRec					RECORD 0
rView					 ds		Rect			; offset: $0 (0)
port					 ds.l	1				; offset: $8 (8)
indent					 ds		Point			; offset: $C (12)
cellSize				 ds		Point			; offset: $10 (16)
visible					 ds		ListBounds		; offset: $14 (20)
vScroll					 ds.l	1				; offset: $1C (28)
hScroll					 ds.l	1				; offset: $20 (32)
selFlags				 ds.b	1				; offset: $24 (36)
lActive					 ds.b	1				; offset: $25 (37)
lReserved				 ds.b	1				; offset: $26 (38)
listFlags				 ds.b	1				; offset: $27 (39)
clikTime				 ds.l	1				; offset: $28 (40)
clikLoc					 ds		Point			; offset: $2C (44)
mouseLoc				 ds		Point			; offset: $30 (48)
lClickLoop				 ds.l	1				; offset: $34 (52)
lastClick				 ds		Cell			; offset: $38 (56)
refCon					 ds.l	1				; offset: $3C (60)
listDefProc				 ds.l	1				; offset: $40 (64)
userHandle				 ds.l	1				; offset: $44 (68)
dataBounds				 ds		ListBounds		; offset: $48 (72)
cells					 ds.l	1				; offset: $50 (80)
maxIndex				 ds.w	1				; offset: $54 (84)
cellArray				 ds.w	1				; offset: $56 (86) <-- really an array of length one
sizeof					 EQU *					; size:   $58 (88)
						ENDR
; typedef struct ListRec *				ListPtr

; typedef ListPtr *						ListHandle

;  ListRef is obsolete.  Use ListHandle. 
; typedef ListHandle 					ListRef




															; ListRec.listFlags bits
lDoVAutoscrollBit				EQU		1
lDoHAutoscrollBit				EQU		0

															; ListRec.listFlags masks
lDoVAutoscroll					EQU		2
lDoHAutoscroll					EQU		1


															; ListRec.selFlags bits
lOnlyOneBit						EQU		7
lExtendDragBit					EQU		6
lNoDisjointBit					EQU		5
lNoExtendBit					EQU		4
lNoRectBit						EQU		3
lUseSenseBit					EQU		2
lNoNilHiliteBit					EQU		1


															; ListRec.selFlags masks
lOnlyOne						EQU		-128
lExtendDrag						EQU		64
lNoDisjoint						EQU		32
lNoExtend						EQU		16
lNoRect							EQU		8
lUseSense						EQU		4
lNoNilHilite					EQU		2


															; LDEF messages
lInitMsg						EQU		0
lDrawMsg						EQU		1
lHiliteMsg						EQU		2
lCloseMsg						EQU		3




kListDefUserProcType			EQU		0
kListDefStandardTextType		EQU		1
kListDefStandardIconType		EQU		2
; typedef UInt32 						ListDefType

ListDefSpec				RECORD 0
defType					 ds.l	1				; offset: $0 (0)
userProc				 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;
; pascal OSStatus CreateCustomList(const Rect *rView, const ListBounds *dataBounds, Point cellSize, const ListDefSpec *theSpec, WindowPtr theWindow, Boolean drawIt, Boolean hasGrow, Boolean scrollHoriz, Boolean scrollVert, ListHandle *outList)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CreateCustomList
	ENDIF


	IF ¬ TARGET_OS_MAC THEN
;  QuickTime 3.0 
	IF CALL_NOT_IN_CARBON THEN
;
; extern void LSetNotificationCallback(ListNotificationProcPtr callBack, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LSetNotificationCallback
	ENDIF

;
; extern void GetListVisibleBounds(ListHandle theList, Rect *visibleBounds)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListVisibleBounds
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF
;
; pascal ListHandle LNew(const Rect *rView, const ListBounds *dataBounds, Point cSize, short theProc, WindowPtr theWindow, Boolean drawIt, Boolean hasGrow, Boolean scrollHoriz, Boolean scrollVert)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LNew
			move.w              #$0044,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LNew
	ENDIF

;
; pascal void LDispose(ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LDispose
			move.w              #$0028,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LDispose
	ENDIF

;
; pascal short LAddColumn(short count, short colNum, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LAddColumn
			move.w              #$0004,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LAddColumn
	ENDIF

;
; pascal short LAddRow(short count, short rowNum, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LAddRow
			move.w              #$0008,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LAddRow
	ENDIF

;
; pascal void LDelColumn(short count, short colNum, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LDelColumn
			move.w              #$0020,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LDelColumn
	ENDIF

;
; pascal void LDelRow(short count, short rowNum, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LDelRow
			move.w              #$0024,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LDelRow
	ENDIF

;
; pascal Boolean LGetSelect(Boolean next, Cell *theCell, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LGetSelect
			move.w              #$003C,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LGetSelect
	ENDIF

;
; pascal Cell LLastClick(ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LLastClick
			move.w              #$0040,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LLastClick
	ENDIF

;
; pascal Boolean LNextCell(Boolean hNext, Boolean vNext, Cell *theCell, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LNextCell
			move.w              #$0048,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LNextCell
	ENDIF

;
; pascal Boolean LSearch(const void *dataPtr, short dataLen, ListSearchUPP searchProc, Cell *theCell, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LSearch
			move.w              #$0054,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LSearch
	ENDIF

;
; pascal void LSize(short listWidth, short listHeight, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LSize
			move.w              #$0060,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LSize
	ENDIF

;
; pascal void LSetDrawingMode(Boolean drawIt, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LSetDrawingMode
			move.w              #$002C,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LSetDrawingMode
	ENDIF

;
; pascal void LScroll(short dCols, short dRows, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LScroll
			move.w              #$0050,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LScroll
	ENDIF

;
; pascal void LAutoScroll(ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LAutoScroll
			move.w              #$0010,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LAutoScroll
	ENDIF

;
; pascal void LUpdate(RgnHandle theRgn, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LUpdate
			move.w              #$0064,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LUpdate
	ENDIF

;
; pascal void LActivate(Boolean act, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LActivate
			clr.w               -(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LActivate
	ENDIF

;
; pascal void LCellSize(Point cSize, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LCellSize
			move.w              #$0014,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LCellSize
	ENDIF

;
; pascal Boolean LClick(Point pt, short modifiers, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LClick
			move.w              #$0018,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LClick
	ENDIF

;
; pascal void LAddToCell(const void *dataPtr, short dataLen, Cell theCell, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LAddToCell
			move.w              #$000C,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LAddToCell
	ENDIF

;
; pascal void LClrCell(Cell theCell, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LClrCell
			move.w              #$001C,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LClrCell
	ENDIF

;
; pascal void LGetCell(void *dataPtr, short *dataLen, Cell theCell, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LGetCell
			move.w              #$0038,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LGetCell
	ENDIF

;
; pascal void LRect(Rect *cellRect, Cell theCell, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LRect
			move.w              #$004C,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LRect
	ENDIF

;
; pascal void LSetCell(const void *dataPtr, short dataLen, Cell theCell, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LSetCell
			move.w              #$0058,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LSetCell
	ENDIF

;
; pascal void LSetSelect(Boolean setIt, Cell theCell, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LSetSelect
			move.w              #$005C,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LSetSelect
	ENDIF

;
; pascal void LDraw(Cell theCell, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LDraw
			move.w              #$0030,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LDraw
	ENDIF

;
; pascal void LGetCellDataLocation(short *offset, short *len, Cell theCell, ListHandle lHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LGetCellDataLocation
			move.w              #$0034,-(sp)
			dc.w            	$A9E7
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LGetCellDataLocation
	ENDIF

	IF CALL_NOT_IN_CARBON THEN
;
; pascal OSErr SetListDefinitionProc(SInt16 resID, ListDefUPP defProc)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListDefinitionProc
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	IF ¬ TARGET_OS_MAC THEN
;  QuickTime 3.0 
	IF CALL_NOT_IN_CARBON THEN
;
; extern void LSetLDEF(ListDefProcPtr proc, ListRef lHandle)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LSetLDEF
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF
	IF OLDROUTINENAMES THEN
	ENDIF	; OLDROUTINENAMES
	IF ACCESSOR_CALLS_ARE_FUNCTIONS THEN
;  Getters 
;
; pascal Rect *GetListViewBounds(ListRef list, Rect *view)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListViewBounds
	ENDIF

;
; pascal CGrafPtr GetListPort(ListRef list)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListPort
	ENDIF

;
; pascal Point *GetListCellIndent(ListRef list, Point *indent)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListCellIndent
	ENDIF

;
; pascal Point *GetListCellSize(ListRef list, Point *size)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListCellSize
	ENDIF

;
; pascal ListBounds *GetListVisibleCells(ListRef list, ListBounds *visible)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListVisibleCells
	ENDIF

;
; pascal ControlHandle GetListVerticalScrollBar(ListRef list)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListVerticalScrollBar
	ENDIF

;
; pascal ControlHandle GetListHorizontalScrollBar(ListRef list)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListHorizontalScrollBar
	ENDIF

;
; pascal Boolean GetListActive(ListRef list)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListActive
	ENDIF

;
; pascal SInt32 GetListClickTime(ListRef list)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListClickTime
	ENDIF

;
; pascal Point *GetListClickLocation(ListRef list, Point *click)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListClickLocation
	ENDIF

;
; pascal Point *GetListMouseLocation(ListRef list, Point *mouse)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListMouseLocation
	ENDIF

;
; pascal ListClickLoopUPP GetListClickLoop(ListRef list)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListClickLoop
	ENDIF

;
; pascal SInt32 GetListRefCon(ListRef list)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListRefCon
	ENDIF

;
; pascal Handle GetListDefinition(ListRef list)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListDefinition
	ENDIF

;
; pascal Handle GetListUserHandle(ListRef list)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListUserHandle
	ENDIF

;
; pascal ListBounds *GetListDataBounds(ListRef list, ListBounds *bounds)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListDataBounds
	ENDIF

;
; pascal DataHandle GetListDataHandle(ListRef list)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListDataHandle
	ENDIF

;
; pascal OptionBits GetListFlags(ListRef list)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListFlags
	ENDIF

;
; pascal OptionBits GetListSelectionFlags(ListRef list)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetListSelectionFlags
	ENDIF

;  Setters 
;
; pascal void SetListViewBounds(ListRef list, const Rect *view)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListViewBounds
	ENDIF

;
; pascal void SetListPort(ListRef list, CGrafPtr port)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListPort
	ENDIF

;
; pascal void SetListCellIndent(ListRef list, Point *indent)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListCellIndent
	ENDIF

;
; pascal void SetListClickTime(ListRef list, SInt32 time)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListClickTime
	ENDIF

;
; pascal void SetListClickLoop(ListRef list, ListClickLoopUPP clickLoop)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListClickLoop
	ENDIF

;
; pascal void SetListLastClick(ListRef list, Cell *lastClick)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListLastClick
	ENDIF

;
; pascal void SetListRefCon(ListRef list, SInt32 refCon)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListRefCon
	ENDIF

;
; pascal void SetListUserHandle(ListRef list, Handle userHandle)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListUserHandle
	ENDIF

;
; pascal void SetListFlags(ListRef list, OptionBits listFlags)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListFlags
	ENDIF

;
; pascal void SetListSelectionFlags(ListRef list, OptionBits selectionFlags)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListSelectionFlags
	ENDIF

;  WARNING: These may go away in a future build.  Beware! 
	IF CALL_NOT_IN_CARBON THEN
;
; pascal void SetListDefinition(ListRef list, Handle listDefProc)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListDefinition
	ENDIF

;
; pascal void SetListCellSize(ListRef list, Point *size)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListCellSize
	ENDIF

;
; pascal void SetListHorizontalScrollBar(ListRef list, ControlHandle hScroll)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListHorizontalScrollBar
	ENDIF

;
; pascal void SetListVerticalScrollBar(ListRef list, ControlHandle vScroll)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListVerticalScrollBar
	ENDIF

;
; pascal void SetListVisibleCells(ListRef list, ListBounds *visible)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetListVisibleCells
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF	; ACCESSOR_CALLS_ARE_FUNCTIONS
	ENDIF ; __LISTS__ 


;
;	File:		Scrap.a
;
;	Contains:	Scrap Manager Interfaces.
;
;	Version:	Technology:	Carbon 1.0
;				Release:	Universal Interfaces 3.3a1
;
;	Copyright:	© 1985-1999 by Apple Computer, Inc., all rights reserved
;
;	Bugs?:		For bug reports, consult the following page on
;				the World Wide Web:
;
;					http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__SCRAP__') = 'UNDEFINED' THEN
__SCRAP__ SET 1

	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF
	IF &TYPE('__ERRORS__') = 'UNDEFINED' THEN
	include 'Errors.a'
	ENDIF


;  	________________________________________________________________
;  	UNIVERSAL SCRAP MANAGER INTERFACES
;  	________________________________________________________________
;  	The following interfaces are available when compiling for BOTH
;  	Carbon AND Mac OS 8.
;  	________________________________________________________________



;  	While were in here mucking about, we defined a new type to
;  	to put some confusion to rest. The old calls, as well as the
;  	new calls, use the new type. Existing clients should be
;  	blissfully ignorant.



; typedef FourCharCode 					ScrapFlavorType


;  	Newsflash! After 15 years of arduous toil, it's finally possible
;  	for specially trained typists wielding advanced text editing
;  	technology to define symbolic names for commonly used scrap
;  	flavor type constants! Apple triumphs again!



kScrapFlavorTypePicture			EQU		'PICT'				; contents of a PicHandle
kScrapFlavorTypeText			EQU		'TEXT'				; stream of characters
kScrapFlavorTypeTextStyle		EQU		'styl'				; see TEGetStyleScrapHandle
kScrapFlavorTypeMovie			EQU		'moov'				; reference to a movie
kScrapFlavorTypeSound			EQU		'snd '				; see SndRecord and SndPlay
kScrapFlavorTypeUnicode			EQU		'utxt'				; stream of UTF16 characters
kScrapFlavorTypeUnicodeStyle	EQU		'ustl'				; ATSUI defines; Textension uses

;  	If you are a Carbon client and you need to run on Mac OS 8,
;  	you may still need to load and unload the scrap. Under Mac OS
;  	X, the scrap is held by the pasteboard server instead of in a
;  	handle in your app's heap, so LoadScrap and UnloadScrap do
;  	nothing when called under Mac OS X.



;
; pascal OSStatus LoadScrap(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_LoadScrap:	OPWORD	$A9FB
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LoadScrap
	ENDIF

;
; pascal OSStatus UnloadScrap(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_UnloadScrap:	OPWORD	$A9FA
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UnloadScrap
	ENDIF


;  	________________________________________________________________
;  	MAC OS 8 SCRAP MANAGER INTERFACES
;  	________________________________________________________________
;  	The following interfaces are available only when compiling for
;  	plain vanilla Mac OS 8. We didn't add comments to them because
;  	Inside Mac covers them in detail.
;  	________________________________________________________________


ScrapStuff				RECORD 0
scrapSize				 ds.l	1				; offset: $0 (0)
scrapHandle				 ds.l	1				; offset: $4 (4)
scrapCount				 ds.w	1				; offset: $8 (8)
scrapState				 ds.w	1				; offset: $A (10)
scrapName				 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct ScrapStuff *			PScrapStuff

; typedef struct ScrapStuff *			ScrapStuffPtr

	IF CALL_NOT_IN_CARBON THEN
;
; pascal ScrapStuffPtr InfoScrap(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InfoScrap:	OPWORD	$A9F9
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InfoScrap
	ENDIF

;
; pascal long GetScrap(Handle destination, ScrapFlavorType flavorType, SInt32 *offset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetScrap:	OPWORD	$A9FD
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetScrap
	ENDIF

;
; pascal OSStatus ZeroScrap(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ZeroScrap:	OPWORD	$A9FC
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ZeroScrap
	ENDIF

;
; pascal OSStatus PutScrap(SInt32 sourceBufferByteCount, ScrapFlavorType flavorType, const void *sourceBuffer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PutScrap:	OPWORD	$A9FE
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutScrap
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

;  	________________________________________________________________
;  	CARBON SCRAP MANAGER INTERFACES
;  	________________________________________________________________
;  	The following interfaces are available only when compiling for
;  	Carbon.
;  	________________________________________________________________



firstScrapErr					EQU		-4999
illegalScrapFlavorSizeErr		EQU		-4999
illegalScrapFlavorTypeErr		EQU		-4998
illegalScrapFlavorFlagsErr		EQU		-4997
scrapFlavorSizeMismatchErr		EQU		-4996
scrapFlavorFlagsMismatchErr		EQU		-4995
nilScrapFlavorDataErr			EQU		-4994
noScrapPromiseKeeperErr			EQU		-4993
scrapPromiseNotKeptErr			EQU		-4992
processStateIncorrectErr		EQU		-4991
badScrapRefErr					EQU		-4990
duplicateScrapFlavorErr			EQU		-4989
internalScrapErr				EQU		-4988
lastScrapErr					EQU		-4988
scrapFlavorNotFoundErr			EQU		-102
needClearScrapErr				EQU		-100

;  	When promising a scrap flavor, it's OK if you
;  	don't yet know how big the flavor data will be.
;  	In this case, just pass kScrapFlavorSizeUnknown
;  	for the flavor data size.




kScrapFlavorSizeUnknown			EQU		-1

;  	kScrapReservedFlavorType is a flavor type which is reserved
;  	for use by Scrap Manager. If you pass it to Scrap Manager,
;  	it will be rejected.




kScrapReservedFlavorType		EQU		'srft'
; 
;	We've added scrap flavor flags ala Drag Manager.
;
;	kScrapFlavorMaskNone means you want none of the flags.
;
;	kScrapFlavorSenderOnlyMask means only the process which
;	put the flavor on the scrap can see it. If some other
;	process put a flavor with this flag on the scrap,
;	your process will never see the flavor, so there's
;	no point in testing for this flag.
;
;	kScrapFlavorTranslated means the flavor was translated
;	from some other flavor in the scrap by Translation Manager.
;	Most callers should not care about this bit.
;


kScrapFlavorMaskNone			EQU		$00000000
kScrapFlavorMaskSenderOnly		EQU		$00000001
kScrapFlavorMaskTranslated		EQU		$00000002
; typedef UInt32 						ScrapFlavorFlags


;  	ScrapFlavorInfo describes a single flavor within
;  	a scrap. If flavorSize is -1, it simply means
;  	the flavor was promised but the promise has not
;  	yet been kept AND the promiser didn't know how
;  	much to data to promise.


ScrapFlavorInfo			RECORD 0
flavorType				 ds.l	1				; offset: $0 (0)
flavorFlags				 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR

;  	Under a future version of Carbon, there may be multiple scraps.
;  	We'll need ScrapRefs to tell them apart.





;  	GetCurrentScrap obtains a reference to the current scrap.
;  	The ScrapRef obtained via GetCurrentScrap will become
;  	invalid and unusable after the scrap is cleared.


;
; pascal OSStatus GetCurrentScrap(ScrapRef *scrap)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCurrentScrap
	ENDIF


;  	GetScrapFlavorFlags tells you [a] whether the scrap contains
;  	data for a particular flavor and [b] some things about that
;  	flavor if it exists. This call never blocks, and is useful
;  	for deciding whether to enable the Paste item in your Edit
;  	menu, among other things.



;
; pascal OSStatus GetScrapFlavorFlags(ScrapRef scrap, ScrapFlavorType flavorType, ScrapFlavorFlags *flavorFlags)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetScrapFlavorFlags
	ENDIF


;  	GetScrapFlavorSize gets the size of the data of the specified
;  	flavor. This function blocks until the specified flavor
;  	data is available. GetScrapFlavorSize is intended as a prelude
;  	to allocating memory and calling GetScrapFlavorData.



;
; pascal OSStatus GetScrapFlavorSize(ScrapRef scrap, ScrapFlavorType flavorType, Size *byteCount)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetScrapFlavorSize
	ENDIF


;  	GetScrapFlavorData gets the data from the specified flavor in the
;  	specified scrap. This function blocks until the specified flavor
;  	data is available. Specify the maximum size your buffer can contain;
;  	on output, this function produces the number of bytes that were
;  	available (even if this is more than you requested).



;
; pascal OSStatus GetScrapFlavorData(ScrapRef scrap, ScrapFlavorType flavorType, Size *byteCount, void *destination)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetScrapFlavorData
	ENDIF


;  	ClearCurrentScrap clears the current scrap. Call this
;  	first when the user requests a Copy or Cut operation --
;  	even if you maintain a private scrap! You should not wait
;  	until receiving a suspend event to call ClearCurrentScrap. Call
;  	it immediately after the user requests a Copy or Cut operation.
;  	You don't need to put any data on the scrap immediately (although
;  	it's perfectly fine to do so). You DO need to call GetCurrentScrap
;  	after ClearCurrentScrap so you'll have a valid ScrapRef to pass
;  	to other functions.



;
; pascal OSStatus ClearCurrentScrap(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClearCurrentScrap
	ENDIF


;  	PutScrapFlavor is a lot like PutScrap, with two differences:
;  	we added a ScrapRef parameter at the beginning and you can
;  	"promise" various aspects of a flavor. If you pass a NIL
;  	data pointer, this is a promise that in the future you
;  	will provide data for this flavor. Provide the data
;  	through a subsequent call to PutScrapFlavor, either later
;  	in the same code flow or during a scrap promise keeper proc.
;  	If you know how big the data is, you can pass the size as
;  	well, and this may allow subsequent callers of GetScrapFlavorInfo
;  	to avoid blocking. If you don't know the size, pass -1.
;  	If you pass a 0 size, you are telling Scrap Manager not to
;  	expect any data for this flavor. In this case, the flavor
;  	data pointer is ignored. NOTE: the last time you can provide
;  	scrap flavor data is when your scrap promise keepr gets
;  	called. It is NOT possible to call PutScrapFlavor while
;  	handling a suspend event; suspend events under Carbon
;  	simply don't work the way they do under Mac OS 8.



;
; pascal OSStatus PutScrapFlavor(ScrapRef scrap, ScrapFlavorType flavorType, ScrapFlavorFlags flavorFlags, Size flavorSize, const void *flavorData)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PutScrapFlavor
	ENDIF


;  	ScrapPromiseKeeper is a function you write which is called by
;  	Scrap Manager as needed to keep your earlier promise of a
;  	particular scrap flavor. When your function is called, deliver
;  	the requested data by calling PutScrapFlavor.




;  	SetScrapPromiseKeeper associates a ScrapPromiseKeeper with a
;  	scrap. You can remove a ScrapPromiseKeeper from a scrap by
;  	passing a NIL ScrapPromiseKeeper to SetScrapPromiseKeeper.
;  	Pass whatever you like in the last parameter; its value will
;  	be passed to your ScrapPromiseKeeper, which can do whatever
;  	it likes with the value. You might choose to pass a pointer
;  	or handle to some private scrap data which the
;  	ScrapPromiseKeeper could use in fabricating one or more
;  	promised flavors.


;
; pascal OSStatus SetScrapPromiseKeeper(ScrapRef scrap, ScrapPromiseKeeperUPP upp, const void *userData)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetScrapPromiseKeeper
	ENDIF


;  	GetScrapFlavorCount produces the number of
;  	items which can be obtained by GetScrapFlavorInfoList.



;
; pascal OSStatus GetScrapFlavorCount(ScrapRef scrap, UInt32 *infoCount)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetScrapFlavorCount
	ENDIF


;  	GetScrapFlavorInfoList produces a list (array)
;  	of items which each describe the corresponding
;  	flavor in the scrap. It produces up to as many
;  	items as are specified. On exit, it produces
;  	the count of items it produced (which may be
;  	smaller than the count requested). YES, you
;  	must provide the memory for the list.



;
; pascal OSStatus GetScrapFlavorInfoList(ScrapRef scrap, UInt32 *infoCount, ScrapFlavorInfo info[])
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetScrapFlavorInfoList
	ENDIF



;  	CallInPromises forces all promises to be kept.
;  	If your application promises at least one flavor
;  	AND it does NOT adopt the new event model, you
;  	should call this function when your application
;  	is about to quit. If your app promises no flavors,
;  	there is no need to call this function, and if
;  	your app adopts the new event model, this function
;  	will be called automagically for you. It doesn't
;  	hurt to call this function more than once, though
;  	promise keepers may be asked to keep promises
;  	they already tried and failed.



;
; pascal OSStatus CallInScrapPromises(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CallInScrapPromises
	ENDIF

	ENDIF ; __SCRAP__ 


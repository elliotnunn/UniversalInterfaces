;
;    File:       AEDataModel.a
;
;    Contains:   AppleEvent Data Model Interfaces.
;
;    Version:    Technology: Mac OS 9
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1996-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__AEDATAMODEL__') = 'UNDEFINED' THEN
__AEDATAMODEL__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF

;  Apple event descriptor types 

typeBoolean						EQU		'bool'
typeChar						EQU		'TEXT'
;  Preferred numeric Apple event descriptor types 

typeSInt16						EQU		'shor'
typeSInt32						EQU		'long'
typeUInt32						EQU		'magn'
typeSInt64						EQU		'comp'
typeIEEE32BitFloatingPoint		EQU		'sing'
typeIEEE64BitFloatingPoint		EQU		'doub'
type128BitFloatingPoint			EQU		'ldbl'
typeDecimalStruct				EQU		'decm'
;  Non-preferred Apple event descriptor types 

typeSMInt						EQU		'shor'
typeShortInteger				EQU		'shor'
typeInteger						EQU		'long'
typeLongInteger					EQU		'long'
typeMagnitude					EQU		'magn'
typeComp						EQU		'comp'
typeSMFloat						EQU		'sing'
typeShortFloat					EQU		'sing'
typeFloat						EQU		'doub'
typeLongFloat					EQU		'doub'
typeExtended					EQU		'exte'
;  More Apple event descriptor types 

typeAEList						EQU		'list'
typeAERecord					EQU		'reco'
typeAppleEvent					EQU		'aevt'
typeEventRecord					EQU		'evrc'
typeTrue						EQU		'true'
typeFalse						EQU		'fals'
typeAlias						EQU		'alis'
typeEnumerated					EQU		'enum'
typeType						EQU		'type'
typeAppParameters				EQU		'appa'
typeProperty					EQU		'prop'
typeFSS							EQU		'fss '
typeFSRef						EQU		'fsrf'
typeKeyword						EQU		'keyw'
typeSectionH					EQU		'sect'
typeWildCard					EQU		'****'
typeApplSignature				EQU		'sign'
typeQDRectangle					EQU		'qdrt'
typeFixed						EQU		'fixd'
typeProcessSerialNumber			EQU		'psn '
typeApplicationURL				EQU		'aprl'
typeNull						EQU		'null'				; null or nonexistent data 
	IF CALL_NOT_IN_CARBON THEN
;  Deprecated addressing modes under Carbon 

typeSessionID					EQU		'ssid'
typeTargetID					EQU		'targ'
typeDispatcherID				EQU		'dspt'
	ENDIF	; CALL_NOT_IN_CARBON
;  Keywords for Apple event attributes 

keyTransactionIDAttr			EQU		'tran'
keyReturnIDAttr					EQU		'rtid'
keyEventClassAttr				EQU		'evcl'
keyEventIDAttr					EQU		'evid'
keyAddressAttr					EQU		'addr'
keyOptionalKeywordAttr			EQU		'optk'
keyTimeoutAttr					EQU		'timo'
keyInteractLevelAttr			EQU		'inte'				; this attribute is read only - will be set in AESend 
keyEventSourceAttr				EQU		'esrc'				; this attribute is read only - returned as typeShortInteger 
keyMissedKeywordAttr			EQU		'miss'				; this attribute is read only 
keyOriginalAddressAttr			EQU		'from'				; new in 1.0.1 
keyAcceptTimeoutAttr			EQU		'actm'				; new for Mac OS X 

;   Constants used for specifying the factoring of AEDescLists. 

kAEDescListFactorNone			EQU		0
kAEDescListFactorType			EQU		4
kAEDescListFactorTypeAndSize	EQU		8
;  Constants used creating an AppleEvent 

															; Constant for the returnID param of AECreateAppleEvent 
kAutoGenerateReturnID			EQU		-1					; AECreateAppleEvent will generate a session-unique ID 
															; Constant for transaction ID’s 
kAnyTransactionID				EQU		0					; no transaction is in use 
;  Apple event manager data types 
; typedef ResType 						DescType

; typedef FourCharCode 					AEKeyword

	IF OPAQUE_TOOLBOX_STRUCTS THEN


	ELSE
; typedef Ptr 							AEDataStorageType

	ENDIF	; OPAQUE_TOOLBOX_STRUCTS
; typedef AEDataStorageType *			AEDataStorage

AEDesc					RECORD 0
descriptorType			 ds.l	1				; offset: $0 (0)
dataHandle				 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct AEDesc *				AEDescPtr

AEKeyDesc				RECORD 0
descKey					 ds.l	1				; offset: $0 (0)
descContent				 ds		AEDesc			; offset: $4 (4)
sizeof					 EQU *					; size:   $C (12)
						ENDR
;  a list of AEDesc's is a special kind of AEDesc 
AEDescList				RECORD 0
f						 ds		AEDesc
sizeof					 EQU *					; size:   $8 (8)
						ENDR


;  AERecord is a list of keyworded AEDesc's 
AERecord				RECORD 0
f						 ds		AEDescList
sizeof					 EQU *					; size:   $8 (8)
						ENDR


;  an AEDesc which contains address data 
AEAddressDesc			RECORD 0
f						 ds		AEDesc
sizeof					 EQU *					; size:   $8 (8)
						ENDR


;  an AERecord that contains an AppleEvent, and related data types 
AppleEvent				RECORD 0
f						 ds		AERecord
sizeof					 EQU *					; size:   $8 (8)
						ENDR


; typedef struct AppleEvent *			AppleEventPtr

; typedef SInt16 						AEReturnID

; typedef SInt32 						AETransactionID

; typedef FourCharCode 					AEEventClass

; typedef FourCharCode 					AEEventID

; typedef SInt8 						AEArrayType


kAEDataArray					EQU		0
kAEPackedArray					EQU		1
kAEDescArray					EQU		3
kAEKeyDescArray					EQU		4


kAEHandleArray					EQU		2
AEArrayData				RECORD 0
kAEDataArray			 ds.w	1				; offset: $0 (0) <-- really an array of length one
						 ORG 0
kAEPackedArray			 ds.b	1				; offset: $0 (0) <-- really an array of length one
						 ORG 0
kAEHandleArray			 ds.l	1				; offset: $0 (0) <-- really an array of length one
						 ORG 0
kAEDescArray			 ds		AEDesc			; offset: $0 (0) <-- really an array of length one
						 ORG 0
kAEKeyDescArray			 ds		AEKeyDesc		; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef union AEArrayData *			AEArrayDataPointer

; **************************************************************************
;  These constants are used by AEMach and AEInteraction APIs.  They are not
;  strictly part of the data format, but are declared here due to layering.
;*************************************************************************


; typedef SInt16						AESendPriority
kAENormalPriority				EQU		$00000000			; post message at the end of the event queue 
kAEHighPriority					EQU		$00000001			; post message at the front of the event queue (same as nAttnMsg) 


; typedef SInt32						AESendMode
kAENoReply						EQU		$00000001			; sender doesn't want a reply to event 
kAEQueueReply					EQU		$00000002			; sender wants a reply but won't wait 
kAEWaitReply					EQU		$00000003			; sender wants a reply and will wait 
kAEDontReconnect				EQU		$00000080			; don't reconnect if there is a sessClosedErr from PPCToolbox 
kAEWantReceipt					EQU		$00000200			; (nReturnReceipt) sender wants a receipt of message 
kAENeverInteract				EQU		$00000010			; server should not interact with user 
kAECanInteract					EQU		$00000020			; server may try to interact with user 
kAEAlwaysInteract				EQU		$00000030			; server should always interact with user where appropriate 
kAECanSwitchLayer				EQU		$00000040			; interaction may switch layer 
kAEDontRecord					EQU		$00001000			; don't record this event - available only in vers 1.0.1 and greater 
kAEDontExecute					EQU		$00002000			; don't send the event for recording - available only in vers 1.0.1 and greater 
kAEProcessNonReplyEvents		EQU		$00008000			; allow processing of non-reply events while awaiting synchronous AppleEvent reply 

;  Constants for timeout durations 

kAEDefaultTimeout				EQU		-1					; timeout value determined by AEM 
kNoTimeOut						EQU		-2					; wait until reply comes back, however long it takes 

; **************************************************************************
;  These calls are used to set up and modify the coercion dispatch table.
;*************************************************************************


; *  NewAECoerceDescUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewAECoercePtrUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeAECoerceDescUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeAECoercePtrUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeAECoerceDescUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeAECoercePtrUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;  a AECoercionHandlerUPP is by default a AECoerceDescUPP.  If you are registering a 
;    Ptr based coercion handler you will have to add a cast to AECoerceDescUPP from 
;    your AECoercePtrUPP type.  A future release of the interfaces will fix this by
;    introducing seperate Desc and Ptr coercion handler installation/remove/query routines. 

; typedef AECoerceDescUPP 				AECoercionHandlerUPP


; *  AEInstallCoercionHandler()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEInstallCoercionHandler(DescType fromType, DescType toType, AECoercionHandlerUPP handler, long handlerRefcon, Boolean fromTypeIsDesc, Boolean isSysHandler)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEInstallCoercionHandler
			move.w              #$0A22,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEInstallCoercionHandler
	ENDIF


; *  AERemoveCoercionHandler()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AERemoveCoercionHandler(DescType fromType, DescType toType, AECoercionHandlerUPP handler, Boolean isSysHandler)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AERemoveCoercionHandler
			move.w              #$0723,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AERemoveCoercionHandler
	ENDIF



; *  AEGetCoercionHandler()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEGetCoercionHandler(DescType fromType, DescType toType, AECoercionHandlerUPP *handler, long *handlerRefcon, Boolean *fromTypeIsDesc, Boolean isSysHandler)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetCoercionHandler
			move.w              #$0B24,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetCoercionHandler
	ENDIF

; **************************************************************************
;  The following calls provide for a coercion interface.
;*************************************************************************


; *  AECoercePtr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AECoercePtr(DescType typeCode, const void *dataPtr, Size dataSize, DescType toType, AEDesc *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AECoercePtr
			move.w              #$0A02,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AECoercePtr
	ENDIF


; *  AECoerceDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AECoerceDesc(const AEDesc *theAEDesc, DescType toType, AEDesc *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AECoerceDesc
			move.w              #$0603,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AECoerceDesc
	ENDIF


; **************************************************************************
; The following calls apply to any AEDesc. Every 'result' descriptor is
; created for you, so you will be responsible for memory management
; (including disposing) of the descriptors so created.  
;*************************************************************************

;  because AEDescs are opaque under Carbon, this AEInitializeDesc provides a
;   'clean' way of initializating them to be empty. 

; *  AEInitializeDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available in CarbonLib 1.x, is availble on Mac OS X version 10.0 or later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void AEInitializeDesc(AEDesc *desc)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEInitializeDesc
	ENDIF



; *  AECreateDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AECreateDesc(DescType typeCode, const void *dataPtr, Size dataSize, AEDesc *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AECreateDesc
			move.w              #$0825,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AECreateDesc
	ENDIF


; *  AEDisposeDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEDisposeDesc(AEDesc *theAEDesc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEDisposeDesc
			move.w              #$0204,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEDisposeDesc
	ENDIF


; *  AEDuplicateDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEDuplicateDesc(const AEDesc *theAEDesc, AEDesc *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEDuplicateDesc
			move.w              #$0405,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEDuplicateDesc
	ENDIF


; **************************************************************************
;  The following calls apply to AEDescList. Since AEDescList is a subtype of
;  AEDesc, the calls in the previous section can also be used for AEDescList.
;  All list and array indices are 1-based. If the data was greater than
;  maximumSize in the routines below, then actualSize will be greater than
;  maximumSize, but only maximumSize bytes will actually be retrieved.
;*************************************************************************


; *  AECreateList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AECreateList(const void *factoringPtr, Size factoredSize, Boolean isRecord, AEDescList *resultList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AECreateList
			move.w              #$0706,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AECreateList
	ENDIF


; *  AECountItems()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AECountItems(const AEDescList *theAEDescList, long *theCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AECountItems
			move.w              #$0407,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AECountItems
	ENDIF


; *  AEPutPtr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEPutPtr(AEDescList *theAEDescList, long index, DescType typeCode, const void *dataPtr, Size dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEPutPtr
			move.w              #$0A08,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEPutPtr
	ENDIF


; *  AEPutDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEPutDesc(AEDescList *theAEDescList, long index, const AEDesc *theAEDesc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEPutDesc
			move.w              #$0609,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEPutDesc
	ENDIF


; *  AEGetNthPtr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEGetNthPtr(const AEDescList *theAEDescList, long index, DescType desiredType, AEKeyword *theAEKeyword, DescType *typeCode, void *dataPtr, Size maximumSize, Size *actualSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetNthPtr
			move.w              #$100A,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetNthPtr
	ENDIF


; *  AEGetNthDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEGetNthDesc(const AEDescList *theAEDescList, long index, DescType desiredType, AEKeyword *theAEKeyword, AEDesc *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetNthDesc
			move.w              #$0A0B,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetNthDesc
	ENDIF


; *  AESizeOfNthItem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AESizeOfNthItem(const AEDescList *theAEDescList, long index, DescType *typeCode, Size *dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AESizeOfNthItem
			move.w              #$082A,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AESizeOfNthItem
	ENDIF


; *  AEGetArray()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEGetArray(const AEDescList *theAEDescList, AEArrayType arrayType, AEArrayDataPointer arrayPtr, Size maximumSize, DescType *itemType, Size *itemSize, long *itemCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetArray
			move.w              #$0D0C,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetArray
	ENDIF


; *  AEPutArray()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEPutArray(AEDescList *theAEDescList, AEArrayType arrayType, const AEArrayData *arrayPtr, DescType itemType, Size itemSize, long itemCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEPutArray
			move.w              #$0B0D,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEPutArray
	ENDIF


; *  AEDeleteItem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEDeleteItem(AEDescList *theAEDescList, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEDeleteItem
			move.w              #$040E,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEDeleteItem
	ENDIF


; **************************************************************************
; The following calls apply to AERecord. Since AERecord is a subtype of
; AEDescList, the calls in the previous sections can also be used for
; AERecord an AERecord can be created by using AECreateList with isRecord
; set to true. 
;*************************************************************************

; *************************************************************************
; AERecords can have an abitrary descriptorType.  This allows you to
; check if desc is truly an AERecord
;***********************************************************************


; *  AECheckIsRecord()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available in CarbonLib 1.x, is availble on Mac OS X version 10.0 or later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern Boolean AECheckIsRecord(const AEDesc *theDesc)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AECheckIsRecord
	ENDIF

; 
;  Note: none of the “key” calls were available in the PowerPC 7.x IntefaceLib.
;  In C, a #define is used to map “key” calls to “param” calls.  In pascal
;  this mapping is done in externally linked glue code.
;

	IF CALL_NOT_IN_CARBON THEN

; *  AEPutKeyPtr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr AEPutKeyPtr(AERecord *theAERecord, AEKeyword theAEKeyword, DescType typeCode, const void *dataPtr, Size dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEPutKeyPtr
			move.w              #$0A0F,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEPutKeyPtr
	ENDIF


; *  AEPutKeyDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr AEPutKeyDesc(AERecord *theAERecord, AEKeyword theAEKeyword, const AEDesc *theAEDesc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEPutKeyDesc
			move.w              #$0610,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEPutKeyDesc
	ENDIF


; *  AEGetKeyPtr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr AEGetKeyPtr(const AERecord *theAERecord, AEKeyword theAEKeyword, DescType desiredType, DescType *typeCode, void *dataPtr, Size maximumSize, Size *actualSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetKeyPtr
			move.w              #$0E11,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetKeyPtr
	ENDIF


; *  AEGetKeyDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr AEGetKeyDesc(const AERecord *theAERecord, AEKeyword theAEKeyword, DescType desiredType, AEDesc *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetKeyDesc
			move.w              #$0812,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetKeyDesc
	ENDIF


; *  AESizeOfKeyDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr AESizeOfKeyDesc(const AERecord *theAERecord, AEKeyword theAEKeyword, DescType *typeCode, Size *dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AESizeOfKeyDesc
			move.w              #$0829,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AESizeOfKeyDesc
	ENDIF


; *  AEDeleteKeyDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr AEDeleteKeyDesc(AERecord *theAERecord, AEKeyword theAEKeyword)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEDeleteKeyDesc
			move.w              #$0413,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEDeleteKeyDesc
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
; **************************************************************************
;  The following calls create and manipulate the AppleEvent data type.
;*************************************************************************


; *  AECreateAppleEvent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AECreateAppleEvent(AEEventClass theAEEventClass, AEEventID theAEEventID, const AEAddressDesc *target, AEReturnID returnID, AETransactionID transactionID, AppleEvent *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AECreateAppleEvent
			move.w              #$0B14,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AECreateAppleEvent
	ENDIF


; **************************************************************************
;  The following calls are used to pack and unpack parameters from records
;  of type AppleEvent. Since AppleEvent is a subtype of AERecord, the calls
;  in the previous sections can also be used for variables of type
;  AppleEvent. The next six calls are in fact identical to the six calls
;  for AERecord.
;*************************************************************************


; *  AEPutParamPtr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEPutParamPtr(AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType typeCode, const void *dataPtr, Size dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEPutParamPtr
			move.w              #$0A0F,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEPutParamPtr
	ENDIF


; *  AEPutParamDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEPutParamDesc(AppleEvent *theAppleEvent, AEKeyword theAEKeyword, const AEDesc *theAEDesc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEPutParamDesc
			move.w              #$0610,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEPutParamDesc
	ENDIF


; *  AEGetParamPtr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEGetParamPtr(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType desiredType, DescType *typeCode, void *dataPtr, Size maximumSize, Size *actualSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetParamPtr
			move.w              #$0E11,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetParamPtr
	ENDIF


; *  AEGetParamDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEGetParamDesc(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType desiredType, AEDesc *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetParamDesc
			move.w              #$0812,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetParamDesc
	ENDIF


; *  AESizeOfParam()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AESizeOfParam(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType *typeCode, Size *dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AESizeOfParam
			move.w              #$0829,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AESizeOfParam
	ENDIF


; *  AEDeleteParam()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEDeleteParam(AppleEvent *theAppleEvent, AEKeyword theAEKeyword)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEDeleteParam
			move.w              #$0413,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEDeleteParam
	ENDIF



; **************************************************************************
; The following calls also apply to type AppleEvent. Message attributes are
; far more restricted, and can only be accessed through the following 5
; calls. The various list and record routines cannot be used to access the
; attributes of an event. 
;*************************************************************************


; *  AEGetAttributePtr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEGetAttributePtr(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType desiredType, DescType *typeCode, void *dataPtr, Size maximumSize, Size *actualSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetAttributePtr
			move.w              #$0E15,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetAttributePtr
	ENDIF


; *  AEGetAttributeDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEGetAttributeDesc(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType desiredType, AEDesc *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEGetAttributeDesc
			move.w              #$0826,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetAttributeDesc
	ENDIF


; *  AESizeOfAttribute()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AESizeOfAttribute(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType *typeCode, Size *dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AESizeOfAttribute
			move.w              #$0828,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AESizeOfAttribute
	ENDIF


; *  AEPutAttributePtr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEPutAttributePtr(AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType typeCode, const void *dataPtr, Size dataSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEPutAttributePtr
			move.w              #$0A16,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEPutAttributePtr
	ENDIF


; *  AEPutAttributeDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEPutAttributeDesc(AppleEvent *theAppleEvent, AEKeyword theAEKeyword, const AEDesc *theAEDesc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_AEPutAttributeDesc
			move.w              #$0627,D0
			dc.w            	$A816
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEPutAttributeDesc
	ENDIF


; **************************************************************************
; AppleEvent Serialization Support
;
;    AESizeOfFlattenedDesc, AEFlattenDesc, AEUnflattenDesc
;    
;    These calls will work for all AppleEvent data types and between different
;    versions of the OS (including between Mac OS 9 and X)
;    
;    Basic types, AEDesc, AEList and AERecord are OK, but AppleEvent records
;    themselves may not be reliably flattened for storage.
;*************************************************************************


;   AEFlattenDesc
;   Returns the amount of buffer space needed to flatten the
;   AEDesc. Call this before AEFlattenDesc to make sure your
;   buffer has enough room for the operation.




; *  AESizeOfFlattenedDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available in CarbonLib 1.x, is availble on Mac OS X version 10.0 or later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern Size AESizeOfFlattenedDesc(const AEDesc *theAEDesc)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AESizeOfFlattenedDesc
	ENDIF


;   AEFlattenDesc
;   Fills a buffer with a flattened representation of the
;   AEDesc and returns the amount of buffer used in actualSize.
;   If bufferSize was too small it returns errAEBufferTooSmall
;   (-1741) and does not fill in any of the buffer. The resulting
;   buffer is only useful with an AEUnflattenDesc call.
;   
;   Note: if you pass a NULL buffer pointer it returns noErr but
;   fills in the actualSize field anyway.




; *  AEFlattenDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available in CarbonLib 1.x, is availble on Mac OS X version 10.0 or later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus AEFlattenDesc(const AEDesc *theAEDesc, Ptr buffer, Size bufferSize, Size *actualSize)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEFlattenDesc
	ENDIF


;   AEUnflattenDesc
;   Allocates an AEDesc (given a Null Desc) given a flattened
;   data buffer. It assumes it was given a good buffer filled
;   in by AEFlattenDesc. It returns paramErr if it discovers
;   something fishy about the buffer.




; *  AEUnflattenDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available in CarbonLib 1.x, is availble on Mac OS X version 10.0 or later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus AEUnflattenDesc(Ptr buffer, AEDesc *result)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEUnflattenDesc
	ENDIF

; **************************************************************************
; The following calls are necessary to deal with opaque data in AEDescs, because the
; traditional way of dealing with a basic AEDesc has been to dereference the dataHandle
; directly.  This is not supported under Carbon.
;*************************************************************************

	IF ACCESSOR_CALLS_ARE_FUNCTIONS THEN
; 
;        AEGetDescData no longer supports automatic coercion. If you'd like to
;        coerce the descriptor use AECoerceDesc.
;    


; *  AEGetDescData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEGetDescData(const AEDesc *theAEDesc, void *dataPtr, Size maximumSize)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetDescData
	ENDIF


; *  AEGetDescDataSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Size AEGetDescDataSize(const AEDesc *theAEDesc)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEGetDescDataSize
	ENDIF


; *  AEReplaceDescData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AEReplaceDescData(DescType typeCode, const void *dataPtr, Size dataSize, AEDesc *theAEDesc)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AEReplaceDescData
	ENDIF

	ENDIF	; ACCESSOR_CALLS_ARE_FUNCTIONS

; **************************************************************************
;  A AEEventHandler is installed to process an AppleEvent 
;*************************************************************************


; *  NewAEEventHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeAEEventHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeAEEventHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


	ENDIF ; __AEDATAMODEL__ 


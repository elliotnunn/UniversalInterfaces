;
;    File:       AppleTalk.a
;
;    Contains:   AppleTalk Interfaces.
;
;    Version:    Technology: System 8.5
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  Â© 1985-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__APPLETALK__') = 'UNDEFINED' THEN
__APPLETALK__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__OSUTILS__') = 'UNDEFINED' THEN
	include 'OSUtils.a'
	ENDIF


															; Driver unit numbers (ADSP is dynamic) 
mppUnitNum						EQU		9					; MPP unit number 
atpUnitNum						EQU		10					; ATP unit number 
xppUnitNum						EQU		40					; XPP unit number 

															; Driver refNums (ADSP is dynamic) 
mppRefNum						EQU		-10					; MPP reference number 
atpRefNum						EQU		-11					; ATP reference number 
xppRefNum						EQU		-41					; XPP reference number 

															; .MPP csCodes 
lookupReply						EQU		242					; This command queued to ourself 
writeLAP						EQU		243					; Write out LAP packet 
detachPH						EQU		244					; Detach LAP protocol handler 
attachPH						EQU		245					; Attach LAP protocol handler 
writeDDP						EQU		246					; Write out DDP packet 
closeSkt						EQU		247					; Close DDP socket 
openSkt							EQU		248					; Open DDP socket 
loadNBP							EQU		249					; Load NBP command-executing code 
lastResident					EQU		249					; Last resident command 
confirmName						EQU		250					; Confirm name 
lookupName						EQU		251					; Look up name on internet 
removeName						EQU		252					; Remove name from Names Table 
registerName					EQU		253					; Register name in Names Table 
killNBP							EQU		254					; Kill outstanding NBP request 
unloadNBP						EQU		255					; Unload NBP command code 
setSelfSend						EQU		256					; MPP: Set to allow writes to self 
SetMyZone						EQU		257					; Set my zone name 
GetATalkInfo					EQU		258					; get AppleTalk information 
ATalkClosePrep					EQU		259					; AppleTalk close query 

															; .ATP csCodes 
nSendRequest					EQU		248					; NSendRequest code 
relRspCB						EQU		249					; Release RspCB 
closeATPSkt						EQU		250					; Close ATP socket 
addResponse						EQU		251					; Add response code | Require open skt 
sendResponse					EQU		252					; Send response code 
getRequest						EQU		253					; Get request code 
openATPSkt						EQU		254					; Open ATP socket 
sendRequest						EQU		255					; Send request code 
relTCB							EQU		256					; Release TCB 
killGetReq						EQU		257					; Kill GetRequest 
killSendReq						EQU		258					; Kill SendRequest 
killAllGetReq					EQU		259					; Kill all getRequests for a skt 

															; .XPP csCodes 
openSess						EQU		255					; Open session 
closeSess						EQU		254					; Close session 
userCommand						EQU		253					; User command 
userWrite						EQU		252					; User write 
getStatus						EQU		251					; Get status 
afpCall							EQU		250					; AFP command (buffer has command code) 
getParms						EQU		249					; Get parameters 
abortOS							EQU		248					; Abort open session request 
closeAll						EQU		247					; Close all open sessions 
xCall							EQU		246					; .XPP extended calls 

															; Transition Queue transition types 
ATTransOpen						EQU		0					;AppleTalk has opened
ATTransClose					EQU		2					;AppleTalk is about to close
ATTransClosePrep				EQU		3					;Is it OK to close AppleTalk ?
ATTransCancelClose				EQU		4					;Cancel the ClosePrep transition

afpByteRangeLock				EQU		1					;AFPCall command codes
afpVolClose						EQU		2					;AFPCall command codes
afpDirClose						EQU		3					;AFPCall command codes
afpForkClose					EQU		4					;AFPCall command codes
afpCopyFile						EQU		5					;AFPCall command codes
afpDirCreate					EQU		6					;AFPCall command codes
afpFileCreate					EQU		7					;AFPCall command codes
afpDelete						EQU		8					;AFPCall command codes
afpEnumerate					EQU		9					;AFPCall command codes
afpFlush						EQU		10					;AFPCall command codes
afpForkFlush					EQU		11					;AFPCall command codes
afpGetDirParms					EQU		12					;AFPCall command codes
afpGetFileParms					EQU		13					;AFPCall command codes
afpGetForkParms					EQU		14					;AFPCall command codes
afpGetSInfo						EQU		15					;AFPCall command codes
afpGetSParms					EQU		16					;AFPCall command codes
afpGetVolParms					EQU		17					;AFPCall command codes
afpLogin						EQU		18					;AFPCall command codes
afpContLogin					EQU		19					;AFPCall command codes
afpLogout						EQU		20					;AFPCall command codes
afpMapID						EQU		21					;AFPCall command codes
afpMapName						EQU		22					;AFPCall command codes
afpMove							EQU		23					;AFPCall command codes
afpOpenVol						EQU		24					;AFPCall command codes
afpOpenDir						EQU		25					;AFPCall command codes
afpOpenFork						EQU		26					;AFPCall command codes
afpRead							EQU		27					;AFPCall command codes
afpRename						EQU		28					;AFPCall command codes
afpSetDirParms					EQU		29					;AFPCall command codes
afpSetFileParms					EQU		30					;AFPCall command codes
afpSetForkParms					EQU		31					;AFPCall command codes
afpSetVolParms					EQU		32					;AFPCall command codes
afpWrite						EQU		33					;AFPCall command codes
afpGetFlDrParms					EQU		34					;AFPCall command codes
afpSetFlDrParms					EQU		35					;AFPCall command codes
afpDTOpen						EQU		48					;AFPCall command codes
afpDTClose						EQU		49					;AFPCall command codes
afpGetIcon						EQU		51					;AFPCall command codes
afpGtIcnInfo					EQU		52					;AFPCall command codes
afpAddAPPL						EQU		53					;AFPCall command codes
afpRmvAPPL						EQU		54					;AFPCall command codes
afpGetAPPL						EQU		55					;AFPCall command codes
afpAddCmt						EQU		56					;AFPCall command codes
afpRmvCmt						EQU		57					;AFPCall command codes
afpGetCmt						EQU		58					;AFPCall command codes
afpAddIcon						EQU		192					;Special code for ASP Write commands

xppLoadedBit					EQU		5					; XPP bit in PortBUse 
scbMemSize						EQU		192					; Size of memory for SCB 
xppFlagClr						EQU		0					; Cs for AFPCommandBlock 

xppFlagSet						EQU		128					; StartEndFlag & NewLineFlag fields. 

lapSize							EQU		20
ddpSize							EQU		26
nbpSize							EQU		26
atpSize							EQU		56

atpXOvalue						EQU		32					;ATP exactly-once bit 
atpEOMvalue						EQU		16					;ATP End-Of-Message bit 
atpSTSvalue						EQU		8					;ATP Send-Transmission-Status bit 
atpTIDValidvalue				EQU		2					;ATP trans. ID valid bit 
atpSendChkvalue					EQU		1					;ATP send checksum bit 

zipGetLocalZones				EQU		5
zipGetZoneList					EQU		6
zipGetMyZone					EQU		7

LAPMgrPtr						EQU		$0B18				;Entry point for LAP Manager

LAPMgrCall						EQU		2					;Offset to LAP routines
LAddAEQ							EQU		23					;LAPAddATQ routine selector
LRmvAEQ							EQU		24					;LAPRmvATQ routine selector

tLAPRead						EQU		0
tLAPWrite						EQU		1
tDDPRead						EQU		2
tDDPWrite						EQU		3
tNBPLookup						EQU		4
tNBPConfirm						EQU		5
tNBPRegister					EQU		6
tATPSndRequest					EQU		7
tATPGetRequest					EQU		8
tATPSdRsp						EQU		9
tATPAddRsp						EQU		10
tATPRequest						EQU		11
tATPResponse					EQU		12
; typedef SInt8 						ABCallType


lapProto						EQU		0
ddpProto						EQU		1
nbpProto						EQU		2
atpProto						EQU		3
; typedef UInt8 						ABProtoType

; typedef Byte 							ABByte

LAPAdrBlock				RECORD 0
dstNodeID				 ds.b	1				; offset: $0 (0)
srcNodeID				 ds.b	1				; offset: $1 (1)
lapProtType				 ds.b	1				; offset: $2 (2)
filler					 ds.b	1				; offset: $3 (3)		;     Filler for proper byte alignment
sizeof					 EQU *					; size:   $4 (4)
						ENDR


; typedef ATQEntry *					ATQEntryPtr

; typedef ATalkTransitionEventUPP 		ATalkTransitionEvent

ATQEntry				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; next queue entry
qType					 ds.w	1				; offset: $4 (4)		; queue type
CallAddr				 ds.l	1				; offset: $6 (6)		; your routine descriptor
sizeof					 EQU *					; size:   $A (10)
						ENDR
;  
;    Real definition of EntityName is 3 PACKED strings of any length (32 is just an example). No
;    offests for Asm since each String address must be calculated by adding length byte to last string ptr.
;    In Pascal, String(32) will be 34 bytes long since fields never start on an odd byte unless they are 
;    only a byte long. So this will generate correct looking interfaces for Pascal and C, but they will not
;    be the same, which is OK since they are not used. 
;

EntityName				RECORD 0
objStr					 ds		Str32Field		; offset: $0 (0)
typeStr					 ds		Str32Field		; offset: $22 (34)
zoneStr					 ds		Str32Field		; offset: $44 (68)
sizeof					 EQU *					; size:   $66 (102)
						ENDR
; typedef struct EntityName *			EntityPtr

AddrBlock				RECORD 0
aNet					 ds.w	1				; offset: $0 (0)
aNode					 ds.b	1				; offset: $2 (2)
aSocket					 ds.b	1				; offset: $3 (3)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
RetransType				RECORD 0
retransInterval			 ds.b	1				; offset: $0 (0)
retransCount			 ds.b	1				; offset: $1 (1)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
BDSElement				RECORD 0
buffSize				 ds.w	1				; offset: $0 (0)
buffPtr					 ds.l	1				; offset: $2 (2)
dataSize				 ds.w	1				; offset: $6 (6)
userBytes				 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
BDSType					RECORD 0
elements				 ds.b	8 * BDSElement.sizeof
sizeof					 EQU *					; size:   $60 (96)
						ENDR


; typedef struct BDSElement *			BDSPtr

; typedef char 							BitMapType

ATLAPRec				RECORD 0
abOpcode				 ds.b	1				; offset: $0 (0)
filler					 ds.b	1				; offset: $1 (1)		;     Filler for proper byte alignment
abResult				 ds.w	1				; offset: $2 (2)
abUserReference			 ds.l	1				; offset: $4 (4)
lapAddress				 ds		LAPAdrBlock		; offset: $8 (8)
lapReqCount				 ds.w	1				; offset: $C (12)
lapActCount				 ds.w	1				; offset: $E (14)
lapDataPtr				 ds.l	1				; offset: $10 (16)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct ATLAPRec *				ATLAPRecPtr

; typedef ATLAPRecPtr *					ATLAPRecHandle

ATDDPRec				RECORD 0
abOpcode				 ds.b	1				; offset: $0 (0)
filler					 ds.b	1				; offset: $1 (1)		;     Filler for proper byte alignment
abResult				 ds.w	1				; offset: $2 (2)
abUserReference			 ds.l	1				; offset: $4 (4)
ddpType					 ds.w	1				; offset: $8 (8)
ddpSocket				 ds.w	1				; offset: $A (10)
ddpAddress				 ds		AddrBlock		; offset: $C (12)
ddpReqCount				 ds.w	1				; offset: $10 (16)
ddpActCount				 ds.w	1				; offset: $12 (18)
ddpDataPtr				 ds.l	1				; offset: $14 (20)
ddpNodeID				 ds.w	1				; offset: $18 (24)
sizeof					 EQU *					; size:   $1A (26)
						ENDR
; typedef struct ATDDPRec *				ATDDPRecPtr

; typedef ATDDPRecPtr *					ATDDPRecHandle

ATNBPRec				RECORD 0
abOpcode				 ds.b	1				; offset: $0 (0)
filler					 ds.b	1				; offset: $1 (1)		;     Filler for proper byte alignment
abResult				 ds.w	1				; offset: $2 (2)
abUserReference			 ds.l	1				; offset: $4 (4)
nbpEntityPtr			 ds.l	1				; offset: $8 (8)
nbpBufPtr				 ds.l	1				; offset: $C (12)
nbpBufSize				 ds.w	1				; offset: $10 (16)
nbpDataField			 ds.w	1				; offset: $12 (18)
nbpAddress				 ds		AddrBlock		; offset: $14 (20)
nbpRetransmitInfo		 ds		RetransType		; offset: $18 (24)
sizeof					 EQU *					; size:   $1A (26)
						ENDR
; typedef struct ATNBPRec *				ATNBPRecPtr

; typedef ATNBPRecPtr *					ATNBPRecHandle

ATATPRec				RECORD 0
abOpcode				 ds.b	1				; offset: $0 (0)
filler1					 ds.b	1				; offset: $1 (1)		;     Filler for proper byte alignment
abResult				 ds.w	1				; offset: $2 (2)
abUserReference			 ds.l	1				; offset: $4 (4)
atpSocket				 ds.w	1				; offset: $8 (8)
atpAddress				 ds		AddrBlock		; offset: $A (10)
atpReqCount				 ds.w	1				; offset: $E (14)
atpDataPtr				 ds.l	1				; offset: $10 (16)
atpRspBDSPtr			 ds.l	1				; offset: $14 (20)
atpBitMap				 ds.b	1				; offset: $18 (24)
filler2					 ds.b	1				; offset: $19 (25)		;     Filler for proper byte alignment
atpTransID				 ds.w	1				; offset: $1A (26)
atpActCount				 ds.w	1				; offset: $1C (28)
atpUserData				 ds.l	1				; offset: $1E (30)
atpXO					 ds.b	1				; offset: $22 (34)
atpEOM					 ds.b	1				; offset: $23 (35)
atpTimeOut				 ds.w	1				; offset: $24 (36)
atpRetries				 ds.w	1				; offset: $26 (38)
atpNumBufs				 ds.w	1				; offset: $28 (40)
atpNumRsp				 ds.w	1				; offset: $2A (42)
atpBDSSize				 ds.w	1				; offset: $2C (44)
atpRspUData				 ds.l	1				; offset: $2E (46)
atpRspBuf				 ds.l	1				; offset: $32 (50)
atpRspSize				 ds.w	1				; offset: $36 (54)
sizeof					 EQU *					; size:   $38 (56)
						ENDR
; typedef struct ATATPRec *				ATATPRecPtr

; typedef ATATPRecPtr *					ATATPRecHandle

AFPCommandBlock			RECORD 0
cmdByte					 ds.b	1				; offset: $0 (0)
startEndFlag			 ds.b	1				; offset: $1 (1)
forkRefNum				 ds.w	1				; offset: $2 (2)
rwOffset				 ds.l	1				; offset: $4 (4)
reqCount				 ds.l	1				; offset: $8 (8)
newLineFlag				 ds.b	1				; offset: $C (12)
newLineChar				 ds.b	1				; offset: $D (13)
sizeof					 EQU *					; size:   $E (14)
						ENDR






; typedef MPPParamBlock *				MPPPBPtr

; typedef ATPParamBlock *				ATPPBPtr

; typedef XPPParamBlock *				XPPParmBlkPtr


WDSElement				RECORD 0
entryLength				 ds.w	1				; offset: $0 (0)
entryPtr				 ds.l	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
NTElement				RECORD 0
nteAddress				 ds		AddrBlock		; offset: $0 (0)		; network address of entity
filler					 ds.b	1				; offset: $4 (4)
entityData				 ds.b	99				; offset: $5 (5)		; Object, Type & Zone
sizeof					 EQU *					; size:   $68 (104)
						ENDR
NamesTableEntry			RECORD 0
qNext					 ds.l	1				; offset: $0 (0)		; ptr to next NTE
nt						 ds		NTElement		; offset: $4 (4)
sizeof					 EQU *					; size:   $6C (108)
						ENDR
; 
;    MPPProtocolHandlerProcs and  DDPSocketListenerProcs cannot be written 
;    in or called from a high-level language without the help of mixed mode 
;    or assembly glue because they use the following parameter-passing conventions:
;
;    typedef Boolean (*MPPProtocolHandlerProcPtr)(Ptr SCCAddr1, Ptr SCCAddr2, 
;            Ptr MPPLocalVars, Ptr nextFreeByteInRHA, Ptr ReadPacketAndReadRestPtr, 
;            short numBytesLeftToReadInPacket);
;
;        In:
;            =>  SCCAddr1                    A0.L
;            =>  SCCAddr2                    A1.L
;            =>  MPPLocalVars                A2.L
;            =>  nextFreeByteInRHA           A3.L
;            =>  ReadPacketAndReadRestPtr    A4.L
;            =>  numBytesLeftToReadInPacket  D1.W
;        Out:
;            <=  Boolean                     Z bit of CCR
;
;    typedef Boolean (*DDPSocketListenerProcPtr)(Ptr SCCAddr1, Ptr SCCAddr2, 
;            Ptr MPPLocalVars, Ptr nextFreeByteInRHA, Ptr ReadPacketAndReadRestPtr, 
;            UInt8 packetDestinationNumber, short numBytesLeftToReadInPacket);
;
;        In:
;            =>  SCCAddr1                    A0.L
;            =>  SCCAddr2                    A1.L
;            =>  MPPLocalVars                A2.L
;            =>  nextFreeByteInRHA           A3.L
;            =>  ReadPacketAndReadRestPtr    A4.L
;            =>  packetDestinationNumber     D0.B
;            =>  numBytesLeftToReadInPacket  D1.W
;        Out:
;            <=  Boolean                     Z bit of CCR
;
;

MPPParamBlock			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; next queue entry
qType					 ds.w	1				; offset: $4 (4)		; queue type
ioTrap					 ds.w	1				; offset: $6 (6)		; routine trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; routine address
ioCompletion			 ds.l	1				; offset: $C (12)		; ATPCompletionUPP or MPPCompletionUPP
ioResult				 ds.w	1				; offset: $10 (16)		; result code
userData				 ds.l	1				; offset: $12 (18)		; Command result (ATP user bytes)
reqTID					 ds.w	1				; offset: $16 (22)		; request transaction ID
ioRefNum				 ds.w	1				; offset: $18 (24)		; driver reference number
csCode					 ds.w	1				; offset: $1A (26)		; Call command code
filler0					 ds.w	1				; offset: $1C (28)
wdsPointer				 ds.l	1				; offset: $1E (30)
						 ORG 28
protType				 ds.b	1				; offset: $1C (28)
filler					 ds.b	1				; offset: $1D (29)
handler					 ds.l	1				; offset: $1E (30)
						 ORG 28
socket					 ds.b	1				; offset: $1C (28)
checksumFlag			 ds.b	1				; offset: $1D (29)
listener				 ds.l	1				; offset: $1E (30)
						 ORG 28
interval				 ds.b	1				; offset: $1C (28)		; retry interval 
count					 ds.b	1				; offset: $1D (29)		; retry count 
nbpPtrs					 ds.l	1				; offset: $1E (30)
verifyFlag				 ds.b	1				; offset: $22 (34)
filler3					 ds.b	1				; offset: $23 (35)
						 ORG 34
retBuffPtr				 ds.l	1				; offset: $22 (34)
retBuffSize				 ds.w	1				; offset: $26 (38)
maxToGet				 ds.w	1				; offset: $28 (40)
numGotten				 ds.w	1				; offset: $2A (42)
						 ORG 34
confirmAddr				 ds		AddrBlock		; offset: $22 (34)
newSocket				 ds.b	1				; offset: $26 (38)
filler4					 ds.b	1				; offset: $27 (39)
						 ORG 44
						 ORG 28
newSelfFlag				 ds.b	1				; offset: $1C (28)		; self-send toggle flag 
oldSelfFlag				 ds.b	1				; offset: $1D (29)		; previous self-send state 
						 ORG 28
nKillQEl				 ds.l	1				; offset: $1C (28)		; ptr to i/o queue element to cancel 
						 ORG 28
version					 ds.w	1				; offset: $1C (28)		; requested info version
varsPtr					 ds.l	1				; offset: $1E (30)		; pointer to well known MPP vars
DCEPtr					 ds.l	1				; offset: $22 (34)		; pointer to MPP DCE
portID					 ds.w	1				; offset: $26 (38)		; port number [0..7]
configuration			 ds.l	1				; offset: $28 (40)		; 32-bit configuration word
selfSend				 ds.w	1				; offset: $2C (44)		; non zero if SelfSend enabled
netLo					 ds.w	1				; offset: $2E (46)		; low value of network range
netHi					 ds.w	1				; offset: $30 (48)		; high value of network range
ourAdd					 ds.l	1				; offset: $32 (50)		; our 24-bit AppleTalk address
routerAddr				 ds.l	1				; offset: $36 (54)		; 24-bit address of (last) router
numOfPHs				 ds.w	1				; offset: $3A (58)		; max. number of protocol handlers
numOfSkts				 ds.w	1				; offset: $3C (60)		; max. number of static sockets
numNBPEs				 ds.w	1				; offset: $3E (62)		; max. concurrent NBP requests
nTQueue					 ds.l	1				; offset: $40 (64)		; pointer to registered name queue
LAlength				 ds.w	1				; offset: $44 (68)		; length in bytes of data link addr
linkAddr				 ds.l	1				; offset: $46 (70)		; data link address returned
zoneName				 ds.l	1				; offset: $4A (74)		; zone name returned
						 ORG 28
appName					 ds.l	1				; offset: $1C (28)		; pointer to application name in buffer
						 ORG 78
sizeof					 EQU *					; size:   $4E (78)
						ENDR
XPPParamBlock			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
cmdResult				 ds.l	1				; offset: $12 (18)
ioVRefNum				 ds.w	1				; offset: $16 (22)
ioRefNum				 ds.w	1				; offset: $18 (24)
csCode					 ds.w	1				; offset: $1A (26)
abortSCBPtr				 ds.l	1				; offset: $1C (28)		;  SCB pointer for AbortOS
						 ORG 28
aspMaxCmdSize			 ds.w	1				; offset: $1C (28)		; For SPGetParms
aspQuantumSize			 ds.w	1				; offset: $1E (30)
numSesss				 ds.w	1				; offset: $20 (32)
						 ORG 28
sessRefnum				 ds.w	1				; offset: $1C (28)		; Offset to session refnum 
aspTimeout				 ds.b	1				; offset: $1E (30)		; Timeout for ATP 
aspRetry				 ds.b	1				; offset: $1F (31)		; Retry count for ATP 
serverAddr				 ds		AddrBlock		; offset: $20 (32)		; Server address block 
scbPointer				 ds.l	1				; offset: $24 (36)		; SCB pointer 
attnRoutine				 ds.l	1				; offset: $28 (40)		; Attention routine pointer
						 ORG 32
cbSize					 ds.w	1				; offset: $20 (32)		; Command block size 
cbPtr					 ds.l	1				; offset: $22 (34)		; Command block pointer 
rbSize					 ds.w	1				; offset: $26 (38)		; Reply buffer size 
rbPtr					 ds.l	1				; offset: $28 (40)		; Reply buffer pointer 
afpAddrBlock			 ds		AddrBlock		; offset: $2C (44)		; block in AFP login 
afpSCBPtr				 ds.l	1				; offset: $30 (48)		; SCB pointer in AFP login 
afpAttnRoutine			 ds.l	1				; offset: $34 (52)		; routine pointer in AFP login 
						 ORG 44
wdSize					 ds.w	1				; offset: $2C (44)		; Write Data size
wdPtr					 ds.l	1				; offset: $2E (46)		; Write Data pointer
ccbStart				 ds.b	296				; offset: $32 (50)		; CCB memory allocated for driver afpWrite max size(CCB)=296 all other calls=150
						 ORG 28
xppSubCode				 ds.w	1				; offset: $1C (28)
xppTimeout				 ds.b	1				; offset: $1E (30)		; retry interval (seconds)
xppRetry				 ds.b	1				; offset: $1F (31)		; retry count
filler1					 ds.w	1				; offset: $20 (32)
zipBuffPtr				 ds.l	1				; offset: $22 (34)		; pointer to buffer (must be 578 bytes)
zipNumZones				 ds.w	1				; offset: $26 (38)		; no. of zone names in this response
zipLastFlag				 ds.b	1				; offset: $28 (40)		; non-zero if no more zones
filler2					 ds.b	1				; offset: $29 (41)		; filler
zipInfoField			 ds.b	70				; offset: $2A (42)		; on initial call, set first word to zero
						 ORG 346
sizeof					 EQU *					; size:   $15A (346)
						ENDR

ATPParamBlock			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; next queue entry
qType					 ds.w	1				; offset: $4 (4)		; queue type
ioTrap					 ds.w	1				; offset: $6 (6)		; routine trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; routine address
ioCompletion			 ds.l	1				; offset: $C (12)		; ATPCompletionUPP or MPPCompletionUPP
ioResult				 ds.w	1				; offset: $10 (16)		; result code
userData				 ds.l	1				; offset: $12 (18)		; Command result (ATP user bytes)
reqTID					 ds.w	1				; offset: $16 (22)		; request transaction ID
ioRefNum				 ds.w	1				; offset: $18 (24)		; driver reference number
csCode					 ds.w	1				; offset: $1A (26)		; Call command code
atpSocket				 ds.b	1				; offset: $1C (28)		; currbitmap for requests or ATP socket number
atpFlags				 ds.b	1				; offset: $1D (29)		; control information
addrBlock				 ds		AddrBlock		; offset: $1E (30)		; source/dest. socket address
reqLength				 ds.w	1				; offset: $22 (34)		; request/response length
reqPointer				 ds.l	1				; offset: $24 (36)		; ->request/response Data
bdsPointer				 ds.l	1				; offset: $28 (40)		; ->response BDS 
numOfBuffs				 ds.b	1				; offset: $2C (44)		; numOfBuffs 
timeOutVal				 ds.b	1				; offset: $2D (45)		; timeout interval 
numOfResps				 ds.b	1				; offset: $2E (46)		; number of responses actually received 
retryCount				 ds.b	1				; offset: $2F (47)		; number of retries 
intBuff					 ds.w	1				; offset: $30 (48)		; used internally for NSendRequest 
TRelTime				 ds.b	1				; offset: $32 (50)		; TRelease time for extended send request 
filler0					 ds.b	1				; offset: $33 (51)
						 ORG 44
filler					 ds.b	1				; offset: $2C (44)
bdsSize					 ds.b	1				; offset: $2D (45)		; number of BDS elements 
transID					 ds.w	1				; offset: $2E (46)		; transaction ID recd. 
						 ORG 44
bitMap					 ds.b	1				; offset: $2C (44)
filler2					 ds.b	1				; offset: $2D (45)
						 ORG 44
rspNum					 ds.b	1				; offset: $2C (44)
filler3					 ds.b	1				; offset: $2D (45)
						 ORG 44
aKillQEl				 ds.l	1				; offset: $2C (44)		; ptr to i/o queue element to cancel
						 ORG 52
sizeof					 EQU *					; size:   $34 (52)
						ENDR
	IF CALL_NOT_IN_CARBON THEN

; *  NewATalkTransitionEventUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewMPPCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewATPCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewXPPCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewAttnRoutineUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewMPPProtocolHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewDDPSocketListenerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeATalkTransitionEventUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeMPPCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeATPCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeXPPCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeAttnRoutineUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeMPPProtocolHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeDDPSocketListenerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeATalkTransitionEventUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeMPPCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeATPCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeXPPCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeAttnRoutineUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeMPPProtocolHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeDDPSocketListenerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  OpenXPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr OpenXPP(short *xppRefnum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenXPP
	ENDIF


; *  ASPOpenSession()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ASPOpenSession(XPPParmBlkPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ASPOpenSession
	ENDIF


; *  ASPCloseSession()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ASPCloseSession(XPPParmBlkPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ASPCloseSession
	ENDIF


; *  ASPAbortOS()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ASPAbortOS(XPPParmBlkPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ASPAbortOS
	ENDIF


; *  ASPGetParms()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ASPGetParms(XPPParmBlkPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ASPGetParms
	ENDIF


; *  ASPCloseAll()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ASPCloseAll(XPPParmBlkPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ASPCloseAll
	ENDIF


; *  ASPUserWrite()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ASPUserWrite(XPPParmBlkPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ASPUserWrite
	ENDIF


; *  ASPUserCommand()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ASPUserCommand(XPPParmBlkPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ASPUserCommand
	ENDIF


; *  ASPGetStatus()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ASPGetStatus(XPPParmBlkPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ASPGetStatus
	ENDIF


; *  AFPCommand()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr AFPCommand(XPPParmBlkPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AFPCommand
	ENDIF


; *  GetLocalZones()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr GetLocalZones(XPPParmBlkPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetLocalZones
	ENDIF


; *  GetZoneList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr GetZoneList(XPPParmBlkPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetZoneList
	ENDIF


; *  GetMyZone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr GetMyZone(XPPParmBlkPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetMyZone
	ENDIF


; *  PAttachPH()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PAttachPH(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PAttachPH
	ENDIF


; *  PDetachPH()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PDetachPH(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PDetachPH
	ENDIF


; *  PWriteLAP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PWriteLAP(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PWriteLAP
	ENDIF


; *  POpenSkt()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr POpenSkt(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION POpenSkt
	ENDIF


; *  PCloseSkt()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PCloseSkt(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PCloseSkt
	ENDIF


; *  PWriteDDP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PWriteDDP(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PWriteDDP
	ENDIF


; *  PRegisterName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PRegisterName(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PRegisterName
	ENDIF


; *  PLookupName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PLookupName(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PLookupName
	ENDIF


; *  PConfirmName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PConfirmName(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PConfirmName
	ENDIF


; *  PRemoveName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PRemoveName(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PRemoveName
	ENDIF


; *  PSetSelfSend()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PSetSelfSend(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PSetSelfSend
	ENDIF


; *  PKillNBP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PKillNBP(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PKillNBP
	ENDIF


; *  PGetAppleTalkInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PGetAppleTalkInfo(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PGetAppleTalkInfo
	ENDIF


; *  PATalkClosePrep()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PATalkClosePrep(MPPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PATalkClosePrep
	ENDIF


; *  POpenATPSkt()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr POpenATPSkt(ATPPBPtr thePBptr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION POpenATPSkt
	ENDIF


; *  PCloseATPSkt()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PCloseATPSkt(ATPPBPtr thePBPtr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PCloseATPSkt
	ENDIF


; *  PSendRequest()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PSendRequest(ATPPBPtr thePBPtr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PSendRequest
	ENDIF


; *  PGetRequest()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PGetRequest(ATPPBPtr thePBPtr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PGetRequest
	ENDIF


; *  PSendResponse()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PSendResponse(ATPPBPtr thePBPtr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PSendResponse
	ENDIF


; *  PAddResponse()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PAddResponse(ATPPBPtr thePBPtr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PAddResponse
	ENDIF


; *  PRelTCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PRelTCB(ATPPBPtr thePBPtr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PRelTCB
	ENDIF


; *  PRelRspCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PRelRspCB(ATPPBPtr thePBPtr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PRelRspCB
	ENDIF


; *  PNSendRequest()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PNSendRequest(ATPPBPtr thePBPtr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PNSendRequest
	ENDIF


; *  PKillSendReq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PKillSendReq(ATPPBPtr thePBPtr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PKillSendReq
	ENDIF


; *  PKillGetReq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PKillGetReq(ATPPBPtr thePBPtr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PKillGetReq
	ENDIF


; *  ATPKillAllGetReq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPKillAllGetReq(ATPPBPtr thePBPtr, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPKillAllGetReq
	ENDIF


; *  BuildLAPwds()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void BuildLAPwds(Ptr wdsPtr, Ptr dataPtr, short destHost, short prototype, short frameLen)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BuildLAPwds
	ENDIF


; *  BuildDDPwds()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void BuildDDPwds(Ptr wdsPtr, Ptr headerPtr, Ptr dataPtr, AddrBlock netAddr, short ddpType, short dataLen)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BuildDDPwds
	ENDIF


; *  NBPSetEntity()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void NBPSetEntity(Ptr buffer, ConstStr32Param nbpObject, ConstStr32Param nbpType, ConstStr32Param nbpZone)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NBPSetEntity
	ENDIF


; *  NBPSetNTE()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void NBPSetNTE(Ptr ntePtr, ConstStr32Param nbpObject, ConstStr32Param nbpType, ConstStr32Param nbpZone, short socket)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NBPSetNTE
	ENDIF


; *  GetBridgeAddress()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal short GetBridgeAddress(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetBridgeAddress
	ENDIF


; *  BuildBDS()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal short BuildBDS(Ptr buffPtr, Ptr bdsPtr, short buffSize)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BuildBDS
	ENDIF


; *  MPPOpen()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr MPPOpen(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MPPOpen
	ENDIF


; *  LAPAddATQ()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr LAPAddATQ(ATQEntryPtr theATQEntry)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LAPAddATQ
	ENDIF


; *  LAPRmvATQ()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr LAPRmvATQ(ATQEntryPtr theATQEntry)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LAPRmvATQ
	ENDIF


; *  ATPLoad()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPLoad(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPLoad
	ENDIF


; *  ATPUnload()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPUnload(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPUnload
	ENDIF


; *  NBPExtract()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr NBPExtract(Ptr theBuffer, short numInBuf, short whichOne, EntityName *abEntity, AddrBlock *address)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NBPExtract
	ENDIF


; *  GetNodeAddress()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr GetNodeAddress(short *myNode, short *myNet)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetNodeAddress
	ENDIF


; *  IsMPPOpen()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Boolean IsMPPOpen(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsMPPOpen
	ENDIF


; *  IsATPOpen()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Boolean IsATPOpen(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsATPOpen
	ENDIF


; *  ATEvent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void ATEvent(long event, Ptr infoPtr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATEvent
	ENDIF


; *  ATPreFlightEvent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPreFlightEvent(long event, long cancel, Ptr infoPtr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPreFlightEvent
	ENDIF

; 
;    The following routines are obsolete and will not be supported on
;    PowerPC. Equivalent functionality is provided by the routines
;    above.
;

	ENDIF	; CALL_NOT_IN_CARBON
	IF TARGET_CPU_68K THEN
	IF CALL_NOT_IN_CARBON THEN

; *  MPPClose()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr MPPClose(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MPPClose
	ENDIF


; *  LAPOpenProtocol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr LAPOpenProtocol(ABByte theLAPType, Ptr protoPtr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LAPOpenProtocol
	ENDIF


; *  LAPCloseProtocol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr LAPCloseProtocol(ABByte theLAPType)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LAPCloseProtocol
	ENDIF


; *  LAPWrite()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr LAPWrite(ATLAPRecHandle abRecord, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LAPWrite
	ENDIF


; *  LAPRead()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr LAPRead(ATLAPRecHandle abRecord, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LAPRead
	ENDIF


; *  LAPRdCancel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr LAPRdCancel(ATLAPRecHandle abRecord)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LAPRdCancel
	ENDIF


; *  DDPOpenSocket()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr DDPOpenSocket(short *theSocket, Ptr sktListener)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DDPOpenSocket
	ENDIF


; *  DDPCloseSocket()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr DDPCloseSocket(short theSocket)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DDPCloseSocket
	ENDIF


; *  DDPRead()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr DDPRead(ATDDPRecHandle abRecord, Boolean retCksumErrs, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DDPRead
	ENDIF


; *  DDPWrite()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr DDPWrite(ATDDPRecHandle abRecord, Boolean doChecksum, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DDPWrite
	ENDIF


; *  DDPRdCancel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr DDPRdCancel(ATDDPRecHandle abRecord)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DDPRdCancel
	ENDIF


; *  ATPOpenSocket()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPOpenSocket(AddrBlock addrRcvd, short *atpSocket)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPOpenSocket
	ENDIF


; *  ATPCloseSocket()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPCloseSocket(short atpSocket)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPCloseSocket
	ENDIF


; *  ATPSndRequest()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPSndRequest(ATATPRecHandle abRecord, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPSndRequest
	ENDIF


; *  ATPRequest()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPRequest(ATATPRecHandle abRecord, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPRequest
	ENDIF


; *  ATPReqCancel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPReqCancel(ATATPRecHandle abRecord, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPReqCancel
	ENDIF


; *  ATPGetRequest()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPGetRequest(ATATPRecHandle abRecord, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPGetRequest
	ENDIF


; *  ATPSndRsp()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPSndRsp(ATATPRecHandle abRecord, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPSndRsp
	ENDIF


; *  ATPAddRsp()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPAddRsp(ATATPRecHandle abRecord)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPAddRsp
	ENDIF


; *  ATPResponse()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPResponse(ATATPRecHandle abRecord, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPResponse
	ENDIF


; *  ATPRspCancel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr ATPRspCancel(ATATPRecHandle abRecord, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ATPRspCancel
	ENDIF


; *  NBPRegister()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr NBPRegister(ATNBPRecHandle abRecord, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NBPRegister
	ENDIF


; *  NBPLookup()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr NBPLookup(ATNBPRecHandle abRecord, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NBPLookup
	ENDIF


; *  NBPConfirm()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr NBPConfirm(ATNBPRecHandle abRecord, Boolean async)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NBPConfirm
	ENDIF


; *  NBPRemove()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr NBPRemove(EntityPtr abEntity)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NBPRemove
	ENDIF


; *  NBPLoad()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr NBPLoad(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NBPLoad
	ENDIF


; *  NBPUnload()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr NBPUnload(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NBPUnload
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF	; TARGET_CPU_68K
	ENDIF ; __APPLETALK__ 


;
;    File:       CGDirectDisplay.a
;
;    Contains:   xxx put contents here xxx
;
;    Version:    Technology: from CoreGraphics-93.14
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  Â© 2000-2001 by Apple Computer, Inc., all rights reserved.
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__CGDIRECTDISPLAY__') = 'UNDEFINED' THEN
__CGDIRECTDISPLAY__ SET 1

	IF &TYPE('__CGBASE__') = 'UNDEFINED' THEN
	include 'CGBase.a'
	ENDIF
	IF &TYPE('__CGGEOMETRY__') = 'UNDEFINED' THEN
	include 'CGGeometry.a'
	ENDIF
	IF &TYPE('__CGERROR__') = 'UNDEFINED' THEN
	include 'CGError.a'
	ENDIF
	IF &TYPE('__CFARRAY__') = 'UNDEFINED' THEN
	include 'CFArray.a'
	ENDIF
	IF &TYPE('__CFSTRING__') = 'UNDEFINED' THEN
	include 'CFString.a'
	ENDIF
	IF &TYPE('__CFDICTIONARY__') = 'UNDEFINED' THEN
	include 'CFDictionary.a'
	ENDIF





; typedef u_int32_t 					CGDisplayCount

; typedef u_int32_t 					CGTableCount

; typedef int32_t 						CGDisplayCoord

; typedef u_int8_t 						CGByteValue

; typedef u_int32_t 					CGOpenGLDisplayMask

; typedef u_int32_t 					CGBeamPosition

; typedef int32_t 						CGMouseDelta

; typedef double 						CGRefreshRate

; typedef CGError 						CGDisplayErr


CGDisplayNoErr					EQU		0
;  A NULL value points to the main display device as a programming convention 
; #define kCGDirectMainDisplay ((CGDirectDisplayID)NULL)

; 
; * Mechanisms used to find screen IDs
; * An array length (maxDisplays) and array of CGDirectDisplayIDs are passed in.
; * Up to maxDisplays of the array are filled in with the displays meeting the
; * specified criteria.  The actual number of displays filled in is returned in
; * dspyCnt.
; *
; * If the dspys array is NULL, maxDisplays is ignored, and *dspyCnt is filled
; * in with the number of displays meeting the function's requirements.
; 


; *  CGGetDisplaysWithPoint()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGGetDisplaysWithPoint(CGPoint point, CGDisplayCount maxDisplays, CGDirectDisplayID *dspys, CGDisplayCount *dspyCnt)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGGetDisplaysWithPoint
	ENDIF


; *  CGGetDisplaysWithRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGGetDisplaysWithRect(CGRect rect, CGDisplayCount maxDisplays, CGDirectDisplayID *dspys, CGDisplayCount *dspyCnt)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGGetDisplaysWithRect
	ENDIF


; *  CGGetDisplaysWithOpenGLDisplayMask()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGGetDisplaysWithOpenGLDisplayMask(CGOpenGLDisplayMask mask, CGDisplayCount maxDisplays, CGDirectDisplayID *dspys, CGDisplayCount *dspyCnt)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGGetDisplaysWithOpenGLDisplayMask
	ENDIF

; 
; * Get lists of displays.  Use this to determine display IDs
; *
; * If the activeDspys array is NULL, maxDisplays is ignored, and *dspyCnt is filled
; * in with the number of displays meeting the function's requirements.
; *
; * The first display returned in the list is the main display,
; * the one with the menu bar.
; * When mirroring, this will be the largest display,
; * or if all are the same size, the one with the deepest pixel depth.
; 


; *  CGGetActiveDisplayList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGGetActiveDisplayList(CGDisplayCount maxDisplays, CGDirectDisplayID *activeDspys, CGDisplayCount *dspyCnt)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGGetActiveDisplayList
	ENDIF

;  Map a display to an OpenGL display mask; returns 0 on invalid display 

; *  CGDisplayIDToOpenGLDisplayMask()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGOpenGLDisplayMask CGDisplayIDToOpenGLDisplayMask(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayIDToOpenGLDisplayMask
	ENDIF

;  Return screen size and origin in global coords; Empty rect if display is invalid 

; *  CGDisplayBounds()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGRect CGDisplayBounds(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayBounds
	ENDIF


; *  CGDisplayPixelsWide()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern size_t CGDisplayPixelsWide(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayPixelsWide
	ENDIF


; *  CGDisplayPixelsHigh()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern size_t CGDisplayPixelsHigh(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayPixelsHigh
	ENDIF

; 
; * Display mode selection
; * Display modes are represented as CFDictionaries
; * All dictionaries and arrays returned via these mechanisms are
; * owned by the framework and should not be released.  The framework
; * will not release them out from under your application.
; *
; * Values associated with the following keys are CFNumber types.
; * With CFNumberGetValue(), use kCFNumberLongType for best results.
; 

; 
; * Keys used in mode dictionaries.  Source C strings shown won't change.
; * Some CFM environments cannot import data variables, and so
; * duplicate these CFStringRefs locally.
; 


; *  kCGDisplayWidth
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 


; *  kCGDisplayHeight
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 


; *  kCGDisplayMode
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 


; *  kCGDisplayBitsPerPixel
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 


; *  kCGDisplayBitsPerSample
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 


; *  kCGDisplaySamplesPerPixel
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 


; *  kCGDisplayRefreshRate
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 


; *  kCGDisplayModeUsableForDesktopGUI
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 


; *  kCGDisplayIOFlags
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

; 
; * Return a CFArray of CFDictionaries describing all display modes.
; * Returns NULL if the display is invalid.
; 


; *  CGDisplayAvailableModes()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CFArrayRef CGDisplayAvailableModes(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayAvailableModes
	ENDIF

; 
; * Try to find a display mode of specified depth with dimensions equal or greater than
; * specified.
; * If no depth match is found, try for the next larger depth with dimensions equal or greater
; * than specified.  If no luck, then just return the current mode.
; *
; * exactmatch, if not NULL, is set to 'true' if an exact match in width, height, and depth is found,
; * and 'false' otherwise.
; * Returns NULL if display is invalid.
; 


; *  CGDisplayBestModeForParameters()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CFDictionaryRef CGDisplayBestModeForParameters(CGDirectDisplayID display, size_t bitsPerPixel, size_t width, size_t height, boolean_t *exactMatch)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayBestModeForParameters
	ENDIF


; *  CGDisplayBestModeForParametersAndRefreshRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CFDictionaryRef CGDisplayBestModeForParametersAndRefreshRate(CGDirectDisplayID display, size_t bitsPerPixel, size_t width, size_t height, CGRefreshRate refresh, boolean_t *exactMatch)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayBestModeForParametersAndRefreshRate
	ENDIF

; 
; * Return a CFDictionary describing the current display mode.
; * Returns NULL if display is invalid.
; 


; *  CGDisplayCurrentMode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CFDictionaryRef CGDisplayCurrentMode(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayCurrentMode
	ENDIF

; 
; * Switch display mode.  Note that after switching, 
; * display parameters and addresses may change.
; * The selected display mode persists for the life of the program, and automatically
; * reverts to the permanent setting made by Preferences when the program terminates.
; * The mode dictionary passed in must be a dictionary vended by other CGDirectDisplay
; * APIs such as CGDisplayBestModeForParameters() and CGDisplayAvailableModes().
; 


; *  CGDisplaySwitchToMode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGDisplaySwitchToMode(CGDirectDisplayID display, CFDictionaryRef mode)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplaySwitchToMode
	ENDIF

;  Query parameters for current mode 

; *  CGDisplayBitsPerPixel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern size_t CGDisplayBitsPerPixel(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayBitsPerPixel
	ENDIF


; *  CGDisplayBitsPerSample()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern size_t CGDisplayBitsPerSample(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayBitsPerSample
	ENDIF


; *  CGDisplaySamplesPerPixel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern size_t CGDisplaySamplesPerPixel(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplaySamplesPerPixel
	ENDIF


; *  CGDisplayBytesPerRow()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern size_t CGDisplayBytesPerRow(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayBytesPerRow
	ENDIF

; 
; * Set a display gamma/transfer function from a formula specifying
; * min and max values and a gamma for each channel.
; * Gamma values must be greater than 0.0.
; * To get an antigamma of 1.6, one would specify a value of (1.0 / 1.6)
; * Min values must be greater than or equal to 0.0 and less than 1.0.
; * Max values must be greater than 0.0 and less than or equal to 1.0.
; * Out of range values, or Max greater than or equal to Min result
; * in a kCGSRangeCheck error.
; *
; * Values are computed by sampling a function for a range of indices from 0 through 1:
; *  value = Min + ((Max - Min) * pow(index, Gamma))
; * The resulting values are converted to a machine specific format
; * and loaded into hardware.
; 

; typedef float 						CGGammaValue


; *  CGSetDisplayTransferByFormula()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGSetDisplayTransferByFormula(CGDirectDisplayID display, CGGammaValue redMin, CGGammaValue redMax, CGGammaValue redGamma, CGGammaValue greenMin, CGGammaValue greenMax, CGGammaValue greenGamma, CGGammaValue blueMin, CGGammaValue blueMax, CGGammaValue blueGamma)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGSetDisplayTransferByFormula
	ENDIF


; *  CGGetDisplayTransferByFormula()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGGetDisplayTransferByFormula(CGDirectDisplayID display, CGGammaValue *redMin, CGGammaValue *redMax, CGGammaValue *redGamma, CGGammaValue *greenMin, CGGammaValue *greenMax, CGGammaValue *greenGamma, CGGammaValue *blueMin, CGGammaValue *blueMax, CGGammaValue *blueGamma)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGGetDisplayTransferByFormula
	ENDIF

; 
; * Set a display gamma/transfer function using tables of data for each channel.
; * Values within each table should have values in the range of 0.0 through 1.0.
; * The same table may be passed in for red, green, and blue channels. 'tableSize'
; * indicates the number of entries in each table.
; * The tables are interpolated as needed to generate the number of samples needed
; * by hardware.
; 


; *  CGSetDisplayTransferByTable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGSetDisplayTransferByTable(CGDirectDisplayID display, CGTableCount tableSize, const CGGammaValue *redTable, const CGGammaValue *greenTable, const CGGammaValue *blueTable)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGSetDisplayTransferByTable
	ENDIF

; 
; * Get transfer tables.  Capacity should contain the number of samples each
; * array can hold, and *sampleCount is filled in with the number of samples
; * actually copied in.
; 


; *  CGGetDisplayTransferByTable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGGetDisplayTransferByTable(CGDirectDisplayID display, CGTableCount capacity, CGGammaValue *redTable, CGGammaValue *greenTable, CGGammaValue *blueTable, CGTableCount *sampleCount)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGGetDisplayTransferByTable
	ENDIF

;  As a convenience, allow setting of the gamma table by byte values 

; *  CGSetDisplayTransferByByteTable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGSetDisplayTransferByByteTable(CGDirectDisplayID display, CGTableCount tableSize, const CGByteValue *redTable, const CGByteValue *greenTable, const CGByteValue *blueTable)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGSetDisplayTransferByByteTable
	ENDIF

;  Restore gamma tables of system displays to the user's ColorSync specified values 

; *  CGDisplayRestoreColorSyncSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void CGDisplayRestoreColorSyncSettings(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayRestoreColorSyncSettings
	ENDIF

;  Display capture and release 

; *  CGDisplayIsCaptured()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern boolean_t CGDisplayIsCaptured(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayIsCaptured
	ENDIF


; *  CGDisplayCapture()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGDisplayCapture(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayCapture
	ENDIF


; *  CGDisplayRelease()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGDisplayRelease(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayRelease
	ENDIF


; 
; * Capture all displays; this has the nice effect of providing an immersive
; * environment, and preventing other apps from trying to adjust themselves
; * to display changes only needed by your app.
; 


; *  CGCaptureAllDisplays()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGCaptureAllDisplays(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGCaptureAllDisplays
	ENDIF

; 
; * Release all captured displays, and restore the display modes to the
; * user's preferences.  May be used in conjunction with CGDisplayCapture()
; * or CGCaptureAllDisplays().
; 


; *  CGReleaseAllDisplays()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGReleaseAllDisplays(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGReleaseAllDisplays
	ENDIF


; 
; * Returns CoreGraphics raw shield window ID or NULL if not shielded
; * This value may be used with drawing surface APIs.
; 


; *  CGShieldingWindowID()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void *CGShieldingWindowID(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGShieldingWindowID
	ENDIF

; 
; * Returns the window level used for the shield window.
; * This value may be used with Cocoa windows to position the
; * Cocoa window in the same window level as the shield window.
; 


; *  CGShieldingWindowLevel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int32_t CGShieldingWindowLevel(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGShieldingWindowLevel
	ENDIF

; 
; * Returns base address of display or NULL for an invalid display.
; * If the display has not been captured, the returned address may refer
; * to read-only memory.
; 


; *  CGDisplayBaseAddress()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void *CGDisplayBaseAddress(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayBaseAddress
	ENDIF

; 
; * return address for X,Y in screen coordinates;
; *  (0,0) represents the upper left corner of the display.
; * returns NULL for an invalid display or out of bounds coordinates
; * If the display has not been captured, the returned address may refer
; * to read-only memory.
; 


; *  CGDisplayAddressForPosition()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void *CGDisplayAddressForPosition(CGDirectDisplayID display, CGDisplayCoord x, CGDisplayCoord y)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayAddressForPosition
	ENDIF


;  Mouse Cursor controls 

; *  CGDisplayHideCursor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGDisplayHideCursor(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayHideCursor
	ENDIF

;  increments hide cursor count 

; *  CGDisplayShowCursor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGDisplayShowCursor(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayShowCursor
	ENDIF

;  decrements hide cursor count  
; 
; * Move the cursor to the specified point relative to the display origin
; * (the upper left corner of the display).  Returns CGDisplayNoErr on success.
; * No events are generated as a result of this move.
; * Points that would lie outside the desktop are clipped to the desktop.
; 


; *  CGDisplayMoveCursorToPoint()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGDisplayMoveCursorToPoint(CGDirectDisplayID display, CGPoint point)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayMoveCursorToPoint
	ENDIF

; 
; * Report the mouse position change associated with the last mouse move event
; * recieved by this application.
; 


; *  CGGetLastMouseDelta()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void CGGetLastMouseDelta(CGMouseDelta *deltaX, CGMouseDelta *deltaY)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGGetLastMouseDelta
	ENDIF


;  Palette controls (8 bit pseudocolor only) 
; 
; * Returns TRUE if the current display mode supports palettes
; 


; *  CGDisplayCanSetPalette()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern boolean_t CGDisplayCanSetPalette(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayCanSetPalette
	ENDIF

; 
; * Set a palette.  The current gamma function is applied to the palette
; * elements before being loaded into hardware.
; 


; *  CGDisplaySetPalette()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGDisplaySetPalette(CGDirectDisplayID display, CGDirectPaletteRef palette)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplaySetPalette
	ENDIF

; 
; * Wait until the beam position is outside the range specified by upperScanLine and lowerScanLine.
; * Note that if upperScanLine and lowerScanLine encompass the entire display height,
; * the function returns an error.
; * lowerScanLine must be greater than or equal to upperScanLine.
; *
; * Some display systems may not conventional video vertical and horizontal sweep in painting.
; * These displays report a kCGDisplayRefreshRate of 0 in the CFDictionaryRef returned by
; * CGDisplayCurrentMode().  On such displays, this function returns at once.
; *
; * Some drivers may not implement support for this mechanism.
; * On such displays, this function returns at once.
; *
; * Returns CGDisplayNoErr on success, and an error if display or upperScanLine and
; * lowerScanLine are invalid.
; *
; * The app should set the values of upperScanLine and lowerScanLine to allow enough lead time
; * for the drawing operation to complete.  A common strategy is to wait for the beam to pass
; * the bottom of the drawing area, allowing almost a full vertical sweep period to perform drawing.
; * To do this, set upperScanLine to 0, and set lowerScanLine to the bottom of the bounding box:
; *  lowerScanLine = (CGBeamPosition)(cgrect.origin.y + cgrect.size.height);
; 


; *  CGDisplayWaitForBeamPositionOutsideLines()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGDisplayErr CGDisplayWaitForBeamPositionOutsideLines(CGDirectDisplayID display, CGBeamPosition upperScanLine, CGBeamPosition lowerScanLine)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayWaitForBeamPositionOutsideLines
	ENDIF

; 
; * Returns the current beam position on the display.  If display is invalid,
; * or the display does not implement conventional video vertical and horizontal
; * sweep in painting, or the driver does not implement this functionality, 0 is returned.
; 


; *  CGDisplayBeamPosition()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGBeamPosition CGDisplayBeamPosition(CGDirectDisplayID display)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGDisplayBeamPosition
	ENDIF

	ENDIF ; __CGDIRECTDISPLAY__ 


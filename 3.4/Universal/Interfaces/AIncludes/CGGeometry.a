;
;    File:       CGGeometry.a
;
;    Contains:   xxx put contents here xxx
;
;    Version:    Technology: from CoreGraphics-70.root
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  Â© 2000-2001 by Apple Computer, Inc., all rights reserved.
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__CGGEOMETRY__') = 'UNDEFINED' THEN
__CGGEOMETRY__ SET 1

	IF &TYPE('__CGBASE__') = 'UNDEFINED' THEN
	include 'CGBase.a'
	ENDIF

;  Points. 
CGPoint					RECORD 0
x						 ds		Float32			; offset: $0 (0)
y						 ds		Float32			; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  Sizes. 
CGSize					RECORD 0
width					 ds		Float32			; offset: $0 (0)
height					 ds		Float32			; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  Rectangles. 
CGRect					RECORD 0
origin					 ds		CGPoint			; offset: $0 (0)
size					 ds		CGSize			; offset: $8 (8)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
;  Rectangle edges. 

; typedef long							CGRectEdge
CGRectMinXEdge					EQU		0
CGRectMinYEdge					EQU		1
CGRectMaxXEdge					EQU		2
CGRectMaxYEdge					EQU		3
;  The "zero" point -- equivalent to CGPointMake(0, 0). 

; *  CGPointZero
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;  The "zero" size -- equivalent to CGSizeMake(0, 0). 

; *  CGSizeZero
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;  The "zero" rectangle -- equivalent to CGRectMake(0, 0, 0, 0). 

; *  CGRectZero
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;  The "empty" rect.  This is the rectangle returned when, for example, we
; * intersect two disjoint rectangles.  Note that the null rect is not the
; * same as the zero rect. 


; *  CGRectNull
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 


;  Make a point from `(x, y)'. 

; *  CGPointMake()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGPoint CGPointMake(float x, float y)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGPointMake
	ENDIF

;  Make a size from `(width, height)'. 

; *  CGSizeMake()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGSize CGSizeMake(float width, float height)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGSizeMake
	ENDIF

;  Make a rect from `(x, y; width, height)'. 

; *  CGRectMake()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGRect CGRectMake(float x, float y, float width, float height)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectMake
	ENDIF

;  Return the leftmost x-value of `rect'. 

; *  CGRectGetMinX()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern float CGRectGetMinX(CGRect rect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectGetMinX
	ENDIF

;  Return the midpoint x-value of `rect'. 

; *  CGRectGetMidX()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern float CGRectGetMidX(CGRect rect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectGetMidX
	ENDIF

;  Return the rightmost x-value of `rect'. 

; *  CGRectGetMaxX()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern float CGRectGetMaxX(CGRect rect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectGetMaxX
	ENDIF

;  Return the bottommost y-value of `rect'. 

; *  CGRectGetMinY()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern float CGRectGetMinY(CGRect rect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectGetMinY
	ENDIF

;  Return the midpoint y-value of `rect'. 

; *  CGRectGetMidY()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern float CGRectGetMidY(CGRect rect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectGetMidY
	ENDIF

;  Return the topmost y-value of `rect'. 

; *  CGRectGetMaxY()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern float CGRectGetMaxY(CGRect rect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectGetMaxY
	ENDIF

;  Return the width of `rect'. 

; *  CGRectGetWidth()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern float CGRectGetWidth(CGRect rect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectGetWidth
	ENDIF

;  Return the height of `rect'. 

; *  CGRectGetHeight()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern float CGRectGetHeight(CGRect rect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectGetHeight
	ENDIF

;  Return 1 if `point1' and `point2' are the same, 0 otherwise. 

; *  CGPointEqualToPoint()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int CGPointEqualToPoint(CGPoint point1, CGPoint point2)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGPointEqualToPoint
	ENDIF

;  Return 1 if `size1' and `size2' are the same, 0 otherwise. 

; *  CGSizeEqualToSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int CGSizeEqualToSize(CGSize size1, CGSize size2)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGSizeEqualToSize
	ENDIF

;  Return 1 if `rect1' and `rect2' are the same, 0 otherwise. 

; *  CGRectEqualToRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int CGRectEqualToRect(CGRect rect1, CGRect rect2)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectEqualToRect
	ENDIF

;  Standardize `rect' -- i.e., convert it to an equivalent rect which has
; * positive width and height. 

; *  CGRectStandardize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGRect CGRectStandardize(CGRect rect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectStandardize
	ENDIF

;  Return 1 if `rect' is empty -- i.e., if it has zero width or height.  A
; * null rect is defined to be empty. 

; *  CGRectIsEmpty()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int CGRectIsEmpty(CGRect rect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectIsEmpty
	ENDIF

;  Return 1 if `rect' is null -- e.g., the result of intersecting two
; * disjoint rectangles is a null rect. 

; *  CGRectIsNull()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int CGRectIsNull(CGRect rect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectIsNull
	ENDIF

;  Inset `rect' by `(dx, dy)' -- i.e., offset its origin by `(dx, dy)', and
; * decrease its size by `(2*dx, 2*dy)'. 

; *  CGRectInset()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGRect CGRectInset(CGRect rect, float dx, float dy)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectInset
	ENDIF

;  Expand `rect' to the smallest rect containing it with integral origin
; * and size. 

; *  CGRectIntegral()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGRect CGRectIntegral(CGRect rect)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectIntegral
	ENDIF

;  Return the union of `r1' and `r2'. 

; *  CGRectUnion()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGRect CGRectUnion(CGRect r1, CGRect r2)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectUnion
	ENDIF

;  Return the intersection of `r1' and `r2'.  This may return a null
; * rect. 

; *  CGRectIntersection()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGRect CGRectIntersection(CGRect r1, CGRect r2)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectIntersection
	ENDIF

;  Offset `rect' by `(dx, dy)'. 

; *  CGRectOffset()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern CGRect CGRectOffset(CGRect rect, float dx, float dy)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectOffset
	ENDIF

;  Make two new rectangles, `slice' and `remainder', by dividing `rect'
; * with a line that's parallel to one of its sides, specified by `edge' --
; * either `CGRectMinXEdge', `CGRectMinYEdge', `CGRectMaxXEdge', or
; * `CGRectMaxYEdge'.  The size of `slice' is determined by `amount', which
; * measures the distance from the specified edge. 


; *  CGRectDivide()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void CGRectDivide(CGRect rect, CGRect *slice, CGRect *remainder, float amount, CGRectEdge edge)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectDivide
	ENDIF

;  Return 1 if `point' is contained in `rect', 0 otherwise. 

; *  CGRectContainsPoint()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int CGRectContainsPoint(CGRect rect, CGPoint point)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectContainsPoint
	ENDIF

;  Return 1 if `rect2' is contained in `rect1', 0 otherwise.  `rect2' is
; * contained in `rect1' if the union of `rect1' and `rect2' is equal to
; * `rect1'. 


; *  CGRectContainsRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int CGRectContainsRect(CGRect rect1, CGRect rect2)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectContainsRect
	ENDIF

;  Return 1 if `rect1' intersects `rect2', 0 otherwise.  `rect1' intersects
; * `rect2' if the intersection of `rect1' and `rect2' is not the null
; * rect. 


; *  CGRectIntersectsRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int CGRectIntersectsRect(CGRect rect1, CGRect rect2)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CGRectIntersectsRect
	ENDIF



	ENDIF ; __CGGEOMETRY__ 


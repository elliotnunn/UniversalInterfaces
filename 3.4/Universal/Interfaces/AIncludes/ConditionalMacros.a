;
;    File:       ConditionalMacros.a
;
;    Contains:   Set up for compiler independent conditionals
;
;    Version:    Technology: Universal Interface Files
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1993-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__CONDITIONALMACROS__') = 'UNDEFINED' THEN
__CONDITIONALMACROS__ SET 1

; ****************************************************************************************************
;    UNIVERSAL_INTERFACES_VERSION
;    
;        0x0400 --> version 4.0 (Mac OS X only)
;        0x0335 --> version 3.4 
;        0x0331 --> version 3.3.1
;        0x0330 --> version 3.3
;        0x0320 --> version 3.2
;        0x0310 --> version 3.1
;        0x0301 --> version 3.0.1
;        0x0300 --> version 3.0
;        0x0210 --> version 2.1
;        This conditional did not exist prior to version 2.1
;***************************************************************************************************

UNIVERSAL_INTERFACES_VERSION EQU $0340


; ****************************************************************************************************
;
;    TARGET_CPU_≈    
;    These conditionals specify which microprocessor instruction set is being
;    generated.  At most one of these is true, the rest are false.
;
;        TARGET_CPU_PPC          - Compiler is generating PowerPC instructions
;        TARGET_CPU_68K          - Compiler is generating 680x0 instructions
;        TARGET_CPU_X86          - Compiler is generating x86 instructions
;        TARGET_CPU_MIPS         - Compiler is generating MIPS instructions
;        TARGET_CPU_SPARC        - Compiler is generating Sparc instructions
;        TARGET_CPU_ALPHA        - Compiler is generating Dec Alpha instructions
;
;
;    TARGET_OS_≈ 
;    These conditionals specify in which Operating System the generated code will
;    run. At most one of the these is true, the rest are false.
;
;        TARGET_OS_MAC           - Generate code will run under Mac OS
;        TARGET_OS_WIN32         - Generate code will run under 32-bit Windows
;        TARGET_OS_UNIX          - Generate code will run under some unix 
;
;
;    TARGET_RT_≈ 
;    These conditionals specify in which runtime the generated code will
;    run. This is needed when the OS and CPU support more than one runtime
;    (e.g. MacOS on 68K supports CFM68K and Classic 68k).
;
;        TARGET_RT_LITTLE_ENDIAN - Generated code uses little endian format for integers
;        TARGET_RT_BIG_ENDIAN    - Generated code uses big endian format for integers    
;        TARGET_RT_MAC_CFM       - TARGET_OS_MAC is true and CFM68K or PowerPC CFM (TVectors) are used
;        TARGET_RT_MAC_MACHO     - TARGET_OS_MAC is true and Mach-O style runtime
;        TARGET_RT_MAC_68881     - TARGET_OS_MAC is true and 68881 floating point instructions used  
;
;
;    TARGET__API_≈_≈ 
;    These conditionals are used to differentiate between sets of API's on the same
;    processor under the same OS.  The first section after _API_ is the OS.  The
;    second section is the API set.  Unlike TARGET_OS_ and TARGET_CPU_, these
;    conditionals are not mutally exclusive. This file will attempt to auto-configure
;    all TARGET_API_≈_≈ values, but will often need a TARGET_API_≈_≈ value predefined
;    in order to disambiguate.
;    
;        TARGET_API_MAC_OS8      - Code is being compiled to run on System 7 through Mac OS 8.x
;        TARGET_API_MAC_CARBON   - Code is being compiled to run on Mac OS 8 and Mac OS X via CarbonLib
;        TARGET_API_MAC_OSX      - Code is being compiled to run on Mac OS X
;
;
;    PRAGMA_≈
;    These conditionals specify whether the compiler supports particular #pragma's
;    
;        PRAGMA_IMPORT           - Compiler supports: #pragma import on/off/reset
;        PRAGMA_ONCE             - Compiler supports: #pragma once
;        PRAGMA_STRUCT_ALIGN     - Compiler supports: #pragma options align=mac68k/power/reset
;        PRAGMA_STRUCT_PACK      - Compiler supports: #pragma pack(n)
;        PRAGMA_STRUCT_PACKPUSH  - Compiler supports: #pragma pack(push, n)/pack(pop)
;        PRAGMA_ENUM_PACK        - Compiler supports: #pragma options(!pack_enums)
;        PRAGMA_ENUM_ALWAYSINT   - Compiler supports: #pragma enumsalwaysint on/off/reset
;        PRAGMA_ENUM_OPTIONS     - Compiler supports: #pragma options enum=int/small/reset
;
;
;    FOUR_CHAR_CODE
;    This conditional does the proper byte swapping to assue that a four character code (e.g. 'TEXT')
;    is compiled down to the correct value on all compilers.
;
;        FOUR_CHAR_CODE('abcd')  - Convert a four-char-code to the correct 32-bit value
;
;
;    TYPE_≈
;    These conditionals specify whether the compiler supports particular types.
;
;        TYPE_LONGLONG               - Compiler supports "long long" 64-bit integers
;        TYPE_BOOL                   - Compiler supports "bool"
;        TYPE_EXTENDED               - Compiler supports "extended" 80/96 bit floating point
;        TYPE_LONGDOUBLE_IS_DOUBLE   - Compiler implements "long double" same as "double"
;
;
;    FUNCTION_≈
;    These conditionals specify whether the compiler supports particular language extensions
;    to function prototypes and definitions.
;
;        FUNCTION_PASCAL         - Compiler supports "pascal void Foo()"
;        FUNCTION_DECLSPEC       - Compiler supports "__declspec(xxx) void Foo()"
;        FUNCTION_WIN32CC        - Compiler supports "void __cdecl Foo()" and "void __stdcall Foo()"
;
;***************************************************************************************************



    IF &TYPE('PowerAsm') <> 'UNDEFINED' THEN
        ;
        ;   PPCAsm PowerPC assembler from Apple Computer, Inc.  
        ;
        TARGET_CPU_68K:             SET     0
        TARGET_CPU_PPC:             SET     1
        TARGET_CPU_X86:             SET     0
        TARGET_CPU_MIPS:            SET     0
        TARGET_CPU_SPARC:           SET     0
        TARGET_RT_MAC_CFM:          SET     1
        TARGET_RT_MAC_MACHO:        SET     0
        TARGET_RT_MAC_68881:        SET     0
        TARGET_OS_MAC:              SET     1
        TARGET_OS_WIN32:            SET     0
        TARGET_OS_UNIX:             SET     0
        TARGET_RT_LITTLE_ENDIAN:    SET     0
        TARGET_RT_BIG_ENDIAN:       SET     1
        TYPE_EXTENDED:              SET     0
        TYPE_LONGLONG:              SET     0
        TYPE_BOOL:                  SET     0
    ELSE
        ;
        ;   Asm 68K assembler from Apple Computer, Inc. 
        ;
        TARGET_CPU_68K:             SET     1
        TARGET_CPU_PPC:             SET     0
        TARGET_CPU_X86:             SET     0
        TARGET_CPU_MIPS:            SET     0
        TARGET_CPU_SPARC:           SET     0
        IF (&TYPE('&SYSMODEL') <> 'UNDEFINED') AND (&SYSMODEL = '__CFM68K__') THEN
            TARGET_RT_MAC_CFM:      SET     1   
        ELSE
            TARGET_RT_MAC_CFM:      SET     0   
        ENDIF
        TARGET_RT_MAC_MACHO:        SET     0
        IF &TYPE('FP0') = 'FPREG FP0' THEN
            TARGET_RT_MAC_68881:    SET     1   
        ELSE
            TARGET_RT_MAC_68881:    SET     0   
        ENDIF
        TARGET_OS_MAC:              SET     1
        TARGET_OS_WIN32:            SET     0
        TARGET_OS_UNIX:             SET     0
        TARGET_RT_LITTLE_ENDIAN:    SET     0
        TARGET_RT_BIG_ENDIAN:       SET     1
        TYPE_EXTENDED:              SET     1
        TYPE_LONGLONG:              SET     0
        TYPE_BOOL:                  SET     0
    ENDIF


; ****************************************************************************************************
;    
;    Set up TARGET_API_≈_≈ values
;
;***************************************************************************************************

	IF TARGET_OS_MAC THEN
	IF ¬ (&TYPE('TARGET_API_MAC_OS8') <> 'UNDEFINED') ** ¬ (&TYPE('TARGET_API_MAC_OSX') <> 'UNDEFINED') ** ¬ (&TYPE('TARGET_API_MAC_CARBON') <> 'UNDEFINED') THEN
	IF TARGET_CPU_PPC ** TARGET_RT_MAC_CFM THEN
;  Looks like CFM style PPC compiler 
	TARGET_API_MAC_OS8: SET 1
	TARGET_API_MAC_CARBON: SET 0
	TARGET_API_MAC_OSX: SET 0
	ELSEIF TARGET_RT_MAC_MACHO THEN
;  Looks like MachO style PPC compiler 
	TARGET_API_MAC_OS8: SET 0
	TARGET_API_MAC_CARBON: SET 0
	TARGET_API_MAC_OSX: SET 1
	ELSE
;  68k or some other compiler 
	TARGET_API_MAC_OS8: SET 1
	TARGET_API_MAC_CARBON: SET 0
	TARGET_API_MAC_OSX: SET 0
	ENDIF	; 
	ELSE
	IF &TYPE('TARGET_API_MAC_OS8') = 'UNDEFINED' THEN
	TARGET_API_MAC_OS8: SET 0
	ENDIF
	IF &TYPE('TARGET_API_MAC_OSX') = 'UNDEFINED' THEN
	TARGET_API_MAC_OSX: SET TARGET_RT_MAC_MACHO
	ENDIF
	IF &TYPE('TARGET_API_MAC_CARBON') = 'UNDEFINED' THEN
	TARGET_API_MAC_CARBON: SET TARGET_API_MAC_OSX
	ENDIF
	ENDIF
	IF TARGET_API_MAC_OS8 ** TARGET_API_MAC_OSX THEN
	ENDIF
	IF ¬ TARGET_API_MAC_OS8 ** ¬ TARGET_API_MAC_CARBON ** ¬ TARGET_API_MAC_OSX THEN
	ENDIF
	ELSE
	TARGET_API_MAC_OS8: SET 0
	TARGET_API_MAC_CARBON: SET 0
	TARGET_API_MAC_OSX: SET 0
	ENDIF	; TARGET_OS_MAC
;  Support source code still using TARGET_CARBON 
	IF &TYPE('TARGET_CARBON') = 'UNDEFINED' THEN
	IF TARGET_API_MAC_CARBON ** ¬ TARGET_API_MAC_OS8 THEN
	TARGET_CARBON: SET 1
	ELSE
	TARGET_CARBON: SET 0
	ENDIF
	ENDIF
; ****************************************************************************************************
;    Backward compatibility for clients expecting 2.x version on ConditionalMacros.h
;
;    GENERATINGPOWERPC       - Compiler is generating PowerPC instructions
;    GENERATING68K           - Compiler is generating 68k family instructions
;    GENERATING68881         - Compiler is generating mc68881 floating point instructions
;    GENERATINGCFM           - Code being generated assumes CFM calling conventions
;    CFMSYSTEMCALLS          - No A-traps.  Systems calls are made using CFM and UPP's
;    PRAGMA_ALIGN_SUPPORTED  - Compiler supports: #pragma options align=mac68k/power/reset
;    PRAGMA_IMPORT_SUPPORTED - Compiler supports: #pragma import on/off/reset
;    CGLUESUPPORTED          - Clients can use all lowercase toolbox functions that take C strings instead of pascal strings
;
;***************************************************************************************************

	IF ¬ TARGET_API_MAC_CARBON THEN
	GENERATINGPOWERPC: SET TARGET_CPU_PPC
	GENERATING68K: SET TARGET_CPU_68K
	GENERATING68881: SET TARGET_RT_MAC_68881
	GENERATINGCFM: SET TARGET_RT_MAC_CFM
	CFMSYSTEMCALLS: SET TARGET_RT_MAC_CFM
	IF &TYPE('CGLUESUPPORTED') = 'UNDEFINED' THEN
	CGLUESUPPORTED: SET 0
	ENDIF
	IF &TYPE('OLDROUTINELOCATIONS') = 'UNDEFINED' THEN
	OLDROUTINELOCATIONS: SET 0
	ENDIF
	ELSE
	ENDIF


; ****************************************************************************************************
;
;    OLDROUTINENAMES         - "Old" names for Macintosh system calls are allowed in source code.
;                              (e.g. DisposPtr instead of DisposePtr). The names of system routine
;                              are now more sensitive to change because CFM binds by name.  In the 
;                              past, system routine names were compiled out to just an A-Trap.  
;                              Macros have been added that each map an old name to its new name.  
;                              This allows old routine names to be used in existing source files,
;                              but the macros only work if OLDROUTINENAMES is true.  This support
;                              will be removed in the near future.  Thus, all source code should 
;                              be changed to use the new names! You can set OLDROUTINENAMES to false
;                              to see if your code has any old names left in it.
;    
;***************************************************************************************************

	IF &TYPE('OLDROUTINENAMES') = 'UNDEFINED' THEN
	OLDROUTINENAMES: SET 0
	ENDIF

;****************************************************************************************************
;   IMPORT_CFM_FUNCTION     -   Macro used instead of IMPORT pseduo opcode because PowerPC
;                               and 68K CFM runtimes differ on naming of imported functions.
;                               PowerPC requires a period (.) in front of the name and CFM 68K
;                               does not.  This macros supplies the period for PowerPC.
;***************************************************************************************************

    IF TARGET_RT_MAC_CFM THEN
        IF TARGET_CPU_PPC THEN
            Macro
            IMPORT_CFM_FUNCTION     &functionName
            IMPORT                  .&functionName
            EndM
        ELSE
            Macro
            IMPORT_CFM_FUNCTION     &functionName
            IMPORT                  &functionName
            EndM
        ENDIF   ; TARGET_OS_PPC
    ENDIF   ; TARGET_RT_MAC_CFM



; ****************************************************************************************************
;
;    TARGET_CARBON                   - default: false. Switches all of the above as described.  Overrides all others
;                                    - NOTE: If you set TARGET_CARBON to 1, then the other switches will be setup by
;                                            ConditionalMacros, and should not be set manually.
;
;    If you wish to do development for pre-Carbon Systems, you can set the following:
;
;    OPAQUE_TOOLBOX_STRUCTS          - default: false. True for Carbon builds, hides struct fields.
;    OPAQUE_UPP_TYPES                - default: false. True for Carbon builds, UPP types are unique and opaque.
;    ACCESSOR_CALLS_ARE_FUNCTIONS    - default: false. True for Carbon builds, enables accessor functions.
;    CALL_NOT_IN_CARBON              - default: true.  False for Carbon builds, hides calls not supported in Carbon.
;    
;    Specifically, if you are building a non-Carbon application (one that links against InterfaceLib)
;    but you wish to use some of the accessor functions, you can set ACCESSOR_CALLS_ARE_FUNCTIONS to 1
;    and link with CarbonAccessors.o, which implements just the accessor functions. This will help you
;    preserve source compatibility between your Carbon and non-Carbon application targets.
;    
;    MIXEDMODE_CALLS_ARE_FUNCTIONS   - deprecated.
;
;***************************************************************************************************

	IF TARGET_API_MAC_CARBON ** ¬ TARGET_API_MAC_OS8 THEN
	IF &TYPE('OPAQUE_TOOLBOX_STRUCTS') = 'UNDEFINED' THEN
	OPAQUE_TOOLBOX_STRUCTS: SET 1
	ENDIF
    IF &TYPE('OPAQUE_UPP_TYPES') = 'UNDEFINED' THEN
    OPAQUE_UPP_TYPES: SET 1
    ENDIF
    IF &TYPE('ACCESSOR_CALLS_ARE_FUNCTIONS') = 'UNDEFINED' THEN
    ACCESSOR_CALLS_ARE_FUNCTIONS: SET 1
    ENDIF
    IF &TYPE('CALL_NOT_IN_CARBON') = 'UNDEFINED' THEN
    CALL_NOT_IN_CARBON: SET 0
    ENDIF
	IF &TYPE('MIXEDMODE_CALLS_ARE_FUNCTIONS') = 'UNDEFINED' THEN
	MIXEDMODE_CALLS_ARE_FUNCTIONS: SET 1
	ENDIF
	ELSE
	IF &TYPE('OPAQUE_TOOLBOX_STRUCTS') = 'UNDEFINED' THEN
	OPAQUE_TOOLBOX_STRUCTS: SET 0
	ENDIF
	IF &TYPE('OPAQUE_UPP_TYPES') = 'UNDEFINED' THEN
	OPAQUE_UPP_TYPES: SET 0
	ENDIF
    IF &TYPE('ACCESSOR_CALLS_ARE_FUNCTIONS') = 'UNDEFINED' THEN
    ACCESSOR_CALLS_ARE_FUNCTIONS: SET 0
    ENDIF
; 
;     * It's possible to have ACCESSOR_CALLS_ARE_FUNCTIONS set to true and OPAQUE_TOOLBOX_STRUCTS
;     * set to false, but not the other way around, so make sure the defines are not set this way.
;     

	IF OPAQUE_TOOLBOX_STRUCTS ** ¬ ACCESSOR_CALLS_ARE_FUNCTIONS THEN
	ENDIF
    IF &TYPE('CALL_NOT_IN_CARBON') = 'UNDEFINED' THEN
    CALL_NOT_IN_CARBON: SET 1
    ENDIF
	IF &TYPE('MIXEDMODE_CALLS_ARE_FUNCTIONS') = 'UNDEFINED' THEN
	MIXEDMODE_CALLS_ARE_FUNCTIONS: SET 0
	ENDIF
	ENDIF


	ENDIF ; __CONDITIONALMACROS__ 


;
;    File:       Debugging.a
;
;    Contains:   Macros to handle exceptions and assertions.
;
;    Version:    Technology: Carbon
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1989-2001 by Apple Computer, Inc., all rights reserved.
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__DEBUGGING__') = 'UNDEFINED' THEN
__DEBUGGING__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__FILES__') = 'UNDEFINED' THEN
	include 'Files.a'
	ENDIF


;  ______________________________________________________________________________________
;                                                                                        
;    This file defines standard exception handling and assertion macros for              
;    system-level programming in C.  Originally used in QuickDraw GX, and heavily        
;    modified since, these macros are used extensively throughout Mac OS system          
;    software.  Now *you* can look and feel like a system software engineer.             
;                                                                                        
;    To activate debugger breaks, #define DEBUG to 1 (one) before including this file.   
;    Five further levels of debugging are available, selected by #defining one           
;    of the following conditionals to 1 after DEBUG is defined to 1.                     
;                                                                                        
;        DEBUG_INTERNAL      the default; includes file and line number information      
;                                                                                        
;        DEBUG_EXTERNAL      used for code which must ship to developers outside         
;                            your organization; no file or line number information is    
;                            included in asserts                                         
;                                                                                        
;        DEBUG_BREAK_ONLY    where an assertion would normally be sent to the debugger,      
;                            send an empty string instead.                               
;                                                                                        
;        PRODUCTION          used for shipping code; no debugger breaks are emitted      
;                                                                                        
;        PERFORMANCE         same as PRODUCTION                                          
;                                                                                        
;    #defining DEBUG to 0 is equivalent to #defining PRODUCTION 1 when DEBUG is 1.       
;    (No code for debugger breaks is emitted in either case.)                            
;                                                                                        
;    Of the multitude of macros, the preferred ones are:                                 
;                                                                                        
;    debug_string(c-string)                                                              
;        If debugging is on, c-string is printed in the debugger.                        
;        In production builds, debug_string() does nothing.                              
;                                                                                        
;    check(expression)                                                                   
;    check_noerr(error)                                                                  
;        If (expression) evaluates to false, break into the debugger.                    
;        In production builds, check() does nothing.                                     
;        Code inside check() statements is not compiled into production builds.          
;                                                                                        
;    require(expression, label)                                                          
;    require_noerr(expression, label)                                                    
;        If (expression) evaluates to false, announce this fact via the                  
;        debugger and then goto label.  In production builds, does not call              
;        the debugger but still goes to label if expression is false.                    
;                                                                                        
;    require_action(expression, label, action)                                           
;    require_noerr_action(expression, label, action)                                     
;        Same as require, but executes (action) before jumping to label.                 
;                                                                                        
;    check_string(expression, c-string)                                                  
;    require_string(expression, label, c-string)                                         
;    require_noerr_string(expression, label, c-string)                                   
;        If expression evaluates to false, print string and then proceed as in           
;        a normal check/require statement                                                
;                                                                                        
;    verify(expression)                                                                  
;    verify_noerr(error)                                                                 
;        If debugging is on, verify is the same as check(expression).                    
;        If debugging is off, verify still evaluates (expression)                        
;        but ignores the result.  Code inside verify() statements                        
;        is executed in both production and debug builds.                                
;                                                                                        
;    Common usage:                                                                       
;                                                                                        
;        // my pixmap is not purgeable, so locking it should never fail                  
;        verify( LockPixels(myPixMap) );                                                 
;        verify_noerr( DisposeThread(myThread, &threadResult, true) );                   
;  ______________________________________________________________________________________





;  ______________________________________________________________________________________
;                                                                                        
;   Before including this file, #define kComponentSignatureString to a C-string          
;   containing the name of your client.                                                  
;                                                                                        
;   example: #define kComponentSignatureString "SurfWriter"                              
;  ______________________________________________________________________________________






DEBUG_LEVEL_PRODUCTION  EQU     0
DEBUG_LEVEL_BREAK_ONLY  EQU     1
DEBUG_LEVEL_EXTERNAL    EQU     3
DEBUG_LEVEL_INTERNAL    EQU     4
DEBUGFULL               EQU     DEBUG_LEVEL_INTERNAL
DEBUG_NO_OPTIONS        EQU     0

    IF &TYPE('DEBUG') <> 'UNDEFINED' THEN
        ;
        ; Only set the DEBUGLEVEL if DEBUG is set.  If DEBUG, then default is DEBUG_LEVEL_INTERNAL
        ;       
        IF DEBUG = 0 THEN
DEBUGLEVEL SET DEBUG_LEVEL_PRODUCTION
        ENDIF

        IF 0 THEN
            ; extra if is to work around PPCAsm 1.2a2 bug
        ELSEIF (&TYPE('PRODUCTION') <> 'UNDEFINED') THEN
DEBUGLEVEL SET DEBUG_LEVEL_PRODUCTION
        ELSEIF (&TYPE('DEBUG_EXTERNAL') <> 'UNDEFINED') THEN
DEBUGLEVEL SET DEBUG_LEVEL_EXTERNAL
        ELSEIF (&TYPE('DEBUG_INTERNAL') <> 'UNDEFINED') THEN
DEBUGLEVEL SET DEBUG_LEVEL_INTERNAL
        ELSEIF (&TYPE('PERFORMANCE') <> 'UNDEFINED') THEN
DEBUGLEVEL SET DEBUG_LEVEL_PRODUCTION
        ELSEIF (&TYPE('DEBUG_BREAK_ONLY') <> 'UNDEFINED') THEN
DEBUGLEVEL SET DEBUG_LEVEL_BREAK_ONLY
        ELSE
DEBUGLEVEL SET DEBUG_LEVEL_INTERNAL
        ENDIF
    ELSE
    ;
    ; If DEBUG is not defined, default to DEBUG_LEVEL_PRODUCTION
    ;
DEBUGLEVEL SET DEBUG_LEVEL_PRODUCTION
    ENDIF




;  ______________________________________________________________________________________
;                                                                                        
;    DEBUGASSERTMSG - all error reporting is routed through this macro, which calls the  
;    system routine DebugAssert().  If you wish to use your own assertion/debugger break 
;    routine, you can override DEBUGASSERTMSG by defining it before including this file. 
;  ______________________________________________________________________________________




; *  DebugAssert()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DebugLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void DebugAssert(OSType componentSignature, UInt32 options, const char *assertionString, const char *exceptionString, const char *errorString, const char *fileName, long lineNumber, void *value)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DebugAssert
			moveq           	#0,D0
			dc.w            	$AA7E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DebugAssert
	ENDIF


;    kBlessedBusErrorBait is an address that will never be mapped
;    by Mac OS 8 or 9. It is close to the middle of the 64K range from
;    0x68F10000 to 0x68F1FFFF that is unmapped and cannot be accessed 
;    without causing an exception. Thus, it's a good value to use for
;    filling uninitialized pointers, etc.



kBlessedBusErrorBait			EQU		$68F168F1

;   TaskLevel masks

k68kInterruptLevelMask			EQU		$00000007
kInVBLTaskMask					EQU		$00000010
kInDeferredTaskMask				EQU		$00000020
kInSecondaryIntHandlerMask		EQU		$00000040
kInNestedInterruptMask			EQU		$00000080

kComponentDebugOption			EQU		0					; optionSelectorNum to turn breaks for component on/off

kGetDebugOption					EQU		1					; get current debug option setting
kSetDebugOption					EQU		2					; set debug option

;    DebugComponentCallback
;    DebugComponentCallback is the callback into a component that registers with DebugLib.
;    It is called to get the debug option setting, or to turn a debug option on or off.
;        Inputs:
;            optionSelectorNum   The component debug option to set
;            command             The command:
;                                    kGetDebugOption     - get current debug option setting
;                                    kSetDebugOption     - set debug option
;        Outputs:
;            optionSetting       The current setting if kGetDebugOption;
;                                the new debug option if kSetDebugOption



;    TaskLevel
;    TaskLevel returns 0 if we're (probably) running at non-interrupt time.
;    There's no way to make this perfect, but this is as close as we can get.
;    If TaskLevel doesn't return 0, then the following masks can be used to learn more:
;        k68kInterruptLevelMask      = 0x00000007
;        kInVBLTaskMask              = 0x00000010
;        kInDeferredTaskMask         = 0x00000020
;        kInSecondaryIntHandlerMask  = 0x00000040
;        kInNestedInterruptMask      = 0x00000080



; *  TaskLevel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DebugLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal UInt32 TaskLevel(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TaskLevel
			moveq           	#1,D0
			dc.w            	$AA7E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TaskLevel
	ENDIF


;    NewDebugComponent
;    NewDebugComponent registers a component with DebugLib.
;        Inputs:
;            componentSignature  The unique signature of component
;            componentName       The displayable string naming the component
;            componentCallback   The callback into component for working with options
;        Result:
;            noErr                           no error
;            memFullErr                      could not allocate memory
;            debuggingExecutionContextErr    routine cannot be called at this time
;            debuggingDuplicateSignatureErr  componentSignature already registered
;            debuggingInvalidNameErr         componentName is invalid (NULL)



; *  NewDebugComponent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DebugLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSStatus NewDebugComponent(OSType componentSignature, ConstStr255Param componentName, DebugComponentCallbackUPP componentCallback)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewDebugComponent
			moveq           	#2,D0
			dc.w            	$AA7E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewDebugComponent
	ENDIF



;    NewDebugOption
;    NewDebugOption registers a debug option with DebugLib.
;        Inputs:
;            componentSignature  The signature of component to register a debug option for
;            optionSelectorNum   The selector number of this debug option
;            optionName          The displayable string naming this debug option
;        Result:
;            noErr                           no error
;            memFullErr                      could not allocate memory
;            debuggingExecutionContextErr    called at interrupt time
;            debuggingDuplicateOptionErr     optionSelectorNum already registered
;            debuggingInvalidSignatureErr    componentSignature not registered
;            debuggingInvalidNameErr         optionName is invalid (NULL)
;            debuggingNoCallbackErr          debugging component has no callback



; *  NewDebugOption()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DebugLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSStatus NewDebugOption(OSType componentSignature, SInt32 optionSelectorNum, ConstStr255Param optionName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NewDebugOption
			moveq           	#3,D0
			dc.w            	$AA7E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewDebugOption
	ENDIF



;    DisposeDebugComponent
;    DisposeDebugComponent removes a component registration and all related debug options from DebugLib.
;        Input:
;            componentSignature  The unique signature of a component
;        Result:
;            noErr                           no error
;            debuggingExecutionContextErr    called at interrupt time
;            debuggingInvalidSignatureErr    componentSignature not registered



; *  DisposeDebugComponent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DebugLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSStatus DisposeDebugComponent(OSType componentSignature)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DisposeDebugComponent
			moveq           	#4,D0
			dc.w            	$AA7E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeDebugComponent
	ENDIF



;    GetDebugComponentInfo
;    GetDebugComponentInfo returns a component registered with DebugLib.
;        Inputs:
;            index               The index into the list of registered components (1-based)
;        Outputs:
;            componentSignature  The unique signature of a component
;            componentName       The displayable string naming a component
;        Result:
;            noErr                           no error
;            debuggingNoMatchErr             debugging component not found at this index



; *  GetDebugComponentInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DebugLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSStatus GetDebugComponentInfo(UInt32 index, OSType *componentSignature, Str255 componentName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetDebugComponentInfo
			moveq           	#5,D0
			dc.w            	$AA7E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetDebugComponentInfo
	ENDIF



;    GetDebugOptionInfo
;    GetDebugOptionInfo returns a debug option registered with DebugLib.
;        Inputs:
;            index               The index into the list of registered debug options (0-based);
;                                    0 = kComponentDebugOption 
;            componentSignature  The unique signature of a component
;        Outputs:
;            optionSelectorNum   The selector number of this debug option
;            optionName          The displayable string naming this debug option
;            optionSetting       The current debug option setting
;        Result:
;            noErr                           no error
;            debuggingInvalidSignatureErr    componentSignature not registered
;            debuggingNoMatchErr             option not found at this index



; *  GetDebugOptionInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DebugLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSStatus GetDebugOptionInfo(UInt32 index, OSType componentSignature, SInt32 *optionSelectorNum, Str255 optionName, Boolean *optionSetting)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetDebugOptionInfo
			moveq           	#6,D0
			dc.w            	$AA7E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetDebugOptionInfo
	ENDIF



;    SetDebugOptionValue
;    SetDebugOptionValue sets a debug option registered with DebugLib.
;        Inputs:
;            componentSignature  The unique signature of a component
;            optionSelectorNum   The selector number of this debug option
;            newOptionSetting    The new debug option setting
;        Result:
;            noErr                           no error
;            debuggingInvalidSignatureErr    componentSignature not registered
;            debuggingInvalidOptionErr       optionSelectorNum is not registered



; *  SetDebugOptionValue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DebugLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSStatus SetDebugOptionValue(OSType componentSignature, SInt32 optionSelectorNum, Boolean newOptionSetting)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetDebugOptionValue
			moveq           	#7,D0
			dc.w            	$AA7E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetDebugOptionValue
	ENDIF


;    DebugAssertOutputHandler
;    DebugAssertOutputHandler is the callback that registers with DebugLib to handle the
;    output from DebugAssert.
;        Inputs:
;            "componentSignature" through "value" are the raw values passed to DebugAssert
;                when an exception occurs.
;            outputMsg is the string DebugAssert build which would normally be passed to
;                DebugStr if a DebugAssertOutputHandler isn't installed.



;    InstallDebugAssertOutputHandler
;    InstallDebugAssertOutputHandler installs a DebugAssertOutputHandler which DebugAssert calls
;    instead of DebugStr.
;        Inputs:
;            handler     the DebugAssertOutputHandler to install or NULL to switch back to
;                        the default handler (DebugStr).



; *  InstallDebugAssertOutputHandler()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DebugLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void InstallDebugAssertOutputHandler(DebugAssertOutputHandlerUPP handler)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InstallDebugAssertOutputHandler
			moveq           	#8,D0
			dc.w            	$AA7E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InstallDebugAssertOutputHandler
	ENDIF


;    dprintf() takes a variable argument list and 'prints' that to the debugging output
;    handler.  Calling dprintf() from anything but C or C++ is tricky.


	IF CALL_NOT_IN_CARBON THEN

; *  dprintf()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DebugLib 1.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void dprintf(const char *format, ...)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_dprintf
			dc.w            	$2057
			dc.w            	$43EF
			dc.w            	$0004
			dc.w            	$303C
			dc.w            	$000A
			dc.w            	$AA7E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION dprintf
	ENDIF



;   vdprintf() takes a va_args list and 'prints' that to the debugging output handler.

; *  vdprintf()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DebugLib 1.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void vdprintf(const char *format, char *va_args_list)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_vdprintf
			moveq           	#9,D0
			dc.w            	$AA7E
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION vdprintf
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  NewDebugComponentCallbackUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewDebugAssertOutputHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeDebugComponentCallbackUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeDebugAssertOutputHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeDebugComponentCallbackUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeDebugAssertOutputHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


;  ______________________________________________________________________________________
;                                                                                        
;    Tech Q&A PLAT-30 says to check bit 5 of the byte at 0xbff to                        
;    determine whether MacsBug ( or any other low level debugger )                       
;    is installed; I also check that MacJmp ( which points to the                        
;    entry point for the debugger ) is not nil and not -1.                               
;                                                                                        
;    MacJmpFlag:                                                                         
;        Bit 5 should be set to indicate the debugger is installed.                      
;        Bit 6 should be set to indicate the debugger is initialized.                    
;        Bit 7 should be clear to indicate that the debugger is NOT busy                 
;                                                                                        
;    Dr. MacsBug says to also check that the byte at 0xBFF isn't 0xFF.                   
;  ______________________________________________________________________________________


	IF CALL_NOT_IN_CARBON THEN
	ENDIF	; CALL_NOT_IN_CARBON
    IF TARGET_OS_MAC ** TARGET_CPU_68K THEN

; SafeDebugger and SafeDebugStr ALWAYS call the debugger if it is installed.

            MACRO
            _LocalLMGetMacJmp &dest=(sp)
            move.l  $0120,&dest
            ENDM

            MACRO
            _LocalLMGetMacJmpFlag &dest=(sp)
            move.b  $0BFF,&dest
            ENDM

            MACRO
            _SafeDebugStr   &message

            ; Do a _DebugStr if Macsbug is installed; nothing otherwise.
            ; Note: message parameter MUST be a Pascal string.

            move.l  d0,-(sp)        ; save D0

            _LocalLMGetMacJmpFlag d0 ; get MacJmpFlag
            cmp.b   #$ff,d0         ; is it $ff?
            beq.s   @noDebugger     ; -> no debugger

            and.b   #$e0,d0         ; keep bits 5, 6, and 7
            cmp.b   #$60,d0         ; are bits 5 and 6 set and bit 7 clear?
            bne.s   @noDebugger     ; -> no debugger or debugger is busy

            _LocalLMGetMacJmp d0    ; get MacJmp
            tst.l   d0              ; is it nil?
            beq.s   @noDebugger     ; -> no debugger

            cmp.l   #$ffffffff,d0   ; is it -1?
            beq.s   @noDebugger     ; -> no debugger

            pea     &message        ; everything looks good so call...
            _DebugStr               ; MacsBug to display the message

@noDebugger
            move.l  (sp)+,d0        ; restore D0
            ENDM

            MACRO
            _SafeDebugger

            ; Do a _Debugger if Macsbug is installed; nothing otherwise.

            move.l  d0,-(sp)        ; save D0

            _LocalLMGetMacJmpFlag d0 ; get MacJmpFlag
            cmp.b   #$ff,d0         ; is it $ff?
            beq.s   @noDebugger     ; -> no debugger

            and.b   #$e0,d0         ; keep bits 5, 6, and 7
            cmp.b   #$60,d0         ; are bits 5 and 6 set and bit 7 clear?
            bne.s   @noDebugger     ; -> no debugger or debugger is busy

            _LocalLMGetMacJmp d0    ; get MacJmp
            tst.l   d0              ; is it nil?
            beq.s   @noDebugger     ; -> no debugger

            cmp.l   #$ffffffff,d0   ; is it -1?
            beq.s   @noDebugger     ; -> no debugger

            _Debugger               ; everything looks good so call MacsBug

@noDebugger
            move.l  (sp)+,d0        ; restore D0
            ENDM
    ENDIF

;  no-op asserts for production code

; ______________________________________________________________________________________
; ______________________________________________________________________________________
; ______________________________________________________________________________________




; ______________________________________________________________________________________
; ______________________________________________________________________________________
; ______________________________________________________________________________________
; ______________________________________________________________________________________
; ______________________________________________________________________________________

; ______________________________________________________________________________________
; ______________________________________________________________________________________

; ______________________________________________________________________________________

; ______________________________________________________________________________________
; ______________________________________________________________________________________
; ______________________________________________________________________________________

; ______________________________________________________________________________________

; ______________________________________________________________________________________


; ______________________________________________________________________________________


	ENDIF ; __DEBUGGING__ 


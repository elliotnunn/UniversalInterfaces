;
;    File:       FSM.a
;
;    Contains:   HFS External File System Interfaces.
;
;    Version:    Technology: Mac OS 9
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1985-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__FSM__') = 'UNDEFINED' THEN
__FSM__ SET 1

	IF &TYPE('__FILES__') = 'UNDEFINED' THEN
	include 'Files.a'
	ENDIF
	IF &TYPE('__HFSVOLUMES__') = 'UNDEFINED' THEN
	include 'HFSVolumes.a'
	ENDIF
	IF &TYPE('__PROCESSES__') = 'UNDEFINED' THEN
	include 'Processes.a'
	ENDIF
	IF &TYPE('__MACERRORS__') = 'UNDEFINED' THEN
	include 'MacErrors.a'
	ENDIF

;  VolMount declarations are now in Files.≈ 

; 
; * Miscellaneous file system values not in Files.≈
; 


fsUsrCNID						EQU		16					; First assignable directory or file number 
															;    File system trap word attribute bits 
kHFSBit							EQU		9					; HFS call: bit 9 
kHFSMask						EQU		$0200
kAsyncBit						EQU		10					; Asynchronous call: bit 10 
kAsyncMask						EQU		$0400

; 
; * HFSCIProc selectCode values
; * Note: The trap attribute bits (the HFS bit and the asynchronous bit)
; * may be set in these selectCode values.
; 


kFSMOpen						EQU		$A000
kFSMClose						EQU		$A001
kFSMRead						EQU		$A002
kFSMWrite						EQU		$A003
kFSMGetVolInfo					EQU		$A007
kFSMCreate						EQU		$A008
kFSMDelete						EQU		$A009
kFSMOpenRF						EQU		$A00A
kFSMRename						EQU		$A00B
kFSMGetFileInfo					EQU		$A00C
kFSMSetFileInfo					EQU		$A00D
kFSMUnmountVol					EQU		$A00E
kFSMMountVol					EQU		$A00F
kFSMAllocate					EQU		$A010
kFSMGetEOF						EQU		$A011
kFSMSetEOF						EQU		$A012
kFSMFlushVol					EQU		$A013
kFSMGetVol						EQU		$A014
kFSMSetVol						EQU		$A015
kFSMEject						EQU		$A017
kFSMGetFPos						EQU		$A018
kFSMOffline						EQU		$A035
kFSMSetFilLock					EQU		$A041
kFSMRstFilLock					EQU		$A042
kFSMSetFilType					EQU		$A043
kFSMSetFPos						EQU		$A044
kFSMFlushFile					EQU		$A045				;    The File System HFSDispatch selectCodes 
kFSMOpenWD						EQU		$0001
kFSMCloseWD						EQU		$0002
kFSMCatMove						EQU		$0005
kFSMDirCreate					EQU		$0006
kFSMGetWDInfo					EQU		$0007
kFSMGetFCBInfo					EQU		$0008
kFSMGetCatInfo					EQU		$0009
kFSMSetCatInfo					EQU		$000A
kFSMSetVolInfo					EQU		$000B
kFSMLockRng						EQU		$0010
kFSMUnlockRng					EQU		$0011
kFSMXGetVolInfo					EQU		$0012
kFSMCreateFileIDRef				EQU		$0014
kFSMDeleteFileIDRef				EQU		$0015
kFSMResolveFileIDRef			EQU		$0016
kFSMExchangeFiles				EQU		$0017
kFSMCatSearch					EQU		$0018
kFSMOpenDF						EQU		$001A
kFSMMakeFSSpec					EQU		$001B				;    The Desktop Manager HFSDispatch selectCodes 
kFSMDTGetPath					EQU		$0020
kFSMDTCloseDown					EQU		$0021
kFSMDTAddIcon					EQU		$0022
kFSMDTGetIcon					EQU		$0023
kFSMDTGetIconInfo				EQU		$0024
kFSMDTAddAPPL					EQU		$0025
kFSMDTRemoveAPPL				EQU		$0026
kFSMDTGetAPPL					EQU		$0027
kFSMDTSetComment				EQU		$0028
kFSMDTRemoveComment				EQU		$0029
kFSMDTGetComment				EQU		$002A
kFSMDTFlush						EQU		$002B
kFSMDTReset						EQU		$002C
kFSMDTGetInfo					EQU		$002D
kFSMDTOpenInform				EQU		$002E
kFSMDTDelete					EQU		$002F				;    The AppleShare HFSDispatch selectCodes 
kFSMGetVolParms					EQU		$0030
kFSMGetLogInInfo				EQU		$0031
kFSMGetDirAccess				EQU		$0032
kFSMSetDirAccess				EQU		$0033
kFSMMapID						EQU		$0034
kFSMMapName						EQU		$0035
kFSMCopyFile					EQU		$0036
kFSMMoveRename					EQU		$0037
kFSMOpenDeny					EQU		$0038
kFSMOpenRFDeny					EQU		$0039
kFSMGetXCatInfo					EQU		$003A
kFSMGetVolMountInfoSize			EQU		$003F
kFSMGetVolMountInfo				EQU		$0040
kFSMVolumeMount					EQU		$0041
kFSMShare						EQU		$0042
kFSMUnShare						EQU		$0043
kFSMGetUGEntry					EQU		$0044
kFSMGetForeignPrivs				EQU		$0060
kFSMSetForeignPrivs				EQU		$0061				; The HFSPlus API SelectCodes (below)
kFSMGetVolumeInfo				EQU		$001D				; Dispatched by ioVRefNum and volumeIndex 
kFSMSetVolumeInfo				EQU		$001E				; Dispatched by ioVRefNum 
kFSMReadFork					EQU		$0051				; Fork I/O calls dispatched by forkRefNum (ioRefNum) 
kFSMWriteFork					EQU		$0052
kFSMGetForkPosition				EQU		$0053
kFSMSetForkPosition				EQU		$0054
kFSMGetForkSize					EQU		$0055
kFSMSetForkSize					EQU		$0056
kFSMAllocateFork				EQU		$0057
kFSMFlushFork					EQU		$0058
kFSMCloseFork					EQU		$0059
kFSMGetForkCBInfo				EQU		$005A
kFSMCloseIterator				EQU		$005B				; Iterator calls are dispatched by upper two bytes of "iterator", 
kFSMGetCatalogInfoBulk			EQU		$005C				; which is treated as an ioRefNum.  By convention, the lower two 
kFSMCatalogSearch				EQU		$005D				; bytes of the FSIterator are zero, though this is not enforced. 
kFSMMakeFSRef					EQU		$006E				; Dispatched by ioVRefNum/ioDirID/ioNamePtr 
kFSMCreateFileUnicode			EQU		$0070				; FSRef dispatched calls.  The first two bytes of an FSRef 
kFSMCreateDirUnicode			EQU		$0071				; are a volume reference number (not a working directory reference 
kFSMDeleteObject				EQU		$0072				; number or drive number).  The remaining bytes of the FSRef are 
kFSMMoveObject					EQU		$0073				; defined by that particular volume format. 
kFSMRenameUnicode				EQU		$0074
kFSMExchangeObjects				EQU		$0075
kFSMGetCatalogInfo				EQU		$0076
kFSMSetCatalogInfo				EQU		$0077
kFSMOpenIterator				EQU		$0078
kFSMOpenFork					EQU		$0079
kFSMMakeFSRefUnicode			EQU		$007A
kFSMCompareFSRefs				EQU		$007C
kFSMCreateFork					EQU		$007D
kFSMDeleteFork					EQU		$007E
kFSMIterateForks				EQU		$007F
; 
; * UTDetermineVol status values
; 


dtmvError						EQU		0					; param error 
dtmvFullPathname				EQU		1					; determined by full pathname 
dtmvVRefNum						EQU		2					; determined by volume refNum 
dtmvWDRefNum					EQU		3					; determined by working directory refNum 
dtmvDriveNum					EQU		4					; determined by drive number 
dtmvDefault						EQU		5					; determined by default volume 

; 
; * UTGetBlock options
; 


gbDefault						EQU		0					; default value - read if not found 
															;    bits and masks 
gbReadBit						EQU		0					; read block from disk (forced read) 
gbReadMask						EQU		$0001
gbExistBit						EQU		1					; get existing cache block 
gbExistMask						EQU		$0002
gbNoReadBit						EQU		2					; don't read block from disk if not found in cache 
gbNoReadMask					EQU		$0004
gbReleaseBit					EQU		3					; release block immediately after GetBlock 
gbReleaseMask					EQU		$0008

; 
; * UTReleaseBlock options
; 


rbDefault						EQU		0					; default value - just mark the buffer not in-use 
															;    bits and masks 
rbWriteBit						EQU		0					; force write buffer to disk 
rbWriteMask						EQU		$0001
rbTrashBit						EQU		1					; trash buffer contents after release 
rbTrashMask						EQU		$0002
rbDirtyBit						EQU		2					; mark buffer dirty 
rbDirtyMask						EQU		$0004
rbFreeBit						EQU		3					; free the buffer (save in the hash) 
rbFreeMask						EQU		$000A				; rbFreeMask (rbFreeBit + rbTrashBit) works as rbTrash on < System 7.0 RamCache; on >= System 7.0, rbfreeMask overrides rbTrash 

; 
; * UTFlushCache options
; 


fcDefault						EQU		0					; default value - pass this fcOption to just flush any dirty buffers 
															;    bits and masks 
fcTrashBit						EQU		0					; (don't pass this as fcOption, use only for testing bit) 
fcTrashMask						EQU		$0001				; pass this fcOption value to flush and trash cache blocks 
fcFreeBit						EQU		1					; (don't pass this as fcOption, use only for testing bit) 
fcFreeMask						EQU		$0003				; pass this fcOption to flush and free cache blocks (Note: both fcTrash and fcFree bits are set) 

; 
; * UTCacheReadIP and UTCacheWriteIP cacheOption bits and masks are the ioPosMode
; * bits and masks in Files.x
; 


; 
; * Cache routine internal error codes
; 


chNoBuf							EQU		1					; no free cache buffers (all in use) 
chInUse							EQU		2					; requested block in use 
chnotfound						EQU		3					; requested block not found 
chNotInUse						EQU		4					; block being released was not in use 

; 
; * FCBRec.fcbFlags bits
; 


fcbWriteBit						EQU		0					; Data can be written to this file 
fcbWriteMask					EQU		$01
fcbResourceBit					EQU		1					; This file is a resource fork 
fcbResourceMask					EQU		$02
fcbWriteLockedBit				EQU		2					; File has a locked byte range 
fcbWriteLockedMask				EQU		$04
fcbLargeFileBit					EQU		3					; File may grow beyond 2GB; cache uses file blocks, not bytes 
fcbLargeFileMask				EQU		$08
fcbSharedWriteBit				EQU		4					; File is open for shared write access 
fcbSharedWriteMask				EQU		$10
fcbFileLockedBit				EQU		5					; File is locked (write-protected) 
fcbFileLockedMask				EQU		$20
fcbOwnClumpBit					EQU		6					; File has clump size specified in FCB 
fcbOwnClumpMask					EQU		$40
fcbModifiedBit					EQU		7					; File has changed since it was last flushed 
fcbModifiedMask					EQU		$80

; 
; *  ForkControlBlock.moreFlags bits
; 


fcbIteratorBit					EQU		0					; FCB belongs to an FSIterator 
fcbIteratorMask					EQU		$0001
fcbUseForkIDBit					EQU		1					; Use the FCB's forkID instead of fcbResourceBit 
fcbUseForkIDMask				EQU		$0002
; 
; *  HFS Component Interface constants
; 


; 
; * compInterfMask bits specific to HFS component
; 


hfsCIDoesHFSBit					EQU		23					; set if file system supports HFS calls 
hfsCIDoesHFSMask				EQU		$00800000
hfsCIDoesAppleShareBit			EQU		22					; set if AppleShare calls supported 
hfsCIDoesAppleShareMask			EQU		$00400000
hfsCIDoesDeskTopBit				EQU		21					; set if Desktop Database calls supported 
hfsCIDoesDeskTopMask			EQU		$00200000
hfsCIDoesDynamicLoadBit			EQU		20					; set if dynamically loading code resource 
hfsCIDoesDynamicLoadMask		EQU		$00100000			;       supported 
hfsCIResourceLoadedBit			EQU		19					; set if code resource already loaded 
hfsCIResourceLoadedMask			EQU		$00080000
hfsCIHasHLL2PProcBit			EQU		18					; set if FFS' log2PhyProc 
hfsCIHasHLL2PProcMask			EQU		$00040000			; is written in a high level language. (i.e., uses Pascal calling convention) 
hfsCIWantsDTSupportBit			EQU		17					; set if FFS wants the Mac OS's Desktop Manager code to handle 
hfsCIWantsDTSupportMask			EQU		$00020000			; all Desktop Manager requests to its volumes. 

; 
; *  Disk Initialization Component Interface constants
; 


; 
; * compInterfMask bits specific to Disk Initialization component
; 


diCIHasExtFormatParamsBit		EQU		18					; set if file system needs extended format 
diCIHasExtFormatParamsMask		EQU		$00040000			;       parameters 
diCIHasMultiVolTypesBit			EQU		17					; set if file system supports more than one 
diCIHasMultiVolTypesMask		EQU		$00020000			;       volume type 
diCIDoesSparingBit				EQU		16					; set if file system supports disk sparing 
diCIDoesSparingMask				EQU		$00010000
diCILiveBit						EQU		0					; set if file system is candidate for current 
diCILiveMask					EQU		$00000001			;       formatting operation (set by PACK2) 

; 
; * Disk Initialization Component Function selectors
; 


diCILoad						EQU		1					; Make initialization code memory resident 
diCIUnload						EQU		2					; Make initialization code purgeable 
diCIEvaluateSizeChoices			EQU		3					; Evaluate size choices 
diCIExtendedZero				EQU		4					; Write an empty volume directory 
diCIValidateVolName				EQU		5					; Validate volume name 
diCIGetVolTypeInfo				EQU		6					; get volume type info 
diCIGetFormatString				EQU		7					; get dialog format string 
diCIGetExtFormatParams			EQU		8					; get extended format parameters 
diCIGetDefectList				EQU		9					; return the defect list for the indicated disk - reserved for future use 

; 
; * Constants used in the DICIEvaluateSizeRec and FormatListRec
; 


diCIFmtListMax					EQU		8					; maximum number of format list entries in DICIEvaluateSizeRec.numSizeEntries 
															;    bits in FormatListRec.formatFlags: 
diCIFmtFlagsValidBit			EQU		7					; set if sec, side, tracks valid 
diCIFmtFlagsValidMask			EQU		$80
diCIFmtFlagsCurrentBit			EQU		6					; set if current disk has this fmt 
diCIFmtFlagsCurrentMask			EQU		$40					;    bits in FormatListRec.sizeListFlags: 
diCISizeListOKBit				EQU		15					; set if this disk size usable 
diCISizeListOKMask				EQU		$8000

; 
; * DICIGetFormatStringRec.stringKind format strings
; 


diCIAlternateFormatStr			EQU		1					; get alternate format  string (Balloon Help) 
diCISizePresentationStr			EQU		2					; get size presentation string (for dialog) 

; 
; * Error codes returned by Disk Sparing
; 


diCIUserCancelErr				EQU		1					; user cancelled the disk init 
diCICriticalSectorBadErr		EQU		20					; critical sectors are bad (hopeless)    
diCISparingFailedErr			EQU		21					; disk cannot be spared 
diCITooManyBadSectorsErr		EQU		22					; too many bad sectors 
diCIUnknownVolTypeErr			EQU		23					; the volume type passed in diCIExtendedZero paramBlock is not supported 
diCIVolSizeMismatchErr			EQU		24					; specified volume size doesn’t match with formatted disk size 
diCIUnknownDICallErr			EQU		25					; bogus DI function call selector 
diCINoSparingErr				EQU		26					; disk is bad but the target FS doesn't do disk sparing 
diCINoExtendInfoErr				EQU		27					; missing file system specific extra parameter in diCIExtendedZero call 
diCINoMessageTextErr			EQU		28					; missing message text in DIReformat call 

; 
; *  File System Manager constants
; 


; 
; * Miscellaneous constants used by FSM
; 


fsdVersion1						EQU		1					; current version of FSD record 
fsmIgnoreFSID					EQU		$FFFE				; this FSID should be ignored by the driver 
fsmGenericFSID					EQU		$FFFF				; unknown foreign file system ID 

; 
; * compInterfMask bits common to all FSM components
; 


fsmComponentEnableBit			EQU		31					; set if FSM component interface is enabled 
fsmComponentEnableMask			EQU		$80000000
fsmComponentBusyBit				EQU		30					; set if FSM component interface is busy 
fsmComponentBusyMask			EQU		$40000000

; 
; * Selectors for GetFSInfo
; 


fsmGetFSInfoByIndex				EQU		-1					; get fs info by index 
fsmGetFSInfoByFSID				EQU		0					; get fs info by FSID 
fsmGetFSInfoByRefNum			EQU		1					; get fs info by file/vol refnum 

; 
; * InformFSM messages
; 


fsmNopMessage					EQU		0					; nop 
fsmDrvQElChangedMessage			EQU		1					; DQE has changed 
fsmGetFSIconMessage				EQU		2					; Get FFS's disk icon 

; 
; * Messages passed to the fileSystemCommProc
; 


ffsNopMessage					EQU		0					; nop, should always return noErr 
ffsGetIconMessage				EQU		1					; return disk icon and mask 
ffsIDDiskMessage				EQU		2					; identify the about-to-be-mounted volume 
ffsLoadMessage					EQU		3					; load in the FFS 
ffsUnloadMessage				EQU		4					; unload the FFS 
ffsIDVolMountMessage			EQU		5					; identify a VolMountInfo record 
ffsInformMessage				EQU		6					; FFS defined message 
ffsGetIconInfoMessage			EQU		7


; 
; *  HFS Utility routine records
; 


; 
; * record used by UTGetPathComponentName
; 

ParsePathRec			RECORD 0
namePtr					 ds.l	1				; offset: $0 (0)		;  pathname to parse 
startOffset				 ds.w	1				; offset: $4 (4)		;  where to start parsing 
componentLength			 ds.w	1				; offset: $6 (6)		;  the length of the pathname component parsed 
moreName				 ds.b	1				; offset: $8 (8)		;  non-zero if there are more components after this one 
foundDelimiter			 ds.b	1				; offset: $9 (9)		;  non-zero if parsing stopped because a colon (:) delimiter was found 
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct ParsePathRec *			ParsePathRecPtr

WDCBRec					RECORD 0
wdVCBPtr				 ds.l	1				; offset: $0 (0)		;  Pointer to VCB of this working directory 
wdDirID					 ds.l	1				; offset: $4 (4)		;  Directory ID number of this working directory 
wdCatHint				 ds.l	1				; offset: $8 (8)		;  Hint for finding this working directory 
wdProcID				 ds.l	1				; offset: $C (12)		;  Process that created this working directory 
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct WDCBRec *				WDCBRecPtr

FCBRec					RECORD 0
fcbFlNm					 ds.l	1				; offset: $0 (0)		;  FCB file number. Non-zero marks FCB used 
fcbFlags				 ds.b	1				; offset: $4 (4)		;  FCB flags 
fcbTypByt				 ds.b	1				; offset: $5 (5)		;  File type byte 
fcbSBlk					 ds.w	1				; offset: $6 (6)		;  File start block (in alloc size blks) 
fcbEOF					 ds.l	1				; offset: $8 (8)		;  Logical length or EOF in bytes 
fcbPLen					 ds.l	1				; offset: $C (12)		;  Physical file length in bytes 
fcbCrPs					 ds.l	1				; offset: $10 (16)		;  Current position within file 
fcbVPtr					 ds.l	1				; offset: $14 (20)		;  Pointer to the corresponding VCB 
fcbBfAdr				 ds.l	1				; offset: $18 (24)		;  File's buffer address 
fcbFlPos				 ds.w	1				; offset: $1C (28)		;  Directory block this file is in 
;  FCB Extensions for HFS 
fcbClmpSize				 ds.l	1				; offset: $1E (30)		;  Number of bytes per clump 
fcbBTCBPtr				 ds.l	1				; offset: $22 (34)		;  Pointer to B*-Tree control block for file 
fcbExtRec				 ds		HFSExtentRecord ; offset: $26 (38)		;  First 3 file extents 
fcbFType				 ds.l	1				; offset: $32 (50)		;  File's 4 Finder Type bytes 
fcbCatPos				 ds.l	1				; offset: $36 (54)		;  Catalog hint for use on Close 
fcbDirID				 ds.l	1				; offset: $3A (58)		;  Parent Directory ID 
fcbCName				 ds		Str31			; offset: $3E (62)		;  CName of open file 
sizeof					 EQU *					; size:   $5E (94)
						ENDR
; typedef struct FCBRec *				FCBRecPtr

ForkControlBlock		RECORD 0
fcbFlNm					 ds.l	1				; offset: $0 (0)		;  FCB file number. Non-zero marks FCB used 
fcbFlags				 ds.b	1				; offset: $4 (4)		;  FCB flags 
fcbTypByt				 ds.b	1				; offset: $5 (5)		;  File type byte 
fcbSBlk					 ds.w	1				; offset: $6 (6)		;  File start block (in alloc size blks) 
fcbEOF					 ds.l	1				; offset: $8 (8)		;  Logical length or EOF in bytes 
fcbPLen					 ds.l	1				; offset: $C (12)		;  Physical file length in bytes 
fcbCrPs					 ds.l	1				; offset: $10 (16)		;  Current position within file 
fcbVPtr					 ds.l	1				; offset: $14 (20)		;  Pointer to the corresponding VCB 
fcbBfAdr				 ds.l	1				; offset: $18 (24)		;  File's buffer address 
fcbFlPos				 ds.w	1				; offset: $1C (28)		;  Directory block this file is in 
;  FCB Extensions for HFS 
fcbClmpSize				 ds.l	1				; offset: $1E (30)		;  Number of bytes per clump 
fcbBTCBPtr				 ds.l	1				; offset: $22 (34)		;  Pointer to B*-Tree control block for file 
fcbExtRec				 ds		HFSExtentRecord ; offset: $26 (38)		;  First 3 file extents 
fcbFType				 ds.l	1				; offset: $32 (50)		;  File's 4 Finder Type bytes 
fcbCatPos				 ds.l	1				; offset: $36 (54)		;  Catalog hint for use on Close 
fcbDirID				 ds.l	1				; offset: $3A (58)		;  Parent Directory ID 
fcbCName				 ds		Str31			; offset: $3E (62)		;  CName of open file 
;     New fields start here
moreFlags				 ds.w	1				; offset: $5E (94)		;  more flags, align following fields
;     Old ExtendedFCB fields
processID				 ds		ProcessSerialNumber ; offset: $60 (96) ;  Process Mgr process that opened the file (used to clean up at process death).
extents					 ds		HFSPlusExtentRecord ; offset: $68 (104) ;  extents for HFS+ volumes
;     New fields for HFS Plus APIs
endOfFile				 ds		UInt64			; offset: $A8 (168)		;  logical size of this fork
physicalEOF				 ds		UInt64			; offset: $B0 (176)		;  amount of space physically allocated to this fork
currentPosition			 ds		UInt64			; offset: $B8 (184)		;  default offset for next read/write
forkID					 ds.l	1				; offset: $C0 (192)
searchListPtr			 ds.l	1				; offset: $C4 (196)		;  reserved for File Manager's use
reserved1				 ds.b	8				; offset: $C8 (200)		;  reserved
sizeof					 EQU *					; size:   $D0 (208)
						ENDR
; typedef struct ForkControlBlock *		ForkControlBlockPtr

; 
; *  IteratorControlBlock - a ForkControlBlock used by a FSIterator
; 

IteratorControlBlock	RECORD 0
containerID				 ds.l	1				; offset: $0 (0)		;  directory ID of iterator's container
flags					 ds.w	1				; offset: $4 (4)		;  reserved
user1					 ds.b	14				; offset: $6 (6)		;  14 bytes iterator's use
vcbPtr					 ds.l	1				; offset: $14 (20)		;  pointer to the iterator's VCB
reserved2				 ds.l	1				; offset: $18 (24)		;  reserved
user2					 ds.b	6				; offset: $1C (28)		;  6 bytes for iterator's use
reserved3				 ds.l	1				; offset: $22 (34)		;  reserved
user3					 ds.b	12				; offset: $26 (38)		;  12 bytes for iterator's use
cbType					 ds.l	1				; offset: $32 (50)		;  must be 'fold'
user4					 ds.b	40				; offset: $36 (54)		;  40 bytes for iterator's use
moreFlags				 ds.w	1				; offset: $5E (94)		;  must be fcbIteratorMask
processID				 ds		ProcessSerialNumber ; offset: $60 (96) ;  Process Mgr process that opened the iterator (used to clean up at process death).
user5					 ds.b	92				; offset: $68 (104)		;  92 bytes for iterator's use
searchListPtr			 ds.l	1				; offset: $C4 (196)		;  reserved for File Manager's use
reserved1				 ds.b	8				; offset: $C8 (200)		;  reserved
sizeof					 EQU *					; size:   $D0 (208)
						ENDR
; typedef struct IteratorControlBlock *	IteratorControlBlockPtr

; 
; *  HFS Component Interface records
; 

	IF CALL_NOT_IN_CARBON THEN

; *  NewLg2PhysUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeLg2PhysUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeLg2PhysUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  NewHFSCIUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeHFSCIUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeHFSCIUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

	ENDIF	; CALL_NOT_IN_CARBON
HFSCIRec				RECORD 0
compInterfMask			 ds.l	1				; offset: $0 (0)		;  component flags 
compInterfProc			 ds.l	1				; offset: $4 (4)		;  pointer to file system call processing code 
log2PhyProc				 ds.l	1				; offset: $8 (8)		;  pointer to Lg2PhysProc() code 
stackTop				 ds.l	1				; offset: $C (12)		;  file system stack top 
stackSize				 ds.l	1				; offset: $10 (16)		;  file system stack size 
stackPtr				 ds.l	1				; offset: $14 (20)		;  current file system stack pointer 
reserved3				 ds.l	1				; offset: $18 (24)		;  --reserved, must be zero-- 
idSector				 ds.l	1				; offset: $1C (28)		;  Sector you need to ID a local volume. For networked volumes, this must be -1 
reserved2				 ds.l	1				; offset: $20 (32)		;  --reserved, must be zero-- 
reserved1				 ds.l	1				; offset: $24 (36)		;  --reserved, must be zero-- 
sizeof					 EQU *					; size:   $28 (40)
						ENDR
; typedef struct HFSCIRec *				HFSCIRecPtr

; 
; *  Disk Initialization Component Interface records
; 

	IF CALL_NOT_IN_CARBON THEN

; *  NewDICIUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeDICIUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeDICIUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

	ENDIF	; CALL_NOT_IN_CARBON
DICIRec					RECORD 0
compInterfMask			 ds.l	1				; offset: $0 (0)		;  component flags 
compInterfProc			 ds.l	1				; offset: $4 (4)		;  pointer to call processing code 
maxVolNameLength		 ds.w	1				; offset: $8 (8)		;  maximum length of your volume name 
blockSize				 ds.w	1				; offset: $A (10)		;  your file system's block size 
reserved3				 ds.l	1				; offset: $C (12)		;  --reserved, must be zero-- 
reserved2				 ds.l	1				; offset: $10 (16)		;  --reserved, must be zero-- 
reserved1				 ds.l	1				; offset: $14 (20)		;  --reserved, must be zero-- 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct DICIRec *				DICIRecPtr

; 
; * FormatListRec as returned by the .Sony disk driver's
; * Return Format List status call (csCode = 6).
; * If the status call to get this list for a drive is not
; * implemented by the driver, then a list with one entry
; * is contructed from the drive queue element for the drive.
; 

FormatListRec			RECORD 0
volSize					 ds.l	1				; offset: $0 (0)		;  disk capacity in SECTORs 
formatFlags				 ds.b	1				; offset: $4 (4)		;  flags 
sectorsPerTrack			 ds.b	1				; offset: $5 (5)		;  sectors per track side 
tracks					 ds.w	1				; offset: $6 (6)		;  number of tracks 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct FormatListRec *		FormatListRecPtr

; 
; * SizeListRec built from FormatListRecs as described above.
; 

SizeListRec				RECORD 0
sizeListFlags			 ds.w	1				; offset: $0 (0)		;  flags as set by external file system 
sizeEntry				 ds		FormatListRec	; offset: $2 (2)		;  disk driver format list record 
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct SizeListRec *			SizeListRecPtr

; 
; * paramBlock for the diCIEvaluateSize call
; 

DICIEvaluateSizeRec		RECORD 0
defaultSizeIndex		 ds.w	1				; offset: $0 (0)		;  default size for this FS 
numSizeEntries			 ds.w	1				; offset: $2 (2)		;  number of size entries 
driveNumber				 ds.w	1				; offset: $4 (4)		;  drive number 
sizeListPtr				 ds.l	1				; offset: $6 (6)		;  ptr to size entry table 
sectorSize				 ds.w	1				; offset: $A (10)		;  bytes per sector 
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct DICIEvaluateSizeRec *	DICIEvaluateSizeRecPtr

; 
; * paramBlock for the diCIExtendedZero call
; 

DICIExtendedZeroRec		RECORD 0
driveNumber				 ds.w	1				; offset: $0 (0)		;  drive number 
volNamePtr				 ds.l	1				; offset: $2 (2)		;  ptr to volume name string 
fsid					 ds.w	1				; offset: $6 (6)		;  file system ID 
volTypeSelector			 ds.w	1				; offset: $8 (8)		;  volume type selector, if supports more than 1 type 
numDefectBlocks			 ds.w	1				; offset: $A (10)		;  number of bad logical blocks 
defectListSize			 ds.w	1				; offset: $C (12)		;  size of the defect list buffer in bytes 
defectListPtr			 ds.l	1				; offset: $E (14)		;  pointer to defect list buffer 
volSize					 ds.l	1				; offset: $12 (18)		;  size of volume in SECTORs 
sectorSize				 ds.w	1				; offset: $16 (22)		;  bytes per sector 
extendedInfoPtr			 ds.l	1				; offset: $18 (24)		;  ptr to extended info 
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct DICIExtendedZeroRec *	DICIExtendedZeroRecPtr

; 
; * paramBlock for the diCIValidateVolName call
; 

DICIValidateVolNameRec	RECORD 0
theChar					 ds.b	1				; offset: $0 (0)		;  the character to validate 
hasMessageBuffer		 ds.b	1				; offset: $1 (1)		;  false if no message 
charOffset				 ds.w	1				; offset: $2 (2)		;  position of the current character (first char = 1) 
messageBufferPtr		 ds.l	1				; offset: $4 (4)		;  pointer to message buffer or nil 
charByteType			 ds.w	1				; offset: $8 (8)		;  theChar's byte type (smSingleByte, smFirstByte, or smLastByte) 
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct DICIValidateVolNameRec * DICIValidateVolNameRecPtr

; 
; * paramBlock for the diCIGetVolTypeInfo call
; 

DICIGetVolTypeInfoRec	RECORD 0
volSize					 ds.l	1				; offset: $0 (0)		;  size of volume in SECTORs 
sectorSize				 ds.w	1				; offset: $4 (4)		;  bytes per sector 
numVolTypes				 ds.w	1				; offset: $6 (6)		;  number of volume types supported 
volTypesBuffer			 ds.b	4 * Str31.sizeof ; offset: $8 (8)		;  4 string buffers 
sizeof					 EQU *					; size:   $88 (136)
						ENDR
; typedef struct DICIGetVolTypeInfoRec * DICIGetVolTypeInfoRecPtr

; 
; * paramBlock for the diCIGetFormatString call
; 

DICIGetFormatStringRec	RECORD 0
volSize					 ds.l	1				; offset: $0 (0)		;  volume size in SECTORs 
sectorSize				 ds.w	1				; offset: $4 (4)		;  sector size 
volTypeSelector			 ds.w	1				; offset: $6 (6)		;  volume type selector 
stringKind				 ds.w	1				; offset: $8 (8)		;  sub-function = type of string 
stringBuffer			 ds		Str255			; offset: $A (10)		;  string buffer 
sizeof					 EQU *					; size:   $10A (266)
						ENDR
; typedef struct DICIGetFormatStringRec * DICIGetFormatStringRecPtr

; 
; * paramBlock for the diCIGetExtendedFormatParams call
; 

DICIGetExtendedFormatRec RECORD 0
driveNumber				 ds.w	1				; offset: $0 (0)		;  drive number 
volTypeSelector			 ds.w	1				; offset: $2 (2)		;  volume type selector or 0 
volSize					 ds.l	1				; offset: $4 (4)		;  size of volume in SECTORs 
sectorSize				 ds.w	1				; offset: $8 (8)		;  bytes per sector 
fileSystemSpecPtr		 ds.l	1				; offset: $A (10)		;  pointer to the foreign file system's FSSpec 
extendedInfoPtr			 ds.l	1				; offset: $E (14)		;  pointer to extended parameter structure 
sizeof					 EQU *					; size:   $12 (18)
						ENDR
; typedef struct DICIGetExtendedFormatRec * DICIGetExtendedFormatRecPtr

; 
; *  File System Manager records
; 


	IF CALL_NOT_IN_CARBON THEN

; *  NewFSDCommUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeFSDCommUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeFSDCommUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

	ENDIF	; CALL_NOT_IN_CARBON


FSDRec					RECORD 0
fsdLink					 ds.l	1				; offset: $0 (0)		;  ptr to next 
fsdLength				 ds.w	1				; offset: $4 (4)		;  length of this FSD in BYTES 
fsdVersion				 ds.w	1				; offset: $6 (6)		;  version number 
fileSystemFSID			 ds.w	1				; offset: $8 (8)		;  file system id 
fileSystemName			 ds		Str31			; offset: $A (10)		;  file system name 
fileSystemSpec			 ds		FSSpec			; offset: $2A (42)		;  foreign file system's FSSpec 
fileSystemGlobalsPtr	 ds.l	1				; offset: $70 (112)		;  ptr to file system globals 
fileSystemCommProc		 ds.l	1				; offset: $74 (116)		;  communication proc with the FFS 
reserved3				 ds.l	1				; offset: $78 (120)		;  --reserved, must be zero-- 
reserved2				 ds.l	1				; offset: $7C (124)		;  --reserved, must be zero-- 
reserved1				 ds.l	1				; offset: $80 (128)		;  --reserved, must be zero-- 
fsdHFSCI				 ds		HFSCIRec		; offset: $84 (132)		;  HFS component interface    
fsdDICI					 ds		DICIRec			; offset: $AC (172)		;  Disk Initialization component interface 
sizeof					 EQU *					; size:   $C4 (196)
						ENDR
; typedef struct FSDRec *				FSDRecPtr

FSMGetIconInfoRec		RECORD 0
theIcon					 ds.l	32				; offset: $0 (0)		;  The ICN# structure 
theMask					 ds.l	32				; offset: $80 (128)		;  The mask for the icon above 
whereStr				 ds		Str255			; offset: $100 (256)
sizeof					 EQU *					; size:   $200 (512)
						ENDR
; typedef struct FSMGetIconInfoRec *	FSMGetIconInfoRecPtr

; 
; * paramBlock for ffsGetIconMessage and fsmGetFSIconMessage
; 

FSMGetIconRec			RECORD 0
refNum					 ds.w	1				; offset: $0 (0)		;  target drive num or volume refnum 
iconBufferPtr			 ds.l	1				; offset: $2 (2)		;  pointer to icon buffer 
requestSize				 ds.l	1				; offset: $6 (6)		;  requested size of the icon buffer 
actualSize				 ds.l	1				; offset: $A (10)		;  actual size of the icon data returned 
iconType				 ds.b	1				; offset: $E (14)		;  kind of icon. Note: A file system supporting kicnsIconFamily must 
;  return noErr, up to requestSize bytes of data, and the actual size 
;  of the 'icns' data in the actualSize field. If actualSize is greater 
;  than requestSize, the caller must resize the icon buffer and retry 
;  the request with the larger buffer and new requestSize. 
isEjectable				 ds.b	1				; offset: $F (15)		;  true if the device is ejectable 
driveQElemPtr			 ds.l	1				; offset: $10 (16)		;  pointer to DQE 
fileSystemSpecPtr		 ds.l	1				; offset: $14 (20)		;  pointer to foreign file system's FSSpec 
reserved1				 ds.l	1				; offset: $18 (24)		;  --reserved, must be zero-- 
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct FSMGetIconRec *		FSMGetIconRecPtr

; 
; *  HFS Utility routine prototypes
; 

	IF CALL_NOT_IN_CARBON THEN

; *  UTAllocateFCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTAllocateFCB(short *fileRefNum, FCBRecPtr *fileCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTAllocateFCB
			moveq           	#0,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTAllocateFCB
	ENDIF


; *  UTReleaseFCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTReleaseFCB(short fileRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTReleaseFCB
			moveq           	#1,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTReleaseFCB
	ENDIF


; *  UTLocateFCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTLocateFCB(VCBPtr volCtrlBlockPtr, unsigned long fileNum, StringPtr namePtr, short *fileRefNum, FCBRecPtr *fileCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTLocateFCB
			moveq           	#2,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTLocateFCB
	ENDIF


; *  UTLocateNextFCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTLocateNextFCB(VCBPtr volCtrlBlockPtr, unsigned long fileNum, StringPtr namePtr, short *fileRefNum, FCBRecPtr *fileCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTLocateNextFCB
			moveq           	#3,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTLocateNextFCB
	ENDIF


; *  UTIndexFCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTIndexFCB(VCBPtr volCtrlBlockPtr, short *fileRefNum, FCBRecPtr *fileCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTIndexFCB
			moveq           	#4,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTIndexFCB
	ENDIF


; *  UTResolveFCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTResolveFCB(short fileRefNum, FCBRecPtr *fileCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTResolveFCB
			moveq           	#5,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTResolveFCB
	ENDIF


; *  UTAllocateVCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTAllocateVCB(unsigned short *sysVCBLength, VCBPtr *volCtrlBlockPtr, unsigned short addSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTAllocateVCB
			moveq           	#6,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTAllocateVCB
	ENDIF


; *  UTAddNewVCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTAddNewVCB(short driveNum, short *vRefNum, VCBPtr volCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTAddNewVCB
			moveq           	#7,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTAddNewVCB
	ENDIF


; *  UTDisposeVCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTDisposeVCB(VCBPtr volCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTDisposeVCB
			moveq           	#8,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTDisposeVCB
	ENDIF


; *  UTLocateVCBByRefNum()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTLocateVCBByRefNum(short refNum, short *vRefNum, VCBPtr *volCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTLocateVCBByRefNum
			moveq           	#9,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTLocateVCBByRefNum
	ENDIF


; *  UTLocateVCBByName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTLocateVCBByName(StringPtr namePtr, short *moreMatches, short *vRefNum, VCBPtr *volCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTLocateVCBByName
			moveq           	#10,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTLocateVCBByName
	ENDIF


; *  UTLocateNextVCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTLocateNextVCB(StringPtr namePtr, short *moreMatches, short *vRefNum, VCBPtr *volCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTLocateNextVCB
			moveq           	#11,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTLocateNextVCB
	ENDIF


; *  UTAllocateWDCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTAllocateWDCB(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTAllocateWDCB
			moveq           	#12,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTAllocateWDCB
	ENDIF


; *  UTReleaseWDCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTReleaseWDCB(short wdRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTReleaseWDCB
			moveq           	#13,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTReleaseWDCB
	ENDIF


; *  UTResolveWDCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTResolveWDCB(long procID, short wdIndex, short wdRefNum, WDCBRecPtr *wdCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTResolveWDCB
			moveq           	#14,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTResolveWDCB
	ENDIF


; *  UTFindDrive()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTFindDrive(short driveNum, DrvQElPtr *driveQElementPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTFindDrive
			moveq           	#15,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTFindDrive
	ENDIF


; *  UTAdjustEOF()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTAdjustEOF(short fileRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTAdjustEOF
			moveq           	#16,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTAdjustEOF
	ENDIF


; *  UTSetDefaultVol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTSetDefaultVol(long nodeHint, unsigned long dirID, short refNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTSetDefaultVol
			moveq           	#17,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTSetDefaultVol
	ENDIF


; *  UTGetDefaultVol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTGetDefaultVol(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTGetDefaultVol
			moveq           	#18,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTGetDefaultVol
	ENDIF


; *  UTEjectVol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTEjectVol(VCBPtr volCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTEjectVol
			moveq           	#43,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTEjectVol
	ENDIF


; *  UTCheckWDRefNum()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTCheckWDRefNum(short wdRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTCheckWDRefNum
			moveq           	#19,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTCheckWDRefNum
	ENDIF


; *  UTCheckFileRefNum()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTCheckFileRefNum(short fileRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTCheckFileRefNum
			moveq           	#20,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTCheckFileRefNum
	ENDIF


; *  UTCheckVolRefNum()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTCheckVolRefNum(short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTCheckVolRefNum
			moveq           	#21,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTCheckVolRefNum
	ENDIF


; *  UTCheckPermission()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTCheckPermission(VCBPtr volCtrlBlockPtr, short *modByte, unsigned long fileNum, ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTCheckPermission
			moveq           	#22,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTCheckPermission
	ENDIF


; *  UTCheckVolOffline()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTCheckVolOffline(short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTCheckVolOffline
			moveq           	#23,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTCheckVolOffline
	ENDIF


; *  UTCheckVolModifiable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTCheckVolModifiable(short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTCheckVolModifiable
			moveq           	#24,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTCheckVolModifiable
	ENDIF


; *  UTCheckFileModifiable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTCheckFileModifiable(short fileRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTCheckFileModifiable
			moveq           	#25,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTCheckFileModifiable
	ENDIF


; *  UTCheckDirBusy()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTCheckDirBusy(VCBPtr volCtrlBlockPtr, unsigned long dirID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTCheckDirBusy
			moveq           	#26,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTCheckDirBusy
	ENDIF


; *  UTParsePathname()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTParsePathname(short *volNamelength, StringPtr namePtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTParsePathname
			moveq           	#27,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTParsePathname
	ENDIF


; *  UTGetPathComponentName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTGetPathComponentName(ParsePathRecPtr parseRec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTGetPathComponentName
			moveq           	#28,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTGetPathComponentName
	ENDIF


; *  UTDetermineVol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTDetermineVol(ParmBlkPtr paramBlock, short *status, short *moreMatches, short *vRefNum, VCBPtr *volCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTDetermineVol
			moveq           	#29,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTDetermineVol
	ENDIF


; *  UTGetBlock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTGetBlock(short refNum, void *log2PhyProc, unsigned long blockNum, short gbOption, Ptr *buffer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTGetBlock
			moveq           	#31,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTGetBlock
	ENDIF


; *  UTReleaseBlock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTReleaseBlock(Ptr buffer, short rbOption)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTReleaseBlock
			moveq           	#32,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTReleaseBlock
	ENDIF


; *  UTFlushCache()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTFlushCache(short refNum, short fcOption)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTFlushCache
			moveq           	#33,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTFlushCache
	ENDIF


; *  UTMarkDirty()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTMarkDirty(Ptr buffer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTMarkDirty
			moveq           	#35,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTMarkDirty
	ENDIF


; *  UTTrashVolBlocks()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTTrashVolBlocks(VCBPtr volCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTTrashVolBlocks
			moveq           	#36,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTTrashVolBlocks
	ENDIF


; *  UTTrashFileBlocks()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTTrashFileBlocks(VCBPtr volCtrlBlockPtr, unsigned long fileNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTTrashFileBlocks
			moveq           	#37,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTTrashFileBlocks
	ENDIF


; *  UTTrashBlocks()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTTrashBlocks(unsigned long beginPosition, unsigned long byteCount, VCBPtr volCtrlBlockPtr, short fileRefNum, short tbOption)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTTrashBlocks
			moveq           	#38,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTTrashBlocks
	ENDIF


; *  UTCacheReadIP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTCacheReadIP(void *log2PhyProc, unsigned long filePosition, Ptr ioBuffer, short fileRefNum, unsigned long reqCount, unsigned long *actCount, short cacheOption)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTCacheReadIP
			moveq           	#39,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTCacheReadIP
	ENDIF


; *  UTCacheWriteIP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTCacheWriteIP(void *log2PhyProc, unsigned long filePosition, Ptr ioBuffer, short fileRefNum, unsigned long reqCount, unsigned long *actCount, short cacheOption)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTCacheWriteIP
			moveq           	#40,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTCacheWriteIP
	ENDIF


; *  UTBlockInFQHashP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTBlockInFQHashP(short vRefNum, unsigned long diskBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTBlockInFQHashP
			moveq           	#44,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTBlockInFQHashP
	ENDIF


; *  UTVolCacheReadIP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTVolCacheReadIP(VCBPtr volCtrlBlockPtr, unsigned long blockPosition, Ptr ioBuffer, unsigned long reqCount, unsigned long *actCount, short cacheOption)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTVolCacheReadIP
			moveq           	#52,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTVolCacheReadIP
	ENDIF


; *  UTVolCacheWriteIP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTVolCacheWriteIP(VCBPtr volCtrlBlockPtr, unsigned long blockPosition, Ptr ioBuffer, unsigned long reqCount, unsigned long *actCount, short cacheOption)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTVolCacheWriteIP
			moveq           	#53,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTVolCacheWriteIP
	ENDIF


; *  UTResolveFileRefNum()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTResolveFileRefNum(FCBRecPtr fileCtrlBlockPtr, short *fileRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTResolveFileRefNum
			moveq           	#54,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTResolveFileRefNum
	ENDIF


; *  UTCheckFCB()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTCheckFCB(FCBRecPtr fileCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTCheckFCB
			moveq           	#55,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTCheckFCB
	ENDIF


; *  UTCheckForkPermissions()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTCheckForkPermissions(VCBPtr volCtrlBlockPtr, UInt32 fileNum, UInt32 forkID, Boolean fileLocked, SInt8 permissions, Boolean useSearchList, SInt8 *fcbFlags, SInt16 *openForkRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTCheckForkPermissions
			moveq           	#56,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTCheckForkPermissions
	ENDIF


; *  UTAddFCBToSearchList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTAddFCBToSearchList(FCBRecPtr fileCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTAddFCBToSearchList
			moveq           	#57,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTAddFCBToSearchList
	ENDIF


; *  UTRemoveFCBFromSearchList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTRemoveFCBFromSearchList(FCBRecPtr fileCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTRemoveFCBFromSearchList
			moveq           	#58,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTRemoveFCBFromSearchList
	ENDIF


; *  UTLocateFCBInSearchList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTLocateFCBInSearchList(VCBPtr volCtrlBlockPtr, unsigned long fileNum, short *fileRefNum, FCBRecPtr *fileCtrlBlockPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTLocateFCBInSearchList
			moveq           	#59,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTLocateFCBInSearchList
	ENDIF


; *  UTGetForkControlBlockSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UTGetForkControlBlockSize(UInt32 *fcbSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_UTGetForkControlBlockSize
			moveq           	#60,D0
			dc.w            	$A824
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UTGetForkControlBlockSize
	ENDIF


; 
; *  File System Manager call prototypes
; 


; *  InstallFS()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr InstallFS(FSDRecPtr fsdPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	fsdPtr          => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_InstallFS
			moveq           	#0,D0
			dc.w            	$A0AC
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InstallFS
	ENDIF


; *  RemoveFS()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr RemoveFS(short fsid)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	fsid            => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_RemoveFS
			moveq           	#1,D0
			dc.w            	$A0AC
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveFS
	ENDIF


; *  GetFSInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr GetFSInfo(short selector, short key, short *bufSize, FSDRecPtr fsdPtr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetFSInfo
	ENDIF

    IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
        ; parameters:
        ;   selector        => D4
        ;   key             => D3
        ;   bufSize         => FSDRec.fsdLength(A0)
        ;   fsdPtr          => A0
        ; returns:
        ;   OSErr           <= D0
        Macro
        _GetFSInfo
            moveq               #2,D0
            dc.w                $A0AC
        EndM
    ENDIF

; *  SetFSInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SetFSInfo(short fsid, short bufSize, FSDRecPtr fsdPtr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetFSInfo
	ENDIF

    IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
        ; parameters:
        ;   fsid            => D4
        ;   bufSize         => D3
        ;   fsdPtr          => A0
        ; returns:
        ;   OSErr           <= D0
        Macro
        _SetFSInfo
            moveq               #5,D0
            dc.w                $A0AC
        EndM
    ENDIF

; *  InformFSM()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr InformFSM(short theMessage, void *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InformFSM
	ENDIF

    IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
        ; parameters:
        ;   theMessage      => D3
        ;   paramBlock      => A0
        ; returns:
        ;   OSErr           <= D0
        Macro
        _InformFSM
            moveq               #6,D0
            dc.w                $A0AC
        EndM
    ENDIF

; *  InformFFS()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr InformFFS(short fsid, void *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InformFFS
	ENDIF

; Note: InformFFS is glue code that uses GetFSInfo to get the FSDRec for a given
;       file system by fsid, and then calls the fileSystemCommProc in that FSDRec.


	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF ; __FSM__ 


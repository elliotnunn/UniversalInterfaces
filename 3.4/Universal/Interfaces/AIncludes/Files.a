;
;    File:       Files.a
;
;    Contains:   File Manager (MFS, HFS, and HFS+) Interfaces.
;
;    Version:    Technology: Mac OS 8.5
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1985-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__FILES__') = 'UNDEFINED' THEN
__FILES__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF
	IF &TYPE('__OSUTILS__') = 'UNDEFINED' THEN
	include 'OSUtils.a'
	ENDIF
	IF &TYPE('__TEXTCOMMON__') = 'UNDEFINED' THEN
	include 'TextCommon.a'
	ENDIF
	IF &TYPE('__UTCUTILS__') = 'UNDEFINED' THEN
	include 'UTCUtils.a'
	ENDIF

;  Finder constants were moved to Finder.≈ 
	IF &TYPE('__FINDER__') = 'UNDEFINED' THEN
	include 'Finder.a'
	ENDIF

;  HFSUniStr255 is the Unicode equivalent of Str255 
HFSUniStr255			RECORD 0
length					 ds.w	1				; offset: $0 (0)		;  number of unicode characters 
unicode					 ds.w	255				; offset: $2 (2)		;  unicode characters 
sizeof					 EQU *					; size:   $200 (512)
						ENDR
; typedef const struct HFSUniStr255 *	ConstHFSUniStr255Param


fsCurPerm						EQU		$00					; open access permissions in ioPermssn 
fsRdPerm						EQU		$01
fsWrPerm						EQU		$02
fsRdWrPerm						EQU		$03
fsRdWrShPerm					EQU		$04
fsRdDenyPerm					EQU		$10					; for use with OpenDeny and OpenRFDeny 
fsWrDenyPerm					EQU		$20					; for use with OpenDeny and OpenRFDeny 

fsRtParID						EQU		1
fsRtDirID						EQU		2

fsAtMark						EQU		0					; positioning modes in ioPosMode 
fsFromStart						EQU		1
fsFromLEOF						EQU		2
fsFromMark						EQU		3

															; ioPosMode flags 
pleaseCacheBit					EQU		4					; please cache this request 
pleaseCacheMask					EQU		$0010
noCacheBit						EQU		5					; please don't cache this request 
noCacheMask						EQU		$0020
rdVerifyBit						EQU		6					; read verify mode 
rdVerifyMask					EQU		$0040
rdVerify						EQU		64					; old name of rdVerifyMask 
forceReadBit					EQU		6
forceReadMask					EQU		$0040
newLineBit						EQU		7					; newline mode 
newLineMask						EQU		$0080
newLineCharMask					EQU		$FF00				; newline character 


															; CatSearch Search bitmask Constants 
fsSBPartialName					EQU		1
fsSBFullName					EQU		2
fsSBFlAttrib					EQU		4
fsSBFlFndrInfo					EQU		8
fsSBFlLgLen						EQU		32
fsSBFlPyLen						EQU		64
fsSBFlRLgLen					EQU		128
fsSBFlRPyLen					EQU		256
fsSBFlCrDat						EQU		512
fsSBFlMdDat						EQU		1024
fsSBFlBkDat						EQU		2048
fsSBFlXFndrInfo					EQU		4096
fsSBFlParID						EQU		8192
fsSBNegate						EQU		16384
fsSBDrUsrWds					EQU		8
fsSBDrNmFls						EQU		16
fsSBDrCrDat						EQU		512
fsSBDrMdDat						EQU		1024
fsSBDrBkDat						EQU		2048
fsSBDrFndrInfo					EQU		4096
fsSBDrParID						EQU		8192

															; CatSearch Search bit value Constants 
fsSBPartialNameBit				EQU		0					;ioFileName points to a substring
fsSBFullNameBit					EQU		1					;ioFileName points to a match string
fsSBFlAttribBit					EQU		2					;search includes file attributes
fsSBFlFndrInfoBit				EQU		3					;search includes finder info
fsSBFlLgLenBit					EQU		5					;search includes data logical length
fsSBFlPyLenBit					EQU		6					;search includes data physical length
fsSBFlRLgLenBit					EQU		7					;search includes resource logical length
fsSBFlRPyLenBit					EQU		8					;search includes resource physical length
fsSBFlCrDatBit					EQU		9					;search includes create date
fsSBFlMdDatBit					EQU		10					;search includes modification date
fsSBFlBkDatBit					EQU		11					;search includes backup date
fsSBFlXFndrInfoBit				EQU		12					;search includes extended finder info
fsSBFlParIDBit					EQU		13					;search includes file's parent ID
fsSBNegateBit					EQU		14					;return all non-matches
fsSBDrUsrWdsBit					EQU		3					;search includes directory finder info
fsSBDrNmFlsBit					EQU		4					;search includes directory valence
fsSBDrCrDatBit					EQU		9					;directory-named version of fsSBFlCrDatBit
fsSBDrMdDatBit					EQU		10					;directory-named version of fsSBFlMdDatBit
fsSBDrBkDatBit					EQU		11					;directory-named version of fsSBFlBkDatBit
fsSBDrFndrInfoBit				EQU		12					;directory-named version of fsSBFlXFndrInfoBit
fsSBDrParIDBit					EQU		13					;directory-named version of fsSBFlParIDBit

															; vMAttrib (GetVolParms) bit position constants 
bLimitFCBs						EQU		31
bLocalWList						EQU		30
bNoMiniFndr						EQU		29
bNoVNEdit						EQU		28
bNoLclSync						EQU		27
bTrshOffLine					EQU		26
bNoSwitchTo						EQU		25
bNoDeskItems					EQU		20
bNoBootBlks						EQU		19
bAccessCntl						EQU		18
bNoSysDir						EQU		17
bHasExtFSVol					EQU		16
bHasOpenDeny					EQU		15
bHasCopyFile					EQU		14
bHasMoveRename					EQU		13
bHasDesktopMgr					EQU		12
bHasShortName					EQU		11
bHasFolderLock					EQU		10
bHasPersonalAccessPrivileges	EQU		9
bHasUserGroupList				EQU		8
bHasCatSearch					EQU		7
bHasFileIDs						EQU		6
bHasBTreeMgr					EQU		5
bHasBlankAccessPrivileges		EQU		4
bSupportsAsyncRequests			EQU		3					; asynchronous requests to this volume are handled correctly at any time
bSupportsTrashVolumeCache		EQU		2

															; vMExtendedAttributes (GetVolParms) bit position constants 
bIsEjectable					EQU		0					; volume is in an ejectable disk drive 
bSupportsHFSPlusAPIs			EQU		1					; volume supports HFS Plus APIs directly (not through compatibility layer) 
bSupportsFSCatalogSearch		EQU		2					; volume supports FSCatalogSearch 
bSupportsFSExchangeObjects		EQU		3					; volume supports FSExchangeObjects 
bSupports2TBFiles				EQU		4					; volume supports supports 2 terabyte files 
bSupportsLongNames				EQU		5					; volume supports file/directory/volume names longer than 31 characters 
bSupportsMultiScriptNames		EQU		6					; volume supports file/directory/volume names with characters from multiple script systems 
bSupportsNamedForks				EQU		7					; volume supports forks beyond the data and resource forks 
bSupportsSubtreeIterators		EQU		8					; volume supports recursive iterators not at the volume root 
bL2PCanMapFileBlocks			EQU		9					; volume supports Lg2Phys SPI correctly 

															; vMExtendedAttributes (GetVolParms) bit position constants 
bParentModDateChanges			EQU		10					; Changing a file or folder causes its parent's mod date to change 
bAncestorModDateChanges			EQU		11					; Changing a file or folder causes all ancestor mod dates to change 

															; vMExtendedAttributes (GetVolParms) bit position constants 
bSupportsSymbolicLinks			EQU		13					; volume supports the creation and use of symbolic links (Mac OS X only) 
bIsAutoMounted					EQU		14					; volume was mounted automatically (Mac OS X only) 
bAllowCDiDataHandler			EQU		17					; allow QuickTime's CDi data handler to examine this volume 

															; Desktop Database, ffsGetIconMessage and fsmGetFSIconMessage icon type and size Constants 
kLargeIcon						EQU		1
kLarge4BitIcon					EQU		2
kLarge8BitIcon					EQU		3
kSmallIcon						EQU		4
kSmall4BitIcon					EQU		5
kSmall8BitIcon					EQU		6
kicnsIconFamily					EQU		239					; Note: The 'icns' icon family record is variable sized. 

kLargeIconSize					EQU		256
kLarge4BitIconSize				EQU		512
kLarge8BitIconSize				EQU		1024
kSmallIconSize					EQU		64
kSmall4BitIconSize				EQU		128
kSmall8BitIconSize				EQU		256

															; Large Volume Constants 
kWidePosOffsetBit				EQU		8
kUseWidePositioning				EQU		$0100
kMaximumBlocksIn4GB				EQU		$007FFFFF

															; Foreign Privilege Model Identifiers 
fsUnixPriv						EQU		1

															; Authentication Constants 
kNoUserAuthentication			EQU		1
kPassword						EQU		2
kEncryptPassword				EQU		3
kTwoWayEncryptPassword			EQU		6

;  mapping codes (ioObjType) for MapName & MapID 

kOwnerID2Name					EQU		1
kGroupID2Name					EQU		2
kOwnerName2ID					EQU		3
kGroupName2ID					EQU		4					; types of oj object to be returned (ioObjType) for _GetUGEntry 
kReturnNextUser					EQU		1
kReturnNextGroup				EQU		2
kReturnNextUG					EQU		3
;  vcbFlags bits 

kVCBFlagsIdleFlushBit			EQU		3					; Set if volume should be flushed at idle time 
kVCBFlagsIdleFlushMask			EQU		$0008
kVCBFlagsHFSPlusAPIsBit			EQU		4					; Set if volume implements HFS Plus APIs itself (not via emulation) 
kVCBFlagsHFSPlusAPIsMask		EQU		$0010
kVCBFlagsHardwareGoneBit		EQU		5					; Set if disk driver returned a hardwareGoneErr to Read or Write 
kVCBFlagsHardwareGoneMask		EQU		$0020
kVCBFlagsVolumeDirtyBit			EQU		15					; Set if volume information has changed since the last FlushVol 
kVCBFlagsVolumeDirtyMask		EQU		$8000
;  ioVAtrb bits returned by PBHGetVInfo and PBXGetVolInfo 

kioVAtrbDefaultVolumeBit		EQU		5					; Set if the volume is the default volume 
kioVAtrbDefaultVolumeMask		EQU		$0020
kioVAtrbFilesOpenBit			EQU		6					; Set if there are open files or iterators 
kioVAtrbFilesOpenMask			EQU		$0040
kioVAtrbHardwareLockedBit		EQU		7					; Set if volume is locked by a hardware setting 
kioVAtrbHardwareLockedMask		EQU		$0080
kioVAtrbSoftwareLockedBit		EQU		15					; Set if volume is locked by software 
kioVAtrbSoftwareLockedMask		EQU		$8000
;  ioFlAttrib bits returned by PBGetCatInfo 

															; file and directory attributes in ioFlAttrib 
kioFlAttribLockedBit			EQU		0					; Set if file or directory is locked 
kioFlAttribLockedMask			EQU		$01
kioFlAttribResOpenBit			EQU		2					; Set if resource fork is open 
kioFlAttribResOpenMask			EQU		$04
kioFlAttribDataOpenBit			EQU		3					; Set if data fork is open 
kioFlAttribDataOpenMask			EQU		$08
kioFlAttribDirBit				EQU		4					; Set if this is a directory 
kioFlAttribDirMask				EQU		$10
ioDirFlg						EQU		4					; Set if this is a directory (old name) 
ioDirMask						EQU		$10
kioFlAttribCopyProtBit			EQU		6					; Set if AppleShare server "copy-protects" the file 
kioFlAttribCopyProtMask			EQU		$40
kioFlAttribFileOpenBit			EQU		7					; Set if file (either fork) is open 
kioFlAttribFileOpenMask			EQU		$80					; ioFlAttrib for directories only 
kioFlAttribInSharedBit			EQU		2					; Set if the directory is within a shared area of the directory hierarchy 
kioFlAttribInSharedMask			EQU		$04
kioFlAttribMountedBit			EQU		3					; Set if the directory is a share point that is mounted by some user 
kioFlAttribMountedMask			EQU		$08
kioFlAttribSharePointBit		EQU		5					; Set if the directory is a share point 
kioFlAttribSharePointMask		EQU		$20
;  ioFCBFlags bits returned by PBGetFCBInfo 

kioFCBWriteBit					EQU		8					; Data can be written to this file 
kioFCBWriteMask					EQU		$0100
kioFCBResourceBit				EQU		9					; This file is a resource fork 
kioFCBResourceMask				EQU		$0200
kioFCBWriteLockedBit			EQU		10					; File has a locked byte range 
kioFCBWriteLockedMask			EQU		$0400
kioFCBLargeFileBit				EQU		11					; File may grow beyond 2GB; cache uses file blocks, not bytes 
kioFCBLargeFileMask				EQU		$0800
kioFCBSharedWriteBit			EQU		12					; File is open for shared write access 
kioFCBSharedWriteMask			EQU		$1000
kioFCBFileLockedBit				EQU		13					; File is locked (write-protected) 
kioFCBFileLockedMask			EQU		$2000
kioFCBOwnClumpBit				EQU		14					; File has clump size specified in FCB 
kioFCBOwnClumpMask				EQU		$4000
kioFCBModifiedBit				EQU		15					; File has changed since it was last flushed 
kioFCBModifiedMask				EQU		$8000
;  ioACUser bits returned by PBGetCatInfo 
;  Note: you must clear ioACUser before calling PBGetCatInfo because some file systems do not use this field 

kioACUserNoSeeFolderBit			EQU		0					; Set if user does not have See Folder privileges 
kioACUserNoSeeFolderMask		EQU		$01
kioACUserNoSeeFilesBit			EQU		1					; Set if user does not have See Files privileges 
kioACUserNoSeeFilesMask			EQU		$02
kioACUserNoMakeChangesBit		EQU		2					; Set if user does not have Make Changes privileges 
kioACUserNoMakeChangesMask		EQU		$04
kioACUserNotOwnerBit			EQU		7					; Set if user is not owner of the directory 
kioACUserNotOwnerMask			EQU		$80
;  Folder and File values of access privileges in ioACAccess 

kioACAccessOwnerBit				EQU		31					; User is owner of directory 
kioACAccessOwnerMask			EQU		$80000000
kioACAccessBlankAccessBit		EQU		28					; Directory has blank access privileges 
kioACAccessBlankAccessMask		EQU		$10000000
kioACAccessUserWriteBit			EQU		26					; User has write privileges 
kioACAccessUserWriteMask		EQU		$04000000
kioACAccessUserReadBit			EQU		25					; User has read privileges 
kioACAccessUserReadMask			EQU		$02000000
kioACAccessUserSearchBit		EQU		24					; User has search privileges 
kioACAccessUserSearchMask		EQU		$01000000
kioACAccessEveryoneWriteBit		EQU		18					; Everyone has write privileges 
kioACAccessEveryoneWriteMask	EQU		$00040000
kioACAccessEveryoneReadBit		EQU		17					; Everyone has read privileges 
kioACAccessEveryoneReadMask		EQU		$00020000
kioACAccessEveryoneSearchBit	EQU		16					; Everyone has search privileges 
kioACAccessEveryoneSearchMask	EQU		$00010000
kioACAccessGroupWriteBit		EQU		10					; Group has write privileges 
kioACAccessGroupWriteMask		EQU		$00000400
kioACAccessGroupReadBit			EQU		9					; Group has read privileges 
kioACAccessGroupReadMask		EQU		$00000200
kioACAccessGroupSearchBit		EQU		8					; Group has search privileges 
kioACAccessGroupSearchMask		EQU		$00000100
kioACAccessOwnerWriteBit		EQU		2					; Owner has write privileges 
kioACAccessOwnerWriteMask		EQU		$00000004
kioACAccessOwnerReadBit			EQU		1					; Owner has read privileges 
kioACAccessOwnerReadMask		EQU		$00000002
kioACAccessOwnerSearchBit		EQU		0					; Owner has search privileges 
kioACAccessOwnerSearchMask		EQU		$00000001
kfullPrivileges					EQU		$00070007			; all privileges for everybody and owner
kownerPrivileges				EQU		$00000007			; all privileges for owner only
;  values of user IDs and group IDs 

knoUser							EQU		0
kadministratorUser				EQU		1

knoGroup						EQU		0

GetVolParmsInfoBuffer	RECORD 0
vMVersion				 ds.w	1				; offset: $0 (0)		; version number
vMAttrib				 ds.l	1				; offset: $2 (2)		; bit vector of attributes (see vMAttrib constants)
vMLocalHand				 ds.l	1				; offset: $6 (6)		; handle to private data
vMServerAdr				 ds.l	1				; offset: $A (10)		; AppleTalk server address or zero
;        vMVersion 1 GetVolParmsInfoBuffer ends here 
vMVolumeGrade			 ds.l	1				; offset: $E (14)		; approx. speed rating or zero if unrated
vMForeignPrivID			 ds.w	1				; offset: $12 (18)		; foreign privilege model supported or zero if none
;        vMVersion 2 GetVolParmsInfoBuffer ends here 
vMExtendedAttributes	 ds.l	1				; offset: $14 (20)		; extended attribute bits (see vMExtendedAttributes constants)
;        vMVersion 3 GetVolParmsInfoBuffer ends here 
vMDeviceID				 ds.l	1				; offset: $18 (24)		;  device id name for interoperability with IOKit 
;        vMVersion 4 GetVolParmsInfoBuffer ends here 
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef ParamBlockRec *				ParmBlkPtr

IOParam					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioRefNum				 ds.w	1				; offset: $18 (24)		; refNum for I/O operation
ioVersNum				 ds.b	1				; offset: $1A (26)		; version number
ioPermssn				 ds.b	1				; offset: $1B (27)		; Open: permissions (byte)
ioMisc					 ds.l	1				; offset: $1C (28)		; Rename: new name (GetEOF,SetEOF: logical end of file) (Open: optional ptr to buffer) (SetFileType: new type)
ioBuffer				 ds.l	1				; offset: $20 (32)		; data buffer Ptr
ioReqCount				 ds.l	1				; offset: $24 (36)		; requested byte count; also = ioNewDirID
ioActCount				 ds.l	1				; offset: $28 (40)		; actual byte count completed
ioPosMode				 ds.w	1				; offset: $2C (44)		; initial file positioning
ioPosOffset				 ds.l	1				; offset: $2E (46)		; file position offset
sizeof					 EQU *					; size:   $32 (50)
						ENDR
; typedef struct IOParam *				IOParamPtr

FileParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioFRefNum				 ds.w	1				; offset: $18 (24)		; reference number
ioFVersNum				 ds.b	1				; offset: $1A (26)		; version number
filler1					 ds.b	1				; offset: $1B (27)
ioFDirIndex				 ds.w	1				; offset: $1C (28)		; GetFInfo directory index
ioFlAttrib				 ds.b	1				; offset: $1E (30)		; GetFInfo: in-use bit=7, lock bit=0
ioFlVersNum				 ds.b	1				; offset: $1F (31)		; file version number
ioFlFndrInfo			 ds		FInfo			; offset: $20 (32)		; user info
ioFlNum					 ds.l	1				; offset: $30 (48)		; GetFInfo: file number; TF- ioDirID
ioFlStBlk				 ds.w	1				; offset: $34 (52)		; start file block (0 if none)
ioFlLgLen				 ds.l	1				; offset: $36 (54)		; logical length (EOF)
ioFlPyLen				 ds.l	1				; offset: $3A (58)		; physical length
ioFlRStBlk				 ds.w	1				; offset: $3E (62)		; start block rsrc fork
ioFlRLgLen				 ds.l	1				; offset: $40 (64)		; file logical length rsrc fork
ioFlRPyLen				 ds.l	1				; offset: $44 (68)		; file physical length rsrc fork
ioFlCrDat				 ds.l	1				; offset: $48 (72)		; file creation date& time (32 bits in secs)
ioFlMdDat				 ds.l	1				; offset: $4C (76)		; last modified date and time
sizeof					 EQU *					; size:   $50 (80)
						ENDR
; typedef struct FileParam *			FileParamPtr

VolumeParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
filler2					 ds.l	1				; offset: $18 (24)
ioVolIndex				 ds.w	1				; offset: $1C (28)		; volume index number
ioVCrDate				 ds.l	1				; offset: $1E (30)		; creation date and time
ioVLsBkUp				 ds.l	1				; offset: $22 (34)		; last backup date and time
ioVAtrb					 ds.w	1				; offset: $26 (38)		; volume attrib
ioVNmFls				 ds.w	1				; offset: $28 (40)		; number of files in directory
ioVDirSt				 ds.w	1				; offset: $2A (42)		; start block of file directory
ioVBlLn					 ds.w	1				; offset: $2C (44)		; GetVolInfo: length of dir in blocks
ioVNmAlBlks				 ds.w	1				; offset: $2E (46)		; for compatibilty ioVNmAlBlks * ioVAlBlkSiz <= 2 GB
ioVAlBlkSiz				 ds.l	1				; offset: $30 (48)		; for compatibilty ioVAlBlkSiz is <= $0000FE00 (65,024)
ioVClpSiz				 ds.l	1				; offset: $34 (52)		; GetVolInfo: bytes to allocate at a time
ioAlBlSt				 ds.w	1				; offset: $38 (56)		; starting disk(512-byte) block in block map
ioVNxtFNum				 ds.l	1				; offset: $3A (58)		; GetVolInfo: next free file number
ioVFrBlk				 ds.w	1				; offset: $3E (62)		; GetVolInfo: # free alloc blks for this vol
sizeof					 EQU *					; size:   $40 (64)
						ENDR
; typedef struct VolumeParam *			VolumeParamPtr

CntrlParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioCRefNum				 ds.w	1				; offset: $18 (24)		; refNum for I/O operation
csCode					 ds.w	1				; offset: $1A (26)		; word for control status code
csParam					 ds.w	11				; offset: $1C (28)		; operation-defined parameters
sizeof					 EQU *					; size:   $32 (50)
						ENDR
; typedef struct CntrlParam *			CntrlParamPtr

SlotDevParam			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioSRefNum				 ds.w	1				; offset: $18 (24)
ioSVersNum				 ds.b	1				; offset: $1A (26)
ioSPermssn				 ds.b	1				; offset: $1B (27)
ioSMix					 ds.l	1				; offset: $1C (28)
ioSFlags				 ds.w	1				; offset: $20 (32)
ioSlot					 ds.b	1				; offset: $22 (34)
ioID					 ds.b	1				; offset: $23 (35)
sizeof					 EQU *					; size:   $24 (36)
						ENDR
; typedef struct SlotDevParam *			SlotDevParamPtr

MultiDevParam			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioMRefNum				 ds.w	1				; offset: $18 (24)
ioMVersNum				 ds.b	1				; offset: $1A (26)
ioMPermssn				 ds.b	1				; offset: $1B (27)
ioMMix					 ds.l	1				; offset: $1C (28)
ioMFlags				 ds.w	1				; offset: $20 (32)
ioSEBlkPtr				 ds.l	1				; offset: $22 (34)
sizeof					 EQU *					; size:   $26 (38)
						ENDR
; typedef struct MultiDevParam *		MultiDevParamPtr

ParamBlockRec			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioRefNum				 ds.w	1				; offset: $18 (24)		; refNum for I/O operation
ioVersNum				 ds.b	1				; offset: $1A (26)		; version number
ioPermssn				 ds.b	1				; offset: $1B (27)		; Open: permissions (byte)
ioMisc					 ds.l	1				; offset: $1C (28)		; Rename: new name (GetEOF,SetEOF: logical end of file) (Open: optional ptr to buffer) (SetFileType: new type)
ioBuffer				 ds.l	1				; offset: $20 (32)		; data buffer Ptr
ioReqCount				 ds.l	1				; offset: $24 (36)		; requested byte count; also = ioNewDirID
ioActCount				 ds.l	1				; offset: $28 (40)		; actual byte count completed
ioPosMode				 ds.w	1				; offset: $2C (44)		; initial file positioning
ioPosOffset				 ds.l	1				; offset: $2E (46)		; file position offset
						 ORG 24
ioFRefNum				 ds.w	1				; offset: $18 (24)		; reference number
ioFVersNum				 ds.b	1				; offset: $1A (26)		; version number
filler1					 ds.b	1				; offset: $1B (27)
ioFDirIndex				 ds.w	1				; offset: $1C (28)		; GetFInfo directory index
ioFlAttrib				 ds.b	1				; offset: $1E (30)		; GetFInfo: in-use bit=7, lock bit=0
ioFlVersNum				 ds.b	1				; offset: $1F (31)		; file version number
ioFlFndrInfo			 ds		FInfo			; offset: $20 (32)		; user info
ioFlNum					 ds.l	1				; offset: $30 (48)		; GetFInfo: file number; TF- ioDirID
ioFlStBlk				 ds.w	1				; offset: $34 (52)		; start file block (0 if none)
ioFlLgLen				 ds.l	1				; offset: $36 (54)		; logical length (EOF)
ioFlPyLen				 ds.l	1				; offset: $3A (58)		; physical length
ioFlRStBlk				 ds.w	1				; offset: $3E (62)		; start block rsrc fork
ioFlRLgLen				 ds.l	1				; offset: $40 (64)		; file logical length rsrc fork
ioFlRPyLen				 ds.l	1				; offset: $44 (68)		; file physical length rsrc fork
ioFlCrDat				 ds.l	1				; offset: $48 (72)		; file creation date& time (32 bits in secs)
ioFlMdDat				 ds.l	1				; offset: $4C (76)		; last modified date and time
						 ORG 24
filler2					 ds.l	1				; offset: $18 (24)
ioVolIndex				 ds.w	1				; offset: $1C (28)		; volume index number
ioVCrDate				 ds.l	1				; offset: $1E (30)		; creation date and time
ioVLsBkUp				 ds.l	1				; offset: $22 (34)		; last backup date and time
ioVAtrb					 ds.w	1				; offset: $26 (38)		; volume attrib
ioVNmFls				 ds.w	1				; offset: $28 (40)		; number of files in directory
ioVDirSt				 ds.w	1				; offset: $2A (42)		; start block of file directory
ioVBlLn					 ds.w	1				; offset: $2C (44)		; GetVolInfo: length of dir in blocks
ioVNmAlBlks				 ds.w	1				; offset: $2E (46)		; for compatibilty ioVNmAlBlks * ioVAlBlkSiz <= 2 GB
ioVAlBlkSiz				 ds.l	1				; offset: $30 (48)		; for compatibilty ioVAlBlkSiz is <= $0000FE00 (65,024)
ioVClpSiz				 ds.l	1				; offset: $34 (52)		; GetVolInfo: bytes to allocate at a time
ioAlBlSt				 ds.w	1				; offset: $38 (56)		; starting disk(512-byte) block in block map
ioVNxtFNum				 ds.l	1				; offset: $3A (58)		; GetVolInfo: next free file number
ioVFrBlk				 ds.w	1				; offset: $3E (62)		; GetVolInfo: # free alloc blks for this vol
						 ORG 24
ioCRefNum				 ds.w	1				; offset: $18 (24)		; refNum for I/O operation
csCode					 ds.w	1				; offset: $1A (26)		; word for control status code
csParam					 ds.w	11				; offset: $1C (28)		; operation-defined parameters
						 ORG 24
ioSRefNum				 ds.w	1				; offset: $18 (24)
ioSVersNum				 ds.b	1				; offset: $1A (26)
ioSPermssn				 ds.b	1				; offset: $1B (27)
ioSMix					 ds.l	1				; offset: $1C (28)
ioSFlags				 ds.w	1				; offset: $20 (32)
ioSlot					 ds.b	1				; offset: $22 (34)
ioID					 ds.b	1				; offset: $23 (35)
						 ORG 24
ioMRefNum				 ds.w	1				; offset: $18 (24)
ioMVersNum				 ds.b	1				; offset: $1A (26)
ioMPermssn				 ds.b	1				; offset: $1B (27)
ioMMix					 ds.l	1				; offset: $1C (28)
ioMFlags				 ds.w	1				; offset: $20 (32)
ioSEBlkPtr				 ds.l	1				; offset: $22 (34)
						 ORG 80
sizeof					 EQU *					; size:   $50 (80)
						ENDR
CInfoPBRec				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioFRefNum				 ds.w	1				; offset: $18 (24)
ioFVersNum				 ds.b	1				; offset: $1A (26)
filler1					 ds.b	1				; offset: $1B (27)
ioFDirIndex				 ds.w	1				; offset: $1C (28)
ioFlAttrib				 ds.b	1				; offset: $1E (30)
ioACUser				 ds.b	1				; offset: $1F (31)
ioFlFndrInfo			 ds		FInfo			; offset: $20 (32)
ioDirID					 ds.l	1				; offset: $30 (48)
ioFlStBlk				 ds.w	1				; offset: $34 (52)
ioFlLgLen				 ds.l	1				; offset: $36 (54)
ioFlPyLen				 ds.l	1				; offset: $3A (58)
ioFlRStBlk				 ds.w	1				; offset: $3E (62)
ioFlRLgLen				 ds.l	1				; offset: $40 (64)
ioFlRPyLen				 ds.l	1				; offset: $44 (68)
ioFlCrDat				 ds.l	1				; offset: $48 (72)
ioFlMdDat				 ds.l	1				; offset: $4C (76)
ioFlBkDat				 ds.l	1				; offset: $50 (80)
ioFlXFndrInfo			 ds		FXInfo			; offset: $54 (84)
ioFlParID				 ds.l	1				; offset: $64 (100)
ioFlClpSiz				 ds.l	1				; offset: $68 (104)
						 ORG 32
ioDrUsrWds				 ds		DInfo			; offset: $20 (32)
ioDrDirID				 ds.l	1				; offset: $30 (48)
ioDrNmFls				 ds.w	1				; offset: $34 (52)
filler3					 ds.w	9				; offset: $36 (54)
ioDrCrDat				 ds.l	1				; offset: $48 (72)
ioDrMdDat				 ds.l	1				; offset: $4C (76)
ioDrBkDat				 ds.l	1				; offset: $50 (80)
ioDrFndrInfo			 ds		DXInfo			; offset: $54 (84)
ioDrParID				 ds.l	1				; offset: $64 (100)
						 ORG 108
sizeof					 EQU *					; size:   $6C (108)
						ENDR
; typedef struct CInfoPBRec *			CInfoPBPtr

XCInfoPBRec				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)		;  --> A pointer to a completion routine 
ioResult				 ds.w	1				; offset: $10 (16)		;  --> The result code of the function 
ioNamePtr				 ds.l	1				; offset: $12 (18)		;  --> Pointer to pathname to object 
ioVRefNum				 ds.w	1				; offset: $16 (22)		;  --> A volume specification 
filler1					 ds.l	1				; offset: $18 (24)
ioShortNamePtr			 ds.l	1				; offset: $1C (28)		;  <-> A pointer to the short name string buffer - required! 
filler2					 ds.w	1				; offset: $20 (32)
ioPDType				 ds.w	1				; offset: $22 (34)		;  <-- The ProDOS file type 
ioPDAuxType				 ds.l	1				; offset: $24 (36)		;  <-- The ProDOS aux type 
filler3					 ds.l	2				; offset: $28 (40)
ioDirID					 ds.l	1				; offset: $30 (48)		;  --> A directory ID 
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct XCInfoPBRec *			XCInfoPBPtr

;  Catalog position record 
CatPositionRec			RECORD 0
initialize				 ds.l	1				; offset: $0 (0)
priv					 ds.w	6				; offset: $4 (4)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
FSSpec					RECORD 0
vRefNum					 ds.w	1				; offset: $0 (0)
parID					 ds.l	1				; offset: $2 (2)
name					 ds		StrFileName		; offset: $6 (6)		;  a Str63 on MacOS
sizeof					 EQU *					; size:   $46 (70)
						ENDR
; typedef struct FSSpec *				FSSpecPtr

; typedef FSSpecPtr *					FSSpecHandle

;  pointer to array of FSSpecs 
; typedef FSSpecPtr 					FSSpecArrayPtr

;  
;    The only difference between "const FSSpec*" and "ConstFSSpecPtr" is 
;    that as a parameter, ConstFSSpecPtr is allowed to be NULL 
;

; typedef const struct FSSpec *			ConstFSSpecPtr

;  
;    The following are structures to be filled out with the _PBGetVolMountInfo call
;    and passed back into the _PBVolumeMount call for external file system mounts. 
;

;  the "signature" of the file system 
; typedef OSType 						VolumeType


															; the signature for AppleShare 
AppleShareMediaType				EQU		'afpm'
; 
;    VolMount stuff was once in FSM.≈
;

VolMountInfoHeader		RECORD 0
length					 ds.w	1				; offset: $0 (0)		;  length of location data (including self) 
media					 ds.l	1				; offset: $2 (2)		;  type of media.  Variable length data follows 
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct VolMountInfoHeader *	VolMountInfoPtr

;  The new volume mount info record.  The old one is included for compatibility. 
;    the new record allows access by foriegn filesystems writers to the flags 
;    portion of the record. This portion is now public.  
;

VolumeMountInfoHeader	RECORD 0
length					 ds.w	1				; offset: $0 (0)		;  length of location data (including self) 
media					 ds.l	1				; offset: $2 (2)		;  type of media (must be registered with Apple) 
flags					 ds.w	1				; offset: $6 (6)		;  volume mount flags. Variable length data follows 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct VolumeMountInfoHeader * VolumeMountInfoHeaderPtr

;  volume mount flags 

volMountNoLoginMsgFlagBit		EQU		0					; Input to VolumeMount: If set, the file system 
volMountNoLoginMsgFlagMask		EQU		$0001				;  should suppresss any log-in message/greeting dialog 
volMountExtendedFlagsBit		EQU		7					; Input to VolumeMount: If set, the mount info is a 
volMountExtendedFlagsMask		EQU		$0080				;  AFPXVolMountInfo record for 3.7 AppleShare Client 
volMountInteractBit				EQU		15					; Input to VolumeMount: If set, it's OK for the file system 
volMountInteractMask			EQU		$8000				;  to perform user interaction to mount the volume 
volMountChangedBit				EQU		14					; Output from VoumeMount: If set, the volume was mounted, but 
volMountChangedMask				EQU		$4000				;  the volume mounting information record needs to be updated. 
volMountFSReservedMask			EQU		$00FF				; bits 0-7 are defined by each file system for its own use 
volMountSysReservedMask			EQU		$FF00				; bits 8-15 are reserved for Apple system use 


AFPVolMountInfo			RECORD 0
length					 ds.w	1				; offset: $0 (0)		;  length of location data (including self) 
media					 ds.l	1				; offset: $2 (2)		;  type of media 
flags					 ds.w	1				; offset: $6 (6)		;  bits for no messages, no reconnect 
nbpInterval				 ds.b	1				; offset: $8 (8)		;  NBP Interval parameter (IM2, p.322) 
nbpCount				 ds.b	1				; offset: $9 (9)		;  NBP Interval parameter (IM2, p.322) 
uamType					 ds.w	1				; offset: $A (10)		;  User Authentication Method 
zoneNameOffset			 ds.w	1				; offset: $C (12)		;  short positive offset from start of struct to Zone Name 
serverNameOffset		 ds.w	1				; offset: $E (14)		;  offset to pascal Server Name string 
volNameOffset			 ds.w	1				; offset: $10 (16)		;  offset to pascal Volume Name string 
userNameOffset			 ds.w	1				; offset: $12 (18)		;  offset to pascal User Name string 
userPasswordOffset		 ds.w	1				; offset: $14 (20)		;  offset to pascal User Password string 
volPasswordOffset		 ds.w	1				; offset: $16 (22)		;  offset to pascal Volume Password string 
AFPData					 ds.b	144				; offset: $18 (24)		;  variable length data may follow 
sizeof					 EQU *					; size:   $A8 (168)
						ENDR
; typedef struct AFPVolMountInfo *		AFPVolMountInfoPtr



;  AFPXVolMountInfo is the new AFP volume mount info record, requires the 3.7 AppleShare Client 
AFPXVolMountInfo		RECORD 0
length					 ds.w	1				; offset: $0 (0)		;  length of location data (including self) 
media					 ds.l	1				; offset: $2 (2)		;  type of media 
flags					 ds.w	1				; offset: $6 (6)		;  bits for no messages, no reconnect 
nbpInterval				 ds.b	1				; offset: $8 (8)		;  NBP Interval parameter (IM2, p.322) 
nbpCount				 ds.b	1				; offset: $9 (9)		;  NBP Interval parameter (IM2, p.322) 
uamType					 ds.w	1				; offset: $A (10)		;  User Authentication Method type 
zoneNameOffset			 ds.w	1				; offset: $C (12)		;  short positive offset from start of struct to Zone Name 
serverNameOffset		 ds.w	1				; offset: $E (14)		;  offset to pascal Server Name string 
volNameOffset			 ds.w	1				; offset: $10 (16)		;  offset to pascal Volume Name string 
userNameOffset			 ds.w	1				; offset: $12 (18)		;  offset to pascal User Name string 
userPasswordOffset		 ds.w	1				; offset: $14 (20)		;  offset to pascal User Password string 
volPasswordOffset		 ds.w	1				; offset: $16 (22)		;  offset to pascal Volume Password string 
extendedFlags			 ds.w	1				; offset: $18 (24)		;  extended flags word 
uamNameOffset			 ds.w	1				; offset: $1A (26)		;  offset to a pascal UAM name string 
alternateAddressOffset	 ds.w	1				; offset: $1C (28)		;  offset to Alternate Addresses in tagged format 
AFPData					 ds.b	176				; offset: $1E (30)		;  variable length data may follow 
sizeof					 EQU *					; size:   $CE (206)
						ENDR
; typedef struct AFPXVolMountInfo *		AFPXVolMountInfoPtr


kAFPExtendedFlagsAlternateAddressMask EQU 1					;  bit in AFPXVolMountInfo.extendedFlags that means alternateAddressOffset is used


															; constants for use in AFPTagData.fType field
kAFPTagTypeIP					EQU		$01					; 4 byte IP address (MSB first)            
kAFPTagTypeIPPort				EQU		$02					; 4 byte IP address, 2 byte port (MSB first)     
kAFPTagTypeDDP					EQU		$03					; Net,Node,Socket Sent by the server, currently unused by the client 
kAFPTagTypeDNS					EQU		$04					; DNS name in  address:port format   (total length variable up to 254 chars of dns name)          


															; constants for use in AFPTagData.fLength field
kAFPTagLengthIP					EQU		$06
kAFPTagLengthIPPort				EQU		$08
kAFPTagLengthDDP				EQU		$06
AFPTagData				RECORD 0
fLength					 ds.b	1				; offset: $0 (0)		;  length of this data tag including the fLength field 
fType					 ds.b	1				; offset: $1 (1)
fData					 ds.b	1				; offset: $2 (2) <-- really an array of length one ;  variable length data 
						 ORG 4
sizeof					 EQU *					; size:   $4 (4)
						ENDR
AFPAlternateAddress		RECORD 0
;  ••• NOTE: fVersion was missing in 3.2 Universal Interfaces
fVersion				 ds.b	1				; offset: $0 (0)		;  version of the structure (currently 0x00)
fAddressCount			 ds.b	1				; offset: $1 (1)
fAddressList			 ds.b	1				; offset: $2 (2) <-- really an array of length one ;  actually variable length packed set of AFPTagData 
						 ORG 4
sizeof					 EQU *					; size:   $4 (4)
						ENDR
DTPBRec					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioDTRefNum				 ds.w	1				; offset: $18 (24)		;  desktop refnum 
ioIndex					 ds.w	1				; offset: $1A (26)
ioTagInfo				 ds.l	1				; offset: $1C (28)
ioDTBuffer				 ds.l	1				; offset: $20 (32)
ioDTReqCount			 ds.l	1				; offset: $24 (36)
ioDTActCount			 ds.l	1				; offset: $28 (40)
ioFiller1				 ds.b	1				; offset: $2C (44)
ioIconType				 ds.b	1				; offset: $2D (45)
ioFiller2				 ds.w	1				; offset: $2E (46)
ioDirID					 ds.l	1				; offset: $30 (48)
ioFileCreator			 ds.l	1				; offset: $34 (52)
ioFileType				 ds.l	1				; offset: $38 (56)
ioFiller3				 ds.l	1				; offset: $3C (60)
ioDTLgLen				 ds.l	1				; offset: $40 (64)
ioDTPyLen				 ds.l	1				; offset: $44 (68)
ioFiller4				 ds.w	14				; offset: $48 (72)
ioAPPLParID				 ds.l	1				; offset: $64 (100)
sizeof					 EQU *					; size:   $68 (104)
						ENDR
; typedef struct DTPBRec *				DTPBPtr


HIOParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioRefNum				 ds.w	1				; offset: $18 (24)
ioVersNum				 ds.b	1				; offset: $1A (26)
ioPermssn				 ds.b	1				; offset: $1B (27)
ioMisc					 ds.l	1				; offset: $1C (28)
ioBuffer				 ds.l	1				; offset: $20 (32)
ioReqCount				 ds.l	1				; offset: $24 (36)
ioActCount				 ds.l	1				; offset: $28 (40)
ioPosMode				 ds.w	1				; offset: $2C (44)
ioPosOffset				 ds.l	1				; offset: $2E (46)
sizeof					 EQU *					; size:   $32 (50)
						ENDR
; typedef struct HIOParam *				HIOParamPtr

HFileParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioFRefNum				 ds.w	1				; offset: $18 (24)
ioFVersNum				 ds.b	1				; offset: $1A (26)
filler1					 ds.b	1				; offset: $1B (27)
ioFDirIndex				 ds.w	1				; offset: $1C (28)
ioFlAttrib				 ds.b	1				; offset: $1E (30)
ioFlVersNum				 ds.b	1				; offset: $1F (31)
ioFlFndrInfo			 ds		FInfo			; offset: $20 (32)
ioDirID					 ds.l	1				; offset: $30 (48)
ioFlStBlk				 ds.w	1				; offset: $34 (52)
ioFlLgLen				 ds.l	1				; offset: $36 (54)
ioFlPyLen				 ds.l	1				; offset: $3A (58)
ioFlRStBlk				 ds.w	1				; offset: $3E (62)
ioFlRLgLen				 ds.l	1				; offset: $40 (64)
ioFlRPyLen				 ds.l	1				; offset: $44 (68)
ioFlCrDat				 ds.l	1				; offset: $48 (72)
ioFlMdDat				 ds.l	1				; offset: $4C (76)
sizeof					 EQU *					; size:   $50 (80)
						ENDR
; typedef struct HFileParam *			HFileParamPtr

HVolumeParam			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
filler2					 ds.l	1				; offset: $18 (24)
ioVolIndex				 ds.w	1				; offset: $1C (28)
ioVCrDate				 ds.l	1				; offset: $1E (30)
ioVLsMod				 ds.l	1				; offset: $22 (34)
ioVAtrb					 ds.w	1				; offset: $26 (38)
ioVNmFls				 ds.w	1				; offset: $28 (40)
ioVBitMap				 ds.w	1				; offset: $2A (42)
ioAllocPtr				 ds.w	1				; offset: $2C (44)
ioVNmAlBlks				 ds.w	1				; offset: $2E (46)
ioVAlBlkSiz				 ds.l	1				; offset: $30 (48)
ioVClpSiz				 ds.l	1				; offset: $34 (52)
ioAlBlSt				 ds.w	1				; offset: $38 (56)
ioVNxtCNID				 ds.l	1				; offset: $3A (58)
ioVFrBlk				 ds.w	1				; offset: $3E (62)
ioVSigWord				 ds.w	1				; offset: $40 (64)
ioVDrvInfo				 ds.w	1				; offset: $42 (66)
ioVDRefNum				 ds.w	1				; offset: $44 (68)
ioVFSID					 ds.w	1				; offset: $46 (70)
ioVBkUp					 ds.l	1				; offset: $48 (72)
ioVSeqNum				 ds.w	1				; offset: $4C (76)
ioVWrCnt				 ds.l	1				; offset: $4E (78)
ioVFilCnt				 ds.l	1				; offset: $52 (82)
ioVDirCnt				 ds.l	1				; offset: $56 (86)
ioVFndrInfo				 ds.l	8				; offset: $5A (90)
sizeof					 EQU *					; size:   $7A (122)
						ENDR
; typedef struct HVolumeParam *			HVolumeParamPtr

XIOParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
ioNamePtr				 ds.l	1				; offset: $12 (18)
ioVRefNum				 ds.w	1				; offset: $16 (22)
ioRefNum				 ds.w	1				; offset: $18 (24)
ioVersNum				 ds.b	1				; offset: $1A (26)
ioPermssn				 ds.b	1				; offset: $1B (27)
ioMisc					 ds.l	1				; offset: $1C (28)
ioBuffer				 ds.l	1				; offset: $20 (32)
ioReqCount				 ds.l	1				; offset: $24 (36)
ioActCount				 ds.l	1				; offset: $28 (40)
ioPosMode				 ds.w	1				; offset: $2C (44)		;  must have kUseWidePositioning bit set 
ioWPosOffset			 ds		wide			; offset: $2E (46)		;  wide positioning offset 
sizeof					 EQU *					; size:   $36 (54)
						ENDR
; typedef struct XIOParam *				XIOParamPtr

XVolumeParam			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
ioNamePtr				 ds.l	1				; offset: $12 (18)
ioVRefNum				 ds.w	1				; offset: $16 (22)
ioXVersion				 ds.l	1				; offset: $18 (24)		;  this XVolumeParam version (0) 
ioVolIndex				 ds.w	1				; offset: $1C (28)
ioVCrDate				 ds.l	1				; offset: $1E (30)
ioVLsMod				 ds.l	1				; offset: $22 (34)
ioVAtrb					 ds.w	1				; offset: $26 (38)
ioVNmFls				 ds.w	1				; offset: $28 (40)
ioVBitMap				 ds.w	1				; offset: $2A (42)
ioAllocPtr				 ds.w	1				; offset: $2C (44)
ioVNmAlBlks				 ds.w	1				; offset: $2E (46)
ioVAlBlkSiz				 ds.l	1				; offset: $30 (48)
ioVClpSiz				 ds.l	1				; offset: $34 (52)
ioAlBlSt				 ds.w	1				; offset: $38 (56)
ioVNxtCNID				 ds.l	1				; offset: $3A (58)
ioVFrBlk				 ds.w	1				; offset: $3E (62)
ioVSigWord				 ds.w	1				; offset: $40 (64)
ioVDrvInfo				 ds.w	1				; offset: $42 (66)
ioVDRefNum				 ds.w	1				; offset: $44 (68)
ioVFSID					 ds.w	1				; offset: $46 (70)
ioVBkUp					 ds.l	1				; offset: $48 (72)
ioVSeqNum				 ds.w	1				; offset: $4C (76)
ioVWrCnt				 ds.l	1				; offset: $4E (78)
ioVFilCnt				 ds.l	1				; offset: $52 (82)
ioVDirCnt				 ds.l	1				; offset: $56 (86)
ioVFndrInfo				 ds.l	8				; offset: $5A (90)
ioVTotalBytes			 ds		UInt64			; offset: $7A (122)		;  total number of bytes on volume 
ioVFreeBytes			 ds		UInt64			; offset: $82 (130)		;  number of free bytes on volume 
sizeof					 EQU *					; size:   $8A (138)
						ENDR
; typedef struct XVolumeParam *			XVolumeParamPtr

AccessParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
filler3					 ds.w	1				; offset: $18 (24)
ioDenyModes				 ds.w	1				; offset: $1A (26)		; access rights data
filler4					 ds.w	1				; offset: $1C (28)
filler5					 ds.b	1				; offset: $1E (30)
ioACUser				 ds.b	1				; offset: $1F (31)		; access rights for directory only
filler6					 ds.l	1				; offset: $20 (32)
ioACOwnerID				 ds.l	1				; offset: $24 (36)		; owner ID
ioACGroupID				 ds.l	1				; offset: $28 (40)		; group ID
ioACAccess				 ds.l	1				; offset: $2C (44)		; access rights
ioDirID					 ds.l	1				; offset: $30 (48)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct AccessParam *			AccessParamPtr

ObjParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
filler7					 ds.w	1				; offset: $18 (24)
ioObjType				 ds.w	1				; offset: $1A (26)		; function code
ioObjNamePtr			 ds.l	1				; offset: $1C (28)		; ptr to returned creator/group name
ioObjID					 ds.l	1				; offset: $20 (32)		; creator/group ID
sizeof					 EQU *					; size:   $24 (36)
						ENDR
; typedef struct ObjParam *				ObjParamPtr

CopyParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioDstVRefNum			 ds.w	1				; offset: $18 (24)		; destination vol identifier
filler8					 ds.w	1				; offset: $1A (26)
ioNewName				 ds.l	1				; offset: $1C (28)		; ptr to destination pathname
ioCopyName				 ds.l	1				; offset: $20 (32)		; ptr to optional name
ioNewDirID				 ds.l	1				; offset: $24 (36)		; destination directory ID
filler14				 ds.l	1				; offset: $28 (40)
filler15				 ds.l	1				; offset: $2C (44)
ioDirID					 ds.l	1				; offset: $30 (48)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct CopyParam *			CopyParamPtr

WDParam					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioWDCreated				 ds.w	1				; offset: $18 (24)
ioWDIndex				 ds.w	1				; offset: $1A (26)
ioWDProcID				 ds.l	1				; offset: $1C (28)
ioWDVRefNum				 ds.w	1				; offset: $20 (32)
filler10				 ds.w	1				; offset: $22 (34)
filler11				 ds.l	1				; offset: $24 (36)
filler12				 ds.l	1				; offset: $28 (40)
filler13				 ds.l	1				; offset: $2C (44)
ioWDDirID				 ds.l	1				; offset: $30 (48)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct WDParam *				WDParamPtr

FIDParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
filler14				 ds.l	1				; offset: $18 (24)
ioDestNamePtr			 ds.l	1				; offset: $1C (28)		;  dest file name 
filler15				 ds.l	1				; offset: $20 (32)
ioDestDirID				 ds.l	1				; offset: $24 (36)		;  dest file's directory id 
filler16				 ds.l	1				; offset: $28 (40)
filler17				 ds.l	1				; offset: $2C (44)
ioSrcDirID				 ds.l	1				; offset: $30 (48)		;  source file's directory id 
filler18				 ds.w	1				; offset: $34 (52)
ioFileID				 ds.l	1				; offset: $36 (54)		;  file ID 
sizeof					 EQU *					; size:   $3A (58)
						ENDR
; typedef struct FIDParam *				FIDParamPtr

ForeignPrivParam		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioFiller21				 ds.l	1				; offset: $18 (24)
ioFiller22				 ds.l	1				; offset: $1C (28)
ioForeignPrivBuffer		 ds.l	1				; offset: $20 (32)
ioForeignPrivActCount	 ds.l	1				; offset: $24 (36)
ioForeignPrivReqCount	 ds.l	1				; offset: $28 (40)
ioFiller23				 ds.l	1				; offset: $2C (44)
ioForeignPrivDirID		 ds.l	1				; offset: $30 (48)
ioForeignPrivInfo1		 ds.l	1				; offset: $34 (52)
ioForeignPrivInfo2		 ds.l	1				; offset: $38 (56)
ioForeignPrivInfo3		 ds.l	1				; offset: $3C (60)
ioForeignPrivInfo4		 ds.l	1				; offset: $40 (64)
sizeof					 EQU *					; size:   $44 (68)
						ENDR
; typedef struct ForeignPrivParam *		ForeignPrivParamPtr

CSParam					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioMatchPtr				 ds.l	1				; offset: $18 (24)		;  match array 
ioReqMatchCount			 ds.l	1				; offset: $1C (28)		;  maximum allowable matches 
ioActMatchCount			 ds.l	1				; offset: $20 (32)		;  actual match count 
ioSearchBits			 ds.l	1				; offset: $24 (36)		;  search criteria selector 
ioSearchInfo1			 ds.l	1				; offset: $28 (40)		;  search values and range lower bounds 
ioSearchInfo2			 ds.l	1				; offset: $2C (44)		;  search values and range upper bounds 
ioSearchTime			 ds.l	1				; offset: $30 (48)		;  length of time to run search 
ioCatPosition			 ds		CatPositionRec ; offset: $34 (52)		;  current position in the catalog 
ioOptBuffer				 ds.l	1				; offset: $44 (68)		;  optional performance enhancement buffer 
ioOptBufSize			 ds.l	1				; offset: $48 (72)		;  size of buffer pointed to by ioOptBuffer 
sizeof					 EQU *					; size:   $4C (76)
						ENDR
; typedef struct CSParam *				CSParamPtr



HParamBlockRec			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
ioRefNum				 ds.w	1				; offset: $18 (24)
ioVersNum				 ds.b	1				; offset: $1A (26)
ioPermssn				 ds.b	1				; offset: $1B (27)
ioMisc					 ds.l	1				; offset: $1C (28)
ioBuffer				 ds.l	1				; offset: $20 (32)
ioReqCount				 ds.l	1				; offset: $24 (36)
ioActCount				 ds.l	1				; offset: $28 (40)
ioPosMode				 ds.w	1				; offset: $2C (44)
ioPosOffset				 ds.l	1				; offset: $2E (46)
						 ORG 24
ioFRefNum				 ds.w	1				; offset: $18 (24)
ioFVersNum				 ds.b	1				; offset: $1A (26)
filler1					 ds.b	1				; offset: $1B (27)
ioFDirIndex				 ds.w	1				; offset: $1C (28)
ioFlAttrib				 ds.b	1				; offset: $1E (30)
ioFlVersNum				 ds.b	1				; offset: $1F (31)
ioFlFndrInfo			 ds		FInfo			; offset: $20 (32)
ioDirID					 ds.l	1				; offset: $30 (48)
ioFlStBlk				 ds.w	1				; offset: $34 (52)
ioFlLgLen				 ds.l	1				; offset: $36 (54)
ioFlPyLen				 ds.l	1				; offset: $3A (58)
ioFlRStBlk				 ds.w	1				; offset: $3E (62)
ioFlRLgLen				 ds.l	1				; offset: $40 (64)
ioFlRPyLen				 ds.l	1				; offset: $44 (68)
ioFlCrDat				 ds.l	1				; offset: $48 (72)
ioFlMdDat				 ds.l	1				; offset: $4C (76)
						 ORG 24
filler2					 ds.l	1				; offset: $18 (24)
ioVolIndex				 ds.w	1				; offset: $1C (28)
ioVCrDate				 ds.l	1				; offset: $1E (30)
ioVLsMod				 ds.l	1				; offset: $22 (34)
ioVAtrb					 ds.w	1				; offset: $26 (38)
ioVNmFls				 ds.w	1				; offset: $28 (40)
ioVBitMap				 ds.w	1				; offset: $2A (42)
ioAllocPtr				 ds.w	1				; offset: $2C (44)
ioVNmAlBlks				 ds.w	1				; offset: $2E (46)
ioVAlBlkSiz				 ds.l	1				; offset: $30 (48)
ioVClpSiz				 ds.l	1				; offset: $34 (52)
ioAlBlSt				 ds.w	1				; offset: $38 (56)
ioVNxtCNID				 ds.l	1				; offset: $3A (58)
ioVFrBlk				 ds.w	1				; offset: $3E (62)
ioVSigWord				 ds.w	1				; offset: $40 (64)
ioVDrvInfo				 ds.w	1				; offset: $42 (66)
ioVDRefNum				 ds.w	1				; offset: $44 (68)
ioVFSID					 ds.w	1				; offset: $46 (70)
ioVBkUp					 ds.l	1				; offset: $48 (72)
ioVSeqNum				 ds.w	1				; offset: $4C (76)
ioVWrCnt				 ds.l	1				; offset: $4E (78)
ioVFilCnt				 ds.l	1				; offset: $52 (82)
ioVDirCnt				 ds.l	1				; offset: $56 (86)
ioVFndrInfo				 ds.l	8				; offset: $5A (90)
						 ORG 24
filler3					 ds.w	1				; offset: $18 (24)
ioDenyModes				 ds.w	1				; offset: $1A (26)		; access rights data
filler4					 ds.w	1				; offset: $1C (28)
filler5					 ds.b	1				; offset: $1E (30)
ioACUser				 ds.b	1				; offset: $1F (31)		; access rights for directory only
filler6					 ds.l	1				; offset: $20 (32)
ioACOwnerID				 ds.l	1				; offset: $24 (36)		; owner ID
ioACGroupID				 ds.l	1				; offset: $28 (40)		; group ID
ioACAccess				 ds.l	1				; offset: $2C (44)		; access rights
						 ORG 24
filler7					 ds.w	1				; offset: $18 (24)
ioObjType				 ds.w	1				; offset: $1A (26)		; function code
ioObjNamePtr			 ds.l	1				; offset: $1C (28)		; ptr to returned creator/group name
ioObjID					 ds.l	1				; offset: $20 (32)		; creator/group ID
						 ORG 24
ioDstVRefNum			 ds.w	1				; offset: $18 (24)		; destination vol identifier
filler8					 ds.w	1				; offset: $1A (26)
ioNewName				 ds.l	1				; offset: $1C (28)		; ptr to destination pathname
ioCopyName				 ds.l	1				; offset: $20 (32)		; ptr to optional name
ioNewDirID				 ds.l	1				; offset: $24 (36)		; destination directory ID
						 ORG 24
ioWDCreated				 ds.w	1				; offset: $18 (24)
ioWDIndex				 ds.w	1				; offset: $1A (26)
ioWDProcID				 ds.l	1				; offset: $1C (28)
ioWDVRefNum				 ds.w	1				; offset: $20 (32)
filler10				 ds.w	1				; offset: $22 (34)
filler11				 ds.l	1				; offset: $24 (36)
filler12				 ds.l	1				; offset: $28 (40)
filler13				 ds.l	1				; offset: $2C (44)
ioWDDirID				 ds.l	1				; offset: $30 (48)
						 ORG 24
filler14				 ds.l	1				; offset: $18 (24)
ioDestNamePtr			 ds.l	1				; offset: $1C (28)		;  dest file name 
filler15				 ds.l	1				; offset: $20 (32)
ioDestDirID				 ds.l	1				; offset: $24 (36)		;  dest file's directory id 
filler16				 ds.l	1				; offset: $28 (40)
filler17				 ds.l	1				; offset: $2C (44)
ioSrcDirID				 ds.l	1				; offset: $30 (48)		;  source file's directory id 
filler18				 ds.w	1				; offset: $34 (52)
ioFileID				 ds.l	1				; offset: $36 (54)		;  file ID 
						 ORG 24
ioMatchPtr				 ds.l	1				; offset: $18 (24)		;  match array 
ioReqMatchCount			 ds.l	1				; offset: $1C (28)		;  maximum allowable matches 
ioActMatchCount			 ds.l	1				; offset: $20 (32)		;  actual match count 
ioSearchBits			 ds.l	1				; offset: $24 (36)		;  search criteria selector 
ioSearchInfo1			 ds.l	1				; offset: $28 (40)		;  search values and range lower bounds 
ioSearchInfo2			 ds.l	1				; offset: $2C (44)		;  search values and range upper bounds 
ioSearchTime			 ds.l	1				; offset: $30 (48)		;  length of time to run search 
ioCatPosition			 ds		CatPositionRec ; offset: $34 (52)		;  current position in the catalog 
ioOptBuffer				 ds.l	1				; offset: $44 (68)		;  optional performance enhancement buffer 
ioOptBufSize			 ds.l	1				; offset: $48 (72)		;  size of buffer pointed to by ioOptBuffer 
						 ORG 24
ioFiller21				 ds.l	1				; offset: $18 (24)
ioFiller22				 ds.l	1				; offset: $1C (28)
ioForeignPrivBuffer		 ds.l	1				; offset: $20 (32)
ioForeignPrivActCount	 ds.l	1				; offset: $24 (36)
ioForeignPrivReqCount	 ds.l	1				; offset: $28 (40)
ioFiller23				 ds.l	1				; offset: $2C (44)
ioForeignPrivDirID		 ds.l	1				; offset: $30 (48)
ioForeignPrivInfo1		 ds.l	1				; offset: $34 (52)
ioForeignPrivInfo2		 ds.l	1				; offset: $38 (56)
ioForeignPrivInfo3		 ds.l	1				; offset: $3C (60)
ioForeignPrivInfo4		 ds.l	1				; offset: $40 (64)
						 ORG 122
sizeof					 EQU *					; size:   $7A (122)
						ENDR
; typedef struct HParamBlockRec *		HParmBlkPtr


CMovePBRec				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
ioNamePtr				 ds.l	1				; offset: $12 (18)
ioVRefNum				 ds.w	1				; offset: $16 (22)
filler1					 ds.l	1				; offset: $18 (24)
ioNewName				 ds.l	1				; offset: $1C (28)
filler2					 ds.l	1				; offset: $20 (32)
ioNewDirID				 ds.l	1				; offset: $24 (36)
filler3					 ds.l	2				; offset: $28 (40)
ioDirID					 ds.l	1				; offset: $30 (48)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct CMovePBRec *			CMovePBPtr

WDPBRec					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
ioNamePtr				 ds.l	1				; offset: $12 (18)
ioVRefNum				 ds.w	1				; offset: $16 (22)
filler1					 ds.w	1				; offset: $18 (24)
ioWDIndex				 ds.w	1				; offset: $1A (26)
ioWDProcID				 ds.l	1				; offset: $1C (28)
ioWDVRefNum				 ds.w	1				; offset: $20 (32)
filler2					 ds.w	7				; offset: $22 (34)
ioWDDirID				 ds.l	1				; offset: $30 (48)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct WDPBRec *				WDPBPtr

FCBPBRec				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
ioTrap					 ds.w	1				; offset: $6 (6)
ioCmdAddr				 ds.l	1				; offset: $8 (8)
ioCompletion			 ds.l	1				; offset: $C (12)
ioResult				 ds.w	1				; offset: $10 (16)
ioNamePtr				 ds.l	1				; offset: $12 (18)
ioVRefNum				 ds.w	1				; offset: $16 (22)
ioRefNum				 ds.w	1				; offset: $18 (24)
filler					 ds.w	1				; offset: $1A (26)
ioFCBIndx				 ds.w	1				; offset: $1C (28)
filler1					 ds.w	1				; offset: $1E (30)
ioFCBFlNm				 ds.l	1				; offset: $20 (32)
ioFCBFlags				 ds.w	1				; offset: $24 (36)
ioFCBStBlk				 ds.w	1				; offset: $26 (38)
ioFCBEOF				 ds.l	1				; offset: $28 (40)
ioFCBPLen				 ds.l	1				; offset: $2C (44)
ioFCBCrPs				 ds.l	1				; offset: $30 (48)
ioFCBVRefNum			 ds.w	1				; offset: $34 (52)
ioFCBClpSiz				 ds.l	1				; offset: $36 (54)
ioFCBParID				 ds.l	1				; offset: $3A (58)
sizeof					 EQU *					; size:   $3E (62)
						ENDR
; typedef struct FCBPBRec *				FCBPBPtr

VCB						RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
vcbFlags				 ds.w	1				; offset: $6 (6)
vcbSigWord				 ds.w	1				; offset: $8 (8)
vcbCrDate				 ds.l	1				; offset: $A (10)
vcbLsMod				 ds.l	1				; offset: $E (14)
vcbAtrb					 ds.w	1				; offset: $12 (18)
vcbNmFls				 ds.w	1				; offset: $14 (20)
vcbVBMSt				 ds.w	1				; offset: $16 (22)
vcbAllocPtr				 ds.w	1				; offset: $18 (24)
vcbNmAlBlks				 ds.w	1				; offset: $1A (26)
vcbAlBlkSiz				 ds.l	1				; offset: $1C (28)
vcbClpSiz				 ds.l	1				; offset: $20 (32)
vcbAlBlSt				 ds.w	1				; offset: $24 (36)
vcbNxtCNID				 ds.l	1				; offset: $26 (38)
vcbFreeBks				 ds.w	1				; offset: $2A (42)
vcbVN					 ds		Str27			; offset: $2C (44)
vcbDrvNum				 ds.w	1				; offset: $48 (72)
vcbDRefNum				 ds.w	1				; offset: $4A (74)
vcbFSID					 ds.w	1				; offset: $4C (76)
vcbVRefNum				 ds.w	1				; offset: $4E (78)
vcbMAdr					 ds.l	1				; offset: $50 (80)
vcbBufAdr				 ds.l	1				; offset: $54 (84)
vcbMLen					 ds.w	1				; offset: $58 (88)
vcbDirIndex				 ds.w	1				; offset: $5A (90)
vcbDirBlk				 ds.w	1				; offset: $5C (92)
vcbVolBkUp				 ds.l	1				; offset: $5E (94)
vcbVSeqNum				 ds.w	1				; offset: $62 (98)
vcbWrCnt				 ds.l	1				; offset: $64 (100)
vcbXTClpSiz				 ds.l	1				; offset: $68 (104)
vcbCTClpSiz				 ds.l	1				; offset: $6C (108)
vcbNmRtDirs				 ds.w	1				; offset: $70 (112)
vcbFilCnt				 ds.l	1				; offset: $72 (114)
vcbDirCnt				 ds.l	1				; offset: $76 (118)
vcbFndrInfo				 ds.l	8				; offset: $7A (122)
vcbVCSize				 ds.w	1				; offset: $9A (154)
vcbVBMCSiz				 ds.w	1				; offset: $9C (156)
vcbCtlCSiz				 ds.w	1				; offset: $9E (158)
vcbXTAlBlks				 ds.w	1				; offset: $A0 (160)
vcbCTAlBlks				 ds.w	1				; offset: $A2 (162)
vcbXTRef				 ds.w	1				; offset: $A4 (164)
vcbCTRef				 ds.w	1				; offset: $A6 (166)
vcbCtlBuf				 ds.l	1				; offset: $A8 (168)
vcbDirIDM				 ds.l	1				; offset: $AC (172)
vcbOffsM				 ds.w	1				; offset: $B0 (176)
sizeof					 EQU *					; size:   $B2 (178)
						ENDR
; typedef struct VCB *					VCBPtr

DrvQEl					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)
qType					 ds.w	1				; offset: $4 (4)
dQDrive					 ds.w	1				; offset: $6 (6)
dQRefNum				 ds.w	1				; offset: $8 (8)
dQFSID					 ds.w	1				; offset: $A (10)
dQDrvSz					 ds.w	1				; offset: $C (12)
dQDrvSz2				 ds.w	1				; offset: $E (14)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct DrvQEl *				DrvQElPtr


; *  NewIOCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeIOCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeIOCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 



;   PBOpenSync(), PBOpenAsync(), PBOpenImmed() were moved to Devices.h
;   PBCloseSync(), PBCloseAsync(), PBCloseImmed() were moved to Devices.h
;   PBReadSync(), PBReadAsync(), PBReadImmed() were moved to Devices.h
;   PBWriteSync(), PBWriteAsync(), PBWriteImmed() were moved to Devices.h




	IF CALL_NOT_IN_CARBON THEN

; *  PBGetVInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBGetVInfoSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetVInfoSync:	OPWORD	$A007
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVInfoSync
	ENDIF


; *  PBGetVInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBGetVInfoAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetVInfoAsync:	OPWORD	$A407
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVInfoAsync
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  PBXGetVolInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBXGetVolInfoSync(XVolumeParamPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBXGetVolInfoSync
			moveq           	#18,D0
			dc.w            	$A060
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBXGetVolInfoSync
	ENDIF


; *  PBXGetVolInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBXGetVolInfoAsync(XVolumeParamPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBXGetVolInfoAsync
			moveq           	#18,D0
			dc.w            	$A460
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBXGetVolInfoAsync
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  PBGetVolSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBGetVolSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetVolSync:	OPWORD	$A014
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVolSync
	ENDIF


; *  PBGetVolAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBGetVolAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetVolAsync:	OPWORD	$A414
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVolAsync
	ENDIF


; *  PBSetVolSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBSetVolSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetVolSync:	OPWORD	$A015
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetVolSync
	ENDIF


; *  PBSetVolAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBSetVolAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetVolAsync:	OPWORD	$A415
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetVolAsync
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  PBFlushVolSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBFlushVolSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBFlushVolSync:	OPWORD	$A013
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBFlushVolSync
	ENDIF


; *  PBFlushVolAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBFlushVolAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBFlushVolAsync:	OPWORD	$A413
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBFlushVolAsync
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  PBHTrashVolumeCachesSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBHTrashVolumeCachesSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHTrashVolumeCachesSync:	OPWORD	$A213
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHTrashVolumeCachesSync
	ENDIF


; *  PBCreateSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBCreateSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBCreateSync:	OPWORD	$A008
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateSync
	ENDIF


; *  PBCreateAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBCreateAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBCreateAsync:	OPWORD	$A408
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateAsync
	ENDIF


; *  PBDeleteSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBDeleteSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBDeleteSync:	OPWORD	$A009
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDeleteSync
	ENDIF


; *  PBDeleteAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBDeleteAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBDeleteAsync:	OPWORD	$A409
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDeleteAsync
	ENDIF


; *  PBOpenDFSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBOpenDFSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBOpenDFSync
			moveq           	#26,D0
			dc.w            	$A060
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenDFSync
	ENDIF


; *  PBOpenDFAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBOpenDFAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBOpenDFAsync
			moveq           	#26,D0
			dc.w            	$A460
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenDFAsync
	ENDIF


; *  PBOpenRFSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBOpenRFSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBOpenRFSync:	OPWORD	$A00A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenRFSync
	ENDIF


; *  PBOpenRFAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBOpenRFAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBOpenRFAsync:	OPWORD	$A40A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenRFAsync
	ENDIF


; *  PBRenameSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBRenameSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBRenameSync:	OPWORD	$A00B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBRenameSync
	ENDIF


; *  PBRenameAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBRenameAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBRenameAsync:	OPWORD	$A40B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBRenameAsync
	ENDIF


; *  PBGetFInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBGetFInfoSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetFInfoSync:	OPWORD	$A00C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetFInfoSync
	ENDIF


; *  PBGetFInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBGetFInfoAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetFInfoAsync:	OPWORD	$A40C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetFInfoAsync
	ENDIF


; *  PBSetFInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBSetFInfoSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFInfoSync:	OPWORD	$A00D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFInfoSync
	ENDIF


; *  PBSetFInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBSetFInfoAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFInfoAsync:	OPWORD	$A40D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFInfoAsync
	ENDIF


; *  PBSetFLockSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBSetFLockSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFLockSync:	OPWORD	$A041
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFLockSync
	ENDIF


; *  PBSetFLockAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBSetFLockAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFLockAsync:	OPWORD	$A441
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFLockAsync
	ENDIF


; *  PBRstFLockSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBRstFLockSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBRstFLockSync:	OPWORD	$A042
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBRstFLockSync
	ENDIF


; *  PBRstFLockAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBRstFLockAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBRstFLockAsync:	OPWORD	$A442
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBRstFLockAsync
	ENDIF


; *  PBSetFVersSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBSetFVersSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFVersSync:	OPWORD	$A043
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFVersSync
	ENDIF


; *  PBSetFVersAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBSetFVersAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFVersAsync:	OPWORD	$A443
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFVersAsync
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  PBAllocateSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBAllocateSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBAllocateSync:	OPWORD	$A010
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBAllocateSync
	ENDIF


; *  PBAllocateAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBAllocateAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBAllocateAsync:	OPWORD	$A410
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBAllocateAsync
	ENDIF


; *  PBGetEOFSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetEOFSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetEOFSync:	OPWORD	$A011
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetEOFSync
	ENDIF


; *  PBGetEOFAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetEOFAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetEOFAsync:	OPWORD	$A411
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetEOFAsync
	ENDIF


; *  PBSetEOFSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetEOFSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetEOFSync:	OPWORD	$A012
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetEOFSync
	ENDIF


; *  PBSetEOFAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetEOFAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetEOFAsync:	OPWORD	$A412
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetEOFAsync
	ENDIF


; *  PBGetFPosSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetFPosSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetFPosSync:	OPWORD	$A018
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetFPosSync
	ENDIF


; *  PBGetFPosAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetFPosAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBGetFPosAsync:	OPWORD	$A418
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetFPosAsync
	ENDIF


; *  PBSetFPosSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetFPosSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFPosSync:	OPWORD	$A044
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFPosSync
	ENDIF


; *  PBSetFPosAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetFPosAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBSetFPosAsync:	OPWORD	$A444
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetFPosAsync
	ENDIF


; *  PBFlushFileSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBFlushFileSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBFlushFileSync:	OPWORD	$A045
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBFlushFileSync
	ENDIF


; *  PBFlushFileAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBFlushFileAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBFlushFileAsync:	OPWORD	$A445
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBFlushFileAsync
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  PBMountVol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBMountVol(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBMountVol:	OPWORD	$A00F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBMountVol
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  PBUnmountVol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBUnmountVol(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBUnmountVol:	OPWORD	$A00E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBUnmountVol
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  PBUnmountVolImmed()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBUnmountVolImmed(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBUnmountVolImmed:	OPWORD	$A20E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBUnmountVolImmed
	ENDIF


; *  PBEject()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBEject(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBEject:	OPWORD	$A017
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBEject
	ENDIF


; *  PBOffLine()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBOffLine(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBOffLine:	OPWORD	$A035
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOffLine
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  PBCatSearchSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCatSearchSync(CSParamPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCatSearchSync
			moveq           	#24,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCatSearchSync
	ENDIF


; *  PBCatSearchAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCatSearchAsync(CSParamPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCatSearchAsync
			moveq           	#24,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCatSearchAsync
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  SetVol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SetVol(ConstStr63Param volName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetVol
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  UnmountVol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr UnmountVol(ConstStr63Param volName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UnmountVol
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  Eject()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr Eject(ConstStr63Param volName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Eject
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  FlushVol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FlushVol(ConstStr63Param volName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlushVol
	ENDIF


; *  HSetVol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HSetVol(ConstStr63Param volName, short vRefNum, long dirID)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HSetVol
	ENDIF

;  AddDrive() was moved to Devices.h

	IF CALL_NOT_IN_CARBON THEN

; *  FSOpen()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr FSOpen(ConstStr255Param fileName, short vRefNum, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSOpen
	ENDIF


; *  OpenDF()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr OpenDF(ConstStr255Param fileName, short vRefNum, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenDF
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  FSClose()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSClose(short refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSClose
	ENDIF


; *  FSRead()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSRead(short refNum, long *count, void *buffPtr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSRead
	ENDIF


; *  FSWrite()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSWrite(short refNum, long *count, const void *buffPtr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSWrite
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  GetVInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr GetVInfo(short drvNum, StringPtr volName, short *vRefNum, long *freeBytes)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetVInfo
	ENDIF


; *  GetFInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr GetFInfo(ConstStr255Param fileName, short vRefNum, FInfo *fndrInfo)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetFInfo
	ENDIF


; *  GetVol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr GetVol(StringPtr volName, short *vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetVol
	ENDIF


; *  Create()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr Create(ConstStr255Param fileName, short vRefNum, OSType creator, OSType fileType)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Create
	ENDIF


; *  FSDelete()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr FSDelete(ConstStr255Param fileName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSDelete
	ENDIF


; *  OpenRF()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr OpenRF(ConstStr255Param fileName, short vRefNum, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenRF
	ENDIF


; *  Rename()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr Rename(ConstStr255Param oldName, short vRefNum, ConstStr255Param newName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Rename
	ENDIF


; *  SetFInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SetFInfo(ConstStr255Param fileName, short vRefNum, const FInfo *fndrInfo)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetFInfo
	ENDIF


; *  SetFLock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SetFLock(ConstStr255Param fileName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetFLock
	ENDIF


; *  RstFLock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr RstFLock(ConstStr255Param fileName, short vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RstFLock
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  Allocate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr Allocate(short refNum, long *count)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Allocate
	ENDIF


; *  GetEOF()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr GetEOF(short refNum, long *logEOF)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetEOF
	ENDIF


; *  SetEOF()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr SetEOF(short refNum, long logEOF)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetEOF
	ENDIF


; *  GetFPos()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr GetFPos(short refNum, long *filePos)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetFPos
	ENDIF


; *  SetFPos()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr SetFPos(short refNum, short posMode, long posOff)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetFPos
	ENDIF


; *  GetVRefNum()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr GetVRefNum(short fileRefNum, short *vRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetVRefNum
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  PBOpenWDSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBOpenWDSync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBOpenWDSync
			moveq           	#1,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenWDSync
	ENDIF


; *  PBOpenWDAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBOpenWDAsync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBOpenWDAsync
			moveq           	#1,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenWDAsync
	ENDIF


; *  PBCloseWDSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBCloseWDSync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCloseWDSync
			moveq           	#2,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCloseWDSync
	ENDIF


; *  PBCloseWDAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBCloseWDAsync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCloseWDAsync
			moveq           	#2,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCloseWDAsync
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  PBHSetVolSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHSetVolSync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHSetVolSync:	OPWORD	$A215
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetVolSync
	ENDIF


; *  PBHSetVolAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHSetVolAsync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHSetVolAsync:	OPWORD	$A615
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetVolAsync
	ENDIF


; *  PBHGetVolSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHGetVolSync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHGetVolSync:	OPWORD	$A214
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetVolSync
	ENDIF


; *  PBHGetVolAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHGetVolAsync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHGetVolAsync:	OPWORD	$A614
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetVolAsync
	ENDIF


; *  PBCatMoveSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCatMoveSync(CMovePBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCatMoveSync
			moveq           	#5,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCatMoveSync
	ENDIF


; *  PBCatMoveAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCatMoveAsync(CMovePBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCatMoveAsync
			moveq           	#5,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCatMoveAsync
	ENDIF


; *  PBDirCreateSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDirCreateSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDirCreateSync
			moveq           	#6,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDirCreateSync
	ENDIF


; *  PBDirCreateAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDirCreateAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDirCreateAsync
			moveq           	#6,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDirCreateAsync
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  PBGetWDInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBGetWDInfoSync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetWDInfoSync
			moveq           	#7,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetWDInfoSync
	ENDIF


; *  PBGetWDInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBGetWDInfoAsync(WDPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetWDInfoAsync
			moveq           	#7,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetWDInfoAsync
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  PBGetFCBInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetFCBInfoSync(FCBPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetFCBInfoSync
			moveq           	#8,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetFCBInfoSync
	ENDIF


; *  PBGetFCBInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetFCBInfoAsync(FCBPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetFCBInfoAsync
			moveq           	#8,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetFCBInfoAsync
	ENDIF


; *  PBGetCatInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetCatInfoSync(CInfoPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetCatInfoSync
			moveq           	#9,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetCatInfoSync
	ENDIF


; *  PBGetCatInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetCatInfoAsync(CInfoPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetCatInfoAsync
			moveq           	#9,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetCatInfoAsync
	ENDIF


; *  PBSetCatInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetCatInfoSync(CInfoPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetCatInfoSync
			moveq           	#10,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetCatInfoSync
	ENDIF


; *  PBSetCatInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetCatInfoAsync(CInfoPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetCatInfoAsync
			moveq           	#10,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetCatInfoAsync
	ENDIF


; *  PBAllocContigSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBAllocContigSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBAllocContigSync:	OPWORD	$A210
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBAllocContigSync
	ENDIF


; *  PBAllocContigAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBAllocContigAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBAllocContigAsync:	OPWORD	$A610
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBAllocContigAsync
	ENDIF


; *  PBLockRangeSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBLockRangeSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBLockRangeSync
			moveq           	#16,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBLockRangeSync
	ENDIF


; *  PBLockRangeAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBLockRangeAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBLockRangeAsync
			moveq           	#16,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBLockRangeAsync
	ENDIF


; *  PBUnlockRangeSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBUnlockRangeSync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBUnlockRangeSync
			moveq           	#17,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBUnlockRangeSync
	ENDIF


; *  PBUnlockRangeAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBUnlockRangeAsync(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBUnlockRangeAsync
			moveq           	#17,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBUnlockRangeAsync
	ENDIF


; *  PBSetVInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetVInfoSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetVInfoSync
			moveq           	#11,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetVInfoSync
	ENDIF


; *  PBSetVInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetVInfoAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetVInfoAsync
			moveq           	#11,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetVInfoAsync
	ENDIF


; *  PBHGetVInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHGetVInfoSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHGetVInfoSync:	OPWORD	$A207
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetVInfoSync
	ENDIF


; *  PBHGetVInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHGetVInfoAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHGetVInfoAsync:	OPWORD	$A607
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetVInfoAsync
	ENDIF


; *  PBHOpenSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHOpenSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHOpenSync:	OPWORD	$A200
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenSync
	ENDIF


; *  PBHOpenAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHOpenAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHOpenAsync:	OPWORD	$A600
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenAsync
	ENDIF


; *  PBHOpenRFSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHOpenRFSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHOpenRFSync:	OPWORD	$A20A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenRFSync
	ENDIF


; *  PBHOpenRFAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHOpenRFAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHOpenRFAsync:	OPWORD	$A60A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenRFAsync
	ENDIF


; *  PBHOpenDFSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHOpenDFSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHOpenDFSync
			moveq           	#26,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenDFSync
	ENDIF


; *  PBHOpenDFAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHOpenDFAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHOpenDFAsync
			moveq           	#26,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenDFAsync
	ENDIF


; *  PBHCreateSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHCreateSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHCreateSync:	OPWORD	$A208
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHCreateSync
	ENDIF


; *  PBHCreateAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHCreateAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHCreateAsync:	OPWORD	$A608
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHCreateAsync
	ENDIF


; *  PBHDeleteSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHDeleteSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHDeleteSync:	OPWORD	$A209
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHDeleteSync
	ENDIF


; *  PBHDeleteAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHDeleteAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHDeleteAsync:	OPWORD	$A609
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHDeleteAsync
	ENDIF


; *  PBHRenameSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHRenameSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHRenameSync:	OPWORD	$A20B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHRenameSync
	ENDIF


; *  PBHRenameAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHRenameAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHRenameAsync:	OPWORD	$A60B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHRenameAsync
	ENDIF


; *  PBHRstFLockSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHRstFLockSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHRstFLockSync:	OPWORD	$A242
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHRstFLockSync
	ENDIF


; *  PBHRstFLockAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHRstFLockAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHRstFLockAsync:	OPWORD	$A642
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHRstFLockAsync
	ENDIF


; *  PBHSetFLockSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHSetFLockSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHSetFLockSync:	OPWORD	$A241
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetFLockSync
	ENDIF


; *  PBHSetFLockAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHSetFLockAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHSetFLockAsync:	OPWORD	$A641
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetFLockAsync
	ENDIF


; *  PBHGetFInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHGetFInfoSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHGetFInfoSync:	OPWORD	$A20C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetFInfoSync
	ENDIF


; *  PBHGetFInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHGetFInfoAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHGetFInfoAsync:	OPWORD	$A60C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetFInfoAsync
	ENDIF


; *  PBHSetFInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHSetFInfoSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHSetFInfoSync:	OPWORD	$A20D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetFInfoSync
	ENDIF


; *  PBHSetFInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHSetFInfoAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		_PBHSetFInfoAsync:	OPWORD	$A60D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetFInfoAsync
	ENDIF


; *  PBMakeFSSpecSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBMakeFSSpecSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBMakeFSSpecSync
			moveq           	#27,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBMakeFSSpecSync
	ENDIF


; *  PBMakeFSSpecAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBMakeFSSpecAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBMakeFSSpecAsync
			moveq           	#27,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBMakeFSSpecAsync
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  FInitQueue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void FInitQueue(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_FInitQueue:	OPWORD	$A016
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FInitQueue
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  GetFSQHdr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal QHdrPtr GetFSQHdr(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetFSQHdr            &dest=(sp)
			move.l            #$00000360,&dest
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetFSQHdr
	ENDIF


; *  GetVCBQHdr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal QHdrPtr GetVCBQHdr(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetVCBQHdr           &dest=(sp)
			move.l            #$00000356,&dest
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetVCBQHdr
	ENDIF

;  GetDrvQHdr was moved to Devices.h

	ENDIF	; CALL_NOT_IN_CARBON

; *  HGetVol()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HGetVol(StringPtr volName, short *vRefNum, long *dirID)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HGetVol
	ENDIF


; *  HOpen()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HOpen(short vRefNum, long dirID, ConstStr255Param fileName, SInt8 permission, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HOpen
	ENDIF


; *  HOpenDF()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HOpenDF(short vRefNum, long dirID, ConstStr255Param fileName, SInt8 permission, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HOpenDF
	ENDIF


; *  HOpenRF()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HOpenRF(short vRefNum, long dirID, ConstStr255Param fileName, SInt8 permission, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HOpenRF
	ENDIF


; *  AllocContig()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr AllocContig(short refNum, long *count)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION AllocContig
	ENDIF


; *  HCreate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HCreate(short vRefNum, long dirID, ConstStr255Param fileName, OSType creator, OSType fileType)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HCreate
	ENDIF


; *  DirCreate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr DirCreate(short vRefNum, long parentDirID, ConstStr255Param directoryName, long *createdDirID)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DirCreate
	ENDIF


; *  HDelete()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HDelete(short vRefNum, long dirID, ConstStr255Param fileName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HDelete
	ENDIF


; *  HGetFInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HGetFInfo(short vRefNum, long dirID, ConstStr255Param fileName, FInfo *fndrInfo)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HGetFInfo
	ENDIF


; *  HSetFInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HSetFInfo(short vRefNum, long dirID, ConstStr255Param fileName, const FInfo *fndrInfo)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HSetFInfo
	ENDIF


; *  HSetFLock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HSetFLock(short vRefNum, long dirID, ConstStr255Param fileName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HSetFLock
	ENDIF


; *  HRstFLock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HRstFLock(short vRefNum, long dirID, ConstStr255Param fileName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HRstFLock
	ENDIF


; *  HRename()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HRename(short vRefNum, long dirID, ConstStr255Param oldName, ConstStr255Param newName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HRename
	ENDIF


; *  CatMove()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr CatMove(short vRefNum, long dirID, ConstStr255Param oldName, long newDirID, ConstStr255Param newName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CatMove
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  OpenWD()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr OpenWD(short vRefNum, long dirID, long procID, short *wdRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OpenWD
	ENDIF


; *  CloseWD()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr CloseWD(short wdRefNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CloseWD
	ENDIF


; *  GetWDInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr GetWDInfo(short wdRefNum, short *vRefNum, long *dirID, long *procID)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetWDInfo
	ENDIF

;   shared environment  
	ENDIF	; CALL_NOT_IN_CARBON

; *  PBHGetVolParmsSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHGetVolParmsSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHGetVolParmsSync
			moveq           	#48,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetVolParmsSync
	ENDIF


; *  PBHGetVolParmsAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHGetVolParmsAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHGetVolParmsAsync
			moveq           	#48,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetVolParmsAsync
	ENDIF


; *  PBHGetLogInInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHGetLogInInfoSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHGetLogInInfoSync
			moveq           	#49,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetLogInInfoSync
	ENDIF


; *  PBHGetLogInInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHGetLogInInfoAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHGetLogInInfoAsync
			moveq           	#49,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetLogInInfoAsync
	ENDIF


; *  PBHGetDirAccessSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHGetDirAccessSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHGetDirAccessSync
			moveq           	#50,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetDirAccessSync
	ENDIF


; *  PBHGetDirAccessAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHGetDirAccessAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHGetDirAccessAsync
			moveq           	#50,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHGetDirAccessAsync
	ENDIF


; *  PBHSetDirAccessSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHSetDirAccessSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHSetDirAccessSync
			moveq           	#51,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetDirAccessSync
	ENDIF


; *  PBHSetDirAccessAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHSetDirAccessAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHSetDirAccessAsync
			moveq           	#51,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHSetDirAccessAsync
	ENDIF


; *  PBHMapIDSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHMapIDSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHMapIDSync
			moveq           	#52,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHMapIDSync
	ENDIF


; *  PBHMapIDAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHMapIDAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHMapIDAsync
			moveq           	#52,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHMapIDAsync
	ENDIF


; *  PBHMapNameSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHMapNameSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHMapNameSync
			moveq           	#53,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHMapNameSync
	ENDIF


; *  PBHMapNameAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHMapNameAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHMapNameAsync
			moveq           	#53,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHMapNameAsync
	ENDIF


; *  PBHCopyFileSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHCopyFileSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHCopyFileSync
			moveq           	#54,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHCopyFileSync
	ENDIF


; *  PBHCopyFileAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHCopyFileAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHCopyFileAsync
			moveq           	#54,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHCopyFileAsync
	ENDIF


; *  PBHMoveRenameSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHMoveRenameSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHMoveRenameSync
			moveq           	#55,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHMoveRenameSync
	ENDIF


; *  PBHMoveRenameAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHMoveRenameAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHMoveRenameAsync
			moveq           	#55,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHMoveRenameAsync
	ENDIF


; *  PBHOpenDenySync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHOpenDenySync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHOpenDenySync
			moveq           	#56,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenDenySync
	ENDIF


; *  PBHOpenDenyAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHOpenDenyAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHOpenDenyAsync
			moveq           	#56,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenDenyAsync
	ENDIF


; *  PBHOpenRFDenySync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHOpenRFDenySync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHOpenRFDenySync
			moveq           	#57,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenRFDenySync
	ENDIF


; *  PBHOpenRFDenyAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBHOpenRFDenyAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBHOpenRFDenyAsync
			moveq           	#57,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBHOpenRFDenyAsync
	ENDIF


; *  PBGetXCatInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetXCatInfoSync(XCInfoPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetXCatInfoSync
			moveq           	#58,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetXCatInfoSync
	ENDIF


; *  PBGetXCatInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetXCatInfoAsync(XCInfoPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetXCatInfoAsync
			moveq           	#58,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetXCatInfoAsync
	ENDIF


; *  PBExchangeFilesSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBExchangeFilesSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBExchangeFilesSync
			moveq           	#23,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBExchangeFilesSync
	ENDIF


; *  PBExchangeFilesAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBExchangeFilesAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBExchangeFilesAsync
			moveq           	#23,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBExchangeFilesAsync
	ENDIF


; *  PBCreateFileIDRefSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCreateFileIDRefSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCreateFileIDRefSync
			moveq           	#20,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateFileIDRefSync
	ENDIF


; *  PBCreateFileIDRefAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCreateFileIDRefAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCreateFileIDRefAsync
			moveq           	#20,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateFileIDRefAsync
	ENDIF


; *  PBResolveFileIDRefSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBResolveFileIDRefSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBResolveFileIDRefSync
			moveq           	#22,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBResolveFileIDRefSync
	ENDIF


; *  PBResolveFileIDRefAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBResolveFileIDRefAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBResolveFileIDRefAsync
			moveq           	#22,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBResolveFileIDRefAsync
	ENDIF


; *  PBDeleteFileIDRefSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDeleteFileIDRefSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDeleteFileIDRefSync
			moveq           	#21,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDeleteFileIDRefSync
	ENDIF


; *  PBDeleteFileIDRefAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDeleteFileIDRefAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDeleteFileIDRefAsync
			moveq           	#21,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDeleteFileIDRefAsync
	ENDIF


; *  PBGetForeignPrivsSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetForeignPrivsSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetForeignPrivsSync
			moveq           	#96,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetForeignPrivsSync
	ENDIF


; *  PBGetForeignPrivsAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetForeignPrivsAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetForeignPrivsAsync
			moveq           	#96,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetForeignPrivsAsync
	ENDIF


; *  PBSetForeignPrivsSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetForeignPrivsSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetForeignPrivsSync
			moveq           	#97,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetForeignPrivsSync
	ENDIF


; *  PBSetForeignPrivsAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetForeignPrivsAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetForeignPrivsAsync
			moveq           	#97,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetForeignPrivsAsync
	ENDIF

;   Desktop Manager  

; *  PBDTGetPath()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTGetPath(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetPath
			moveq           	#32,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetPath
	ENDIF


; *  PBDTCloseDown()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTCloseDown(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTCloseDown
			moveq           	#33,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTCloseDown
	ENDIF


; *  PBDTAddIconSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTAddIconSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTAddIconSync
			moveq           	#34,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTAddIconSync
	ENDIF


; *  PBDTAddIconAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTAddIconAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTAddIconAsync
			moveq           	#34,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTAddIconAsync
	ENDIF


; *  PBDTGetIconSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTGetIconSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetIconSync
			moveq           	#35,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetIconSync
	ENDIF


; *  PBDTGetIconAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTGetIconAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetIconAsync
			moveq           	#35,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetIconAsync
	ENDIF


; *  PBDTGetIconInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTGetIconInfoSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetIconInfoSync
			moveq           	#36,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetIconInfoSync
	ENDIF


; *  PBDTGetIconInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTGetIconInfoAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetIconInfoAsync
			moveq           	#36,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetIconInfoAsync
	ENDIF


; *  PBDTAddAPPLSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTAddAPPLSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTAddAPPLSync
			moveq           	#37,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTAddAPPLSync
	ENDIF


; *  PBDTAddAPPLAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTAddAPPLAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTAddAPPLAsync
			moveq           	#37,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTAddAPPLAsync
	ENDIF


; *  PBDTRemoveAPPLSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTRemoveAPPLSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTRemoveAPPLSync
			moveq           	#38,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTRemoveAPPLSync
	ENDIF


; *  PBDTRemoveAPPLAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTRemoveAPPLAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTRemoveAPPLAsync
			moveq           	#38,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTRemoveAPPLAsync
	ENDIF


; *  PBDTGetAPPLSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTGetAPPLSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetAPPLSync
			moveq           	#39,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetAPPLSync
	ENDIF


; *  PBDTGetAPPLAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTGetAPPLAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetAPPLAsync
			moveq           	#39,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetAPPLAsync
	ENDIF


; *  PBDTSetCommentSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTSetCommentSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTSetCommentSync
			moveq           	#40,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTSetCommentSync
	ENDIF


; *  PBDTSetCommentAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTSetCommentAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTSetCommentAsync
			moveq           	#40,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTSetCommentAsync
	ENDIF


; *  PBDTRemoveCommentSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTRemoveCommentSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTRemoveCommentSync
			moveq           	#41,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTRemoveCommentSync
	ENDIF


; *  PBDTRemoveCommentAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTRemoveCommentAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTRemoveCommentAsync
			moveq           	#41,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTRemoveCommentAsync
	ENDIF


; *  PBDTGetCommentSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTGetCommentSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetCommentSync
			moveq           	#42,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetCommentSync
	ENDIF


; *  PBDTGetCommentAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTGetCommentAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetCommentAsync
			moveq           	#42,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetCommentAsync
	ENDIF


; *  PBDTFlushSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTFlushSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTFlushSync
			moveq           	#43,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTFlushSync
	ENDIF


; *  PBDTFlushAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTFlushAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTFlushAsync
			moveq           	#43,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTFlushAsync
	ENDIF


; *  PBDTResetSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTResetSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTResetSync
			moveq           	#44,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTResetSync
	ENDIF


; *  PBDTResetAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTResetAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTResetAsync
			moveq           	#44,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTResetAsync
	ENDIF


; *  PBDTGetInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTGetInfoSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetInfoSync
			moveq           	#45,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetInfoSync
	ENDIF


; *  PBDTGetInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTGetInfoAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTGetInfoAsync
			moveq           	#45,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTGetInfoAsync
	ENDIF


; *  PBDTOpenInform()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTOpenInform(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTOpenInform
			moveq           	#46,D0
			dc.w            	$A060
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTOpenInform
	ENDIF


; *  PBDTDeleteSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTDeleteSync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTDeleteSync
			moveq           	#47,D0
			dc.w            	$A060
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTDeleteSync
	ENDIF


; *  PBDTDeleteAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDTDeleteAsync(DTPBPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDTDeleteAsync
			moveq           	#47,D0
			dc.w            	$A460
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDTDeleteAsync
	ENDIF

;   VolumeMount traps  

; *  PBGetVolMountInfoSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetVolMountInfoSize(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetVolMountInfoSize
			moveq           	#63,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVolMountInfoSize
	ENDIF


; *  PBGetVolMountInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetVolMountInfo(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetVolMountInfo
			moveq           	#64,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVolMountInfo
	ENDIF


; *  PBVolumeMount()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBVolumeMount(ParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBVolumeMount
			moveq           	#65,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBVolumeMount
	ENDIF

;   FSp traps  

; *  FSMakeFSSpec()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSMakeFSSpec(short vRefNum, long dirID, ConstStr255Param fileName, FSSpec *spec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSMakeFSSpec
			moveq           	#1,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSMakeFSSpec
	ENDIF


; *  FSpOpenDF()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpOpenDF(const FSSpec *spec, SInt8 permission, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpOpenDF
			moveq           	#2,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpOpenDF
	ENDIF


; *  FSpOpenRF()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpOpenRF(const FSSpec *spec, SInt8 permission, short *refNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpOpenRF
			moveq           	#3,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpOpenRF
	ENDIF


; *  FSpCreate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpCreate(const FSSpec *spec, OSType creator, OSType fileType, ScriptCode scriptTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpCreate
			moveq           	#4,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpCreate
	ENDIF


; *  FSpDirCreate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpDirCreate(const FSSpec *spec, ScriptCode scriptTag, long *createdDirID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpDirCreate
			moveq           	#5,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpDirCreate
	ENDIF


; *  FSpDelete()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpDelete(const FSSpec *spec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpDelete
			moveq           	#6,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpDelete
	ENDIF


; *  FSpGetFInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpGetFInfo(const FSSpec *spec, FInfo *fndrInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpGetFInfo
			moveq           	#7,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpGetFInfo
	ENDIF


; *  FSpSetFInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpSetFInfo(const FSSpec *spec, const FInfo *fndrInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpSetFInfo
			moveq           	#8,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpSetFInfo
	ENDIF


; *  FSpSetFLock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpSetFLock(const FSSpec *spec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpSetFLock
			moveq           	#9,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpSetFLock
	ENDIF


; *  FSpRstFLock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpRstFLock(const FSSpec *spec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpRstFLock
			moveq           	#10,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpRstFLock
	ENDIF


; *  FSpRename()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpRename(const FSSpec *spec, ConstStr255Param newName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpRename
			moveq           	#11,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpRename
	ENDIF


; *  FSpCatMove()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpCatMove(const FSSpec *source, const FSSpec *dest)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpCatMove
			moveq           	#12,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpCatMove
	ENDIF


; *  FSpExchangeFiles()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpExchangeFiles(const FSSpec *source, const FSSpec *dest)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpExchangeFiles
			moveq           	#15,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpExchangeFiles
	ENDIF



; *  PBShareSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBShareSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBShareSync
			moveq           	#66,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBShareSync
	ENDIF


; *  PBShareAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBShareAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBShareAsync
			moveq           	#66,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBShareAsync
	ENDIF


; *  PBUnshareSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBUnshareSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBUnshareSync
			moveq           	#67,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBUnshareSync
	ENDIF


; *  PBUnshareAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBUnshareAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBUnshareAsync
			moveq           	#67,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBUnshareAsync
	ENDIF


; *  PBGetUGEntrySync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetUGEntrySync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetUGEntrySync
			moveq           	#68,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetUGEntrySync
	ENDIF


; *  PBGetUGEntryAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetUGEntryAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetUGEntryAsync
			moveq           	#68,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetUGEntryAsync
	ENDIF




	IF TARGET_CPU_68K THEN
; 
;    PBGetAltAccess and PBSetAltAccess are obsolete and will not be supported 
;    on PowerPC. Equivalent functionality is provided by the routines 
;    PBGetForeignPrivs and PBSetForeignPrivs.
;

	IF CALL_NOT_IN_CARBON THEN

; *  PBGetAltAccessSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBGetAltAccessSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetAltAccessSync
			moveq           	#96,D0
			dc.w            	$A060
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetAltAccessSync
	ENDIF


; *  PBGetAltAccessAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBGetAltAccessAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetAltAccessAsync
			moveq           	#96,D0
			dc.w            	$A460
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetAltAccessAsync
	ENDIF


; *  PBSetAltAccessSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBSetAltAccessSync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetAltAccessSync
			moveq           	#97,D0
			dc.w            	$A060
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetAltAccessSync
	ENDIF


; *  PBSetAltAccessAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PBSetAltAccessAsync(HParmBlkPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetAltAccessAsync
			moveq           	#97,D0
			dc.w            	$A460
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetAltAccessAsync
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF	; TARGET_CPU_68K

; 
;    The PBxxx() routines are obsolete.  
;    
;    Use the PBxxxSync() or PBxxxAsync() version instead.
;


; typedef SInt16 						FSVolumeRefNum


kFSInvalidVolumeRefNum			EQU		0
FSRef					RECORD 0
hidden					 ds.b	80				; offset: $0 (0)		;  private to File Manager; •• need symbolic constant 
sizeof					 EQU *					; size:   $50 (80)
						ENDR
; typedef struct FSRef *				FSRefPtr



; *  FSPermissionInfo
; *  
; *  Discussion:
; *    This structure is used when kFSCatInfoPermissions is passed to
; *    the HFSPlus API. On return from GetCatalogInfo and
; *    GetCatalogInfoBulk, the userID, groupID, and mode fields are
; *    returned.  When passed to SetCatalogInfo, only the mode field is
; *    set.  See chmod(2) for details about the mode field. This is
; *    supported on Mac OS X only.
; 

FSPermissionInfo		RECORD 0
userID					 ds.l	1				; offset: $0 (0)
groupID					 ds.l	1				; offset: $4 (4)
reserved1				 ds.b	1				; offset: $8 (8)
userAccess				 ds.b	1				; offset: $9 (9)
mode					 ds.w	1				; offset: $A (10)
reserved2				 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
;   CatalogInfoBitmap describes which fields of the CatalogInfo you wish to get or set.
; typedef UInt32 						FSCatalogInfoBitmap


kFSCatInfoNone					EQU		$00000000
kFSCatInfoTextEncoding			EQU		$00000001
kFSCatInfoNodeFlags				EQU		$00000002			; Locked (bit 0) and directory (bit 4) only 
kFSCatInfoVolume				EQU		$00000004
kFSCatInfoParentDirID			EQU		$00000008
kFSCatInfoNodeID				EQU		$00000010
kFSCatInfoCreateDate			EQU		$00000020
kFSCatInfoContentMod			EQU		$00000040
kFSCatInfoAttrMod				EQU		$00000080
kFSCatInfoAccessDate			EQU		$00000100
kFSCatInfoBackupDate			EQU		$00000200
kFSCatInfoPermissions			EQU		$00000400			; Should this be finer granularity? 
kFSCatInfoFinderInfo			EQU		$00000800
kFSCatInfoFinderXInfo			EQU		$00001000
kFSCatInfoValence				EQU		$00002000			; Folders only, zero for files 
kFSCatInfoDataSizes				EQU		$00004000			; Data fork logical and physical size 
kFSCatInfoRsrcSizes				EQU		$00008000			; Resource fork logical and physical size 
kFSCatInfoSharingFlags			EQU		$00010000			; sharingFlags: kioFlAttribMountedBit, kioFlAttribSharePointBit 
kFSCatInfoUserPrivs				EQU		$00020000			; userPrivileges 
kFSCatInfoAllDates				EQU		$000003E0
kFSCatInfoGettableInfo			EQU		$0003FFFF
kFSCatInfoSettableInfo			EQU		$00001FE3			; flags, dates, permissions, Finder info, text encoding 
kFSCatInfoReserved				EQU		$FFFC0000			; bits that are currently reserved 
;   Constants for nodeFlags field of FSCatalogInfo 

kFSNodeLockedBit				EQU		0					; Set if file or directory is locked 
kFSNodeLockedMask				EQU		$0001
kFSNodeResOpenBit				EQU		2					; Set if the resource fork is open 
kFSNodeResOpenMask				EQU		$0004
kFSNodeDataOpenBit				EQU		3					; Set if the data fork is open 
kFSNodeDataOpenMask				EQU		$0008
kFSNodeIsDirectoryBit			EQU		4					; Set if the object is a directory 
kFSNodeIsDirectoryMask			EQU		$0010
kFSNodeCopyProtectBit			EQU		6
kFSNodeCopyProtectMask			EQU		$0040
kFSNodeForkOpenBit				EQU		7					; Set if the file or directory has any open fork 
kFSNodeForkOpenMask				EQU		$0080
;   Constants for sharingFlags field of FSCatalogInfo 

kFSNodeInSharedBit				EQU		2					; Set if a directory is within a share point 
kFSNodeInSharedMask				EQU		$0004
kFSNodeIsMountedBit				EQU		3					; Set if a directory is a share point currently mounted by some user 
kFSNodeIsMountedMask			EQU		$0008
kFSNodeIsSharePointBit			EQU		5					; Set if a directory is a share point (exported volume) 
kFSNodeIsSharePointMask			EQU		$0020

FSCatalogInfo			RECORD 0
nodeFlags				 ds.w	1				; offset: $0 (0)		;  node flags 
volume					 ds.w	1				; offset: $2 (2)		;  object's volume ref 
parentDirID				 ds.l	1				; offset: $4 (4)		;  parent directory's ID 
nodeID					 ds.l	1				; offset: $8 (8)		;  file/directory ID 
sharingFlags			 ds.b	1				; offset: $C (12)		;  kioFlAttribMountedBit and kioFlAttribSharePointBit 
userPrivileges			 ds.b	1				; offset: $D (13)		;  user's effective AFP privileges (same as ioACUser) 
reserved1				 ds.b	1				; offset: $E (14)
reserved2				 ds.b	1				; offset: $F (15)
createDate				 ds		UTCDateTime		; offset: $10 (16)		;  date and time of creation 
contentModDate			 ds		UTCDateTime		; offset: $18 (24)		;  date and time of last fork modification 
attributeModDate		 ds		UTCDateTime		; offset: $20 (32)		;  date and time of last attribute modification 
accessDate				 ds		UTCDateTime		; offset: $28 (40)		;  date and time of last access (for Mac OS X) 
backupDate				 ds		UTCDateTime		; offset: $30 (48)		;  date and time of last backup 
permissions				 ds.l	4				; offset: $38 (56)		;  permissions (for Mac OS X) 
finderInfo				 ds.b	16				; offset: $48 (72)		;  Finder information part 1 
extFinderInfo			 ds.b	16				; offset: $58 (88)		;  Finder information part 2 
dataLogicalSize			 ds		UInt64			; offset: $68 (104)		;  files only 
dataPhysicalSize		 ds		UInt64			; offset: $70 (112)		;  files only 
rsrcLogicalSize			 ds		UInt64			; offset: $78 (120)		;  files only 
rsrcPhysicalSize		 ds		UInt64			; offset: $80 (128)		;  files only 
valence					 ds.l	1				; offset: $88 (136)		;  folders only 
textEncodingHint		 ds.l	1				; offset: $8C (140)
sizeof					 EQU *					; size:   $90 (144)
						ENDR
; typedef struct FSCatalogInfo *		FSCatalogInfoPtr

FSRefParam				RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		; ptr to Vol:FileName string
ioVRefNum				 ds.w	1				; offset: $16 (22)		; volume refnum (DrvNum for Eject and MountVol)
reserved1				 ds.w	1				; offset: $18 (24)		;  was ioRefNum 
reserved2				 ds.b	1				; offset: $1A (26)		;  was ioVersNum 
reserved3				 ds.b	1				; offset: $1B (27)		;  was ioPermssn 
ref						 ds.l	1				; offset: $1C (28)		;  Input ref; the target of the call 
whichInfo				 ds.l	1				; offset: $20 (32)
catInfo					 ds.l	1				; offset: $24 (36)
nameLength				 ds.l	1				; offset: $28 (40)		;  input name length for create/rename 
name					 ds.l	1				; offset: $2C (44)		;  input name for create/rename 
ioDirID					 ds.l	1				; offset: $30 (48)
spec					 ds.l	1				; offset: $34 (52)
parentRef				 ds.l	1				; offset: $38 (56)		;  ref of directory to move another ref to 
newRef					 ds.l	1				; offset: $3C (60)		;  Output ref 
textEncodingHint		 ds.l	1				; offset: $40 (64)		;  for Rename, MakeFSRefUnicode 
outName					 ds.l	1				; offset: $44 (68)		;  Output name for GetCatalogInfo 
sizeof					 EQU *					; size:   $48 (72)
						ENDR
; typedef struct FSRefParam *			FSRefParamPtr




kFSIterateFlat					EQU		0					; Immediate children of container only 
kFSIterateSubtree				EQU		1					; Entire subtree rooted at container 
kFSIterateDelete				EQU		2
kFSIterateReserved				EQU		$FFFFFFFC
; typedef OptionBits 					FSIteratorFlags


															; CatalogSearch constants 
fsSBNodeID						EQU		$00008000			; search by range of nodeID 
fsSBAttributeModDate			EQU		$00010000			; search by range of attributeModDate 
fsSBAccessDate					EQU		$00020000			; search by range of accessDate 
fsSBPermissions					EQU		$00040000			; search by value/mask of permissions 
fsSBNodeIDBit					EQU		15
fsSBAttributeModDateBit			EQU		16
fsSBAccessDateBit				EQU		17
fsSBPermissionsBit				EQU		18
FSSearchParams			RECORD 0
searchTime				 ds.l	1				; offset: $0 (0)		;  a Time Manager duration 
searchBits				 ds.l	1				; offset: $4 (4)		;  which fields to search on 
searchNameLength		 ds.l	1				; offset: $8 (8)
searchName				 ds.l	1				; offset: $C (12)
searchInfo1				 ds.l	1				; offset: $10 (16)		;  values and lower bounds 
searchInfo2				 ds.l	1				; offset: $14 (20)		;  masks and upper bounds 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct FSSearchParams *		FSSearchParamsPtr

FSCatalogBulkParam		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
containerChanged		 ds.b	1				; offset: $12 (18)		;  true if container changed since last iteration 
reserved				 ds.b	1				; offset: $13 (19)		;  make following fields 4-byte aligned 
iteratorFlags			 ds.l	1				; offset: $14 (20)
iterator				 ds.l	1				; offset: $18 (24)
container				 ds.l	1				; offset: $1C (28)		;  directory/volume to iterate 
maximumItems			 ds.l	1				; offset: $20 (32)
actualItems				 ds.l	1				; offset: $24 (36)
whichInfo				 ds.l	1				; offset: $28 (40)
catalogInfo				 ds.l	1				; offset: $2C (44)		;  returns an array 
refs					 ds.l	1				; offset: $30 (48)		;  returns an array 
specs					 ds.l	1				; offset: $34 (52)		;  returns an array 
names					 ds.l	1				; offset: $38 (56)		;  returns an array 
searchParams			 ds.l	1				; offset: $3C (60)
sizeof					 EQU *					; size:   $40 (64)
						ENDR
; typedef struct FSCatalogBulkParam *	FSCatalogBulkParamPtr

; typedef UInt16 						FSAllocationFlags


kFSAllocDefaultFlags			EQU		$0000				; as much as possible, not contiguous 
kFSAllocAllOrNothingMask		EQU		$0001				; allocate all of the space, or nothing 
kFSAllocContiguousMask			EQU		$0002				; new space must be one contiguous piece 
kFSAllocNoRoundUpMask			EQU		$0004				; don't round up allocation to clump size 
kFSAllocReservedMask			EQU		$FFF8				; these bits are reserved and must not be set 
FSForkIOParam			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
reserved1				 ds.l	1				; offset: $12 (18)		;  was ioNamePtr 
reserved2				 ds.w	1				; offset: $16 (22)		;  was ioVRefNum 
forkRefNum				 ds.w	1				; offset: $18 (24)		;  same as ioRefNum 
reserved3				 ds.b	1				; offset: $1A (26)		;  was ioVersNum 
permissions				 ds.b	1				; offset: $1B (27)		;  desired access to the fork 
ref						 ds.l	1				; offset: $1C (28)		;  which object to open 
buffer					 ds.l	1				; offset: $20 (32)		; data buffer Ptr
requestCount			 ds.l	1				; offset: $24 (36)		; requested byte count
actualCount				 ds.l	1				; offset: $28 (40)		; actual byte count completed
positionMode			 ds.w	1				; offset: $2C (44)		; initial file positioning
positionOffset			 ds		SInt64			; offset: $2E (46)		; file position offset
allocationFlags			 ds.w	1				; offset: $36 (54)
allocationAmount		 ds		UInt64			; offset: $38 (56)
forkNameLength			 ds.l	1				; offset: $40 (64)		;  input; length of fork name 
forkName				 ds.l	1				; offset: $44 (68)		;  input; name of fork 
forkIterator			 ds		CatPositionRec ; offset: $48 (72)
outForkName				 ds.l	1				; offset: $58 (88)		;  output; name of fork 
sizeof					 EQU *					; size:   $5C (92)
						ENDR
; typedef struct FSForkIOParam *		FSForkIOParamPtr

FSForkInfo				RECORD 0
flags					 ds.b	1				; offset: $0 (0)		;  copy of FCB flags 
permissions				 ds.b	1				; offset: $1 (1)
volume					 ds.w	1				; offset: $2 (2)
reserved2				 ds.l	1				; offset: $4 (4)
nodeID					 ds.l	1				; offset: $8 (8)		;  file or directory ID 
forkID					 ds.l	1				; offset: $C (12)		;  fork ID 
currentPosition			 ds		UInt64			; offset: $10 (16)
logicalEOF				 ds		UInt64			; offset: $18 (24)
physicalEOF				 ds		UInt64			; offset: $20 (32)
process					 ds		UInt64			; offset: $28 (40)		;  should be ProcessSerialNumber 
sizeof					 EQU *					; size:   $30 (48)
						ENDR
; typedef struct FSForkInfo *			FSForkInfoPtr

FSForkCBInfoParam		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
desiredRefNum			 ds.w	1				; offset: $12 (18)		;  0 to iterate, non-0 for specific refnum 
volumeRefNum			 ds.w	1				; offset: $14 (20)		;  volume to match, or 0 for all volumes 
iterator				 ds.w	1				; offset: $16 (22)		;  0 to start iteration 
actualRefNum			 ds.w	1				; offset: $18 (24)		;  actual refnum found 
ref						 ds.l	1				; offset: $1A (26)
forkInfo				 ds.l	1				; offset: $1E (30)
forkName				 ds.l	1				; offset: $22 (34)
sizeof					 EQU *					; size:   $26 (38)
						ENDR
; typedef struct FSForkCBInfoParam *	FSForkCBInfoParamPtr

; typedef UInt32 						FSVolumeInfoBitmap


kFSVolInfoNone					EQU		$0000
kFSVolInfoCreateDate			EQU		$0001
kFSVolInfoModDate				EQU		$0002
kFSVolInfoBackupDate			EQU		$0004
kFSVolInfoCheckedDate			EQU		$0008
kFSVolInfoFileCount				EQU		$0010
kFSVolInfoDirCount				EQU		$0020
kFSVolInfoSizes					EQU		$0040				; totalBytes and freeBytes 
kFSVolInfoBlocks				EQU		$0080				; blockSize, totalBlocks, freeBlocks 
kFSVolInfoNextAlloc				EQU		$0100
kFSVolInfoRsrcClump				EQU		$0200
kFSVolInfoDataClump				EQU		$0400
kFSVolInfoNextID				EQU		$0800
kFSVolInfoFinderInfo			EQU		$1000
kFSVolInfoFlags					EQU		$2000
kFSVolInfoFSInfo				EQU		$4000				; filesystemID, signature 
kFSVolInfoDriveInfo				EQU		$8000				; driveNumber, driverRefNum 
kFSVolInfoGettableInfo			EQU		$FFFF				; This seems like it is here just for completeness 
kFSVolInfoSettableInfo			EQU		$3004				; backup date, Finder info, flags 
;  FSVolumeInfo.flags bits.  These are the same as for ioVAtrb, but with nicer names. 

kFSVolFlagDefaultVolumeBit		EQU		5					; Set if the volume is the default volume 
kFSVolFlagDefaultVolumeMask		EQU		$0020
kFSVolFlagFilesOpenBit			EQU		6					; Set if there are open files or iterators 
kFSVolFlagFilesOpenMask			EQU		$0040
kFSVolFlagHardwareLockedBit		EQU		7					; Set if volume is locked by a hardware setting 
kFSVolFlagHardwareLockedMask	EQU		$0080
kFSVolFlagSoftwareLockedBit		EQU		15					; Set if volume is locked by software 
kFSVolFlagSoftwareLockedMask	EQU		$8000

FSVolumeInfo			RECORD 0
;  Dates -- zero means "never" or "unknown" 
createDate				 ds		UTCDateTime		; offset: $0 (0)
modifyDate				 ds		UTCDateTime		; offset: $8 (8)
backupDate				 ds		UTCDateTime		; offset: $10 (16)
checkedDate				 ds		UTCDateTime		; offset: $18 (24)
;  File/Folder counts -- return zero if unknown 
fileCount				 ds.l	1				; offset: $20 (32)		;  total files on volume 
folderCount				 ds.l	1				; offset: $24 (36)		;  total folders on volume 
;  Note: no root directory counts 
totalBytes				 ds		UInt64			; offset: $28 (40)		;  total number of bytes on volume 
freeBytes				 ds		UInt64			; offset: $30 (48)		;  number of free bytes on volume 
;  HFS and HFS Plus specific.  Set fields to zero if not appropriate 
blockSize				 ds.l	1				; offset: $38 (56)		;  size (in bytes) of allocation blocks 
totalBlocks				 ds.l	1				; offset: $3C (60)		;  number of allocation blocks in volume 
freeBlocks				 ds.l	1				; offset: $40 (64)		;  number of unused allocation blocks 
nextAllocation			 ds.l	1				; offset: $44 (68)		;  start of next allocation search 
rsrcClumpSize			 ds.l	1				; offset: $48 (72)		;  default resource fork clump size 
dataClumpSize			 ds.l	1				; offset: $4C (76)		;  default data fork clump size 
nextCatalogID			 ds.l	1				; offset: $50 (80)		;  next unused catalog node ID ••• OYG ••• need to make HFSVolumes.h work Should be HFSCatalogNodeID
finderInfo				 ds.b	32				; offset: $54 (84)		;  information used by Finder 
;  Identifying information 
flags					 ds.w	1				; offset: $74 (116)		;  ioVAtrb 
filesystemID			 ds.w	1				; offset: $76 (118)		;  ioVFSID 
signature				 ds.w	1				; offset: $78 (120)		;  ioVSigWord, unique within an FSID 
driveNumber				 ds.w	1				; offset: $7A (122)		;  ioVDrvInfo 
driverRefNum			 ds.w	1				; offset: $7C (124)		;  ioVDRefNum 
sizeof					 EQU *					; size:   $7E (126)
						ENDR
; typedef struct FSVolumeInfo *			FSVolumeInfoPtr

FSVolumeInfoParam		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		; queue link in header
qType					 ds.w	1				; offset: $4 (4)		; type byte for safety check
ioTrap					 ds.w	1				; offset: $6 (6)		; FS: the Trap
ioCmdAddr				 ds.l	1				; offset: $8 (8)		; FS: address to dispatch to
ioCompletion			 ds.l	1				; offset: $C (12)		; completion routine addr (0 for synch calls)
ioResult				 ds.w	1				; offset: $10 (16)		; result code
ioNamePtr				 ds.l	1				; offset: $12 (18)		;  unused 
ioVRefNum				 ds.w	1				; offset: $16 (22)		;  volume refnum 
volumeIndex				 ds.l	1				; offset: $18 (24)		;  index, or 0 to use ioVRefNum 
whichInfo				 ds.l	1				; offset: $1C (28)		;  which volumeInfo fields to get/set 
volumeInfo				 ds.l	1				; offset: $20 (32)		;  information about the volume 
volumeName				 ds.l	1				; offset: $24 (36)		;  output; pointer to volume name 
ref						 ds.l	1				; offset: $28 (40)		;  volume's FSRef 
sizeof					 EQU *					; size:   $2C (44)
						ENDR
; typedef struct FSVolumeInfoParam *	FSVolumeInfoParamPtr


;    MakeFSRef
;    Create an FSRef for an existing object specified by a combination
;    of volume refnum, parent directory, and pathname.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ioNamePtr       A pointer to a pathname
;    ->  ioVRefNum       A volume specification
;    ->  ioDirID         A directory ID
;    <-  newRef          A pointer to an FSRef



; *  FSpMakeFSRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSpMakeFSRef(const FSSpec *source, FSRef *newRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSpMakeFSRef
			move.w              #$041A,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSpMakeFSRef
	ENDIF


; *  PBMakeFSRefSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBMakeFSRefSync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBMakeFSRefSync
			moveq           	#110,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBMakeFSRefSync
	ENDIF


; *  PBMakeFSRefAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBMakeFSRefAsync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBMakeFSRefAsync
			moveq           	#110,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBMakeFSRefAsync
	ENDIF



;    MakeFSRefUnicode
;    Create an FSRef for an existing object specified by 
;    Parent FSRef and Unicode name.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             A pointer to the parent directory FSRef
;    ->  name            A pointer to Unicde name
;    ->  nameLength      The length of the Unicode Name
;    ->  textEncodingHint A suggested text encoding to use for the name
;    <-  newRef          A pointer to an FSRef



; *  FSMakeFSRefUnicode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSMakeFSRefUnicode(const FSRef *parentRef, UniCharCount nameLength, const UniChar *name, TextEncoding textEncodingHint, FSRef *newRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSMakeFSRefUnicode
			move.w              #$0A1B,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSMakeFSRefUnicode
	ENDIF


; *  PBMakeFSRefUnicodeSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBMakeFSRefUnicodeSync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBMakeFSRefUnicodeSync
			moveq           	#122,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBMakeFSRefUnicodeSync
	ENDIF


; *  PBMakeFSRefUnicodeAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBMakeFSRefUnicodeAsync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBMakeFSRefUnicodeAsync
			moveq           	#122,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBMakeFSRefUnicodeAsync
	ENDIF



;    CompareFSRefs
;    Test whether two FSRefs refer to the same file or directory.
;    If they do, noErr is returned.  Otherwise, an appropriate error
;    (such as errFSRefsDifferent) is returned.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             A pointer to the first FSRef
;    ->  parentRef       A pointer to the second FSRef



; *  FSCompareFSRefs()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSCompareFSRefs(const FSRef *ref1, const FSRef *ref2)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSCompareFSRefs
			move.w              #$0435,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSCompareFSRefs
	ENDIF


; *  PBCompareFSRefsSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCompareFSRefsSync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCompareFSRefsSync
			moveq           	#124,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCompareFSRefsSync
	ENDIF


; *  PBCompareFSRefsAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBCompareFSRefsAsync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBCompareFSRefsAsync
			moveq           	#124,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCompareFSRefsAsync
	ENDIF



;    CreateFileUnicode
;    Creates a new file.  The input filename is in Unicode.
;    You can optionally set catalog info for the file.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             The directory where the file is to be created
;    ->  whichInfo       Which catalog info fields to set
;    ->  catInfo         The values for catalog info fields to set; may be NULL
;    ->  nameLength      Number of Unicode characters in the file's name
;    ->  name            A pointer to the Unicode name
;    <-  spec            A pointer to the FSSpec for the new directory; may be NULL
;    <-  newRef          A pointer to the FSRef for the new file; may be NULL



; *  FSCreateFileUnicode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSCreateFileUnicode(const FSRef *parentRef, UniCharCount nameLength, const UniChar *name, FSCatalogInfoBitmap whichInfo, const FSCatalogInfo *catalogInfo, FSRef *newRef, FSSpec *newSpec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSCreateFileUnicode
			move.w              #$0E1C,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSCreateFileUnicode
	ENDIF


; *  PBCreateFileUnicodeSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCreateFileUnicodeSync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCreateFileUnicodeSync
			moveq           	#112,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateFileUnicodeSync
	ENDIF


; *  PBCreateFileUnicodeAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBCreateFileUnicodeAsync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBCreateFileUnicodeAsync
			moveq           	#112,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateFileUnicodeAsync
	ENDIF



;    CreateDirectoryUnicode
;    Creates a new directory.  The input directory name is in Unicode.
;    You can optionally set catalog info for the directory.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             The parent directory where the directory is to be created
;    ->  whichInfo       Which catalog info fields to set
;    ->  catInfo         The values for catalog info fields to set; may be NULL
;    ->  nameLength      Number of Unicode characters in the directory's name
;    ->  name            A pointer to the Unicode name
;    <-  ioDirID         The DirID of the new directory
;    <-  spec            A pointer to the FSSpec for the new directory; may be NULL
;    <-  newRef          A pointer to the FSRef for the new directory; may be NULL



; *  FSCreateDirectoryUnicode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSCreateDirectoryUnicode(const FSRef *parentRef, UniCharCount nameLength, const UniChar *name, FSCatalogInfoBitmap whichInfo, const FSCatalogInfo *catalogInfo, FSRef *newRef, FSSpec *newSpec, UInt32 *newDirID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSCreateDirectoryUnicode
			move.w              #$101D,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSCreateDirectoryUnicode
	ENDIF


; *  PBCreateDirectoryUnicodeSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCreateDirectoryUnicodeSync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCreateDirectoryUnicodeSync
			moveq           	#113,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateDirectoryUnicodeSync
	ENDIF


; *  PBCreateDirectoryUnicodeAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBCreateDirectoryUnicodeAsync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBCreateDirectoryUnicodeAsync
			moveq           	#113,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateDirectoryUnicodeAsync
	ENDIF



;    DeleteObject
;    Deletes an existing file or directory.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             The file or directory to be deleted



; *  FSDeleteObject()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSDeleteObject(const FSRef *ref)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSDeleteObject
			move.w              #$021E,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSDeleteObject
	ENDIF


; *  PBDeleteObjectSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDeleteObjectSync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDeleteObjectSync
			moveq           	#114,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDeleteObjectSync
	ENDIF


; *  PBDeleteObjectAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBDeleteObjectAsync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBDeleteObjectAsync
			moveq           	#114,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDeleteObjectAsync
	ENDIF



;    MoveObject
;    Move an existing file or directory into a different directory.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             The file or directory to be moved
;    ->  parentRef       The file or directory will be moved into this directory
;    <-  newRef          A new FSRef for the file or directory in its new location;
;                        optional, may be NULL
;    NOTE: Moving an object may change its FSRef.  If you want to continue to
;    refer to the object, you should pass a non-NULL pointer in newRef and use
;    that returned FSRef to access the object after the move.  The FSRef passed
;    in "ref" may or may not be usable to access the object after it is moved.
;    "newRef" may point to the same storage as "parentRef" or "ref".



; *  FSMoveObject()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSMoveObject(const FSRef *ref, const FSRef *destDirectory, FSRef *newRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSMoveObject
			move.w              #$061F,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSMoveObject
	ENDIF


; *  PBMoveObjectSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBMoveObjectSync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBMoveObjectSync
			moveq           	#115,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBMoveObjectSync
	ENDIF


; *  PBMoveObjectAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBMoveObjectAsync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBMoveObjectAsync
			moveq           	#115,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBMoveObjectAsync
	ENDIF



;    ExchangeObjects
;    swap the contents of two files.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             The first file 
;    ->  parentRef       The second file 



; *  FSExchangeObjects()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSExchangeObjects(const FSRef *ref, const FSRef *destRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSExchangeObjects
			move.w              #$0421,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSExchangeObjects
	ENDIF


; *  PBExchangeObjectsSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBExchangeObjectsSync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBExchangeObjectsSync
			moveq           	#117,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBExchangeObjectsSync
	ENDIF


; *  PBExchangeObjectsAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBExchangeObjectsAsync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBExchangeObjectsAsync
			moveq           	#117,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBExchangeObjectsAsync
	ENDIF



;    RenameUnicode
;    Change the name of an existing file or directory.  The new name is in
;    Unicode.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             The file or directory to be moved
;    ->  nameLength      Number of Unicode characters in the new name
;    ->  name            A pointer to the new Unicode name
;    ->  textEncodingHint A suggested text encoding to use for the name
;    <-  newRef          A new FSRef for the file or directory; may be NULL
;    NOTE: Renaming an object may change its FSRef.  If you want to continue to
;    refer to the object, you should pass a non-NULL pointer in newRef and use
;    that returned FSRef to access the object after the rename.  The FSRef passed
;    in "ref" may or may not be usable to access the object after it is renamed.
;    "newRef" may point to the same storage as "ref".



; *  FSRenameUnicode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSRenameUnicode(const FSRef *ref, UniCharCount nameLength, const UniChar *name, TextEncoding textEncodingHint, FSRef *newRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSRenameUnicode
			move.w              #$0A20,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSRenameUnicode
	ENDIF


; *  PBRenameUnicodeSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBRenameUnicodeSync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBRenameUnicodeSync
			moveq           	#116,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBRenameUnicodeSync
	ENDIF


; *  PBRenameUnicodeAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBRenameUnicodeAsync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBRenameUnicodeAsync
			moveq           	#116,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBRenameUnicodeAsync
	ENDIF



;    GetCatalogInfo
;    Returns various information about a given file or directory.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             The file or directory whose information is to be returned
;    ->  whichInfo       Which catalog info fields to get
;    <-  catInfo         The returned values of catalog info fields; may be NULL
;    <-  spec            A pointer to the FSSpec for the object; may be NULL
;    <-  parentRef       A pointer to the FSRef for the object's parent directory; may be NULL
;    <-  outName         The Unicode name is returned here.  This pointer may be NULL.
;    Note: All of the outputs are optional; if you don't want that particular output, just
;    set its pointer to NULL.  This is the call to use to map from an FSRef to an FSSpec.



; *  FSGetCatalogInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSGetCatalogInfo(const FSRef *ref, FSCatalogInfoBitmap whichInfo, FSCatalogInfo *catalogInfo, HFSUniStr255 *outName, FSSpec *fsSpec, FSRef *parentRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSGetCatalogInfo
			move.w              #$0C22,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSGetCatalogInfo
	ENDIF


; *  PBGetCatalogInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetCatalogInfoSync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetCatalogInfoSync
			moveq           	#118,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetCatalogInfoSync
	ENDIF


; *  PBGetCatalogInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBGetCatalogInfoAsync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBGetCatalogInfoAsync
			moveq           	#118,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetCatalogInfoAsync
	ENDIF



;    SetCatalogInfo
;    Set catalog information about a given file or directory.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             The file or directory whose information is to be changed
;    ->  whichInfo       Which catalog info fields to set
;    ->  catInfo         The new values of catalog info fields
;    Note: Only some of the catalog info fields may be set.  The settable fields
;    are given by the constant kFSCatInfoSettableInfo; no other bits may be set in
;    whichInfo.



; *  FSSetCatalogInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSSetCatalogInfo(const FSRef *ref, FSCatalogInfoBitmap whichInfo, const FSCatalogInfo *catalogInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSSetCatalogInfo
			move.w              #$0623,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSSetCatalogInfo
	ENDIF


; *  PBSetCatalogInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetCatalogInfoSync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetCatalogInfoSync
			moveq           	#119,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetCatalogInfoSync
	ENDIF


; *  PBSetCatalogInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBSetCatalogInfoAsync(FSRefParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBSetCatalogInfoAsync
			moveq           	#119,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetCatalogInfoAsync
	ENDIF



;    OpenIterator
;    Creates an FSIterator to iterate over a directory or subtree.  The
;    iterator can then be passed to GetCatalogInfoBulk or CatalogSearch.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    <-  iterator        The returned FSIterator
;    ->  iteratorFlags   Controls whether the iterator iterates over subtrees
;                        or just the immediate children of the container.
;    ->  container       An FSRef for the directory to iterate (or root of
;                        the subtree to iterate).



; *  FSOpenIterator()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSOpenIterator(const FSRef *container, FSIteratorFlags iteratorFlags, FSIterator *iterator)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSOpenIterator
			move.w              #$0624,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSOpenIterator
	ENDIF


; *  PBOpenIteratorSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBOpenIteratorSync(FSCatalogBulkParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBOpenIteratorSync
			moveq           	#120,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenIteratorSync
	ENDIF


; *  PBOpenIteratorAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBOpenIteratorAsync(FSCatalogBulkParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBOpenIteratorAsync
			moveq           	#120,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenIteratorAsync
	ENDIF



;    CloseIterator
;    Invalidates and disposes an FSIterator.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  iterator        The returned FSIterator



; *  FSCloseIterator()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSCloseIterator(FSIterator iterator)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSCloseIterator
			move.w              #$0225,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSCloseIterator
	ENDIF


; *  PBCloseIteratorSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCloseIteratorSync(FSCatalogBulkParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCloseIteratorSync
			moveq           	#91,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCloseIteratorSync
	ENDIF


; *  PBCloseIteratorAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBCloseIteratorAsync(FSCatalogBulkParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBCloseIteratorAsync
			moveq           	#91,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCloseIteratorAsync
	ENDIF



;    GetCatalogInfoBulk
;    Iterates over catalog objects and returns information about them.
;    For now, iterator must have been created with kFSIterateFlat option.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  iterator        The iterator
;    ->  maximumItems    The maximum number of items to return
;    <-  actualItems     The actual number of items returned
;    <-  containerChanged Set to true if the container's contents changed
;    ->  whichInfo       The catalog information fields to return for each item
;    <-  catalogInfo     An array of catalog information; one for each returned item
;    <-  refs            An array of FSRefs; one for each returned item
;    <-  specs           An array of FSSpecs; one for each returned item
;    <-  names           An array of filenames; one for each returned item
;    Note: The catalogInfo, refs, specs, names, and containerChanged are all optional outputs;
;    if you don't want that particular output, set its pointer to NULL.



; *  FSGetCatalogInfoBulk()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSGetCatalogInfoBulk(FSIterator iterator, ItemCount maximumObjects, ItemCount *actualObjects, Boolean *containerChanged, FSCatalogInfoBitmap whichInfo, FSCatalogInfo *catalogInfos, FSRef *refs, FSSpec *specs, HFSUniStr255 *names)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSGetCatalogInfoBulk
			move.w              #$1226,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSGetCatalogInfoBulk
	ENDIF


; *  PBGetCatalogInfoBulkSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetCatalogInfoBulkSync(FSCatalogBulkParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetCatalogInfoBulkSync
			moveq           	#92,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetCatalogInfoBulkSync
	ENDIF


; *  PBGetCatalogInfoBulkAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBGetCatalogInfoBulkAsync(FSCatalogBulkParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBGetCatalogInfoBulkAsync
			moveq           	#92,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetCatalogInfoBulkAsync
	ENDIF


;    CatalogSearch
;    Iterates over catalog objects, searching for objects that match given
;    search criteria.  Returns various information about matching objects.
;    For now, iterator must have been created with kFSIterateSubtree option
;    and the container must have been the root directory of a volume.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  iterator        The iterator
;    ->  maximumItems    The maximum number of items to return
;    <-  actualItems     The actual number of items returned
;    <-  containerChanged Set to true if the container's contents changed
;    ->  whichInfo       The catalog information fields to return for each item
;    <-  catalogInfo     An array of catalog information; one for each returned item
;    <-  refs            An array of FSRefs; one for each returned item
;    <-  specs           An array of FSSpecs; one for each returned item
;    <-  names           An array of filenames; one for each returned item
;    ->  searchParams    The criteria that controls the matching, including timeout, a bitmap
;                        controlling the fields to compare, and the (Unicode) name to compare.
;    Note: The catalogInfo, refs, specs, and names are all optional outputs; if you don't want
;    that particular output, set its pointer to NULL.



; *  FSCatalogSearch()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSCatalogSearch(FSIterator iterator, const FSSearchParams *searchCriteria, ItemCount maximumObjects, ItemCount *actualObjects, Boolean *containerChanged, FSCatalogInfoBitmap whichInfo, FSCatalogInfo *catalogInfos, FSRef *refs, FSSpec *specs, HFSUniStr255 *names)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSCatalogSearch
			move.w              #$1427,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSCatalogSearch
	ENDIF


; *  PBCatalogSearchSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCatalogSearchSync(FSCatalogBulkParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCatalogSearchSync
			moveq           	#93,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCatalogSearchSync
	ENDIF


; *  PBCatalogSearchAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBCatalogSearchAsync(FSCatalogBulkParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBCatalogSearchAsync
			moveq           	#93,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCatalogSearchAsync
	ENDIF



;    CreateFork
;    Create a named fork for a file or directory.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             The file or directory
;    ->  forkNameLength  The length of the fork name (in Unicode characters)
;    ->  forkName        The name of the fork to open (in Unicode)



; *  FSCreateFork()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSCreateFork(const FSRef *ref, UniCharCount forkNameLength, const UniChar *forkName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSCreateFork
			move.w              #$0636,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSCreateFork
	ENDIF


; *  PBCreateForkSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCreateForkSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCreateForkSync
			moveq           	#125,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateForkSync
	ENDIF


; *  PBCreateForkAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBCreateForkAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBCreateForkAsync
			moveq           	#125,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCreateForkAsync
	ENDIF



;    DeleteFork
;    Delete a named fork of a file or directory.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             The file or directory
;    ->  forkNameLength  The length of the fork name (in Unicode characters)
;    ->  forkName        The name of the fork to open (in Unicode)



; *  FSDeleteFork()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSDeleteFork(const FSRef *ref, UniCharCount forkNameLength, const UniChar *forkName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSDeleteFork
			move.w              #$0637,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSDeleteFork
	ENDIF


; *  PBDeleteForkSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBDeleteForkSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBDeleteForkSync
			moveq           	#126,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDeleteForkSync
	ENDIF


; *  PBDeleteForkAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBDeleteForkAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBDeleteForkAsync
			moveq           	#126,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBDeleteForkAsync
	ENDIF



;    IterateForks
;    Return the names and sizes of the forks of a file or directory.
;    One fork is returned per call.
;    ->  ioCompletion    A pointer to a completion routine.
;    <-  ioResult        The result code of the function.
;    ->  ref             The file or directory containing the forks.
;    <-  positionOffset  The length of the fork, in bytes.
;    <-  allocationAmount The space allocated to the fork (physical length).
;    <-  outForkName     The name of the fork in Unicode.
;    <>  forkIterator    Maintains state between calls for a given FSRef.
;                        Before the first call, set the initialize field to zero.



; *  FSIterateForks()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSIterateForks(const FSRef *ref, CatPositionRec *forkIterator, HFSUniStr255 *forkName, SInt64 *forkSize, UInt64 *forkPhysicalSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSIterateForks
			move.w              #$0A38,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSIterateForks
	ENDIF


; *  PBIterateForksSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBIterateForksSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBIterateForksSync
			moveq           	#127,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBIterateForksSync
	ENDIF


; *  PBIterateForksAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBIterateForksAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBIterateForksAsync
			moveq           	#127,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBIterateForksAsync
	ENDIF



;    OpenFork
;    Open a fork for reading and/or writing.  Allows the opened fork
;    to grow beyond 2GB in size.  All volumes should support data and
;    resource forks.  Other named forks may be supported by some
;    volumes.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ref             The file or directory containing the fork to open
;    ->  forkNameLength  The length of the fork name (in Unicode characters)
;    ->  forkName        The name of the fork to open (in Unicode)
;    ->  permissions     The access (read and/or write) you want
;    <-  forkRefNum      The reference number for accessing the open fork



; *  FSOpenFork()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSOpenFork(const FSRef *ref, UniCharCount forkNameLength, const UniChar *forkName, SInt8 permissions, SInt16 *forkRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSOpenFork
			move.w              #$0928,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSOpenFork
	ENDIF


; *  PBOpenForkSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBOpenForkSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBOpenForkSync
			moveq           	#121,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenForkSync
	ENDIF


; *  PBOpenForkAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBOpenForkAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBOpenForkAsync
			moveq           	#121,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBOpenForkAsync
	ENDIF



;    ReadFork
;    Read data from a fork opened via OpenFork.  The first byte to read is
;    indicated by a combination of positionMode and positionOffset.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  forkRefNum      The reference number of the fork to read from
;    <-  buffer          Pointer to buffer where data will be returned
;    ->  requestCount    The number of bytes to read
;    <-  actualCount     The number of bytes actually read
;    ->  positionMode    The base location for start of read
;    ->  positionOffset  The offset from base location for start of read



; *  FSReadFork()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSReadFork(SInt16 forkRefNum, UInt16 positionMode, SInt64 positionOffset, ByteCount requestCount, void *buffer, ByteCount *actualCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSReadFork
			move.w              #$0A29,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSReadFork
	ENDIF


; *  PBReadForkSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBReadForkSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBReadForkSync
			moveq           	#81,D0
			dc.w            	$A2A8
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBReadForkSync
	ENDIF


; *  PBReadForkAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBReadForkAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBReadForkAsync
			moveq           	#81,D0
			dc.w            	$A6A8
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBReadForkAsync
	ENDIF



;    WriteFork
;    Write data to a fork opened via OpenFork.  The first byte to write is
;    indicated by a combination of positionMode and positionOffset.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  forkRefNum      The reference number of the fork to write to
;    ->  buffer          Pointer to data to write
;    ->  requestCount    The number of bytes to write
;    <-  actualCount     The number of bytes actually written
;    ->  positionMode    The base location for start of write
;    ->  positionOffset  The offset from base location for start of write



; *  FSWriteFork()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSWriteFork(SInt16 forkRefNum, UInt16 positionMode, SInt64 positionOffset, ByteCount requestCount, const void *buffer, ByteCount *actualCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSWriteFork
			move.w              #$0A2A,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSWriteFork
	ENDIF


; *  PBWriteForkSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBWriteForkSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBWriteForkSync
			moveq           	#82,D0
			dc.w            	$A2A8
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBWriteForkSync
	ENDIF


; *  PBWriteForkAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBWriteForkAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBWriteForkAsync
			moveq           	#82,D0
			dc.w            	$A6A8
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBWriteForkAsync
	ENDIF



;    GetForkPosition
;    Get the current (default) position of a fork that was
;    opened via OpenFork.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  forkRefNum      The reference number of the fork
;    <-  positionOffset  The current position of the fork



; *  FSGetForkPosition()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSGetForkPosition(SInt16 forkRefNum, SInt64 *position)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSGetForkPosition
			move.w              #$032B,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSGetForkPosition
	ENDIF


; *  PBGetForkPositionSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetForkPositionSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetForkPositionSync
			moveq           	#83,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetForkPositionSync
	ENDIF


; *  PBGetForkPositionAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBGetForkPositionAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBGetForkPositionAsync
			moveq           	#83,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetForkPositionAsync
	ENDIF



;    SetForkPosition
;    Set the current (default) position of a fork that was
;    opened via OpenFork.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  forkRefNum      The reference number of the fork
;    ->  positionMode    The base location for the new position
;    ->  positionOffset  The offset of the new position from the base



; *  FSSetForkPosition()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSSetForkPosition(SInt16 forkRefNum, UInt16 positionMode, SInt64 positionOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSSetForkPosition
			move.w              #$042C,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSSetForkPosition
	ENDIF


; *  PBSetForkPositionSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetForkPositionSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetForkPositionSync
			moveq           	#84,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetForkPositionSync
	ENDIF


; *  PBSetForkPositionAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBSetForkPositionAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBSetForkPositionAsync
			moveq           	#84,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetForkPositionAsync
	ENDIF



;    GetForkSize
;    Get the current logical size (end-of-file) of an open fork.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  forkRefNum      The reference number of the fork
;    <-  positionOffset  The logical size of the fork, in bytes



; *  FSGetForkSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSGetForkSize(SInt16 forkRefNum, SInt64 *forkSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSGetForkSize
			move.w              #$032D,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSGetForkSize
	ENDIF


; *  PBGetForkSizeSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetForkSizeSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetForkSizeSync
			moveq           	#85,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetForkSizeSync
	ENDIF


; *  PBGetForkSizeAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBGetForkSizeAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBGetForkSizeAsync
			moveq           	#85,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetForkSizeAsync
	ENDIF



;    SetForkSize
;    Set the logical size (end-of-file) of an open fork.  This
;    may cause space to be allocated or deallocated.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  forkRefNum      The reference number of the fork
;    ->  positionMode    The base location for the new size
;    ->  positionOffset  The offset of the new size from the base



; *  FSSetForkSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSSetForkSize(SInt16 forkRefNum, UInt16 positionMode, SInt64 positionOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSSetForkSize
			move.w              #$042E,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSSetForkSize
	ENDIF


; *  PBSetForkSizeSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetForkSizeSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetForkSizeSync
			moveq           	#86,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetForkSizeSync
	ENDIF


; *  PBSetForkSizeAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBSetForkSizeAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBSetForkSizeAsync
			moveq           	#86,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetForkSizeAsync
	ENDIF



;    AllocateFork
;    Allocate space to an open fork.  Typically, the space to be
;    allocated is beyond the current size of the fork, to reserve
;    space so the file will be able to grow later.  Some volume
;    formats are unable to allocate space beyond the logical size
;    of the fork.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  forkRefNum      The reference number of the fork
;    ->  positionMode    The base location for start of allocation
;    ->  positionOffset  The offset of the start of allocation
;    ->  allocationFlags Zero or more of the following flags:
;        kFSAllocContiguousMask
;                Any newly allocated space must be one contiguous piece.
;        kFSAllocAllOrNothingMask
;                All of the request space must be available, or the call
;                will fail.  (If not set, the call may succeed even though
;                some of the requested space wasn't allocated.)
;        kFSAllocNoRoundUpMask
;                Do not allocate additional space.  (If not set, a volume
;                may allocate additional space in order to reduce fragmentation.)
;    <>  allocationAmount    The number of bytes to allocate
;                            On output, the number of bytes actually added



; *  FSAllocateFork()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSAllocateFork(SInt16 forkRefNum, FSAllocationFlags flags, UInt16 positionMode, SInt64 positionOffset, UInt64 requestCount, UInt64 *actualCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSAllocateFork
			move.w              #$092F,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSAllocateFork
	ENDIF


; *  PBAllocateForkSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBAllocateForkSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBAllocateForkSync
			moveq           	#87,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBAllocateForkSync
	ENDIF


; *  PBAllocateForkAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBAllocateForkAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBAllocateForkAsync
			moveq           	#87,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBAllocateForkAsync
	ENDIF



;    FlushFork
;    Flush a fork.  Any data written to this fork refnum is flushed to the device.
;    The volume's control structures are also flushed to the device.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  forkRefNum      The reference number of the fork to flush



; *  FSFlushFork()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSFlushFork(SInt16 forkRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSFlushFork
			move.w              #$0130,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSFlushFork
	ENDIF


; *  PBFlushForkSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBFlushForkSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBFlushForkSync
			moveq           	#88,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBFlushForkSync
	ENDIF


; *  PBFlushForkAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBFlushForkAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBFlushForkAsync
			moveq           	#88,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBFlushForkAsync
	ENDIF



;    CloseFork
;    Flush and close a fork.  Any data written to this fork refnum is flushed
;    to the device.  The volume's control structures are also flushed to the device.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  forkRefNum      The reference number of the fork to close



; *  FSCloseFork()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSCloseFork(SInt16 forkRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSCloseFork
			move.w              #$0131,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSCloseFork
	ENDIF


; *  PBCloseForkSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBCloseForkSync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBCloseForkSync
			moveq           	#89,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCloseForkSync
	ENDIF


; *  PBCloseForkAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBCloseForkAsync(FSForkIOParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBCloseForkAsync
			moveq           	#89,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBCloseForkAsync
	ENDIF



;    GetForkCBInfo
;    Return information about an open fork.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    <>  desiredRefNum   If non-zero on input, then get information for this refnum;
;                        unchanged on output.  If zero on input, iterate over all open
;                        forks (possibly limited to a single volume); on output, contains
;                        the fork's refnum.
;    ->  volumeRefNum    Used when desiredRefNum is zero on input.  Set to 0 to iterate over all
;                        volumes, or set to a FSVolumeRefNum to limit iteration to that volume.
;    <>  iterator        Used when desiredRefNum is zero on input.  Set to 0 before iterating.
;                        Pass the iterator returned by the previous call to continue iterating.
;    <-  actualRefNum    The refnum of the open fork.
;    <-  ref             The FSRef for the file or directory that contains the fork.
;    <-  forkInfo        Various information about the open fork.
;    <-  outForkName     The name of the fork
;    Note: the foundRefNum, ref, forkInfo, and fork name outputs are all optional; if you don't want
;    a particular output, then set its pointer to NULL.  If forkName is NULL, then forkNameLength
;    will be undefined.
;    Note: Returning the forkInfo generally does not require a disk access.  Returning the
;    ref or forkName may cause disk access for some volume formats.



; *  FSGetForkCBInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSGetForkCBInfo(SInt16 desiredRefNum, FSVolumeRefNum volume, SInt16 *iterator, SInt16 *actualRefNum, FSForkInfo *forkInfo, FSRef *ref, HFSUniStr255 *outForkName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSGetForkCBInfo
			move.w              #$0C32,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSGetForkCBInfo
	ENDIF


; *  PBGetForkCBInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetForkCBInfoSync(FSForkCBInfoParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetForkCBInfoSync
			moveq           	#90,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetForkCBInfoSync
	ENDIF


; *  PBGetForkCBInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBGetForkCBInfoAsync(FSForkCBInfoParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBGetForkCBInfoAsync
			moveq           	#90,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetForkCBInfoAsync
	ENDIF



;    GetVolumeInfo
;    Returns various information about a given volume, or indexing over all volumes.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    <>  ioVRefNum       On input, the volume reference number or drive number whose
;                        information is to be returned (if volumeIndex is 0); same
;                        as "volume" input to FSGetVolumeInfo.
;                        On output, the actual volume reference number; same as
;                        "actualVolume" output of FSGetVolumeInfo.
;    ->  volumeIndex     The index of the desired volume, or 0 to use ioVRefNum
;    ->  whichInfo       Which volInfo info fields to get
;    <-  volumeInfo      The returned values of Volume info fields; may be NULL
;    <-  name            The Unicode name is returned here.  This pointer may be NULL.
;    Note: All of the outputs are optional; if you don't want that particular output, just
;    set it's pointer to NULL.



; *  FSGetVolumeInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSGetVolumeInfo(FSVolumeRefNum volume, ItemCount volumeIndex, FSVolumeRefNum *actualVolume, FSVolumeInfoBitmap whichInfo, FSVolumeInfo *info, HFSUniStr255 *volumeName, FSRef *rootDirectory)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSGetVolumeInfo
			move.w              #$0D33,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSGetVolumeInfo
	ENDIF


; *  PBGetVolumeInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBGetVolumeInfoSync(FSVolumeInfoParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBGetVolumeInfoSync
			moveq           	#29,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVolumeInfoSync
	ENDIF


; *  PBGetVolumeInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBGetVolumeInfoAsync(FSVolumeInfoParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBGetVolumeInfoAsync
			moveq           	#29,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBGetVolumeInfoAsync
	ENDIF



;    SetVolumeInfo
;    Set information about a given volume.
;    ->  ioCompletion    A pointer to a completion routine
;    <-  ioResult        The result code of the function
;    ->  ioVRefNum       The volume whose information is to be changed
;    ->  whichInfo       Which catalog info fields to set
;    ->  volumeInfo      The new values of volume info fields
;    Note: Only some of the volume info fields may be set.  The settable fields
;    are given by the constant kFSVolInfoSettableInfo; no other bits may be set in
;    whichInfo.



; *  FSSetVolumeInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSSetVolumeInfo(FSVolumeRefNum volume, FSVolumeInfoBitmap whichInfo, const FSVolumeInfo *info)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSSetVolumeInfo
			move.w              #$0534,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSSetVolumeInfo
	ENDIF


; *  PBSetVolumeInfoSync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PBSetVolumeInfoSync(FSVolumeInfoParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_PBSetVolumeInfoSync
			moveq           	#30,D0
			dc.w            	$A260
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetVolumeInfoSync
	ENDIF


; *  PBSetVolumeInfoAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PBSetVolumeInfoAsync(FSVolumeInfoParam *paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		Macro
		_PBSetVolumeInfoAsync
			moveq           	#30,D0
			dc.w            	$A660
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PBSetVolumeInfoAsync
	ENDIF


;    FSGetDataForkName
;    Returns the constant for the name of the data fork (the empty string)



; *  FSGetDataForkName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSGetDataForkName(HFSUniStr255 *dataForkName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSGetDataForkName
			move.w              #$0218,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSGetDataForkName
	ENDIF


;    FSGetResourceForkName
;    Returns the constant for the name of the resource fork
;    (currently "RESOURCE_FORK").



; *  FSGetResourceForkName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FSGetResourceForkName(HFSUniStr255 *resourceForkName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FSGetResourceForkName
			move.w              #$0219,D0
			dc.w            	$AA52
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSGetResourceForkName
	ENDIF


; *  FSRefMakePath()
; *  
; *  Summary:
; *    converts an FSRef to a POSIX path
; *  
; *  Parameters:
; *    
; *    ref:
; *      the file/dir to get the POSIX path for
; *    
; *    path:
; *      a pointer to a buffer which FSRefMakePath will fill with a UTF8
; *      encoded C string representing the path the the specified FSRef
; *    
; *    maxPathSize:
; *      the maximum size path length in bytes that path can hold
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSStatus FSRefMakePath(const FSRef *ref, UInt8 *path, UInt32 maxPathSize)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSRefMakePath
	ENDIF


; *  FSPathMakeRef()
; *  
; *  Summary:
; *    converts a POSIX path to an FSRef
; *  
; *  Parameters:
; *    
; *    path:
; *      a pointer to a UTF8 encoded C String that is a POSIX path
; *    
; *    ref:
; *      a pointer to an FSRef to fill in
; *    
; *    isDirectory:
; *      an optional pointer to a Boolean that will be filled in with
; *      whether the specified path is a directory (vs. a file)
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSStatus FSPathMakeRef(const UInt8 *path, FSRef *ref, Boolean *isDirectory)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FSPathMakeRef
	ENDIF




; *  FNMessage
; *  
; *  Discussion:
; *    Messages broadcast about a directory.  If system clients (such as
; *    the Finder) are interested in changes to a directory, they will
; *    receive notifications when application code broadcasts change
; *    messages about that directory.
; 


; typedef UInt32						FNMessage
kFNDirectoryModifiedMessage		EQU		1

; *  FNNotify()
; *  
; *  Summary:
; *    Broadcasts notification of changes to the specified directory.
; *  
; *  Parameters:
; *    
; *    ref:
; *      The directory for which to broadcast the notification
; *    
; *    message:
; *      An indication of what happened to the target directory
; *    
; *    flags:
; *      Options about delivery of the notification (specify kNilOptions
; *      for default behaviour)
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus FNNotify(const FSRef *ref, FNMessage message, OptionBits flags)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FNNotify
	ENDIF


; *  FNNotifyByPath()
; *  
; *  Summary:
; *    Broadcasts notification of changes to the specified directory.
; *  
; *  Parameters:
; *    
; *    path:
; *      Path to the directory for which to broadcast the notification
; *    
; *    message:
; *      An indication of what happened to the target directory
; *    
; *    flags:
; *      Options about delivery of the notification (specify kNilOptions
; *      for default behaviour)
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus FNNotifyByPath(const UInt8 *path, FNMessage message, OptionBits flags)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FNNotifyByPath
	ENDIF


; *  FNNotifyAll()
; *  
; *  Discussion:
; *    Broadcasts notification of changes to the filesystem (should only
; *    be used by installers or programs which make lots of changes and
; *    only send one broadcast).
; *  
; *  Parameters:
; *    
; *    message:
; *      An indication of what happened
; *    
; *    flags:
; *      Options about delivery of the notification (specify kNilOptions
; *      for default behaviour)
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus FNNotifyAll(FNMessage message, OptionBits flags)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FNNotifyAll
	ENDIF


	ENDIF ; __FILES__ 


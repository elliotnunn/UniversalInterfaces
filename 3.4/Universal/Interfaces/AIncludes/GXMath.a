;
;    File:       GXMath.a
;
;    Contains:   QuickDraw GX math routine interfaces.
;
;    Version:    Technology: Quickdraw GX 1.1
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1994-2001 by Apple Computer, Inc., all rights reserved.
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__GXMATH__') = 'UNDEFINED' THEN
__GXMATH__ SET 1

	IF &TYPE('__CONDITIONALMACROS__') = 'UNDEFINED' THEN
	include 'ConditionalMacros.a'
	ENDIF
	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__FIXMATH__') = 'UNDEFINED' THEN
	include 'FixMath.a'
	ENDIF


gxPoint					RECORD 0
x						 ds.l	1				; offset: $0 (0)
y						 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef unsigned short 				gxColorValue

gxPolar					RECORD 0
radius					 ds.l	1				; offset: $0 (0)
angle					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
gxMapping				RECORD 0
map						 ds.l	3 * 3			; offset: $0 (0)
sizeof					 EQU *					; size:   $24 (36)
						ENDR

gxColorValue1					EQU		$0000FFFF			; gxColorValue 1.0 

gxPositiveInfinity				EQU		$7FFFFFFF			; for Fixed and Fract 
gxNegativeInfinity				EQU		$80000000			; for Fixed and Fract 

	IF CALL_NOT_IN_CARBON THEN

; *  CopyToMapping()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern gxMapping *CopyToMapping(gxMapping *target, const gxMapping *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_CopyToMapping
			move.w              #$0031,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyToMapping
	ENDIF


; *  InvertMapping()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern gxMapping *InvertMapping(gxMapping *target, const gxMapping *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InvertMapping
			move.w              #$0032,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InvertMapping
	ENDIF


; *  MapMapping()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern gxMapping *MapMapping(gxMapping *target, const gxMapping *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MapMapping
			move.w              #$0033,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MapMapping
	ENDIF


; *  MoveMapping()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern gxMapping *MoveMapping(gxMapping *target, Fixed hOffset, Fixed vOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MoveMapping
			move.w              #$0034,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MoveMapping
	ENDIF


; *  MoveMappingTo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern gxMapping *MoveMappingTo(gxMapping *target, Fixed hPosition, Fixed vPosition)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MoveMappingTo
			move.w              #$0035,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MoveMappingTo
	ENDIF


; *  NormalizeMapping()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern gxMapping *NormalizeMapping(gxMapping *target)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_NormalizeMapping
			move.w              #$0036,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NormalizeMapping
	ENDIF


; *  RotateMapping()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern gxMapping *RotateMapping(gxMapping *target, Fixed angle, Fixed xCenter, Fixed yCenter)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RotateMapping
			move.w              #$0037,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RotateMapping
	ENDIF


; *  ScaleMapping()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern gxMapping *ScaleMapping(gxMapping *target, Fixed hFactor, Fixed vFactor, Fixed xCenter, Fixed yCenter)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ScaleMapping
			move.w              #$0038,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ScaleMapping
	ENDIF


; *  ResetMapping()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern gxMapping *ResetMapping(gxMapping *target)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ResetMapping
			move.w              #$0039,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ResetMapping
	ENDIF


; *  SkewMapping()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern gxMapping *SkewMapping(gxMapping *target, Fixed skewX, Fixed skewY, Fixed xCenter, Fixed yCenter)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SkewMapping
			move.w              #$003A,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SkewMapping
	ENDIF


; *  MapPoints()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void MapPoints(const gxMapping *source, long count, gxPoint theVector[])
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MapPoints
			move.w              #$003B,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MapPoints
	ENDIF


; *  FirstBit()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern short FirstBit(unsigned long x)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FirstBit
			move.w              #$003C,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FirstBit
	ENDIF


; *  WideScale()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern short WideScale(const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideScale
			move.w              #$003D,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideScale
	ENDIF


; *  LinearRoot()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern short LinearRoot(Fixed first, Fixed last, Fract t[])
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LinearRoot
			move.w              #$003E,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LinearRoot
	ENDIF


; *  QuadraticRoot()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern short QuadraticRoot(Fixed first, Fixed control, Fixed last, Fract t[])
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QuadraticRoot
			move.w              #$003F,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QuadraticRoot
	ENDIF


; *  PolarToPoint()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern gxPoint *PolarToPoint(const gxPolar *ra, gxPoint *xy)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PolarToPoint
			move.w              #$0040,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PolarToPoint
	ENDIF


; *  PointToPolar()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern gxPolar *PointToPolar(const gxPoint *xy, gxPolar *ra)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PointToPolar
			move.w              #$0041,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PointToPolar
	ENDIF


; *  FractCubeRoot()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Fract FractCubeRoot(Fract source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FractCubeRoot
			move.w              #$0042,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FractCubeRoot
	ENDIF


; *  FractDivide()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Fract FractDivide(Fract dividend, Fract divisor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FractDivide
			move.w              #$0043,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FractDivide
	ENDIF


; *  FractMultiply()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Fract FractMultiply(Fract multiplicand, Fract multiplier)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FractMultiply
			move.w              #$0044,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FractMultiply
	ENDIF


; *  FractSineCosine()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Fract FractSineCosine(Fixed degrees, Fract *cosine)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FractSineCosine
			move.w              #$0045,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FractSineCosine
	ENDIF


; *  FractSquareRoot()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Fract FractSquareRoot(Fract source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FractSquareRoot
			move.w              #$0046,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FractSquareRoot
	ENDIF


; *  FixedDivide()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Fixed FixedDivide(Fixed dividend, Fixed divisor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FixedDivide
			move.w              #$0047,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FixedDivide
	ENDIF


; *  FixedMultiply()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Fixed FixedMultiply(Fixed multiplicand, Fixed multiplier)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_FixedMultiply
			move.w              #$0048,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FixedMultiply
	ENDIF

;  This next call is (source * multiplier / divisor) -- it avoids underflow, overflow by using wides 

; *  MultiplyDivide()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern long MultiplyDivide(long source, long multiplier, long divisor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MultiplyDivide
			move.w              #$0049,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MultiplyDivide
	ENDIF


; *  Magnitude()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern unsigned long Magnitude(long deltaX, long deltaY)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_Magnitude
			move.w              #$004A,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Magnitude
	ENDIF


; *  VectorMultiplyDivide()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern long VectorMultiplyDivide(long count, const long *vector1, long step1, const long *vector2, long step2, long divisor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VectorMultiplyDivide
			move.w              #$004B,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VectorMultiplyDivide
	ENDIF




;  wide operations are defined within FixMath.h for PowerPC 
	ENDIF	; CALL_NOT_IN_CARBON
	IF TARGET_OS_MAC ** TARGET_CPU_68K THEN
	IF CALL_NOT_IN_CARBON THEN

; *  WideAdd()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern wide *WideAdd(wide *target, const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideAdd
			move.w              #$004C,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideAdd
	ENDIF


; *  WideCompare()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern short WideCompare(const wide *target, const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideCompare
			move.w              #$004D,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideCompare
	ENDIF


; *  WideNegate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern wide *WideNegate(wide *target)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideNegate
			move.w              #$004E,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideNegate
	ENDIF


; *  WideShift()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern wide *WideShift(wide *target, long shift)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideShift
			move.w              #$004F,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideShift
	ENDIF


; *  WideSquareRoot()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern unsigned long WideSquareRoot(const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideSquareRoot
			move.w              #$0050,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideSquareRoot
	ENDIF


; *  WideSubtract()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern wide *WideSubtract(wide *target, const wide *source)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideSubtract
			move.w              #$0051,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideSubtract
	ENDIF


; *  WideMultiply()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern wide *WideMultiply(long multiplicand, long multiplier, wide *target)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideMultiply
			move.w              #$0052,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideMultiply
	ENDIF

;  returns the quotient 

; *  WideDivide()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern long WideDivide(const wide *dividend, long divisor, long *remainder)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideDivide
			move.w              #$0053,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideDivide
	ENDIF

;  quotient replaces dividend 

; *  WideWideDivide()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern wide *WideWideDivide(wide *dividend, long divisor, long *remainder)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WideWideDivide
			move.w              #$0055,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WideWideDivide
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF


	IF CALL_NOT_IN_CARBON THEN

; *  VectorMultiply()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern wide *VectorMultiply(long count, const long *vector1, long step1, const long *vector2, long step2, wide *dot)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VectorMultiply
			move.w              #$0054,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VectorMultiply
	ENDIF


; *  RandomBits()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern unsigned long RandomBits(long count, long focus)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RandomBits
			move.w              #$0056,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RandomBits
	ENDIF


; *  SetRandomSeed()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void SetRandomSeed(const wide *seed)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetRandomSeed
			move.w              #$0057,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetRandomSeed
	ENDIF


; *  GetRandomSeed()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern wide *GetRandomSeed(wide *seed)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetRandomSeed
			move.w              #$0058,D0
			dc.w            	$A832
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetRandomSeed
	ENDIF


	ENDIF	; CALL_NOT_IN_CARBON


	ENDIF ; __GXMATH__ 


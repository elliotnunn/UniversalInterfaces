;
;    File:       GXTypes.a
;
;    Contains:   QuickDraw GX object and constant definitions
;
;    Version:    Technology: Quickdraw GX 1.1
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  Â© 1994-2001 by Apple Computer, Inc., all rights reserved.
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__GXTYPES__') = 'UNDEFINED' THEN
__GXTYPES__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF
	IF &TYPE('__FIXMATH__') = 'UNDEFINED' THEN
	include 'FixMath.a'
	ENDIF
	IF &TYPE('__GXMATH__') = 'UNDEFINED' THEN
	include 'GXMath.a'
	ENDIF


























; typedef long 							gxColorSpace

;  gxShape enumerations 

gxEmptyType						EQU		1
gxPointType						EQU		2
gxLineType						EQU		3
gxCurveType						EQU		4
gxRectangleType					EQU		5
gxPolygonType					EQU		6
gxPathType						EQU		7
gxBitmapType					EQU		8
gxTextType						EQU		9
gxGlyphType						EQU		10
gxLayoutType					EQU		11
gxFullType						EQU		12
gxPictureType					EQU		13
; typedef long 							gxShapeType


gxNoFill						EQU		0
gxOpenFrameFill					EQU		1
gxFrameFill						EQU		1
gxClosedFrameFill				EQU		2
gxHollowFill					EQU		2
gxEvenOddFill					EQU		3
gxSolidFill						EQU		3
gxWindingFill					EQU		4
gxInverseEvenOddFill			EQU		5
gxInverseSolidFill				EQU		5
gxInverseFill					EQU		5
gxInverseWindingFill			EQU		6
; typedef long 							gxShapeFill


gxNoAttributes					EQU		0
gxDirectShape					EQU		$0001
gxRemoteShape					EQU		$0002
gxCachedShape					EQU		$0004
gxLockedShape					EQU		$0008
gxGroupShape					EQU		$0010
gxMapTransformShape				EQU		$0020
gxUniqueItemsShape				EQU		$0040
gxIgnorePlatformShape			EQU		$0080
gxNoMetricsGridShape			EQU		$0100
gxDiskShape						EQU		$0200
gxMemoryShape					EQU		$0400
; typedef long 							gxShapeAttribute

;  gxShape editing enumerations 

gxBreakNeitherEdit				EQU		0
gxBreakLeftEdit					EQU		$0001
gxBreakRightEdit				EQU		$0002
gxRemoveDuplicatePointsEdit		EQU		$0004
;  if the new first (or last) point exactly matches the point before it in 
;  the same contour, then remove it) 
; typedef long 							gxEditShapeFlag


gxSelectToEnd					EQU		-1

gxAnyNumber						EQU		1
gxSetToNil						EQU		-1

gxCounterclockwiseDirection		EQU		0
gxClockwiseDirection			EQU		1
; typedef long 							gxContourDirection

;  gxShape structures 
;  The type 'gxPoint' is defined in "GXMath.h" 
gxLine					RECORD 0
first					 ds		gxPoint			; offset: $0 (0)
last					 ds		gxPoint			; offset: $8 (8)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
gxCurve					RECORD 0
first					 ds		gxPoint			; offset: $0 (0)
control					 ds		gxPoint			; offset: $8 (8)
last					 ds		gxPoint			; offset: $10 (16)
sizeof					 EQU *					; size:   $18 (24)
						ENDR
gxRectangle				RECORD 0
left					 ds.l	1				; offset: $0 (0)
top						 ds.l	1				; offset: $4 (4)
right					 ds.l	1				; offset: $8 (8)
bottom					 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
gxPolygon				RECORD 0
vectors					 ds.l	1				; offset: $0 (0)
vector					 ds		gxPoint			; offset: $4 (4) <-- really an array of length one
sizeof					 EQU *					; size:   $C (12)
						ENDR
gxPolygons				RECORD 0
contours				 ds.l	1				; offset: $0 (0)
contour					 ds		gxPolygon		; offset: $4 (4) <-- really an array of length one
sizeof					 EQU *					; size:   $10 (16)
						ENDR
gxPath					RECORD 0
vectors					 ds.l	1				; offset: $0 (0)
controlBits				 ds.l	1				; offset: $4 (4) <-- really an array of length one
vector					 ds		gxPoint			; offset: $8 (8) <-- really an array of length one
sizeof					 EQU *					; size:   $10 (16)
						ENDR
gxPaths					RECORD 0
contours				 ds.l	1				; offset: $0 (0)
contour					 ds		gxPath			; offset: $4 (4) <-- really an array of length one
sizeof					 EQU *					; size:   $14 (20)
						ENDR
gxBitmap				RECORD 0
image					 ds.l	1				; offset: $0 (0)		;  pointer to pixels 
width					 ds.l	1				; offset: $4 (4)		;  width in pixels 
height					 ds.l	1				; offset: $8 (8)		;  height in pixels 
rowBytes				 ds.l	1				; offset: $C (12)		;  width in bytes 
pixelSize				 ds.l	1				; offset: $10 (16)		;  physical bits per pixel 
space					 ds.l	1				; offset: $14 (20)
colorSet				 ds.l	1				; offset: $18 (24)
profile					 ds.l	1				; offset: $1C (28)
sizeof					 EQU *					; size:   $20 (32)
						ENDR
gxLongRectangle			RECORD 0
left					 ds.l	1				; offset: $0 (0)
top						 ds.l	1				; offset: $4 (4)
right					 ds.l	1				; offset: $8 (8)
bottom					 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
;  gxStyle enumerations 

gxCenterFrameStyle				EQU		0
gxSourceGridStyle				EQU		$0001
gxDeviceGridStyle				EQU		$0002
gxInsideFrameStyle				EQU		$0004
gxOutsideFrameStyle				EQU		$0008
gxAutoInsetStyle				EQU		$0010
; typedef long 							gxStyleAttribute


gxBendDash						EQU		$0001
gxBreakDash						EQU		$0002
gxClipDash						EQU		$0004
gxLevelDash						EQU		$0008
gxAutoAdvanceDash				EQU		$0010
; typedef long 							gxDashAttribute


gxPortAlignPattern				EQU		$0001
gxPortMapPattern				EQU		$0002
; typedef long 							gxPatternAttribute


gxSharpJoin						EQU		$0000
gxCurveJoin						EQU		$0001
gxLevelJoin						EQU		$0002
gxSnapJoin						EQU		$0004
; typedef long 							gxJoinAttribute


gxLevelStartCap					EQU		$0001
gxLevelEndCap					EQU		$0002
; typedef long 							gxCapAttribute


gxAutoAdvanceText				EQU		$0001
gxNoContourGridText				EQU		$0002
gxNoMetricsGridText				EQU		$0004
gxAnchorPointsText				EQU		$0008
gxVerticalText					EQU		$0010
gxNoOpticalScaleText			EQU		$0020
; typedef long 							gxTextAttribute


gxLeftJustify					EQU		0
gxCenterJustify					EQU		$20000000
gxRightJustify					EQU		$40000000
gxFillJustify					EQU		-1

gxUnderlineAdvanceLayer			EQU		$0001				; a gxLine is drawn through the advances 
gxSkipWhiteSpaceLayer			EQU		$0002				; except characters describing white space 
gxUnderlineIntervalLayer		EQU		$0004				; (+ gxStringLayer) a gxLine is drawn through the gaps between advances 
gxUnderlineContinuationLayer	EQU		$0008				; (+ gxStringLayer) join this underline with another face 
gxWhiteLayer					EQU		$0010				; the layer draws to white instead of black 
gxClipLayer						EQU		$0020				; the characters define a clip 
gxStringLayer					EQU		$0040				; all characters in run are combined 
; typedef long 							gxLayerFlag

;  gxStyle structures 
gxFaceLayer				RECORD 0
outlineFill				 ds.l	1				; offset: $0 (0)		;  outline framed or filled 
flags					 ds.l	1				; offset: $4 (4)		;  various additional effects 
outlineStyle			 ds.l	1				; offset: $8 (8)		;  outline 
outlineTransform		 ds.l	1				; offset: $C (12)		;  italic, condense, extend 
boldOutset				 ds		gxPoint			; offset: $10 (16)		;  bold 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
gxTextFace				RECORD 0
faceLayers				 ds.l	1				; offset: $0 (0)		;  layer to implement shadow 
advanceMapping			 ds		gxMapping		; offset: $4 (4)		;  algorithmic change to advance width 
faceLayer				 ds		gxFaceLayer		; offset: $28 (40) <-- really an array of length one ;  zero or more face layers describing the face 
sizeof					 EQU *					; size:   $40 (64)
						ENDR
gxJoinRecord			RECORD 0
attributes				 ds.l	1				; offset: $0 (0)
join					 ds.l	1				; offset: $4 (4)
miter					 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
gxDashRecord			RECORD 0
attributes				 ds.l	1				; offset: $0 (0)
dash					 ds.l	1				; offset: $4 (4)		;  similar to pattern, except rotated to gxLine slope 
advance					 ds.l	1				; offset: $8 (8)		;  specifies repeating frequency of dash 
phase					 ds.l	1				; offset: $C (12)		;  specifies offset into the gxPath to start dashing 
scale					 ds.l	1				; offset: $10 (16)		;  specifies height of dash to be mapped to penWidth 
sizeof					 EQU *					; size:   $14 (20)
						ENDR
gxPatternRecord			RECORD 0
attributes				 ds.l	1				; offset: $0 (0)
pattern					 ds.l	1				; offset: $4 (4)
u						 ds		gxPoint			; offset: $8 (8)
v						 ds		gxPoint			; offset: $10 (16)
sizeof					 EQU *					; size:   $18 (24)
						ENDR
gxCapRecord				RECORD 0
attributes				 ds.l	1				; offset: $0 (0)
startCap				 ds.l	1				; offset: $4 (4)
endCap					 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR

;  gxInk enumerations 

gxPortAlignDitherInk			EQU		$0001
gxForceDitherInk				EQU		$0002
gxSuppressDitherInk				EQU		$0004
gxSuppressHalftoneInk			EQU		$0008
; typedef long 							gxInkAttribute


gxNoMode						EQU		0
gxCopyMode						EQU		1
gxAddMode						EQU		2
gxBlendMode						EQU		3
gxMigrateMode					EQU		4
gxMinimumMode					EQU		5
gxMaximumMode					EQU		6
gxHighlightMode					EQU		7
gxAndMode						EQU		8
gxOrMode						EQU		9
gxXorMode						EQU		10
gxRampAndMode					EQU		11
gxRampOrMode					EQU		12
gxRampXorMode					EQU		13
gxOverMode						EQU		14					; Alpha channel modes          
gxAtopMode						EQU		15					; Note: In England = Beta channel modes   
gxExcludeMode					EQU		16
gxFadeMode						EQU		17
; typedef unsigned char 				gxComponentMode


gxRejectSourceTransfer			EQU		$0001				; at least one component must be out of range       
gxRejectDeviceTransfer			EQU		$0002				; at least one component must be out of range       
gxSingleComponentTransfer		EQU		$0004				; duplicate gxTransferComponent[0] for all components in transfer 
; typedef long 							gxTransferFlag


gxOverResultComponent			EQU		$01					; & result gxColor with 0xFFFF before clamping   
gxReverseComponent				EQU		$02					; reverse source and device before moding       
; typedef unsigned char 				gxComponentFlag

;  gxInk structures 
gxTransferComponent		RECORD 0
mode					 ds.b	1				; offset: $0 (0)		;  how the component is operated upon 
flags					 ds.b	1				; offset: $1 (1)		;  flags for each component   
sourceMinimum			 ds.w	1				; offset: $2 (2)
sourceMaximum			 ds.w	1				; offset: $4 (4)		;  input filter range 
deviceMinimum			 ds.w	1				; offset: $6 (6)
deviceMaximum			 ds.w	1				; offset: $8 (8)		;  output filter range 
clampMinimum			 ds.w	1				; offset: $A (10)
clampMaximum			 ds.w	1				; offset: $C (12)		;  output clamping range 
operand					 ds.w	1				; offset: $E (14)		;  ratio for blend, step for migrate, gxColor for highlight   
sizeof					 EQU *					; size:   $10 (16)
						ENDR
gxTransferMode			RECORD 0
space					 ds.l	1				; offset: $0 (0)		;  the gxColor-space the transfer mode is to operate in   
colorSet				 ds.l	1				; offset: $4 (4)
profile					 ds.l	1				; offset: $8 (8)
sourceMatrix			 ds.l	5 * 4			; offset: $C (12)
deviceMatrix			 ds.l	5 * 4			; offset: $5C (92)
resultMatrix			 ds.l	5 * 4			; offset: $AC (172)
flags					 ds.l	1				; offset: $FC (252)
component				 ds.b	4 * gxTransferComponent.sizeof ; offset: $100 (256) ;  how each component is operated upon         
sizeof					 EQU *					; size:   $140 (320)
						ENDR

;  gxColor space enumerations 

gxNoColorPacking				EQU		$0000				; 16 bits per channel 
gxAlphaSpace					EQU		$0080				; space includes alpha channel 
gxWord5ColorPacking				EQU		$0500				; 5 bits per channel, right-justified 
gxLong8ColorPacking				EQU		$0800				; 8 bits per channel, right-justified 
gxLong10ColorPacking			EQU		$0A00				; 10 bits per channel, right-justified 
gxAlphaFirstPacking				EQU		$1000				; alpha channel is the first field in the packed space 

gxNoSpace						EQU		0
gxRGBSpace						EQU		1
gxCMYKSpace						EQU		2
gxHSVSpace						EQU		3
gxHLSSpace						EQU		4
gxYXYSpace						EQU		5
gxXYZSpace						EQU		6
gxLUVSpace						EQU		7
gxLABSpace						EQU		8
gxYIQSpace						EQU		9
gxNTSCSpace						EQU		9
gxPALSpace						EQU		9
gxGraySpace						EQU		10
gxIndexedSpace					EQU		11
gxRGBASpace						EQU		129
gxGrayASpace					EQU		138
gxRGB16Space					EQU		$0501
gxRGB32Space					EQU		$0801
gxARGB32Space					EQU		$1881
gxCMYK32Space					EQU		$0802
gxHSV32Space					EQU		$0A03
gxHLS32Space					EQU		$0A04
gxYXY32Space					EQU		$0A05
gxXYZ32Space					EQU		$0A06
gxLUV32Space					EQU		$0A07
gxLAB32Space					EQU		$0A08
gxYIQ32Space					EQU		$0A09
gxNTSC32Space					EQU		$0A09
gxPAL32Space					EQU		$0A09
;  gxColor space structures 
gxRGBColor				RECORD 0
red						 ds.w	1				; offset: $0 (0)
green					 ds.w	1				; offset: $2 (2)
blue					 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
gxRGBAColor				RECORD 0
red						 ds.w	1				; offset: $0 (0)
green					 ds.w	1				; offset: $2 (2)
blue					 ds.w	1				; offset: $4 (4)
alpha					 ds.w	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
gxHSVColor				RECORD 0
hue						 ds.w	1				; offset: $0 (0)
saturation				 ds.w	1				; offset: $2 (2)
value					 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
gxHLSColor				RECORD 0
hue						 ds.w	1				; offset: $0 (0)
lightness				 ds.w	1				; offset: $2 (2)
saturation				 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
gxCMYKColor				RECORD 0
cyan					 ds.w	1				; offset: $0 (0)
magenta					 ds.w	1				; offset: $2 (2)
yellow					 ds.w	1				; offset: $4 (4)
black					 ds.w	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
gxXYZColor				RECORD 0
x						 ds.w	1				; offset: $0 (0)
y						 ds.w	1				; offset: $2 (2)
z						 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
gxYXYColor				RECORD 0
capY					 ds.w	1				; offset: $0 (0)
x						 ds.w	1				; offset: $2 (2)
y						 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
gxLUVColor				RECORD 0
l						 ds.w	1				; offset: $0 (0)
u						 ds.w	1				; offset: $2 (2)
v						 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
gxLABColor				RECORD 0
l						 ds.w	1				; offset: $0 (0)
a						 ds.w	1				; offset: $2 (2)
b						 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
gxYIQColor				RECORD 0
y						 ds.w	1				; offset: $0 (0)
i						 ds.w	1				; offset: $2 (2)
q						 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
gxGrayAColor			RECORD 0
gray					 ds.w	1				; offset: $0 (0)
alpha					 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef long 							gxColorIndex

gxIndexedColor			RECORD 0
index					 ds.l	1				; offset: $0 (0)
colorSet				 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
gxColor					RECORD 0
space					 ds.l	1				; offset: $0 (0)
profile					 ds.l	1				; offset: $4 (4)
cmyk					 ds		gxCMYKColor		; offset: $8 (8)
						 ORG 8
rgb						 ds		gxRGBColor		; offset: $8 (8)
						 ORG 8
rgba					 ds		gxRGBAColor		; offset: $8 (8)
						 ORG 8
hsv						 ds		gxHSVColor		; offset: $8 (8)
						 ORG 8
hls						 ds		gxHLSColor		; offset: $8 (8)
						 ORG 8
xyz						 ds		gxXYZColor		; offset: $8 (8)
						 ORG 8
yxy						 ds		gxYXYColor		; offset: $8 (8)
						 ORG 8
luv						 ds		gxLUVColor		; offset: $8 (8)
						 ORG 8
lab						 ds		gxLABColor		; offset: $8 (8)
						 ORG 8
yiq						 ds		gxYIQColor		; offset: $8 (8)
						 ORG 8
gray					 ds.w	1				; offset: $8 (8)
						 ORG 8
graya					 ds		gxGrayAColor	; offset: $8 (8)
						 ORG 8
pixel16					 ds.w	1				; offset: $8 (8)
						 ORG 8
pixel32					 ds.l	1				; offset: $8 (8)
						 ORG 8
indexed					 ds		gxIndexedColor ; offset: $8 (8)
						 ORG 8
component				 ds.w	4				; offset: $8 (8)
sizeof					 EQU *					; size:   $10 (16)
						ENDR

;  gxColorSet structures 
gxSetColor				RECORD 0
cmyk					 ds		gxCMYKColor		; offset: $0 (0)
						 ORG 0
rgb						 ds		gxRGBColor		; offset: $0 (0)
						 ORG 0
rgba					 ds		gxRGBAColor		; offset: $0 (0)
						 ORG 0
hsv						 ds		gxHSVColor		; offset: $0 (0)
						 ORG 0
hls						 ds		gxHLSColor		; offset: $0 (0)
						 ORG 0
xyz						 ds		gxXYZColor		; offset: $0 (0)
						 ORG 0
yxy						 ds		gxYXYColor		; offset: $0 (0)
						 ORG 0
luv						 ds		gxLUVColor		; offset: $0 (0)
						 ORG 0
lab						 ds		gxLABColor		; offset: $0 (0)
						 ORG 0
yiq						 ds		gxYIQColor		; offset: $0 (0)
						 ORG 0
gray					 ds.w	1				; offset: $0 (0)
						 ORG 0
graya					 ds		gxGrayAColor	; offset: $0 (0)
						 ORG 0
pixel16					 ds.w	1				; offset: $0 (0)
						 ORG 0
pixel32					 ds.l	1				; offset: $0 (0)
						 ORG 0
component				 ds.w	4				; offset: $0 (0)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  gxTransform enumerations 
;  parts of a gxShape considered in hit testing: 

gxNoPart						EQU		0					; (in order of evaluation) 
gxBoundsPart					EQU		$0001
gxGeometryPart					EQU		$0002
gxPenPart						EQU		$0004
gxCornerPointPart				EQU		$0008
gxControlPointPart				EQU		$0010
gxEdgePart						EQU		$0020
gxJoinPart						EQU		$0040
gxStartCapPart					EQU		$0080
gxEndCapPart					EQU		$0100
gxDashPart						EQU		$0200
gxPatternPart					EQU		$0400
gxGlyphBoundsPart				EQU		$0040
gxGlyphFirstPart				EQU		$0080
gxGlyphLastPart					EQU		$0100
gxSideBearingPart				EQU		$0200
gxAnyPart						EQU		$07FF
; typedef long 							gxShapePart

;  gxTransform structures 
gxHitTestInfo			RECORD 0
what					 ds.l	1				; offset: $0 (0)		;  which part of gxShape 
index					 ds.l	1				; offset: $4 (4)		;  control gxPoint index 
distance				 ds.l	1				; offset: $8 (8)		;  how far from gxPoint or outside of area click was 
;  these fields are only set by GXHitTestPicture 
which					 ds.l	1				; offset: $C (12)
containerPicture		 ds.l	1				; offset: $10 (16)		;  picture which contains gxShape hit 
containerIndex			 ds.l	1				; offset: $14 (20)		;  the index within that picture  
totalIndex				 ds.l	1				; offset: $18 (24)		;  the total index within the root picture 
sizeof					 EQU *					; size:   $1C (28)
						ENDR
;  gxViewPort enumerations 

gxGrayPort						EQU		$0001
gxAlwaysGridPort				EQU		$0002
gxEnableMatchPort				EQU		$0004
; typedef long 							gxPortAttribute

;  gxViewDevice enumerations 

gxDirectDevice					EQU		$01					; for the device gxBitmap baseAddr pointer 
gxRemoteDevice					EQU		$02
gxInactiveDevice				EQU		$04
; typedef long 							gxDeviceAttribute


gxRoundDot						EQU		1
gxSpiralDot						EQU		2
gxSquareDot						EQU		3
gxLineDot						EQU		4
gxEllipticDot					EQU		5
gxTriangleDot					EQU		6
gxDispersedDot					EQU		7
gxCustomDot						EQU		8
; typedef long 							gxDotType

;  gxViewPort structures 

gxNoTint						EQU		0
gxLuminanceTint					EQU		1					; use the luminance of the gxColor 
gxAverageTint					EQU		2					; add all the components and divide by the number of components 
gxMixtureTint					EQU		3					; find the closest gxColor on the axis between the foreground and background 
gxComponent1Tint				EQU		4					; use the value of the first component of the gxColor 
gxComponent2Tint				EQU		5					; ... etc. 
gxComponent3Tint				EQU		6
gxComponent4Tint				EQU		7
; typedef long 							gxTintType

gxHalftone				RECORD 0
angle					 ds.l	1				; offset: $0 (0)
frequency				 ds.l	1				; offset: $4 (4)
method					 ds.l	1				; offset: $8 (8)
tinting					 ds.l	1				; offset: $C (12)
dotColor				 ds		gxColor			; offset: $10 (16)
backgroundColor			 ds		gxColor			; offset: $20 (32)
tintSpace				 ds.l	1				; offset: $30 (48)
sizeof					 EQU *					; size:   $34 (52)
						ENDR
gxHalftoneMatrix		RECORD 0
dpiX					 ds.l	1				; offset: $0 (0)		;  intended resolution 
dpiY					 ds.l	1				; offset: $4 (4)
width					 ds.l	1				; offset: $8 (8)		;  width of matrix (in device pixels) 
height					 ds.l	1				; offset: $C (12)		;  height of matrix (in device pixels) 
tileShift				 ds.l	1				; offset: $10 (16)		;  shift amount (in samples) for rectangular tiling 
samples					 ds.w	1				; offset: $14 (20) <-- really an array of length one ;  samples from 0..MAX(halftone tintSpace) 
sizeof					 EQU *					; size:   $16 (22)
						ENDR
;  gxViewGroup enumerations 

gxAllViewDevices				EQU		0
gxScreenViewDevices				EQU		1
;  graphics stream constants and structures 

gxOpenReadSpool					EQU		1
gxOpenWriteSpool				EQU		2
gxReadSpool						EQU		3
gxWriteSpool					EQU		4
gxCloseSpool					EQU		5
; typedef long 							gxSpoolCommand

; typedef unsigned char 				gxGraphicsOpcode



gxSpoolBlock			RECORD 0
spoolProcedure			 ds.l	1				; offset: $0 (0)		;  these fields are read only 
buffer					 ds.l	1				; offset: $4 (4)		;  source/destination pointer to data 
bufferSize				 ds.l	1				; offset: $8 (8)		;  how many bytes for the system to read (flatten) / write (unflatten) 
;  these fields are written to (but are not read from) 
count					 ds.l	1				; offset: $C (12)		;  how many bytes for the caller to read (unflatten) /write (flatten) 
operationSize			 ds.l	1				; offset: $10 (16)		;  operation size (including operand byte) 
operationOffset			 ds.l	1				; offset: $14 (20)		;  the data offset, if any, within the current operation 
lastTypeOpcode			 ds.b	1				; offset: $18 (24)		;  type of last created object 
currentOperation		 ds.b	1				; offset: $19 (25)		;  operation emitted by flatten, or intrepreted by last unflatten 
currentOperand			 ds.b	1				; offset: $1A (26)		;  e.g., gxTransformTypeOpcode, gxInkTagOpcode 
compressed				 ds.b	1				; offset: $1B (27)		;  one of: gxTwoBitCompressionValues 
sizeof					 EQU *					; size:   $1C (28)
						ENDR
	IF CALL_NOT_IN_CARBON THEN

; *  NewgxSpoolUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposegxSpoolUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokegxSpoolUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

	ENDIF	; CALL_NOT_IN_CARBON


gxFontListFlatten				EQU		$01					; if set, generate a gxTag containing list of each gxFont referenced 
gxFontGlyphsFlatten				EQU		$02					; if set, generate a gxTag containing the list of glyphs referenced inside the gxFont 
gxFontVariationsFlatten			EQU		$04					; if set, append the gxTag with separate [variation] coordinates 
gxBitmapAliasFlatten			EQU		$08					; if set, open bitmap alias files and flatten out their image data 

; typedef long 							gxFlattenFlag

;  gxGraphicsClient constants 

gxGraphicsSystemClient			EQU		-1

gxStaticHeapClient				EQU		$0001
; typedef long 							gxClientAttribute

;  graphics patching constants 

gxOriginalGraphicsFunction		EQU		-1
gxOriginalGraphicsIdentifier	EQU		'grfx'
gxBitmapDataSourceAlias	RECORD 0
fileOffset				 ds.l	1				; offset: $0 (0)		;  file offset (in bytes) of top-left pixel 
aliasRecordSize			 ds.l	1				; offset: $4 (4)		;  size of alias record below 
aliasRecord				 ds.b	1				; offset: $8 (8) <-- really an array of length one ;  the actual alias record data 
						 ORG 10
sizeof					 EQU *					; size:   $A (10)
						ENDR

gxBitmapFileAliasTagType		EQU		'bfil'
gxPICTFileAliasTagType			EQU		'pict'
gxBitmapFileAliasImageValue		EQU		1



gxNoPlatform					EQU		0
gxNoScript						EQU		0
gxNoLanguage					EQU		0
gxNoFontName					EQU		0
gxGlyphPlatform					EQU		-1

gxUnicodePlatform				EQU		1
gxMacintoshPlatform				EQU		2
gxReservedPlatform				EQU		3
gxMicrosoftPlatform				EQU		4
gxCustomPlatform				EQU		5
; typedef long 							gxFontPlatform


gxUnicodeDefaultSemantics		EQU		1
gxUnicodeV1_1Semantics			EQU		2
gxISO10646_1993Semantics		EQU		3

gxRomanScript					EQU		1
gxJapaneseScript				EQU		2
gxTraditionalChineseScript		EQU		3
gxChineseScript					EQU		3
gxKoreanScript					EQU		4
gxArabicScript					EQU		5
gxHebrewScript					EQU		6
gxGreekScript					EQU		7
gxCyrillicScript				EQU		8
gxRussian						EQU		8
gxRSymbolScript					EQU		9
gxDevanagariScript				EQU		10
gxGurmukhiScript				EQU		11
gxGujaratiScript				EQU		12
gxOriyaScript					EQU		13
gxBengaliScript					EQU		14
gxTamilScript					EQU		15
gxTeluguScript					EQU		16
gxKannadaScript					EQU		17
gxMalayalamScript				EQU		18
gxSinhaleseScript				EQU		19
gxBurmeseScript					EQU		20
gxKhmerScript					EQU		21
gxThaiScript					EQU		22
gxLaotianScript					EQU		23
gxGeorgianScript				EQU		24
gxArmenianScript				EQU		25
gxSimpleChineseScript			EQU		26
gxTibetanScript					EQU		27
gxMongolianScript				EQU		28
gxGeezScript					EQU		29
gxEthiopicScript				EQU		29
gxAmharicScript					EQU		29
gxSlavicScript					EQU		30
gxEastEuropeanRomanScript		EQU		30
gxVietnameseScript				EQU		31
gxExtendedArabicScript			EQU		32
gxSindhiScript					EQU		32
gxUninterpretedScript			EQU		33

gxMicrosoftSymbolScript			EQU		1
gxMicrosoftStandardScript		EQU		2

gxCustom8BitScript				EQU		1
gxCustom816BitScript			EQU		2
gxCustom16BitScript				EQU		3
; typedef long 							gxFontScript


gxEnglishLanguage				EQU		1
gxFrenchLanguage				EQU		2
gxGermanLanguage				EQU		3
gxItalianLanguage				EQU		4
gxDutchLanguage					EQU		5
gxSwedishLanguage				EQU		6
gxSpanishLanguage				EQU		7
gxDanishLanguage				EQU		8
gxPortugueseLanguage			EQU		9
gxNorwegianLanguage				EQU		10
gxHebrewLanguage				EQU		11
gxJapaneseLanguage				EQU		12
gxArabicLanguage				EQU		13
gxFinnishLanguage				EQU		14
gxGreekLanguage					EQU		15
gxIcelandicLanguage				EQU		16
gxMalteseLanguage				EQU		17
gxTurkishLanguage				EQU		18
gxCroatianLanguage				EQU		19
gxTradChineseLanguage			EQU		20
gxUrduLanguage					EQU		21
gxHindiLanguage					EQU		22
gxThaiLanguage					EQU		23
gxKoreanLanguage				EQU		24
gxLithuanianLanguage			EQU		25
gxPolishLanguage				EQU		26
gxHungarianLanguage				EQU		27
gxEstonianLanguage				EQU		28
gxLettishLanguage				EQU		29
gxLatvianLanguage				EQU		29
gxSaamiskLanguage				EQU		30
gxLappishLanguage				EQU		30
gxFaeroeseLanguage				EQU		31
gxFarsiLanguage					EQU		32
gxPersianLanguage				EQU		32
gxRussianLanguage				EQU		33
gxSimpChineseLanguage			EQU		34
gxFlemishLanguage				EQU		35
gxIrishLanguage					EQU		36
gxAlbanianLanguage				EQU		37
gxRomanianLanguage				EQU		38
gxCzechLanguage					EQU		39
gxSlovakLanguage				EQU		40
gxSlovenianLanguage				EQU		41
gxYiddishLanguage				EQU		42
gxSerbianLanguage				EQU		43
gxMacedonianLanguage			EQU		44
gxBulgarianLanguage				EQU		45
gxUkrainianLanguage				EQU		46
gxByelorussianLanguage			EQU		47
gxUzbekLanguage					EQU		48
gxKazakhLanguage				EQU		49
gxAzerbaijaniLanguage			EQU		50
gxAzerbaijanArLanguage			EQU		51
gxArmenianLanguage				EQU		52
gxGeorgianLanguage				EQU		53
gxMoldavianLanguage				EQU		54
gxKirghizLanguage				EQU		55
gxTajikiLanguage				EQU		56
gxTurkmenLanguage				EQU		57
gxMongolianLanguage				EQU		58
gxMongolianCyrLanguage			EQU		59
gxPashtoLanguage				EQU		60
gxKurdishLanguage				EQU		61
gxKashmiriLanguage				EQU		62
gxSindhiLanguage				EQU		63
gxTibetanLanguage				EQU		64
gxNepaliLanguage				EQU		65
gxSanskritLanguage				EQU		66
gxMarathiLanguage				EQU		67
gxBengaliLanguage				EQU		68
gxAssameseLanguage				EQU		69
gxGujaratiLanguage				EQU		70
gxPunjabiLanguage				EQU		71
gxOriyaLanguage					EQU		72
gxMalayalamLanguage				EQU		73
gxKannadaLanguage				EQU		74
gxTamilLanguage					EQU		75
gxTeluguLanguage				EQU		76
gxSinhaleseLanguage				EQU		77
gxBurmeseLanguage				EQU		78
gxKhmerLanguage					EQU		79
gxLaoLanguage					EQU		80
gxVietnameseLanguage			EQU		81
gxIndonesianLanguage			EQU		82
gxTagalogLanguage				EQU		83
gxMalayRomanLanguage			EQU		84
gxMalayArabicLanguage			EQU		85
gxAmharicLanguage				EQU		86
gxTigrinyaLanguage				EQU		87
gxGallaLanguage					EQU		88
gxOromoLanguage					EQU		88
gxSomaliLanguage				EQU		89
gxSwahiliLanguage				EQU		90
gxRuandaLanguage				EQU		91
gxRundiLanguage					EQU		92
gxChewaLanguage					EQU		93
gxMalagasyLanguage				EQU		94
gxEsperantoLanguage				EQU		95
gxWelshLanguage					EQU		129
gxBasqueLanguage				EQU		130
gxCatalanLanguage				EQU		131
gxLatinLanguage					EQU		132
gxQuechuaLanguage				EQU		133
gxGuaraniLanguage				EQU		134
gxAymaraLanguage				EQU		135
gxTatarLanguage					EQU		136
gxUighurLanguage				EQU		137
gxDzongkhaLanguage				EQU		138
gxJavaneseRomLanguage			EQU		139
gxSundaneseRomLanguage			EQU		140
; typedef long 							gxFontLanguage


gxCopyrightFontName				EQU		1
gxFamilyFontName				EQU		2
gxStyleFontName					EQU		3
gxUniqueFontName				EQU		4
gxFullFontName					EQU		5
gxVersionFontName				EQU		6
gxPostscriptFontName			EQU		7
gxTrademarkFontName				EQU		8
gxManufacturerFontName			EQU		9
gxLastReservedFontName			EQU		256
; typedef long 							gxFontName

; typedef long 							gxFontTableTag

; typedef long 							gxFontVariationTag

; typedef long 							gxFontFormatTag

; typedef long 							gxFontStorageTag

; typedef gxFontVariationTag 			gxFontDescriptorTag

gxFontVariation			RECORD 0
name					 ds.l	1				; offset: $0 (0)
value					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
gxFontDescriptor		RECORD 0
f						 ds		gxFontVariation
sizeof					 EQU *					; size:   $8 (8)
						ENDR


gxFontFeatureSetting	RECORD 0
setting					 ds.w	1				; offset: $0 (0)
nameID					 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR

gxSystemFontAttribute			EQU		$0001
gxReadOnlyFontAttribute			EQU		$0002
; typedef long 							gxFontAttribute


gxMutuallyExclusiveFeature		EQU		$00008000
; typedef long 							gxFontFeatureFlag

; typedef long 							gxFontFeature


gxResourceFontStorage			EQU		'rsrc'
gxHandleFontStorage				EQU		'hndl'
gxFileFontStorage				EQU		'bass'
gxNfntFontStorage				EQU		'nfnt'
; typedef void *						gxFontStorageReference

; typedef unsigned short 				gxGlyphcode

;  single glyph in a font 
;  byte offset within backing store 
; typedef long 							gxByteOffset

;  The actual constants for feature types and selectors have been moved to a library. 
; typedef unsigned short 				gxRunFeatureType

; typedef unsigned short 				gxRunFeatureSelector

;  If tracking is not desired, specify the following value in the track field in the
;        gxRunControls record (note that a track of 0 does *not* mean to turn tracking off;
;        rather, it means to use normal tracking). 


gxNoTracking					EQU		$80000000
;  The special "gxNoStake" value is returned by the GXGetLayoutBreakOffset call to
;        indicate the absence of a character offset that is stable with respect to
;        metamorphosis and contextual kerning. 


gxNoStake						EQU		-1
;  A glyph's behavior with respect to other glyphs on its line is defined in part by its
;        gxBaselineType. These types allow correct alignment of the baselines of all glyphs on
;        the line. 


gxRomanBaseline					EQU		0
gxIdeographicCenterBaseline		EQU		1
gxIdeographicLowBaseline		EQU		2
gxHangingBaseline				EQU		3
gxMathBaseline					EQU		4
gxLastBaseline					EQU		31
gxNumberOfBaselineTypes			EQU		32
gxNoOverrideBaseline			EQU		255
; typedef unsigned long 				gxBaselineType

gxBaselineDeltas		RECORD 0
elements				 ds.l	32
sizeof					 EQU *					; size:   $80 (128)
						ENDR


;  gxJustificationPriority defines the point during the justification process at which a
;    glyph will begin to receive deltas before and after itself. 

gxKashidaPriority				EQU		0
gxWhiteSpacePriority			EQU		1
gxInterCharPriority				EQU		2
gxNullJustificationPriority		EQU		3
gxNumberOfJustificationPriorities EQU	4
; typedef unsigned char 				gxJustificationPriority

;  gxJustificationFlags are used to control which fields of a gxWidthDeltaRecord are to
;        be overridden and which are not if a gxPriorityJustificationOverride or
;        gxGlyphJustificationOverride (qq.v.) is specified. 


gxOverridePriority				EQU		$8000				; use priority value from override 
gxOverrideLimits				EQU		$4000				; use limits values from override 
gxOverrideUnlimited				EQU		$2000				; use unlimited flag from override 
gxUnlimitedGapAbsorption		EQU		$1000				; glyph can take unlimited gap 
gxJustificationPriorityMask		EQU		$000F				; justification priority 
gxAllJustificationFlags			EQU		$F00F
; typedef unsigned short 				gxJustificationFlags

;  The directional behavior of a glyph can be overridden using a gxDirectionOverride. 

gxNoDirectionOverride			EQU		0
gxImposeLeftToRight				EQU		1
gxImposeRightToLeft				EQU		2
gxImposeArabic					EQU		3
; typedef unsigned short 				gxDirectionOverride

;  gxRunControlFlags describe the nonparametric layout options contained in a gxStyle. 

gxNoCaretAngle					EQU		$40000000
gxImposeWidth					EQU		$20000000
gxNoCrossKerning				EQU		$10000000
gxNoOpticalAlignment			EQU		$08000000
gxForceHanging					EQU		$04000000
gxNoSpecialJustification		EQU		$02000000
gxDirectionOverrideMask			EQU		$00000003
gxNoLigatureSplits				EQU		$80000000

gxAllRunControlFlags			EQU		$FE000003
; typedef unsigned long 				gxRunControlFlags

;  gxHighlightType is used to distinguish various highlighting methods, both in terms of
;        character offset based vs. visual based, and in terms of angled sides vs. non-angled
;        sides. 


gxHighlightStraight				EQU		0					; straight-edged simple highlighting 
gxHighlightAverageAngle			EQU		1					; takes average of two edge angles 
; typedef unsigned long 				gxHighlightType

;  gxCaretType is used to control whether the caret that is returned from GXGetLayoutCaret
;        is a split caret or a (keyboard-syncronized) single caret. 

gxSplitCaretType				EQU		0					; returns Mac-style split caret (default) 
gxLeftRightKeyboardCaret		EQU		1					; single caret in left-right position 
gxRightLeftKeyboardCaret		EQU		2					; single caret in right-left position 
; typedef unsigned long 				gxCaretType

;  gxLayoutOffsetState describes the characteristics of a given gxByteOffset in some
;        layout. It is returned by the GXGetOffsetGlyphs call. Note that the
;        gxOffsetInsideLigature value is returned in addition to the 8/16 (or invalid)
;        indication. 


gxOffset8_8						EQU		0
gxOffset8_16					EQU		1
gxOffset16_8					EQU		2
gxOffset16_16					EQU		3
gxOffsetInvalid					EQU		4

gxOffsetInsideLigature			EQU		$8000
; typedef unsigned short 				gxLayoutOffsetState

;  gxLayoutOptionsFlags are single-bit flags contained in a gxLayoutOptions record. We
;    also define here some utility constants that are useful in setting various fields in
;    the gxLayoutOptions record. 


gxNoLayoutOptions				EQU		0
gxLineIsDisplayOnly				EQU		$00000001
gxKeepSpacesInMargin			EQU		$00000002
gxLimitReorderingToTwoLevels	EQU		$00000004
gxLineLeftEdgeNotAtMargin		EQU		$00000008
gxLineRightEdgeNotAtMargin		EQU		$00000010
gxAllLayoutOptionsFlags			EQU		$0000001F
gxMaxRunLevel					EQU		15
gxFlushLeft						EQU		0
gxFlushCenter					EQU		$20000000
gxFlushRight					EQU		$40000000
gxNoJustification				EQU		0
gxFullJustification				EQU		$40000000
; typedef unsigned long 				gxLayoutOptionsFlags

;  A gxRunFeature describes a feature and a level for that feature. 
gxRunFeature			RECORD 0
featureType				 ds.w	1				; offset: $0 (0)
featureSelector			 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
;  A gxWidthDeltaRecord contains all of the information needed to describe the behavior of one
;        class of glyphs during the justification process. 
gxWidthDeltaRecord		RECORD 0
beforeGrowLimit			 ds.l	1				; offset: $0 (0)		;  ems AW can grow by at most on LT 
beforeShrinkLimit		 ds.l	1				; offset: $4 (4)		;  ems AW can shrink by at most on LT 
afterGrowLimit			 ds.l	1				; offset: $8 (8)		;  ems AW can grow by at most on RB 
afterShrinkLimit		 ds.l	1				; offset: $C (12)		;  ems AW can shrink by at most on RB 
growFlags				 ds.w	1				; offset: $10 (16)		;  flags controlling grow case 
shrinkFlags				 ds.w	1				; offset: $12 (18)		;  flags controlling shrink case 
sizeof					 EQU *					; size:   $14 (20)
						ENDR
;  A gxPriorityJustificationOverride contains an array of WidthDeltaRecords, one for each
;        gxJustificationPriority. 
gxPriorityJustificationOverride RECORD 0
deltas					 ds.b	4 * gxWidthDeltaRecord.sizeof ; offset: $0 (0) ;  overrides for each of the priorities 
sizeof					 EQU *					; size:   $50 (80)
						ENDR
;  A gxGlyphJustificationOverride contains a gxWidthDeltaRecord that is to be used for a
;        specific glyph in a specific run (this limitation is because glyphcodes vary by font). 
gxGlyphJustificationOverride RECORD 0
glyph					 ds.w	1				; offset: $0 (0)
override				 ds		gxWidthDeltaRecord ; offset: $2 (2)
sizeof					 EQU *					; size:   $16 (22)
						ENDR

;  gxRunControls contains flags, shifts, imposed widths and overrides for a run. 
;  NOTE: a value of "gxNoTracking" (see above) in track disables tracking 
gxRunControls			RECORD 0
flags					 ds.l	1				; offset: $0 (0)
beforeWithStreamShift	 ds.l	1				; offset: $4 (4)
afterWithStreamShift	 ds.l	1				; offset: $8 (8)
crossStreamShift		 ds.l	1				; offset: $C (12)
imposedWidth			 ds.l	1				; offset: $10 (16)
track					 ds.l	1				; offset: $14 (20)
hangingInhibitFactor	 ds.l	1				; offset: $18 (24)
kerningInhibitFactor	 ds.l	1				; offset: $1C (28)
decompositionAdjustmentFactor  ds.l 1			; offset: $20 (32)
baselineType			 ds.l	1				; offset: $24 (36)
sizeof					 EQU *					; size:   $28 (40)
						ENDR
;  A gxGlyphSubstitution describes one client-provided substitution that occurs after all
;        other automatic glyph changes have happened. 
gxGlyphSubstitution		RECORD 0
originalGlyph			 ds.w	1				; offset: $0 (0)		;  Whenever you see this glyph... 
substituteGlyph			 ds.w	1				; offset: $2 (2)		;  ...change it to this one. 
sizeof					 EQU *					; size:   $4 (4)
						ENDR
;  gxKerningAdjustmentFactors specify an adjustment to automatic kerning. The adjustment
;        is ax + b where x is the automatic kerning value, a is scaleFactor, and b is
;        adjustmentPointSizeFactor times the run's point size. 

gxKerningAdjustmentFactors RECORD 0
scaleFactor				 ds.l	1				; offset: $0 (0)
adjustmentPointSizeFactor  ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  A gxKerningAdjustment identifies with- and cross-stream kerning adjustments
;        for specific glyph pairs. 
gxKerningAdjustment		RECORD 0
firstGlyph				 ds.w	1				; offset: $0 (0)
secondGlyph				 ds.w	1				; offset: $2 (2)
withStreamFactors		 ds		gxKerningAdjustmentFactors ; offset: $4 (4)
crossStreamFactors		 ds		gxKerningAdjustmentFactors ; offset: $C (12)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
;  A value of gxResetCrossStreamFactor in crossStreamFactors.adjustmentPointSizeFactor
;        will reset the cross-stream kerning to the baseline. 

gxResetCrossStreamFactor		EQU		$80000000
;  gxLayoutHitInfo contains the output from the GXHitTestLayout call. 
gxLayoutHitInfo			RECORD 0
firstPartialDist		 ds.l	1				; offset: $0 (0)
lastPartialDist			 ds.l	1				; offset: $4 (4)
hitSideOffset			 ds.l	1				; offset: $8 (8)
nonHitSideOffset		 ds.l	1				; offset: $C (12)
leadingEdge				 ds.b	1				; offset: $10 (16)
inLoose					 ds.b	1				; offset: $11 (17)
sizeof					 EQU *					; size:   $12 (18)
						ENDR
;  A gxLineBaselineRecord contains the deltas from 0 to all the different baselines for
;        the layout. It can be filled via a call to GetBaselineDeltas (q.v.). 
gxLineBaselineRecord	RECORD 0
deltas					 ds		gxBaselineDeltas ; offset: $0 (0)
sizeof					 EQU *					; size:   $80 (128)
						ENDR
;  The gxLayoutOptions type contains information about the layout characteristics of the
;        whole line. 
gxLayoutOptions			RECORD 0
width					 ds.l	1				; offset: $0 (0)
flush					 ds.l	1				; offset: $4 (4)
just					 ds.l	1				; offset: $8 (8)
flags					 ds.l	1				; offset: $C (12)
baselineRec				 ds.l	1				; offset: $10 (16)
sizeof					 EQU *					; size:   $14 (20)
						ENDR

gxNewObjectOpcode				EQU		$00					; create new object 
gxSetDataOpcode					EQU		$40					; add reference to current object 
gxSetDefaultOpcode				EQU		$80					; replace current default with this object 
gxReservedOpcode				EQU		$C0					; (may be used in future expansion) 
gxNextOpcode					EQU		$FF					; used by currentOperand field to say opcode is coming 
;  new object types (new object opcode) 

gxHeaderTypeOpcode				EQU		$00					; byte following new object uses bottom 6 bits for type 
															; gxShape types use values 1 (gxEmptyType) through 13 (gxPictureType) 
gxStyleTypeOpcode				EQU		$28
gxInkTypeOpcode					EQU		$29
gxTransformTypeOpcode			EQU		$2A
gxColorProfileTypeOpcode		EQU		$2B
gxColorSetTypeOpcode			EQU		$2C
gxTagTypeOpcode					EQU		$2D
gxBitImageOpcode				EQU		$2E
gxFontNameTypeOpcode			EQU		$2F
gxTrailerTypeOpcode				EQU		$3F
;  fields of objects (set data opcodes) 

gxShapeAttributesOpcode			EQU		0
gxShapeTagOpcode				EQU		1
gxShapeFillOpcode				EQU		2

gxOmitPathPositionXMask			EQU		$C0
gxOmitPathPositionYMask			EQU		$30
gxOmitPathDeltaXMask			EQU		$0C
gxOmitPathDeltaYMask			EQU		$03

gxOmitPathPositionXShift		EQU		6
gxOmitPathPositionYShift		EQU		4
gxOmitPathDeltaXShift			EQU		2
gxOmitPathDeltaYShift			EQU		0

gxOmitBitmapImageMask			EQU		$C0
gxOmitBitmapWidthMask			EQU		$30
gxOmitBitmapHeightMask			EQU		$0C
gxOmitBitmapRowBytesMask		EQU		$03

gxOmitBitmapImageShift			EQU		6
gxOmitBitmapWidthShift			EQU		4
gxOmitBitmapHeightShift			EQU		2
gxOmitBitmapRowBytesShift		EQU		0

gxOmitBitmapPixelSizeMask		EQU		$C0
gxOmitBitmapSpaceMask			EQU		$30
gxOmitBitmapSetMask				EQU		$0C
gxOmitBitmapProfileMask			EQU		$03

gxOmitBitmapPixelSizeShift		EQU		6
gxOmitBitmapSpaceShift			EQU		4
gxOmitBitmapSetShift			EQU		2
gxOmitBitmapProfileShift		EQU		0

gxOmitBitmapPositionXMask		EQU		$C0
gxOmitBitmapPositionYMask		EQU		$30

gxOmitBitmapPositionXShift		EQU		6
gxOmitBitmapPositionYShift		EQU		4

gxOmitBitImageRowBytesMask		EQU		$C0
gxOmitBitImageHeightMask		EQU		$30
gxOmitBitImageDataMask			EQU		$08

gxOmitBitImageRowBytesShift		EQU		6
gxOmitBitImageHeightShift		EQU		4
gxOmitBitImageDataShift			EQU		3

gxCopyBitImageBytesOpcode		EQU		$00
gxRepeatBitImageBytesOpcode		EQU		$40
gxLookupBitImageBytesOpcode		EQU		$80
gxRepeatBitImageScanOpcode		EQU		$C0

gxOmitTextCharactersMask		EQU		$C0
gxOmitTextPositionXMask			EQU		$30
gxOmitTextPositionYMask			EQU		$0C
gxOmitTextDataMask				EQU		$02

gxOmitTextCharactersShift		EQU		6
gxOmitTextPositionXShift		EQU		4
gxOmitTextPositionYShift		EQU		2
gxOmitTextDataShift				EQU		1

gxOmitGlyphCharactersMask		EQU		$C0
gxOmitGlyphLengthMask			EQU		$30
gxOmitGlyphRunNumberMask		EQU		$0C
gxOmitGlyphOnePositionMask		EQU		$02
gxOmitGlyphDataMask				EQU		$01

gxOmitGlyphCharactersShift		EQU		6
gxOmitGlyphLengthShift			EQU		4
gxOmitGlyphRunNumberShift		EQU		2
gxOmitGlyphOnePositionShift		EQU		1
gxOmitGlyphDataShift			EQU		0

gxOmitGlyphPositionsMask		EQU		$C0
gxOmitGlyphAdvancesMask			EQU		$20
gxOmitGlyphTangentsMask			EQU		$18
gxOmitGlyphRunsMask				EQU		$04
gxOmitGlyphStylesMask			EQU		$03

gxOmitGlyphPositionsShift		EQU		6
gxOmitGlyphAdvancesShift		EQU		5
gxOmitGlyphTangentsShift		EQU		3
gxOmitGlyphRunsShift			EQU		2
gxOmitGlyphStylesShift			EQU		0

gxOmitLayoutLengthMask			EQU		$C0
gxOmitLayoutPositionXMask		EQU		$30
gxOmitLayoutPositionYMask		EQU		$0C
gxOmitLayoutDataMask			EQU		$02

gxOmitLayoutLengthShift			EQU		6
gxOmitLayoutPositionXShift		EQU		4
gxOmitLayoutPositionYShift		EQU		2
gxOmitLayoutDataShift			EQU		1

gxOmitLayoutWidthMask			EQU		$C0
gxOmitLayoutFlushMask			EQU		$30
gxOmitLayoutJustMask			EQU		$0C
gxOmitLayoutOptionsMask			EQU		$03

gxOmitLayoutWidthShift			EQU		6
gxOmitLayoutFlushShift			EQU		4
gxOmitLayoutJustShift			EQU		2
gxOmitLayoutOptionsShift		EQU		0

gxOmitLayoutStyleRunNumberMask	EQU		$C0
gxOmitLayoutLevelRunNumberMask	EQU		$30
gxOmitLayoutHasBaselineMask		EQU		$08
gxOmitLayoutStyleRunsMask		EQU		$04
gxOmitLayoutStylesMask			EQU		$03

gxOmitLayoutStyleRunNumberShift	EQU		6
gxOmitLayoutLevelRunNumberShift	EQU		4
gxOmitLayoutHasBaselineShift	EQU		3
gxOmitLayoutStyleRunsShift		EQU		2
gxOmitLayoutStylesShift			EQU		0

gxOmitLayoutLevelRunsMask		EQU		$80
gxOmitLayoutLevelsMask			EQU		$40

gxOmitLayoutLevelRunsShift		EQU		7
gxOmitLayoutLevelsShift			EQU		6

gxInkAttributesOpcode			EQU		0
gxInkTagOpcode					EQU		1
gxInkColorOpcode				EQU		2
gxInkTransferModeOpcode			EQU		3

gxOmitColorsSpaceMask			EQU		$C0
gxOmitColorsProfileMask			EQU		$30
gxOmitColorsComponentsMask		EQU		$0F
gxOmitColorsIndexMask			EQU		$0C
gxOmitColorsIndexSetMask		EQU		$03

gxOmitColorsSpaceShift			EQU		6
gxOmitColorsProfileShift		EQU		4
gxOmitColorsComponentsShift		EQU		0
gxOmitColorsIndexShift			EQU		2
gxOmitColorsIndexSetShift		EQU		0

gxOmitTransferSpaceMask			EQU		$C0
gxOmitTransferSetMask			EQU		$30
gxOmitTransferProfileMask		EQU		$0C

gxOmitTransferSpaceShift		EQU		6
gxOmitTransferSetShift			EQU		4
gxOmitTransferProfileShift		EQU		2

gxOmitTransferSourceMatrixMask	EQU		$C0
gxOmitTransferDeviceMatrixMask	EQU		$30
gxOmitTransferResultMatrixMask	EQU		$0C
gxOmitTransferFlagsMask			EQU		$03

gxOmitTransferSourceMatrixShift	EQU		6
gxOmitTransferDeviceMatrixShift	EQU		4
gxOmitTransferResultMatrixShift	EQU		2
gxOmitTransferFlagsShift		EQU		0

gxOmitTransferComponentModeMask	EQU		$80
gxOmitTransferComponentFlagsMask EQU	$40
gxOmitTransferComponentSourceMinimumMask EQU $30
gxOmitTransferComponentSourceMaximumMask EQU $0C
gxOmitTransferComponentDeviceMinimumMask EQU $03

gxOmitTransferComponentModeShift EQU	7
gxOmitTransferComponentFlagsShift EQU	6
gxOmitTransferComponentSourceMinimumShift EQU 4
gxOmitTransferComponentSourceMaximumShift EQU 2
gxOmitTransferComponentDeviceMinimumShift EQU 0

gxOmitTransferComponentDeviceMaximumMask EQU $C0
gxOmitTransferComponentClampMinimumMask EQU $30
gxOmitTransferComponentClampMaximumMask EQU $0C
gxOmitTransferComponentOperandMask EQU	$03

gxOmitTransferComponentDeviceMaximumShift EQU 6
gxOmitTransferComponentClampMinimumShift EQU 4
gxOmitTransferComponentClampMaximumShift EQU 2
gxOmitTransferComponentOperandShift EQU	0

gxStyleAttributesOpcode			EQU		0
gxStyleTagOpcode				EQU		1
gxStyleCurveErrorOpcode			EQU		2
gxStylePenOpcode				EQU		3
gxStyleJoinOpcode				EQU		4
gxStyleDashOpcode				EQU		5
gxStyleCapsOpcode				EQU		6
gxStylePatternOpcode			EQU		7
gxStyleTextAttributesOpcode		EQU		8
gxStyleTextSizeOpcode			EQU		9
gxStyleFontOpcode				EQU		10
gxStyleTextFaceOpcode			EQU		11
gxStylePlatformOpcode			EQU		12
gxStyleFontVariationsOpcode		EQU		13
gxStyleRunControlsOpcode		EQU		14
gxStyleRunPriorityJustOverrideOpcode EQU 15
gxStyleRunGlyphJustOverridesOpcode EQU	16
gxStyleRunGlyphSubstitutionsOpcode EQU	17
gxStyleRunFeaturesOpcode		EQU		18
gxStyleRunKerningAdjustmentsOpcode EQU	19
gxStyleJustificationOpcode		EQU		20

gxOmitDashAttributesMask		EQU		$C0
gxOmitDashShapeMask				EQU		$30
gxOmitDashAdvanceMask			EQU		$0C
gxOmitDashPhaseMask				EQU		$03

gxOmitDashAttributesShift		EQU		6
gxOmitDashShapeShift			EQU		4
gxOmitDashAdvanceShift			EQU		2
gxOmitDashPhaseShift			EQU		0

gxOmitDashScaleMask				EQU		$C0

gxOmitDashScaleShift			EQU		6

gxOmitPatternAttributesMask		EQU		$C0
gxOmitPatternShapeMask			EQU		$30
gxOmitPatternUXMask				EQU		$0C
gxOmitPatternUYMask				EQU		$03

gxOmitPatternAttributesShift	EQU		6
gxOmitPatternShapeShift			EQU		4
gxOmitPatternUXShift			EQU		2
gxOmitPatternUYShift			EQU		0

gxOmitPatternVXMask				EQU		$C0
gxOmitPatternVYMask				EQU		$30

gxOmitPatternVXShift			EQU		6
gxOmitPatternVYShift			EQU		4

gxOmitJoinAttributesMask		EQU		$C0
gxOmitJoinShapeMask				EQU		$30
gxOmitJoinMiterMask				EQU		$0C

gxOmitJoinAttributesShift		EQU		6
gxOmitJoinShapeShift			EQU		4
gxOmitJoinMiterShift			EQU		2

gxOmitCapAttributesMask			EQU		$C0
gxOmitCapStartShapeMask			EQU		$30
gxOmitCapEndShapeMask			EQU		$0C

gxOmitCapAttributesShift		EQU		6
gxOmitCapStartShapeShift		EQU		4
gxOmitCapEndShapeShift			EQU		2

gxOmitFaceLayersMask			EQU		$C0
gxOmitFaceMappingMask			EQU		$30

gxOmitFaceLayersShift			EQU		6
gxOmitFaceMappingShift			EQU		4

gxOmitFaceLayerFillMask			EQU		$C0
gxOmitFaceLayerFlagsMask		EQU		$30
gxOmitFaceLayerStyleMask		EQU		$0C
gxOmitFaceLayerTransformMask	EQU		$03

gxOmitFaceLayerFillShift		EQU		6
gxOmitFaceLayerFlagsShift		EQU		4
gxOmitFaceLayerStyleShift		EQU		2
gxOmitFaceLayerTransformShift	EQU		0

gxOmitFaceLayerBoldXMask		EQU		$C0
gxOmitFaceLayerBoldYMask		EQU		$30

gxOmitFaceLayerBoldXShift		EQU		6
gxOmitFaceLayerBoldYShift		EQU		4

gxColorSetReservedOpcode		EQU		0
gxColorSetTagOpcode				EQU		1

gxColorProfileReservedOpcode	EQU		0
gxColorProfileTagOpcode			EQU		1

gxTransformReservedOpcode		EQU		0
gxTransformTagOpcode			EQU		1
gxTransformClipOpcode			EQU		2
gxTransformMappingOpcode		EQU		3
gxTransformPartMaskOpcode		EQU		4
gxTransformToleranceOpcode		EQU		5

gxTypeOpcode					EQU		0
gxSizeOpcode					EQU		1
;  used by currentOperand when currentOperation is gxNextOpcode 
;     format of top byte:
;xx yyyyyy   xx == 0x00, 0x40, 0x80, 0xC0: defines graphics operation (see gxGraphicsOperationOpcode)
;            yyyyyy == size of operation in bytes
;            if (yyyyyy == 0), byte size follows. If byte following == 0, word size follows; if == 0, long follows
;            word and long, if present, are specified in high-endian order (first byte is largest magnitude)
;            
;format of byte following size specifiers, if any:
;xx yyyyyy   xx == 0x00, 0x40, 0x80, 0xC0: defines compression level (0 == none, 0xC0 == most)
;            exact method of compression is defined by type of data
;            yyyyyy == data type selector (0 to 63): see gxGraphicsNewOpcode, __DataOpcode
;


gxOpcodeShift					EQU		6
gxObjectSizeMask				EQU		$3F
gxCompressionShift				EQU		6
gxObjectTypeMask				EQU		$3F
gxBitImageOpcodeMask			EQU		$C0
gxBitImageCountMask				EQU		$3F
gxBitImageOpcodeShift			EQU		6

gxNoCompression					EQU		0
gxWordCompression				EQU		1
gxByteCompression				EQU		2
gxOmitCompression				EQU		3
gxCompressionMask				EQU		$03
;     the following structures define how primitives without a public geometry
;    are stored (their format mirrors that of the New call to create them)   
gxFlatFontName			RECORD 0
name					 ds.b	1				; offset: $0 (0)		;  gxFontName 
platform				 ds.b	1				; offset: $1 (1)		;  gxFontPlatform 
script					 ds.b	1				; offset: $2 (2)		;  gxFontScript 
language				 ds.b	1				; offset: $3 (3)		;  gxFontLanguage 
length					 ds.w	1				; offset: $4 (4)		;  byte length 
sizeof					 EQU *					; size:   $6 (6)
						ENDR

gxFlatFontListItemTag			EQU		'flst'
gxFlatFontListItem		RECORD 0
fontID					 ds.l	1				; offset: $0 (0)		; ** if we get rid of this, remove #include "font types.h", above 
name					 ds.b	1				; offset: $4 (4)		;  gxFontName 
platform				 ds.b	1				; offset: $5 (5)		;  gxFontPlatform 
script					 ds.b	1				; offset: $6 (6)		;  gxFontScript 
language				 ds.b	1				; offset: $7 (7)		;  gxFontLanguage 
length					 ds.w	1				; offset: $8 (8)		;  byte length of the name that follows 
glyphCount				 ds.w	1				; offset: $A (10)		;  CountFontGlyphs or 0 if gxFontGlyphsFlatten is false 
axisCount				 ds.w	1				; offset: $C (12)		;  CountFontVariations or 0 if gxFontVariationsFlatten is false 
variationCount			 ds.w	1				; offset: $E (14)		;  number of bitsVariationPairs that follow the (optional) glyphBits 
sizeof					 EQU *					; size:   $10 (16)
						ENDR
gxFlatFontList			RECORD 0
count					 ds.l	1				; offset: $0 (0)
items					 ds		gxFlatFontListItem ; offset: $4 (4) <-- really an array of length one
sizeof					 EQU *					; size:   $14 (20)
						ENDR
gxFlattenHeader			RECORD 0
version					 ds.l	1				; offset: $0 (0)
flatFlags				 ds.b	1				; offset: $4 (4)
padding					 ds.b	1				; offset: $5 (5)
sizeof					 EQU *					; size:   $6 (6)
						ENDR

gxOmitPictureShapeMask			EQU		$C0
gxOmitOverrideStyleMask			EQU		$30
gxOmitOverrideInkMask			EQU		$0C
gxOmitOverrideTransformMask		EQU		$03

gxOmitPictureShapeShift			EQU		$06
gxOmitOverrideStyleShift		EQU		$04
gxOmitOverrideInkShift			EQU		$02
gxOmitOverrideTransformShift	EQU		$00

gxPostScriptTag					EQU		'post'
gxPostControlTag				EQU		'psct'

gxNoSave						EQU		1					; don't do save-restore around PS data 
gxPSContinueNext				EQU		2					; next shape is continuation of this shape's PS -- only obeyed if gxNoSave is true 
gxPostControl			RECORD 0
flags					 ds.l	1				; offset: $0 (0)		;  PostScript state flags 
sizeof					 EQU *					; size:   $4 (4)
						ENDR

gxDashSynonymTag				EQU		'sdsh'
gxDashSynonym			RECORD 0
size					 ds.l	1				; offset: $0 (0)		;  number of elements in array 
dashLength				 ds.l	1				; offset: $4 (4) <-- really an array of length one ;  Array of dash lengths 
sizeof					 EQU *					; size:   $8 (8)
						ENDR

gxLineCapSynonymTag				EQU		'lcap'

gxButtCap						EQU		0
gxRoundCap						EQU		1
gxSquareCap						EQU		2
gxTriangleCap					EQU		3
;  gxLine cap type 
; typedef long 							gxLineCapSynonym


gxCubicSynonymTag				EQU		'cubx'

gxIgnoreFlag					EQU		$0000				; Ignore this word, get next one 
gxLineToFlag					EQU		$0001				; Draw a gxLine to gxPoint following this flag 
gxCurveToFlag					EQU		$0002				; Draw a gxCurve through the 3 points following this flag 
gxMoveToFlag					EQU		$0003				; Start a new contour at the gxPoint following this flag 
gxClosePathFlag					EQU		$0004				; Close the contour 
; typedef long 							gxCubicSynonym


gxCubicInstructionMask			EQU		$000F				; low four bits are gxPoint instructions 
;  Low four bits are instruction (moveto, lineto, curveto, closepath) 
; typedef short 						gxCubicSynonymFlags


gxPatternSynonymTag				EQU		'ptrn'

gxHatch							EQU		0
gxCrossHatch					EQU		1
gxPatternSynonym		RECORD 0
patternType				 ds.l	1				; offset: $0 (0)		;  one of the gxPatterns: gxHatch or gxCrossHatch 
angle					 ds.l	1				; offset: $4 (4)		;  angle at which pattern is drawn 
spacing					 ds.l	1				; offset: $8 (8)		;  distance between two parallel pattern lines 
thickness				 ds.l	1				; offset: $C (12)		;  thickness of the pattern 
anchorPoint				 ds		gxPoint			; offset: $10 (16)		;  gxPoint with with respect to which pattern position is calculated 
sizeof					 EQU *					; size:   $18 (24)
						ENDR

gxURLTag						EQU		'urlt'
	ENDIF ; __GXTYPES__ 


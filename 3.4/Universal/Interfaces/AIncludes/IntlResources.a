;
;    File:       IntlResources.a
;
;    Contains:   International Resource definitions.
;
;    Version:    Technology: System 7.5+
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  Â© 1983-2001 by Apple Computer, Inc., all rights reserved.
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__INTLRESOURCES__') = 'UNDEFINED' THEN
__INTLRESOURCES__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF


															; Bits in the itlcFlags byte 
itlcShowIcon					EQU		7					;Show icon even if only one script
itlcDualCaret					EQU		6					;Use dual caret for mixed direction text
															; Bits in the itlcSysFlags word 
itlcSysDirection				EQU		15					;System direction - left to right/right to left

															; One more flag in the itlcFlags byte 
itlcDisableKeyScriptSync		EQU		3					;Disable font and keyboard script synchrinozation

															; We should define masks, too. 
itlcDisableKeyScriptSyncMask	EQU		$08					;Disable font and keyboard script synchrinozation mask


tokLeftQuote					EQU		1					; NumberParts.data[] enumerators                             
tokRightQuote					EQU		2					;  In general, these are NOT to be considered indices into the data[] array 
tokLeadPlacer					EQU		3
tokLeader						EQU		4
tokNonLeader					EQU		5
tokZeroLead						EQU		6
tokPercent						EQU		7
tokPlusSign						EQU		8
tokMinusSign					EQU		9
tokThousands					EQU		10
tokReserved						EQU		11					; 11 is reserved field 
tokSeparator					EQU		12
tokEscape						EQU		13
tokDecPoint						EQU		14
tokEPlus						EQU		15
tokEMinus						EQU		16
tokMaxSymbols					EQU		31
curNumberPartsVersion			EQU		1					;current version of NumberParts record

currSymLead						EQU		16
currNegSym						EQU		32
currTrailingZ					EQU		64
currLeadingZ					EQU		128

mdy								EQU		0
dmy								EQU		1
ymd								EQU		2
myd								EQU		3
dym								EQU		4
ydm								EQU		5
; typedef SInt8 						DateOrders


timeCycle24						EQU		0					;time sequence 0:00 - 23:59
timeCycleZero					EQU		1					;time sequence 0:00-11:59, 0:00 - 11:59
timeCycle12						EQU		255					;time sequence 12:00 - 11:59, 12:00 - 11:59
zeroCycle						EQU		1					;old name for timeCycleZero
longDay							EQU		0					;day of the month
longWeek						EQU		1					;day of the week
longMonth						EQU		2					;month of the year
longYear						EQU		3					;year
supDay							EQU		1					;suppress day of month
supWeek							EQU		2					;suppress day of week
supMonth						EQU		4					;suppress month
supYear							EQU		8					;suppress year
dayLdingZ						EQU		32
mntLdingZ						EQU		64
century							EQU		128
secLeadingZ						EQU		32
minLeadingZ						EQU		64
hrLeadingZ						EQU		128
;  itl2 header offsets to string comparison hooks 

initHook						EQU		0
fetchHook						EQU		2
vernierHook						EQU		4
projectHook						EQU		6
rsvdHook						EQU		8
exitHook						EQU		10
; 
;    Note that the value of itl2FlagsOffset is equal to the value of rsvdHook.
;    In the pre-6.0.4 itl2 format the value at this location was an unused 
;    routine offset. In the itl2 format used with 6.0.4 and later, the value
;    at this location is a flag ($ffff) indicating the new format (i.e., the
;    format that includes the offsets to the tables for LwrString and tables
;    for the simple-script versions of the CharType, Transliterate and FindWord.
;    

;  itl2 header offsets for system 6.0.4 and later 

itl2FlagsOffset					EQU		8
typeListOffset					EQU		12
classArrayOffset				EQU		14
upperListOffset					EQU		16
lowerListOffset					EQU		18
upperNoMarkListOffset			EQU		20
wordTableOffset					EQU		22
wrapTableOffset					EQU		24
noMarkListOffset				EQU		26
itl2VersionOffset				EQU		28
itl2FormatOffset				EQU		30
;  itl2 header offsets for system 7.0 and later 

wordTableLen					EQU		54
wrapTableLen					EQU		56
findScriptTableOffset			EQU		60
findScriptTableLen				EQU		62
;  itl2FormatOffset definitions for system 7.0 and later 

hdrExtensionsExist				EQU		1
;  moved OffsetTable back here from QuickdrawText 
OffPair					RECORD 0
offFirst				 ds.w	1				; offset: $0 (0)
offSecond				 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
OffsetTable				RECORD 0
elements				 ds.b	3 * OffPair.sizeof
sizeof					 EQU *					; size:   $C (12)
						ENDR


Intl0Rec				RECORD 0
decimalPt				 ds.b	1				; offset: $0 (0)		; decimal point character
thousSep				 ds.b	1				; offset: $1 (1)		; thousands separator character
listSep					 ds.b	1				; offset: $2 (2)		; list separator character
currSym1				 ds.b	1				; offset: $3 (3)		; currency symbol
currSym2				 ds.b	1				; offset: $4 (4)
currSym3				 ds.b	1				; offset: $5 (5)
currFmt					 ds.b	1				; offset: $6 (6)		; currency format flags
dateOrder				 ds.b	1				; offset: $7 (7)		; order of short date elements: mdy, dmy, etc.
shrtDateFmt				 ds.b	1				; offset: $8 (8)		; format flags for each short date element
dateSep					 ds.b	1				; offset: $9 (9)		; date separator character
timeCycle				 ds.b	1				; offset: $A (10)		; specifies time cycle: 0..23, 1..12, or 0..11
timeFmt					 ds.b	1				; offset: $B (11)		; format flags for each time element
mornStr					 ds.b	4				; offset: $C (12)		; trailing string for AM if 12-hour cycle
eveStr					 ds.b	4				; offset: $10 (16)		; trailing string for PM if 12-hour cycle
timeSep					 ds.b	1				; offset: $14 (20)		; time separator character
time1Suff				 ds.b	1				; offset: $15 (21)		; trailing string for AM if 24-hour cycle
time2Suff				 ds.b	1				; offset: $16 (22)
time3Suff				 ds.b	1				; offset: $17 (23)
time4Suff				 ds.b	1				; offset: $18 (24)
time5Suff				 ds.b	1				; offset: $19 (25)		; trailing string for PM if 24-hour cycle
time6Suff				 ds.b	1				; offset: $1A (26)
time7Suff				 ds.b	1				; offset: $1B (27)
time8Suff				 ds.b	1				; offset: $1C (28)
metricSys				 ds.b	1				; offset: $1D (29)		; 255 if metric, 0 if inches etc.
intl0Vers				 ds.w	1				; offset: $1E (30)		; region code (hi byte) and version (lo byte)
sizeof					 EQU *					; size:   $20 (32)
						ENDR
; typedef struct Intl0Rec *				Intl0Ptr

; typedef Intl0Ptr *					Intl0Hndl

Intl1Rec				RECORD 0
days					 ds.b	7 * Str15.sizeof ; offset: $0 (0)		; day names
months					 ds.b	12 * Str15.sizeof ; offset: $70 (112)	; month names
suppressDay				 ds.b	1				; offset: $130 (304)	; 255 for no day, or flags to suppress any element
lngDateFmt				 ds.b	1				; offset: $131 (305)	; order of long date elements
dayLeading0				 ds.b	1				; offset: $132 (306)	; 255 for leading 0 in day number
abbrLen					 ds.b	1				; offset: $133 (307)	; length for abbreviating names
st0						 ds.b	4				; offset: $134 (308)	; separator strings for long date format
st1						 ds.b	4				; offset: $138 (312)
st2						 ds.b	4				; offset: $13C (316)
st3						 ds.b	4				; offset: $140 (320)
st4						 ds.b	4				; offset: $144 (324)
intl1Vers				 ds.w	1				; offset: $148 (328)	; region code (hi byte) and version (lo byte)
localRtn				 ds.w	1				; offset: $14A (330) <-- really an array of length one ; now a flag for opt extension
sizeof					 EQU *					; size:   $14C (332)
						ENDR
; typedef struct Intl1Rec *				Intl1Ptr

; typedef Intl1Ptr *					Intl1Hndl

; fields for optional itl1 extension
Itl1ExtRec				RECORD 0
base					 ds		Intl1Rec		; offset: $0 (0)		; un-extended Intl1Rec
version					 ds.w	1				; offset: $14C (332)
format					 ds.w	1				; offset: $14E (334)
calendarCode			 ds.w	1				; offset: $150 (336)	; calendar code for this itl1 resource
extraDaysTableOffset	 ds.l	1				; offset: $152 (338)	; offset in itl1 to extra days table
extraDaysTableLength	 ds.l	1				; offset: $156 (342)	; length of extra days table
extraMonthsTableOffset	 ds.l	1				; offset: $15A (346)	; offset in itl1 to extra months table
extraMonthsTableLength	 ds.l	1				; offset: $15E (350)	; length of extra months table
abbrevDaysTableOffset	 ds.l	1				; offset: $162 (354)	; offset in itl1 to abbrev days table
abbrevDaysTableLength	 ds.l	1				; offset: $166 (358)	; length of abbrev days table
abbrevMonthsTableOffset	 ds.l	1				; offset: $16A (362)	; offset in itl1 to abbrev months table
abbrevMonthsTableLength	 ds.l	1				; offset: $16E (366)	; length of abbrev months table
extraSepsTableOffset	 ds.l	1				; offset: $172 (370)	; offset in itl1 to extra seps table
extraSepsTableLength	 ds.l	1				; offset: $176 (374)	; length of extra seps table
tables					 ds.w	1				; offset: $17A (378) <-- really an array of length one ; now a flag for opt extension
sizeof					 EQU *					; size:   $17C (380)
						ENDR
;  String data structure for itl2 stack frames 
IUStrData				RECORD 0
curChar					 ds.w	1				; offset: $0 (0)		;  current character. 
mapChar					 ds.w	1				; offset: $2 (2)		;  projected character. 
decChar					 ds.w	1				; offset: $4 (4)		;  decision char for weak equality. 
bufChar					 ds.b	1				; offset: $6 (6)		;  buffer for expansion. 
justAfter				 ds.b	1				; offset: $7 (7)		;  boolean for AE vs ligature-AE, etc. 
ignChar					 ds.b	1				; offset: $8 (8)		;  flag: ignore char. 
noFetch					 ds.b	1				; offset: $9 (9)		;  flag: no fetch of next. 
strCnt					 ds.w	1				; offset: $A (10)		;  length word. 
strPtr					 ds.l	1				; offset: $C (12)		;  current ptr to string. 
sizeof					 EQU *					; size:   $10 (16)
						ENDR
;  Stack from for itl2 sorting hooks (pre System 7) 
IUSortFrame     record  {oldA6},decrement
result          ds.w    1
aStrText        ds.l    1
bStrText        ds.l    1
aStrLen         ds.w    1
bStrLen         ds.w    1
return          ds.l    1
oldA6           ds.l    1
aInfo           ds      IUStrData
bInfo           ds      IUStrData
wantMag         ds.b    1               ; 0 to use primary differences only; else 1
weakEq          ds.b    1               ; Signals at most weak equality.
msLock          ds.b    1               ; (obsolete, not used)
weakMag         ds.b    1               ; -1 to force magnitude result (-1,0,1); else 0
supStorage      ds.b    18              ; extra storage.
weakAPtr        ds.l    1               ; sup. pointer
weakBPtr        ds.l    1               ; sup. pointer
lkSize          equ     *               ; frame size.
paramBytes      equ     aStrText-return
                endr
;  Stack from for itl2 sorting hooks (System 7 and later; adds itl2Handle) 
IUNSortFrame    record  {oldA6},decrement
result          ds.w    1
aStrText        ds.l    1
bStrText        ds.l    1
aStrLen         ds.w    1
bStrLen         ds.w    1
return          ds.l    1
oldA6           ds.l    1
aInfo           ds      IUStrData
bInfo           ds      IUStrData
wantMag         ds.b    1               ; 0 to use primary differences only; else 1
weakEq          ds.b    1               ; Signals at most weak equality.
msLock          ds.b    1               ; (obsolete, not used)
weakMag         ds.b    1               ; -1 to force magnitude result (-1,0,1); else 0
supStorage      ds.b    18              ; extra storage.
weakAPtr        ds.l    1               ; sup. pointer
weakBPtr        ds.l    1               ; sup. pointer
itl2Handle      ds.l    1               ; itl2 handle, if supplied
lkSize          equ     *               ; frame size.
paramBytes      equ     aStrText-return
                endr
UntokenTable			RECORD 0
len						 ds.w	1				; offset: $0 (0)
lastToken				 ds.w	1				; offset: $2 (2)
index					 ds.w	256				; offset: $4 (4)		; index table; last = lastToken
sizeof					 EQU *					; size:   $204 (516)
						ENDR
; typedef struct UntokenTable *			UntokenTablePtr

; typedef UntokenTablePtr *				UntokenTableHandle

WideChar				RECORD 0
char16					 ds.w	1				; offset: $0 (0)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
WideCharArr				RECORD 0
size					 ds.w	1				; offset: $0 (0)
data					 ds.b	10 * WideChar.sizeof ; offset: $2 (2)
sizeof					 EQU *					; size:   $16 (22)
						ENDR
NumberParts				RECORD 0
version					 ds.w	1				; offset: $0 (0)
data					 ds.b	31 * WideChar.sizeof ; offset: $2 (2)	; index by [tokLeftQuote..tokMaxSymbols]
pePlus					 ds		WideCharArr		; offset: $40 (64)
peMinus					 ds		WideCharArr		; offset: $56 (86)
peMinusPlus				 ds		WideCharArr		; offset: $6C (108)
altNumTable				 ds		WideCharArr		; offset: $82 (130)
reserved				 ds.b	20				; offset: $98 (152)
sizeof					 EQU *					; size:   $AC (172)
						ENDR
; typedef struct NumberParts *			NumberPartsPtr


Itl4Rec					RECORD 0
flags					 ds.w	1				; offset: $0 (0)		; reserved
resourceType			 ds.l	1				; offset: $2 (2)		; contains 'itl4'
resourceNum				 ds.w	1				; offset: $6 (6)		; resource ID
version					 ds.w	1				; offset: $8 (8)		; version number
resHeader1				 ds.l	1				; offset: $A (10)		; reserved
resHeader2				 ds.l	1				; offset: $E (14)		; reserved
numTables				 ds.w	1				; offset: $12 (18)		; number of tables, one-based
mapOffset				 ds.l	1				; offset: $14 (20)		; offset to table that maps byte to token
strOffset				 ds.l	1				; offset: $18 (24)		; offset to routine that copies canonical string
fetchOffset				 ds.l	1				; offset: $1C (28)		; offset to routine that gets next byte of character
unTokenOffset			 ds.l	1				; offset: $20 (32)		; offset to table that maps token to canonical string
defPartsOffset			 ds.l	1				; offset: $24 (36)		; offset to default number parts table
resOffset6				 ds.l	1				; offset: $28 (40)		; reserved
resOffset7				 ds.l	1				; offset: $2C (44)		; reserved
resOffset8				 ds.l	1				; offset: $30 (48)		; reserved
sizeof					 EQU *					; size:   $34 (52)
						ENDR
; typedef struct Itl4Rec *				Itl4Ptr

; typedef Itl4Ptr *						Itl4Handle

;  New NItl4Rec for System 7.0: 
NItl4Rec				RECORD 0
flags					 ds.w	1				; offset: $0 (0)		; reserved
resourceType			 ds.l	1				; offset: $2 (2)		; contains 'itl4'
resourceNum				 ds.w	1				; offset: $6 (6)		; resource ID
version					 ds.w	1				; offset: $8 (8)		; version number
format					 ds.w	1				; offset: $A (10)		; format code
resHeader				 ds.w	1				; offset: $C (12)		; reserved
resHeader2				 ds.l	1				; offset: $E (14)		; reserved
numTables				 ds.w	1				; offset: $12 (18)		; number of tables, one-based
mapOffset				 ds.l	1				; offset: $14 (20)		; offset to table that maps byte to token
strOffset				 ds.l	1				; offset: $18 (24)		; offset to routine that copies canonical string
fetchOffset				 ds.l	1				; offset: $1C (28)		; offset to routine that gets next byte of character
unTokenOffset			 ds.l	1				; offset: $20 (32)		; offset to table that maps token to canonical string
defPartsOffset			 ds.l	1				; offset: $24 (36)		; offset to default number parts table
whtSpListOffset			 ds.l	1				; offset: $28 (40)		; offset to white space code list
resOffset7				 ds.l	1				; offset: $2C (44)		; reserved
resOffset8				 ds.l	1				; offset: $30 (48)		; reserved
resLength1				 ds.w	1				; offset: $34 (52)		; reserved
resLength2				 ds.w	1				; offset: $36 (54)		; reserved
resLength3				 ds.w	1				; offset: $38 (56)		; reserved
unTokenLength			 ds.w	1				; offset: $3A (58)		; length of untoken table
defPartsLength			 ds.w	1				; offset: $3C (60)		; length of default number parts table
whtSpListLength			 ds.w	1				; offset: $3E (62)		; length of white space code list
resLength7				 ds.w	1				; offset: $40 (64)		; reserved
resLength8				 ds.w	1				; offset: $42 (66)		; reserved
sizeof					 EQU *					; size:   $44 (68)
						ENDR
; typedef struct NItl4Rec *				NItl4Ptr

; typedef NItl4Ptr *					NItl4Handle


TableDirectoryRecord	RECORD 0
tableSignature			 ds.l	1				; offset: $0 (0)		; 4 byte long table name 
reserved				 ds.l	1				; offset: $4 (4)		; Reserved for internal use 
tableStartOffset		 ds.l	1				; offset: $8 (8)		; Table start offset in byte
tableSize				 ds.l	1				; offset: $C (12)		; Table size in byte
sizeof					 EQU *					; size:   $10 (16)
						ENDR
Itl5Record				RECORD 0
versionNumber			 ds.l	1				; offset: $0 (0)		; itl5 resource version number 
numberOfTables			 ds.w	1				; offset: $4 (4)		; Number of tables it contains 
reserved				 ds.w	3				; offset: $6 (6)		; Reserved for internal use 
tableDirectory			 ds		TableDirectoryRecord ; offset: $C (12) <-- really an array of length one ; Table directory records 
sizeof					 EQU *					; size:   $1C (28)
						ENDR
RuleBasedTrslRecord		RECORD 0
sourceType				 ds.w	1				; offset: $0 (0)		; Transliterate target type for the LHS of the rule 
targetType				 ds.w	1				; offset: $2 (2)		; Transliterate target type for the RHS of the rule 
formatNumber			 ds.w	1				; offset: $4 (4)		; Transliterate resource format number 
propertyFlag			 ds.w	1				; offset: $6 (6)		; Transliterate property flags 
numberOfRules			 ds.w	1				; offset: $8 (8)		; Number of rules following this field 
sizeof					 EQU *					; size:   $A (10)
						ENDR

ItlcRecord				RECORD 0
itlcSystem				 ds.w	1				; offset: $0 (0)		; default system script
itlcReserved			 ds.w	1				; offset: $2 (2)		; reserved
itlcFontForce			 ds.b	1				; offset: $4 (4)		; default font force flag
itlcIntlForce			 ds.b	1				; offset: $5 (5)		; default intl force flag
itlcOldKybd				 ds.b	1				; offset: $6 (6)		; MacPlus intl keybd flag
itlcFlags				 ds.b	1				; offset: $7 (7)		; general flags
itlcIconOffset			 ds.w	1				; offset: $8 (8)		; keyboard icon offset; not used in 7.0
itlcIconSide			 ds.b	1				; offset: $A (10)		; keyboard icon side; not used in 7.0
itlcIconRsvd			 ds.b	1				; offset: $B (11)		; rsvd for other icon info
itlcRegionCode			 ds.w	1				; offset: $C (12)		; preferred verXxx code
itlcSysFlags			 ds.w	1				; offset: $E (14)		; flags for setting system globals
itlcReserved4			 ds.b	32				; offset: $10 (16)		; for future use
sizeof					 EQU *					; size:   $30 (48)
						ENDR
ItlbRecord				RECORD 0
itlbNumber				 ds.w	1				; offset: $0 (0)		; itl0 id number
itlbDate				 ds.w	1				; offset: $2 (2)		; itl1 id number
itlbSort				 ds.w	1				; offset: $4 (4)		; itl2 id number
itlbFlags				 ds.w	1				; offset: $6 (6)		; Script flags
itlbToken				 ds.w	1				; offset: $8 (8)		; itl4 id number
itlbEncoding			 ds.w	1				; offset: $A (10)		; itl5 ID # (optional; char encoding)
itlbLang				 ds.w	1				; offset: $C (12)		; current language for script 
itlbNumRep				 ds.b	1				; offset: $E (14)		; number representation code
itlbDateRep				 ds.b	1				; offset: $F (15)		; date representation code 
itlbKeys				 ds.w	1				; offset: $10 (16)		; KCHR id number
itlbIcon				 ds.w	1				; offset: $12 (18)		; ID # of SICN or kcs#/kcs4/kcs8 suite.
sizeof					 EQU *					; size:   $14 (20)
						ENDR
;  New ItlbExtRecord structure for System 7.0 
ItlbExtRecord			RECORD 0
base					 ds		ItlbRecord		; offset: $0 (0)		; un-extended ItlbRecord
itlbLocalSize			 ds.l	1				; offset: $14 (20)		; size of script's local record
itlbMonoFond			 ds.w	1				; offset: $18 (24)		; default monospace FOND ID
itlbMonoSize			 ds.w	1				; offset: $1A (26)		; default monospace font size
itlbPrefFond			 ds.w	1				; offset: $1C (28)		; preferred FOND ID
itlbPrefSize			 ds.w	1				; offset: $1E (30)		; preferred font size
itlbSmallFond			 ds.w	1				; offset: $20 (32)		; default small FOND ID
itlbSmallSize			 ds.w	1				; offset: $22 (34)		; default small font size
itlbSysFond				 ds.w	1				; offset: $24 (36)		; default system FOND ID
itlbSysSize				 ds.w	1				; offset: $26 (38)		; default system font size
itlbAppFond				 ds.w	1				; offset: $28 (40)		; default application FOND ID
itlbAppSize				 ds.w	1				; offset: $2A (42)		; default application font size
itlbHelpFond			 ds.w	1				; offset: $2C (44)		; default Help Mgr FOND ID
itlbHelpSize			 ds.w	1				; offset: $2E (46)		; default Help Mgr font size
itlbValidStyles			 ds.b	1				; offset: $30 (48)		; set of valid styles for script
itlbAliasStyle			 ds.b	1				; offset: $31 (49)		; style (set) to mark aliases
sizeof					 EQU *					; size:   $32 (50)
						ENDR


	ENDIF ; __INTLRESOURCES__ 


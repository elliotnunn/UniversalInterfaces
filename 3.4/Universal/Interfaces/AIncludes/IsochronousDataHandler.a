;
;    File:       IsochronousDataHandler.a
;
;    Contains:   The defines the client API to an Isochronous Data Handler, which is
;
;    Version:    Technology: xxx put version here xxx
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1997-2001 by Apple Computer, Inc., all rights reserved.
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;


	IF &TYPE('__ISOCHRONOUSDATAHANDLER__') = 'UNDEFINED' THEN
__ISOCHRONOUSDATAHANDLER__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__MOVIESFORMAT__') = 'UNDEFINED' THEN
	include 'MoviesFormat.a'
	ENDIF
	IF &TYPE('__QUICKTIMECOMPONENTS__') = 'UNDEFINED' THEN
	include 'QuickTimeComponents.a'
	ENDIF





kIDHComponentType				EQU		'ihlr'				; Component type
kIDHSubtypeDV					EQU		'dv  '				; Subtype for DV (over FireWire)
kIDHSubtypeFireWireConference	EQU		'fwc '				; Subtype for FW Conference

;  Version of Isochronous Data Handler API

kIDHInterfaceVersion1			EQU		$0001				; Initial relase (Summer '99)

;  atom types


kIDHDeviceListAtomType			EQU		'dlst'
kIDHDeviceAtomType				EQU		'devc'				; to be defined elsewhere
kIDHIsochServiceAtomType		EQU		'isoc'
kIDHIsochModeAtomType			EQU		'mode'
kIDHDeviceIDType				EQU		'dvid'
kIDHDefaultIOType				EQU		'dfio'
kIDHIsochVersionAtomType		EQU		'iver'
kIDHUniqueIDType				EQU		'unid'
kIDHNameAtomType				EQU		'name'
kIDHUseCMPAtomType				EQU		'ucmp'
kIDHIsochMediaType				EQU		'av  '
kIDHDataTypeAtomType			EQU		'dtyp'
kIDHDataSizeAtomType			EQU		'dsiz'				; ??? packet size vs. buffer size
kIDHDataBufferSizeAtomType		EQU		'dbuf'				; ??? packet size vs. buffer size
kIDHDataIntervalAtomType		EQU		'intv'
kIDHDataIODirectionAtomType		EQU		'ddir'
kIDHSoundMediaAtomType			EQU		'soun'
kIDHSoundTypeAtomType			EQU		'type'
kIDHSoundChannelCountAtomType	EQU		'ccnt'
kIDHSoundSampleSizeAtomType		EQU		'ssiz'
kIDHSoundSampleRateAtomType		EQU		'srat'				; same as video out... (what does this comment mean?)
kIDHVideoMediaAtomType			EQU		'vide'
kIDHVideoDimensionsAtomType		EQU		'dimn'
kIDHVideoResolutionAtomType		EQU		'resl'
kIDHVideoRefreshRateAtomType	EQU		'refr'
kIDHVideoPixelTypeAtomType		EQU		'pixl'
kIDHVideoDecompressorAtomType	EQU		'deco'
kIDHVideoDecompressorTypeAtomType EQU	'dety'
kIDHVideoDecompressorContinuousAtomType EQU 'cont'
kIDHVideoDecompressorComponentAtomType EQU 'cmpt'
;  I/O Flags 

kIDHDataTypeIsInput				EQU		$00000001
kIDHDataTypeIsOutput			EQU		$00000002
kIDHDataTypeIsInputAndOutput	EQU		$00000004

;  Permission Flags 

kIDHOpenForReadTransactions		EQU		$00000001
kIDHOpenForWriteTransactions	EQU		$00000002
kIDHOpenWithExclusiveAccess		EQU		$00000004
kIDHOpenWithHeldBuffers			EQU		$00000008			; IDH will hold buffer until ReleaseBuffer()
kIDHCloseForReadTransactions	EQU		$00000010
kIDHCloseForWriteTransactions	EQU		$00000020


;   Errors 
;    These REALLY need to be moved into Errors.h
;   ••• needs officially assigned numbers



kIDHErrDeviceDisconnected		EQU		-14101
kIDHErrInvalidDeviceID			EQU		-14102
kIDHErrDeviceInUse				EQU		-14104
kIDHErrDeviceNotOpened			EQU		-14105
kIDHErrDeviceBusy				EQU		-14106
kIDHErrDeviceReadError			EQU		-14107
kIDHErrDeviceWriteError			EQU		-14108
kIDHErrDeviceNotConfigured		EQU		-14109
kIDHErrDeviceList				EQU		-14110
kIDHErrCompletionPending		EQU		-14111
kIDHErrDeviceTimeout			EQU		-14112
kIDHErrInvalidIndex				EQU		-14113
kIDHErrDeviceCantRead			EQU		-14114
kIDHErrDeviceCantWrite			EQU		-14115
kIDHErrCallNotSupported			EQU		-14116



;  Holds Device Identification...
; typedef UInt32 						IDHDeviceID


kIDHInvalidDeviceID				EQU		0
kIDHDeviceIDEveryDevice			EQU		$FFFFFFFF

;   Isoch Interval Atom Data
IDHIsochInterval		RECORD 0
duration				 ds.l	1				; offset: $0 (0)
scale					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  Need to fix this.  For now, cast this as a FWReferenceID



;   Isoch Device Status
;    This is atom-like, but isn’t an atom


IDHDeviceStatus			RECORD 0
version					 ds.l	1				; offset: $0 (0)
physicallyConnected		 ds.b	1				; offset: $4 (4)
readEnabled				 ds.b	1				; offset: $5 (5)
writeEnabled			 ds.b	1				; offset: $6 (6)
exclusiveAccess			 ds.b	1				; offset: $7 (7)
currentBandwidth		 ds.l	1				; offset: $8 (8)
currentChannel			 ds.l	1				; offset: $C (12)
localNodeID				 ds.l	1				; offset: $10 (16)		; ••• may go in atoms 
inputStandard			 ds.w	1				; offset: $14 (20)		;  One of the QT input standards
deviceActive			 ds.b	1				; offset: $16 (22)
						 ORG 24
sizeof					 EQU *					; size:   $18 (24)
						ENDR

;   Isochronous Data Handler Events
;    


; typedef UInt32 						IDHEvent


kIDHEventInvalid				EQU		0
kIDHEventDeviceAdded			EQU		$00000001			; A new device has been added to the bus
kIDHEventDeviceRemoved			EQU		$00000002			; A device has been removed from the bus
kIDHEventDeviceChanged			EQU		$00000004			; Some device has changed state on the bus
kIDHEventReadEnabled			EQU		$00000008			; A client has enabled a device for read
kIDHEventReserved1				EQU		$00000010			; Reserved for future use
kIDHEventReadDisabled			EQU		$00000020			; A client has disabled a device from read
kIDHEventWriteEnabled			EQU		$00000040			; A client has enabled a device for write
kIDHEventReserved2				EQU		$00000080			; Reserved for future use
kIDHEventWriteDisabled			EQU		$00000100			; A client has disabled a device for write
kIDHEventEveryEvent				EQU		$FFFFFFFF
; typedef UInt32 						IDHNotificationID

IDHEventHeader			RECORD 0
deviceID				 ds.l	1				; offset: $0 (0)		;  Device which generated event
notificationID			 ds.l	1				; offset: $4 (4)
event					 ds.l	1				; offset: $8 (8)		;  What the event is
sizeof					 EQU *					; size:   $C (12)
						ENDR




;   IDHGenericEvent
;    An IDH will often have to post events from at interrupt time.  Since memory
;    allocation cannot occur from the interrupt handler, the IDH can preallocate
;    storage needed for handling the event by creating some IDHGenericEvent items.
;    Subsequently, when an event is generated, the type of event (specified in the
;    IDHEventHeader) will dictate how the IDHGenericEvent should be interpretted.
;    
;    IMPORTANT NOTE : This means that a specific event structure can NEVER be greater
;    than the size of the generic one.
;    


IDHGenericEvent			RECORD 0
eventHeader				 ds		IDHEventHeader ; offset: $0 (0)
pad						 ds.l	4				; offset: $C (12)
sizeof					 EQU *					; size:   $1C (28)
						ENDR

;   IDHDeviceConnectionEvent
;    For kIDHEventDeviceAdded or kIDHEventDeviceRemoved events.


IDHDeviceConnectionEvent RECORD 0
eventHeader				 ds		IDHEventHeader ; offset: $0 (0)
sizeof					 EQU *					; size:   $C (12)
						ENDR

;   IDHDeviceIOEnableEvent
;    For kIDHEventReadEnabled, kIDHEventReadDisabled, kIDHEventWriteEnabled, or
;    kIDHEventWriteDisabled.


IDHDeviceIOEnableEvent	RECORD 0
eventHeader				 ds		IDHEventHeader ; offset: $0 (0)
sizeof					 EQU *					; size:   $C (12)
						ENDR
IDHParameterBlock		RECORD 0
reserved1				 ds.l	1				; offset: $0 (0)
reserved2				 ds.w	1				; offset: $4 (4)
buffer					 ds.l	1				; offset: $6 (6)
requestedCount			 ds.l	1				; offset: $A (10)
actualCount				 ds.l	1				; offset: $E (14)
completionProc			 ds.l	1				; offset: $12 (18)
refCon					 ds.l	1				; offset: $16 (22)
result					 ds.w	1				; offset: $1A (26)
sizeof					 EQU *					; size:   $1C (28)
						ENDR
IDHResolution			RECORD 0
x						 ds.l	1				; offset: $0 (0)
y						 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
IDHDimension			RECORD 0
x						 ds.l	1				; offset: $0 (0)
y						 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR


; *  IDHGetDeviceList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHGetDeviceList(ComponentInstance idh, QTAtomContainer *deviceList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHGetDeviceList
			move.l              #$00040001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHGetDeviceList
	ENDIF


; *  IDHGetDeviceConfiguration()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHGetDeviceConfiguration(ComponentInstance idh, QTAtomSpec *configurationID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHGetDeviceConfiguration
			move.l              #$00040002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHGetDeviceConfiguration
	ENDIF


; *  IDHSetDeviceConfiguration()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHSetDeviceConfiguration(ComponentInstance idh, const QTAtomSpec *configurationID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHSetDeviceConfiguration
			move.l              #$00040003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHSetDeviceConfiguration
	ENDIF


; *  IDHGetDeviceStatus()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHGetDeviceStatus(ComponentInstance idh, const QTAtomSpec *configurationID, IDHDeviceStatus *status)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHGetDeviceStatus
			move.l              #$00080004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHGetDeviceStatus
	ENDIF


; *  IDHGetDeviceClock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHGetDeviceClock(ComponentInstance idh, Component *clock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHGetDeviceClock
			move.l              #$00040005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHGetDeviceClock
	ENDIF


; *  IDHOpenDevice()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHOpenDevice(ComponentInstance idh, UInt32 permissions)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHOpenDevice
			move.l              #$00040006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHOpenDevice
	ENDIF


; *  IDHCloseDevice()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHCloseDevice(ComponentInstance idh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHCloseDevice
			move.l              #$00000007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHCloseDevice
	ENDIF


; *  IDHRead()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHRead(ComponentInstance idh, IDHParameterBlock *pb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHRead
			move.l              #$00040008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHRead
	ENDIF


; *  IDHWrite()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHWrite(ComponentInstance idh, IDHParameterBlock *pb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHWrite
			move.l              #$00040009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHWrite
	ENDIF


; *  IDHNewNotification()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHNewNotification(ComponentInstance idh, IDHDeviceID deviceID, IDHNotificationProc notificationProc, void *userData, IDHNotificationID *notificationID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHNewNotification
			move.l              #$0010000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHNewNotification
	ENDIF


; *  IDHNotifyMeWhen()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHNotifyMeWhen(ComponentInstance idh, IDHNotificationID notificationID, IDHEvent events)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHNotifyMeWhen
			move.l              #$0008000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHNotifyMeWhen
	ENDIF


; *  IDHCancelNotification()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHCancelNotification(ComponentInstance idh, IDHNotificationID notificationID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHCancelNotification
			move.l              #$0004000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHCancelNotification
	ENDIF


; *  IDHDisposeNotification()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHDisposeNotification(ComponentInstance idh, IDHNotificationID notificationID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHDisposeNotification
			move.l              #$0004000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHDisposeNotification
	ENDIF


; *  IDHReleaseBuffer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHReleaseBuffer(ComponentInstance idh, IDHParameterBlock *pb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHReleaseBuffer
			move.l              #$0004000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHReleaseBuffer
	ENDIF


; *  IDHCancelPendingIO()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHCancelPendingIO(ComponentInstance idh, IDHParameterBlock *pb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHCancelPendingIO
			move.l              #$0004000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHCancelPendingIO
	ENDIF


; *  IDHGetDeviceControl()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHGetDeviceControl(ComponentInstance idh, ComponentInstance *deviceControl)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHGetDeviceControl
			move.l              #$00040010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHGetDeviceControl
	ENDIF


; *  IDHUpdateDeviceList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in IDHLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         not available
; 

;
; pascal ComponentResult IDHUpdateDeviceList(ComponentInstance idh, QTAtomContainer *deviceList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_IDHUpdateDeviceList
			move.l              #$00040011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IDHUpdateDeviceList
	ENDIF



	ENDIF ; __ISOCHRONOUSDATAHANDLER__ 


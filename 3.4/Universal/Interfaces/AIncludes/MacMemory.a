;
;    File:       MacMemory.a
;
;    Contains:   Memory Manager Interfaces.
;
;    Version:    Technology: Mac OS 9
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1985-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__MACMEMORY__') = 'UNDEFINED' THEN
__MACMEMORY__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF


maxSize							EQU		$7FFFFFF0			;the largest block possible

defaultPhysicalEntryCount		EQU		8

															; values returned from the GetPageState function 
kPageInMemory					EQU		0
kPageOnDisk						EQU		1
kNotPaged						EQU		2

															; masks for Zone->heapType field 
k32BitHeap						EQU		1					; valid in all Memory Managers 
kNewStyleHeap					EQU		2					; true if new Heap Manager is present 
kNewDebugHeap					EQU		4					; true if new Heap Manager is running in debug mode on this heap 

;  bits for use with HGetState/HSetState

kHandleIsResourceBit			EQU		5
kHandlePurgeableBit				EQU		6
kHandleLockedBit				EQU		7
;  masks for use with HGetState/HSetState

kHandleIsResourceMask			EQU		$20
kHandlePurgeableMask			EQU		$40
kHandleLockedMask				EQU		$80

Zone					RECORD 0
bkLim					 ds.l	1				; offset: $0 (0)
purgePtr				 ds.l	1				; offset: $4 (4)
hFstFree				 ds.l	1				; offset: $8 (8)
zcbFree					 ds.l	1				; offset: $C (12)
gzProc					 ds.l	1				; offset: $10 (16)
moreMast				 ds.w	1				; offset: $14 (20)
flags					 ds.w	1				; offset: $16 (22)
cntRel					 ds.w	1				; offset: $18 (24)
maxRel					 ds.w	1				; offset: $1A (26)
cntNRel					 ds.w	1				; offset: $1C (28)
heapType				 ds.b	1				; offset: $1E (30)		;  previously "maxNRel", now holds flags (e.g. k32BitHeap)
unused					 ds.b	1				; offset: $1F (31)
cntEmpty				 ds.w	1				; offset: $20 (32)
cntHandles				 ds.w	1				; offset: $22 (34)
minCBFree				 ds.l	1				; offset: $24 (36)
purgeProc				 ds.l	1				; offset: $28 (40)
sparePtr				 ds.l	1				; offset: $2C (44)
allocPtr				 ds.l	1				; offset: $30 (48)
heapData				 ds.w	1				; offset: $34 (52)
sizeof					 EQU *					; size:   $36 (54)
						ENDR
; typedef struct Zone *					THz

; typedef THz *							THzPtr

MemoryBlock				RECORD 0
address					 ds.l	1				; offset: $0 (0)
count					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
LogicalToPhysicalTable	RECORD 0
logical					 ds		MemoryBlock		; offset: $0 (0)
physical				 ds.b	8 * MemoryBlock.sizeof ; offset: $8 (8)
sizeof					 EQU *					; size:   $48 (72)
						ENDR
; typedef short 						PageState

; typedef short 						StatusRegisterContents


kVolumeVirtualMemoryInfoVersion1 EQU	1					; first version of VolumeVirtualMemoryInfo
VolumeVirtualMemoryInfo	RECORD 0
version					 ds.l	1				; offset: $0 (0)		;  Input: Version of the VolumeVirtualMemoryInfo structure
volumeRefNum			 ds.w	1				; offset: $4 (4)		;  Input: volume reference number
inUse					 ds.b	1				; offset: $6 (6)		;  output: true if volume is currently used for file mapping
_fill					 ds.b	1				; offset: $7 (7)
vmOptions				 ds.l	1				; offset: $8 (8)		;  output: tells what volume can support (same as DriverGestaltVMOptionsResponse vmOptions bits in DriverGestalt)
;  end of kVolumeVirtualMemoryInfoVersion1 structure
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct VolumeVirtualMemoryInfo * VolumeVirtualMemoryInfoPtr


; *  NewGrowZoneUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewPurgeUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewUserFnUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeGrowZoneUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposePurgeUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeUserFnUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeGrowZoneUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokePurgeUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeUserFnUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

	IF CALL_NOT_IN_CARBON THEN

; *  GetApplLimit()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Ptr GetApplLimit(void)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetApplLimit         &dest=(sp)
			move.l            $0130,&dest
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetApplLimit
	ENDIF


; *  SystemZone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal THz SystemZone(void)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SystemZone           &dest=(sp)
			move.l            $02A6,&dest
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SystemZone
	ENDIF


; *  ApplicationZone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal THz ApplicationZone(void)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ApplicationZone      &dest=(sp)
			move.l            $02AA,&dest
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ApplicationZone
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  GZSaveHnd()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Handle GZSaveHnd(void)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GZSaveHnd            &dest=(sp)
			move.l            $0328,&dest
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GZSaveHnd
	ENDIF


; *  TopMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Ptr TopMem(void)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TopMem               &dest=(sp)
			move.l            $0108,&dest
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TopMem
	ENDIF


; *  MemError()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr MemError(void)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MemError             &dest=(sp)
			move.w            $0220,&dest
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MemError
	ENDIF


	IF CALL_NOT_IN_CARBON THEN

; *  GetZone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal THz GetZone(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	THz             <= A0
		_GetZone:	OPWORD	$A11A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetZone
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  NewHandle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Handle NewHandle(Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	byteCount       => D0
		; returns:
		;	Handle          <= A0
		_NewHandle:	OPWORD	$A122
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewHandle
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  NewHandleSys()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Handle NewHandleSys(Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	byteCount       => D0
		; returns:
		;	Handle          <= A0
		_NewHandleSys:	OPWORD	$A522
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewHandleSys
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  NewHandleClear()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Handle NewHandleClear(Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	byteCount       => D0
		; returns:
		;	Handle          <= A0
		_NewHandleClear:	OPWORD	$A322
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewHandleClear
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  NewHandleSysClear()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Handle NewHandleSysClear(Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	byteCount       => D0
		; returns:
		;	Handle          <= A0
		_NewHandleSysClear:	OPWORD	$A722
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewHandleSysClear
	ENDIF


; *  HandleZone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal THz HandleZone(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		; returns:
		;	THz             <= A0
		_HandleZone:	OPWORD	$A126
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HandleZone
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  RecoverHandle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Handle RecoverHandle(Ptr p)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	p               => A0
		; returns:
		;	Handle          <= A0
		_RecoverHandle:	OPWORD	$A128
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RecoverHandle
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  RecoverHandleSys()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Handle RecoverHandleSys(Ptr p)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	p               => A0
		; returns:
		;	Handle          <= A0
		_RecoverHandleSys:	OPWORD	$A528
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RecoverHandleSys
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  NewPtr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Ptr NewPtr(Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	byteCount       => D0
		; returns:
		;	Ptr             <= A0
		_NewPtr:	OPWORD	$A11E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewPtr
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  NewPtrSys()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Ptr NewPtrSys(Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	byteCount       => D0
		; returns:
		;	Ptr             <= A0
		_NewPtrSys:	OPWORD	$A51E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewPtrSys
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  NewPtrClear()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Ptr NewPtrClear(Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	byteCount       => D0
		; returns:
		;	Ptr             <= A0
		_NewPtrClear:	OPWORD	$A31E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewPtrClear
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  NewPtrSysClear()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Ptr NewPtrSysClear(Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	byteCount       => D0
		; returns:
		;	Ptr             <= A0
		_NewPtrSysClear:	OPWORD	$A71E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewPtrSysClear
	ENDIF


; *  PtrZone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal THz PtrZone(Ptr p)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	p               => A0
		; returns:
		;	THz             <= A0
		_PtrZone:	OPWORD	$A148
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PtrZone
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  MaxBlock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal long MaxBlock(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	long            <= D0
		_MaxBlock:	OPWORD	$A061
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MaxBlock
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  MaxBlockSys()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal long MaxBlockSys(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	long            <= D0
		_MaxBlockSys:	OPWORD	$A461
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MaxBlockSys
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  StackSpace()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal long StackSpace(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	long            <= D0
		_StackSpace:	OPWORD	$A065
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StackSpace
	ENDIF


; *  NewEmptyHandle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Handle NewEmptyHandle(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	Handle          <= A0
		_NewEmptyHandle:	OPWORD	$A166
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewEmptyHandle
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  NewEmptyHandleSys()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Handle NewEmptyHandleSys(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	Handle          <= A0
		_NewEmptyHandleSys:	OPWORD	$A566
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION NewEmptyHandleSys
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  HLock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void HLock(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		_HLock:	OPWORD	$A029
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HLock
	ENDIF


; *  HUnlock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void HUnlock(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		_HUnlock:	OPWORD	$A02A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HUnlock
	ENDIF


; *  HPurge()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void HPurge(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		_HPurge:	OPWORD	$A049
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HPurge
	ENDIF


; *  HNoPurge()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void HNoPurge(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		_HNoPurge:	OPWORD	$A04A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HNoPurge
	ENDIF


; *  HLockHi()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void HLockHi(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		Macro
		_HLockHi
			dc.w            	$A064
			dc.w            	$A029
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HLockHi
	ENDIF


; *  TempNewHandle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Handle TempNewHandle(Size logicalSize, OSErr *resultCode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TempNewHandle
			move.w              #$001D,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TempNewHandle
	ENDIF


; *  TempMaxMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Size TempMaxMem(Size *grow)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TempMaxMem
			move.w              #$0015,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TempMaxMem
	ENDIF


; *  TempFreeMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal long TempFreeMem(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TempFreeMem
			move.w              #$0018,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TempFreeMem
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  InitZone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void InitZone(GrowZoneUPP pgrowZone, short cmoreMasters, void *limitPtr, void *startPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InitZone:	OPWORD	$A019
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InitZone
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  SetZone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void SetZone(THz hz)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	hz              => A0
		_SetZone:	OPWORD	$A01B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetZone
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  CompactMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Size CompactMem(Size cbNeeded)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	cbNeeded        => D0
		; returns:
		;	Size            <= D0
		_CompactMem:	OPWORD	$A04C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CompactMem
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  CompactMemSys()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Size CompactMemSys(Size cbNeeded)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	cbNeeded        => D0
		; returns:
		;	Size            <= D0
		_CompactMemSys:	OPWORD	$A44C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CompactMemSys
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  PurgeMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void PurgeMem(Size cbNeeded)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	cbNeeded        => D0
		_PurgeMem:	OPWORD	$A04D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PurgeMem
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  PurgeMemSys()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void PurgeMemSys(Size cbNeeded)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	cbNeeded        => D0
		_PurgeMemSys:	OPWORD	$A44D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PurgeMemSys
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  FreeMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal long FreeMem(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	long            <= D0
		_FreeMem:	OPWORD	$A01C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FreeMem
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  FreeMemSys()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal long FreeMemSys(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	long            <= D0
		_FreeMemSys:	OPWORD	$A41C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FreeMemSys
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  ReserveMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void ReserveMem(Size cbNeeded)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	cbNeeded        => D0
		_ReserveMem:	OPWORD	$A040
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ReserveMem
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  ReserveMemSys()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void ReserveMemSys(Size cbNeeded)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	cbNeeded        => D0
		_ReserveMemSys:	OPWORD	$A440
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ReserveMemSys
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  MaxMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Size MaxMem(Size *grow)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_MaxMem:	OPWORD	$A11D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MaxMem
	ENDIF


; *  MaxMemSys()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Size MaxMemSys(Size *grow)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_MaxMemSys:	OPWORD	$A51D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MaxMemSys
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  SetGrowZone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void SetGrowZone(GrowZoneUPP growZone)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	growZone        => A0
		_SetGrowZone:	OPWORD	$A04B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetGrowZone
	ENDIF


; *  GetGrowZone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal GrowZoneUPP GetGrowZone(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetGrowZone
	ENDIF


; *  MoveHHi()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void MoveHHi(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		_MoveHHi:	OPWORD	$A064
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MoveHHi
	ENDIF


; *  DisposePtr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void DisposePtr(Ptr p)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	p               => A0
		_DisposePtr:	OPWORD	$A01F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposePtr
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  GetPtrSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Size GetPtrSize(Ptr p)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetPtrSize:	OPWORD	$A021
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPtrSize
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  SetPtrSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void SetPtrSize(Ptr p, Size newSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	p               => A0
		;	newSize         => D0
		_SetPtrSize:	OPWORD	$A020
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetPtrSize
	ENDIF


; *  DisposeHandle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void DisposeHandle(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		_DisposeHandle:	OPWORD	$A023
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DisposeHandle
	ENDIF


; *  SetHandleSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void SetHandleSize(Handle h, Size newSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		;	newSize         => D0
		_SetHandleSize:	OPWORD	$A024
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetHandleSize
	ENDIF

;  
;    NOTE
;    
;    GetHandleSize and GetPtrSize are documented in Inside Mac as returning 0 
;    in case of an error, but the traps actually return an error code in D0.
;    The glue sets D0 to 0 if an error occurred.
;

	IF CALL_NOT_IN_CARBON THEN

; *  GetHandleSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Size GetHandleSize(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_GetHandleSize:	OPWORD	$A025
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetHandleSize
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  InlineGetHandleSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Size InlineGetHandleSize(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		; returns:
		;	Size            <= D0
		_InlineGetHandleSize:	OPWORD	$A025
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InlineGetHandleSize
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  ReallocateHandle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void ReallocateHandle(Handle h, Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		;	byteCount       => D0
		_ReallocateHandle:	OPWORD	$A027
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ReallocateHandle
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  ReallocateHandleSys()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void ReallocateHandleSys(Handle h, Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		;	byteCount       => D0
		_ReallocateHandleSys:	OPWORD	$A427
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ReallocateHandleSys
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  EmptyHandle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void EmptyHandle(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		_EmptyHandle:	OPWORD	$A02B
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EmptyHandle
	ENDIF


; *  HSetRBit()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void HSetRBit(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		_HSetRBit:	OPWORD	$A067
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HSetRBit
	ENDIF


; *  HClrRBit()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void HClrRBit(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		_HClrRBit:	OPWORD	$A068
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HClrRBit
	ENDIF


; *  HGetState()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal SInt8 HGetState(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		; returns:
		;	SInt8           <= D0
		_HGetState:	OPWORD	$A069
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HGetState
	ENDIF


; *  HSetState()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void HSetState(Handle h, SInt8 flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	h               => A0
		;	flags           => D0
		_HSetState:	OPWORD	$A06A
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HSetState
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  PurgeSpace()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void PurgeSpace(long *total, long *contig)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PurgeSpace:	OPWORD	$A162
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PurgeSpace
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
; 
;    PurgeSpaceTotal and PurgeSpaceContiguous are currently only implement
;    on classic 68K.  The are the same as PurgeSpace() but return just
;    one value (either total space purgable or contiguous space purgable).
;    Begining in Mac OS 8.5 they are available in InterfaceLib.
;


; *  PurgeSpaceTotal()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal long PurgeSpaceTotal(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	long            <= A0
		_PurgeSpaceTotal:	OPWORD	$A062
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PurgeSpaceTotal
	ENDIF


; *  PurgeSpaceContiguous()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal long PurgeSpaceContiguous(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	long            <= D0
		_PurgeSpaceContiguous:	OPWORD	$A062
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PurgeSpaceContiguous
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  PurgeSpaceSysTotal()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal long PurgeSpaceSysTotal(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	long            <= A0
		_PurgeSpaceSysTotal:	OPWORD	$A562
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PurgeSpaceSysTotal
	ENDIF


; *  PurgeSpaceSysContiguous()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal long PurgeSpaceSysContiguous(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	long            <= D0
		_PurgeSpaceSysContiguous:	OPWORD	$A562
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PurgeSpaceSysContiguous
	ENDIF


; *****************************************************************************
;
;    The routines: 
;
;        BlockMoveUncached, BlockMoveDataUncached
;        BlockZero, BlockZeroUncached
;    
;    were first created for developers writing drivers. Originally they only
;    existed in DriverServicesLib.  Later they were added to InterfaceLib 
;    in PCI based PowerMacs.  MacOS 8.5 provides these routines in InterfaceLib
;    on all supported machines. 
;    
;****************************************************************************

	ENDIF	; CALL_NOT_IN_CARBON

; *  BlockMove()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DriverServicesLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void BlockMove(const void *srcPtr, void *destPtr, Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	srcPtr          => A0
		;	destPtr         => A1
		;	byteCount       => D0
		_BlockMove:	OPWORD	$A02E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BlockMove
	ENDIF


; *  BlockMoveData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DriverServicesLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void BlockMoveData(const void *srcPtr, void *destPtr, Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	srcPtr          => A0
		;	destPtr         => A1
		;	byteCount       => D0
		_BlockMoveData:	OPWORD	$A22E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BlockMoveData
	ENDIF


; *  BlockMoveUncached()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void BlockMoveUncached(const void *srcPtr, void *destPtr, Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BlockMoveUncached
	ENDIF


; *  BlockMoveDataUncached()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void BlockMoveDataUncached(const void *srcPtr, void *destPtr, Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BlockMoveDataUncached
	ENDIF


; *  BlockZero()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void BlockZero(void *destPtr, Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BlockZero
	ENDIF


; *  BlockZeroUncached()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void BlockZeroUncached(void *destPtr, Size byteCount)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION BlockZeroUncached
	ENDIF


	IF CALL_NOT_IN_CARBON THEN

; *  MaxApplZone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void MaxApplZone(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_MaxApplZone:	OPWORD	$A063
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MaxApplZone
	ENDIF


; *  SetApplBase()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void SetApplBase(void *startPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	startPtr        => A0
		_SetApplBase:	OPWORD	$A057
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetApplBase
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  MoreMasters()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void MoreMasters(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_MoreMasters:	OPWORD	$A036
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MoreMasters
	ENDIF


; *  MoreMasterPointers()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void MoreMasterPointers(UInt32 inCount)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MoreMasterPointers
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  SetApplLimit()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void SetApplLimit(void *zoneLimit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	zoneLimit       => A0
		_SetApplLimit:	OPWORD	$A02D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetApplLimit
	ENDIF


; *  InitApplZone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void InitApplZone(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_InitApplZone:	OPWORD	$A02C
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InitApplZone
	ENDIF


;   Temporary Memory routines renamed, but obsolete, in System 7.0 and later.  
	ENDIF	; CALL_NOT_IN_CARBON

; *  TempHLock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void TempHLock(Handle h, OSErr *resultCode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TempHLock
			move.w              #$001E,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TempHLock
	ENDIF


; *  TempHUnlock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void TempHUnlock(Handle h, OSErr *resultCode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TempHUnlock
			move.w              #$001F,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TempHUnlock
	ENDIF


; *  TempDisposeHandle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void TempDisposeHandle(Handle h, OSErr *resultCode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TempDisposeHandle
			move.w              #$0020,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TempDisposeHandle
	ENDIF


; *  TempTopMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Ptr TempTopMem(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TempTopMem
			move.w              #$0016,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TempTopMem
	ENDIF


; *  HoldMemory()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HoldMemory(void *address, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		;	count           => A1
		; returns:
		;	OSErr           <= D0
		Macro
		_HoldMemory
			moveq           	#0,D0
			dc.w            	$A05C
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HoldMemory
	ENDIF


; *  UnholdMemory()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr UnholdMemory(void *address, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		;	count           => A1
		; returns:
		;	OSErr           <= D0
		Macro
		_UnholdMemory
			moveq           	#1,D0
			dc.w            	$A05C
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UnholdMemory
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  LockMemory()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr LockMemory(void *address, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		;	count           => A1
		; returns:
		;	OSErr           <= D0
		Macro
		_LockMemory
			moveq           	#2,D0
			dc.w            	$A05C
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LockMemory
	ENDIF


; *  LockMemoryForOutput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr LockMemoryForOutput(void *address, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		;	count           => A1
		; returns:
		;	OSErr           <= D0
		Macro
		_LockMemoryForOutput
			moveq           	#10,D0
			dc.w            	$A05C
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LockMemoryForOutput
	ENDIF


; *  LockMemoryContiguous()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr LockMemoryContiguous(void *address, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		;	count           => A1
		; returns:
		;	OSErr           <= D0
		Macro
		_LockMemoryContiguous
			moveq           	#4,D0
			dc.w            	$A05C
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LockMemoryContiguous
	ENDIF


; *  UnlockMemory()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr UnlockMemory(void *address, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		;	count           => A1
		; returns:
		;	OSErr           <= D0
		Macro
		_UnlockMemory
			moveq           	#3,D0
			dc.w            	$A05C
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UnlockMemory
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  MakeMemoryResident()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr MakeMemoryResident(void *address, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		;	count           => A1
		; returns:
		;	OSErr           <= D0
		Macro
		_MakeMemoryResident
			moveq           	#11,D0
			dc.w            	$A05C
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MakeMemoryResident
	ENDIF


; *  ReleaseMemoryData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr ReleaseMemoryData(void *address, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		;	count           => A1
		; returns:
		;	OSErr           <= D0
		Macro
		_ReleaseMemoryData
			moveq           	#12,D0
			dc.w            	$A05C
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ReleaseMemoryData
	ENDIF


; *  MakeMemoryNonResident()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr MakeMemoryNonResident(void *address, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		;	count           => A1
		; returns:
		;	OSErr           <= D0
		Macro
		_MakeMemoryNonResident
			moveq           	#13,D0
			dc.w            	$A05C
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MakeMemoryNonResident
	ENDIF


; *  FlushMemory()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr FlushMemory(void *address, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		;	count           => A1
		; returns:
		;	OSErr           <= D0
		Macro
		_FlushMemory
			moveq           	#14,D0
			dc.w            	$A05C
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION FlushMemory
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  GetPhysical()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr GetPhysical(LogicalToPhysicalTable *addresses, unsigned long *physicalEntryCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetPhysical
			moveq           	#5,D0
			dc.w            	$A05C
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPhysical
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  GetVolumeVirtualMemoryInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr GetVolumeVirtualMemoryInfo(VolumeVirtualMemoryInfoPtr volVMInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	volVMInfo       => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_GetVolumeVirtualMemoryInfo
			moveq           	#15,D0
			dc.w            	$A05C
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetVolumeVirtualMemoryInfo
	ENDIF


; *  DeferUserFn()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr DeferUserFn(UserFnUPP userFunction, void *argument)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	userFunctionargument=> A0
		;	argument        => D0
		; returns:
		;	OSErr           <= D0
		_DeferUserFn:	OPWORD	$A08F
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DeferUserFn
	ENDIF


; *  DebuggerGetMax()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal long DebuggerGetMax(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	long            <= D0
		Macro
		_DebuggerGetMax
			moveq           	#0,D0
			dc.w            	$A08D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DebuggerGetMax
	ENDIF


; *  DebuggerEnter()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void DebuggerEnter(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DebuggerEnter
			moveq           	#1,D0
			dc.w            	$A08D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DebuggerEnter
	ENDIF


; *  DebuggerExit()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void DebuggerExit(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DebuggerExit
			moveq           	#2,D0
			dc.w            	$A08D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DebuggerExit
	ENDIF


; *  DebuggerPoll()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void DebuggerPoll(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DebuggerPoll
			moveq           	#3,D0
			dc.w            	$A08D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DebuggerPoll
	ENDIF


; *  GetPageState()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal PageState GetPageState(const void *address)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		; returns:
		;	PageState       <= D0
		Macro
		_GetPageState
			moveq           	#4,D0
			dc.w            	$A08D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetPageState
	ENDIF


; *  PageFaultFatal()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Boolean PageFaultFatal(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	Boolean         <= D0
		Macro
		_PageFaultFatal
			moveq           	#5,D0
			dc.w            	$A08D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PageFaultFatal
	ENDIF


; *  DebuggerLockMemory()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr DebuggerLockMemory(void *address, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		;	count           => A1
		; returns:
		;	OSErr           <= D0
		Macro
		_DebuggerLockMemory
			moveq           	#6,D0
			dc.w            	$A08D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DebuggerLockMemory
	ENDIF


; *  DebuggerUnlockMemory()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr DebuggerUnlockMemory(void *address, unsigned long count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	address         => A0
		;	count           => A1
		; returns:
		;	OSErr           <= D0
		Macro
		_DebuggerUnlockMemory
			moveq           	#7,D0
			dc.w            	$A08D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DebuggerUnlockMemory
	ENDIF


; *  EnterSupervisorMode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal StatusRegisterContents EnterSupervisorMode(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; returns:
		;	StatusRegisterContents <= D0
		Macro
		_EnterSupervisorMode
			moveq           	#8,D0
			dc.w            	$A08D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION EnterSupervisorMode
	ENDIF



; *  StripAddress()
; *  
; *  Summary:
; *    A trap on classic 68K, and the identity function for pre-carbon
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Ptr StripAddress(void *theAddress)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	theAddress      => D0
		; returns:
		;	Ptr             <= D0
		_StripAddress:	OPWORD	$A055
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION StripAddress
	ENDIF



; *  Translate24To32()
; *  
; *  Summary:
; *    A trap on classic 68K, and the identity function for pre-carbon
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal Ptr Translate24To32(void *addr24)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	addr24          => D0
		; returns:
		;	Ptr             <= D0
		_Translate24To32:	OPWORD	$A091
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Translate24To32
	ENDIF


	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  HandToHand()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr HandToHand(Handle *theHndl)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_HandToHand:	OPWORD	$A9E1
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HandToHand
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  PtrToXHand()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PtrToXHand(const void *srcPtr, Handle dstHndl, long size)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	srcPtr          => A0
		;	dstHndl         => A1
		;	size            => D0
		; returns:
		;	OSErr           <= D0
		_PtrToXHand:	OPWORD	$A9E2
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PtrToXHand
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  PtrToHand()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr PtrToHand(const void *srcPtr, Handle *dstHndl, long size)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_PtrToHand:	OPWORD	$A9E3
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PtrToHand
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  HandAndHand()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr HandAndHand(Handle hand1, Handle hand2)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	hand1           => A0
		;	hand2           => A1
		; returns:
		;	OSErr           <= D0
		_HandAndHand:	OPWORD	$A9E4
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION HandAndHand
	ENDIF


; *  PtrAndHand()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr PtrAndHand(const void *ptr1, Handle hand2, long size)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	ptr1            => A0
		;	hand2           => A1
		;	size            => D0
		; returns:
		;	OSErr           <= D0
		_PtrAndHand:	OPWORD	$A9EF
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PtrAndHand
	ENDIF

;  Carbon routines to aid in debugging. 
;  Checks all applicable heaps for validity 

; *  CheckAllHeaps()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Boolean CheckAllHeaps(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CheckAllHeaps
	ENDIF

;  Checks the application heap for validity 

; *  IsHeapValid()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Boolean IsHeapValid(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsHeapValid
	ENDIF

;  It is invalid to pass a NULL or an empty Handle to IsHandleValid 

; *  IsHandleValid()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Boolean IsHandleValid(Handle h)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsHandleValid
	ENDIF

;  It is invalid to pass a NULL Pointer to IsPointerValid 

; *  IsPointerValid()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal Boolean IsPointerValid(Ptr p)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsPointerValid
	ENDIF


	IF OLDROUTINENAMES THEN
	ENDIF	; OLDROUTINENAMES
	ENDIF ; __MACMEMORY__ 


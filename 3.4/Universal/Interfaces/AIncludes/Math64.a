;
;    File:       Math64.a
;
;    Contains:   64-bit integer math Interfaces.
;
;    Version:    Technology: Mac OS 9
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1994-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__MATH64__') = 'UNDEFINED' THEN
__MATH64__ SET 1

	IF &TYPE('__CONDITIONALMACROS__') = 'UNDEFINED' THEN
	include 'ConditionalMacros.a'
	ENDIF
	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF



; *  S64Max()
; *  
; *  Discussion:
; *    Returns largest possible SInt64 value
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64Max(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Max
	ENDIF


; *  S64Min()
; *  
; *  Discussion:
; *    Returns smallest possible SInt64 value
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64Min(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Min
	ENDIF



; *  S64Add()
; *  
; *  Discussion:
; *    Adds two integers, producing an integer result.  If an overflow
; *    occurs the result is congruent mod (2^64) as if the operands and
; *    result were unsigned.  No overflow is signaled.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64Add(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Add
	ENDIF



; *  S64Subtract()
; *  
; *  Discussion:
; *    Subtracts two integers, producing an integer result.  If an
; *    overflow occurs the result is congruent mod (2^64) as if the
; *    operands and result were unsigned.  No overflow is signaled.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64Subtract(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Subtract
	ENDIF



; *  S64Negate()
; *  
; *  Discussion:
; *    Returns the additive inverse of a signed number (i.e. it returns
; *    0 - the number).  S64Negate (S64Min) is not representable (in
; *    fact, it returns S64Min).
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64Negate(SInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Negate
	ENDIF


	IF ¬ TYPE_LONGLONG THEN

; *  S64Absolute()
; *  
; *  Discussion:
; *    Returns the absolute value of the number (i.e. the number if it
; *    is positive, or 0 - the number if it is negative). Disabled for
; *    compilers that support long long until llabs() is available
; *    everywhere.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64Absolute(SInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Absolute
	ENDIF

	ENDIF

; *  S64Multiply()
; *  
; *  Discussion:
; *    Multiplies two signed numbers, producing a signed result. 
; *    Overflow is ignored and the low-order part of the product is
; *    returned.  The sign of the result is not guaranteed to be correct
; *    if the magnitude of the product is not representable.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64Multiply(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Multiply
	ENDIF


	IF CALL_NOT_IN_CARBON THEN

; *  S64Mod()
; *  
; *  Discussion:
; *    Returns the remainder of divide of dividend by divisor.  The sign
; *    of the remainder is the same as the sign of the dividend (i.e.,
; *    it takes the absolute values of the operands, does the division,
; *    then fixes the sign of the quotient and remainder).
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern SInt64 S64Mod(SInt64 dividend, SInt64 divisor)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Mod
	ENDIF



	ENDIF	; CALL_NOT_IN_CARBON

; *  S64Divide()
; *  
; *  Discussion:
; *    Divides dividend by divisor, returning the quotient.  The
; *    remainder is returned in *remainder if remainder (the pointer) is
; *    non-NULL. The sign of the remainder is the same as the sign of
; *    the dividend (i.e. it takes the absolute values of the operands,
; *    does the division, then fixes the sign of the quotient and
; *    remainder).  If the divisor is zero, then S64Max() will be
; *    returned (or S64Min() if the dividend is negative), and the
; *    remainder will be the dividend; no error is reported.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64Divide(SInt64 dividend, SInt64 divisor, SInt64 *remainder)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Divide
	ENDIF




; *  S64Set()
; *  
; *  Discussion:
; *    Given an SInt32, returns an SInt64 with the same value.  Use this
; *    routine instead of coding 64-bit constants (at least when the
; *    constant will fit in an SInt32).
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64Set(SInt32 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Set
	ENDIF



; *  S64SetU()
; *  
; *  Discussion:
; *    Given a UInt32, returns a SInt64 with the same value.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64SetU(UInt32 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64SetU
	ENDIF


; *  S32Set()
; *  
; *  Discussion:
; *    Given an SInt64, returns an SInt32 by discarding the high-order
; *    32 bits.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt32 S32Set(SInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S32Set
	ENDIF



; *  S64And()
; *  
; *  Discussion:
; *    Returns one if left and right are non-zero, otherwise returns zero
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern Boolean S64And(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64And
	ENDIF



; *  S64Or()
; *  
; *  Discussion:
; *    Returns one if left or right are non-zero, otherwise returns zero
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern Boolean S64Or(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Or
	ENDIF



; *  S64Eor()
; *  
; *  Discussion:
; *    Returns one if left xor right are non-zero, otherwise returns zero
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern Boolean S64Eor(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Eor
	ENDIF



; *  S64Not()
; *  
; *  Discussion:
; *    Returns one if value is non-zero, otherwisze returns zero.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern Boolean S64Not(SInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Not
	ENDIF



; *  S64Compare()
; *  
; *  Discussion:
; *    Given two signed numbers, left and right, returns an SInt32 that
; *    compares with zero the same way left compares with right.  If you
; *    wanted to perform a comparison on 64-bit integers of the
; *    form:
; *    operand_1 <operation> operand_2
; *    then you could use an expression of the form:
; *     xxxS64Compare(operand_1,operand_2) <operation> 0
; *    to test for the same condition. CAUTION: DO NOT depend on the
; *    exact value returned by this routine. Only the sign (i.e.
; *    positive, zero, or negative) of the result is guaranteed.
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt32 S64Compare(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64Compare
	ENDIF



; *  S64BitwiseAnd()
; *  
; *  Discussion:
; *    bitwise AND
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64BitwiseAnd(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64BitwiseAnd
	ENDIF



; *  S64BitwiseOr()
; *  
; *  Discussion:
; *    bitwise OR
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64BitwiseOr(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64BitwiseOr
	ENDIF



; *  S64BitwiseEor()
; *  
; *  Discussion:
; *    bitwise XOR
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64BitwiseEor(SInt64 left, SInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64BitwiseEor
	ENDIF



; *  S64BitwiseNot()
; *  
; *  Discussion:
; *    bitwise negate
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64BitwiseNot(SInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64BitwiseNot
	ENDIF



; *  S64ShiftRight()
; *  
; *  Discussion:
; *    Arithmetic shift of value by the lower 7 bits of the shift.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64ShiftRight(SInt64 value, UInt32 shift)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64ShiftRight
	ENDIF



; *  S64ShiftLeft()
; *  
; *  Discussion:
; *    Logical shift of value by the lower 7 bits of the shift.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 S64ShiftLeft(SInt64 value, UInt32 shift)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION S64ShiftLeft
	ENDIF




; *  U64Max()
; *  
; *  Discussion:
; *    Returns largest possible UInt64 value
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64Max(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Max
	ENDIF


; *  U64Add()
; *  
; *  Discussion:
; *    Adds two unsigned integers, producing an integer result.  If an
; *    overflow occurs the result is congruent mod (2^64) as if the
; *    operands and result were unsigned.  No overflow is signaled.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64Add(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Add
	ENDIF


; *  U64Subtract()
; *  
; *  Discussion:
; *    Subtracts two unsigned integers, producing an integer result.  If
; *    an overflow occurs the result is congruent mod (2^64) as if the
; *    operands and result were unsigned.  No overflow is signaled.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64Subtract(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Subtract
	ENDIF



; *  U64Multiply()
; *  
; *  Discussion:
; *    Multiplies two unsigned numbers, producing a signed result. 
; *    Overflow is ignored and the low-order part of the product is
; *    returned.  The sign of the result is not guaranteed to be correct
; *    if the magnitude of the product is not representable.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64Multiply(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Multiply
	ENDIF


	IF CALL_NOT_IN_CARBON THEN

; *  U64Mod()
; *  
; *  Discussion:
; *    Returns the remainder of divide of dividend by divisor.  The sign
; *    of the remainder is the same as the sign of the dividend (i.e.,
; *    it takes the absolute values of the operands, does the division,
; *    then fixes the sign of the quotient and remainder).
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern UInt64 U64Mod(UInt64 dividend, UInt64 divisor)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Mod
	ENDIF


	ENDIF	; CALL_NOT_IN_CARBON

; *  U64Divide()
; *  
; *  Discussion:
; *    Divides dividend by divisor, returning the quotient.  The
; *    remainder is returned in *remainder if remainder (the pointer) is
; *    non-NULL. The sign of the remainder is the same as the sign of
; *    the dividend (i.e. it takes the absolute values of the operands,
; *    does the division, then fixes the sign of the quotient and
; *    remainder).  If the divisor is zero, then U64Max() will be
; *    returned (or U64Min() if the dividend is negative), and the
; *    remainder will be the dividend; no error is reported.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64Divide(UInt64 dividend, UInt64 divisor, UInt64 *remainder)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Divide
	ENDIF




; *  U64Set()
; *  
; *  Discussion:
; *    Given an SInt32, returns an UInt64 with the same value.  Use this
; *    routine instead of coding 64-bit constants (at least when the
; *    constant will fit in an SInt32).
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64Set(SInt32 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Set
	ENDIF



; *  U64SetU()
; *  
; *  Discussion:
; *    Given a UInt32, returns a UInt64 with the same value.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64SetU(UInt32 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64SetU
	ENDIF


; *  U32SetU()
; *  
; *  Discussion:
; *    Given an UInt64, returns an UInt32 by discarding the high-order
; *    32 bits.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt32 U32SetU(UInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U32SetU
	ENDIF



; *  U64And()
; *  
; *  Discussion:
; *    Returns one if left and right are non-zero, otherwise returns zero
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern Boolean U64And(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64And
	ENDIF



; *  U64Or()
; *  
; *  Discussion:
; *    Returns one if left or right are non-zero, otherwise returns zero
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern Boolean U64Or(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Or
	ENDIF



; *  U64Eor()
; *  
; *  Discussion:
; *    Returns one if left xor right are non-zero, otherwise returns zero
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern Boolean U64Eor(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Eor
	ENDIF



; *  U64Not()
; *  
; *  Discussion:
; *    Returns one if value is non-zero, otherwisze returns zero.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern Boolean U64Not(UInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Not
	ENDIF



; *  U64Compare()
; *  
; *  Discussion:
; *    Given two unsigned numbers, left and right, returns an SInt32
; *    that compares with zero the same way left compares with right. 
; *    If you wanted to perform a comparison on 64-bit integers of the
; *    form:
; *    operand_1 <operation> operand_2
; *    then you could use an expression of the form:
; *     xxxU64Compare(operand_1,operand_2) <operation> 0
; *    to test for the same condition. CAUTION: DO NOT depend on the
; *    exact value returned by this routine. Only the sign (i.e.
; *    positive, zero, or negative) of the result is guaranteed.
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt32 U64Compare(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64Compare
	ENDIF


; *  U64BitwiseAnd()
; *  
; *  Discussion:
; *    bitwise AND
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64BitwiseAnd(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64BitwiseAnd
	ENDIF



; *  U64BitwiseOr()
; *  
; *  Discussion:
; *    bitwise OR
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64BitwiseOr(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64BitwiseOr
	ENDIF



; *  U64BitwiseEor()
; *  
; *  Discussion:
; *    bitwise XOR
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64BitwiseEor(UInt64 left, UInt64 right)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64BitwiseEor
	ENDIF



; *  U64BitwiseNot()
; *  
; *  Discussion:
; *    bitwise negate
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64BitwiseNot(UInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64BitwiseNot
	ENDIF



; *  U64ShiftRight()
; *  
; *  Discussion:
; *    Arithmetic shift of value by the lower 7 bits of the shift.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64ShiftRight(UInt64 value, UInt32 shift)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64ShiftRight
	ENDIF



; *  U64ShiftLeft()
; *  
; *  Discussion:
; *    Logical shift of value by the lower 7 bits of the shift.
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 U64ShiftLeft(UInt64 value, UInt32 shift)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION U64ShiftLeft
	ENDIF




; *  UInt64ToSInt64()
; *  
; *  Discussion:
; *    converts UInt64 -> SInt64
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern SInt64 UInt64ToSInt64(UInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UInt64ToSInt64
	ENDIF



; *  SInt64ToUInt64()
; *  
; *  Discussion:
; *    converts SInt64 -> UInt64
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern UInt64 SInt64ToUInt64(SInt64 value)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SInt64ToUInt64
	ENDIF






	ENDIF ; __MATH64__ 


;
;    File:       OSA.a
;
;    Contains:   Open Scripting Architecture Client Interfaces.
;
;    Version:    Technology: AppleScript 1.4
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  Â© 1992-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__OSA__') = 'UNDEFINED' THEN
__OSA__ SET 1

	IF &TYPE('__MACERRORS__') = 'UNDEFINED' THEN
	include 'MacErrors.a'
	ENDIF
	IF &TYPE('__APPLEEVENTS__') = 'UNDEFINED' THEN
	include 'AppleEvents.a'
	ENDIF
	IF &TYPE('__AEOBJECTS__') = 'UNDEFINED' THEN
	include 'AEObjects.a'
	ENDIF
	IF &TYPE('__AEINTERACTION__') = 'UNDEFINED' THEN
	include 'AEInteraction.a'
	ENDIF
	IF &TYPE('__COMPONENTS__') = 'UNDEFINED' THEN
	include 'Components.a'
	ENDIF
	IF &TYPE('__MACERRORS__') = 'UNDEFINED' THEN
	include 'MacErrors.a'
	ENDIF

; **************************************************************************
;    Types and Constants
;*************************************************************************


;     The componenent manager type code for components that
;        support the OSA interface defined here. 
;  0x6f736120 

kOSAComponentType				EQU		'osa '
;  0x73637074 

kOSAGenericScriptingComponentSubtype EQU 'scpt'
;   Type of script document files.  
;  0x6f736173 

kOSAFileType					EQU		'osas'
; 
;        Suite and event code of the RecordedText event. 
;        (See OSAStartRecording, below.)
;    

;  0x61736372 

kOSASuite						EQU		'ascr'
;  0x72656364 

kOSARecordedText				EQU		'recd'
;  Selector returns boolean 
;  0x6d6f6469 

kOSAScriptIsModified			EQU		'modi'
;  Selector returns boolean 
;  0x63736372 

kOSAScriptIsTypeCompiledScript	EQU		'cscr'
;  Selector returns boolean 
;  0x76616c75 

kOSAScriptIsTypeScriptValue		EQU		'valu'
;  Selector returns boolean 
;  0x636e7478 

kOSAScriptIsTypeScriptContext	EQU		'cntx'
;  Selector returns a DescType which may be passed to OSACoerceToDesc 
;  0x62657374 

kOSAScriptBestType				EQU		'best'
; 
;        This selector is used to determine whether a script has source 
;        associated with it that when given to OSAGetSource, the call will not
;        fail.  The selector returns a boolean.
;    

;  0x67737263 

kOSACanGetSource				EQU		'gsrc'


typeOSADialectInfo				EQU		'difo'				;  0x6469666f   
keyOSADialectName				EQU		'dnam'				;  0x646e616d   
keyOSADialectCode				EQU		'dcod'				;  0x64636f64   
keyOSADialectLangCode			EQU		'dlcd'				;  0x646c6364   
keyOSADialectScriptCode			EQU		'dscd'				;  0x64736364   
; typedef ComponentResult 				OSAError

;  Under the Open Scripting Architecture all error results are longs 
; typedef unsigned long 				OSAID

; 
;        OSAIDs allow transparent manipulation of scripts associated with
;        various scripting systems.
;    


kOSANullScript					EQU		0
;  No -script constant. 

kOSANullMode					EQU		0					; sounds better 
kOSAModeNull					EQU		0					; tastes consistent 
; 
;        Some routines take flags that control their execution.  This constant
;        declares default mode settings are used.
;    


; *  NewOSACreateAppleEventUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewOSASendUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeOSACreateAppleEventUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeOSASendUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeOSACreateAppleEventUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeOSASendUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

; **************************************************************************
;    OSA Interface Descriptions
;**************************************************************************
;    The OSA Interface is broken down into a required interface, and several
;    optional interfaces to support additional functionality.  A given scripting
;    component may choose to support only some of the optional interfaces in
;    addition to the basic interface.  The OSA Component Flags may be used to 
;    query the Component Manager to find a scripting component with a particular
;    capability, or determine if a particular scripting component supports a 
;    particular capability.
;*************************************************************************

;  OSA Component Flags: 

kOSASupportsCompiling			EQU		$0002
kOSASupportsGetSource			EQU		$0004
kOSASupportsAECoercion			EQU		$0008
kOSASupportsAESending			EQU		$0010
kOSASupportsRecording			EQU		$0020
kOSASupportsConvenience			EQU		$0040
kOSASupportsDialects			EQU		$0080
kOSASupportsEventHandling		EQU		$0100
;  Component Selectors: 

kOSASelectLoad					EQU		$0001
kOSASelectStore					EQU		$0002
kOSASelectExecute				EQU		$0003
kOSASelectDisplay				EQU		$0004
kOSASelectScriptError			EQU		$0005
kOSASelectDispose				EQU		$0006
kOSASelectSetScriptInfo			EQU		$0007
kOSASelectGetScriptInfo			EQU		$0008
kOSASelectSetActiveProc			EQU		$0009
kOSASelectGetActiveProc			EQU		$000A
;  Compiling: 

kOSASelectScriptingComponentName EQU	$0102
kOSASelectCompile				EQU		$0103
kOSASelectCopyID				EQU		$0104

kOSASelectCopyScript			EQU		$0105
;  GetSource: 

kOSASelectGetSource				EQU		$0201
;  AECoercion: 

kOSASelectCoerceFromDesc		EQU		$0301
kOSASelectCoerceToDesc			EQU		$0302
;  AESending: 

kOSASelectSetSendProc			EQU		$0401
kOSASelectGetSendProc			EQU		$0402
kOSASelectSetCreateProc			EQU		$0403
kOSASelectGetCreateProc			EQU		$0404
kOSASelectSetDefaultTarget		EQU		$0405
;  Recording: 

kOSASelectStartRecording		EQU		$0501
kOSASelectStopRecording			EQU		$0502
;  Convenience: 

kOSASelectLoadExecute			EQU		$0601
kOSASelectCompileExecute		EQU		$0602
kOSASelectDoScript				EQU		$0603
;  Dialects: 

kOSASelectSetCurrentDialect		EQU		$0701
kOSASelectGetCurrentDialect		EQU		$0702
kOSASelectAvailableDialects		EQU		$0703
kOSASelectGetDialectInfo		EQU		$0704
kOSASelectAvailableDialectCodeList EQU	$0705
;  Event Handling: 

kOSASelectSetResumeDispatchProc	EQU		$0801
kOSASelectGetResumeDispatchProc	EQU		$0802
kOSASelectExecuteEvent			EQU		$0803
kOSASelectDoEvent				EQU		$0804
kOSASelectMakeContext			EQU		$0805
;  Debugging 

kOSADebuggerCreateSession		EQU		$0901
kOSADebuggerGetSessionState		EQU		$0902
kOSADebuggerSessionStep			EQU		$0903
kOSADebuggerDisposeSession		EQU		$0904
kOSADebuggerGetStatementRanges	EQU		$0905
kOSADebuggerGetBreakpoint		EQU		$0910
kOSADebuggerSetBreakpoint		EQU		$0911
kOSADebuggerGetDefaultBreakpoint EQU	$0912
kOSADebuggerGetCurrentCallFrame	EQU		$0906
kOSADebuggerGetCallFrameState	EQU		$0907
kOSADebuggerGetVariable			EQU		$0908
kOSADebuggerSetVariable			EQU		$0909
kOSADebuggerGetPreviousCallFrame EQU	$090A
kOSADebuggerDisposeCallFrame	EQU		$090B
;  scripting component specific selectors are added beginning with this value  

kOSASelectComponentSpecificStart EQU	$1001

;         Mode Flags:
;
;    Warning: These should not conflict with the AESend mode flags in
;    AppleEvents.h, because we may want to use them as OSA mode flags too.
;


; 
;        This mode flag may be passed to OSALoad, OSAStore or OSACompile to
;        instruct the scripting component to not retain the "source" of an
;        expression.  This will cause the OSAGetSource call to return the error
;        errOSASourceNotAvailable if used.  However, some scripting components
;        may not retain the source anyway.  This is mainly used when either space
;        efficiency is desired, or a script is to be "locked" so that its
;        implementation may not be viewed.
;    


kOSAModePreventGetSource		EQU		$00000001
; 
;        These mode flags may be passed to OSACompile, OSAExecute, OSALoadExecute
;        OSACompileExecute, OSADoScript, OSAExecuteEvent, or OSADoEvent to
;        indicate whether or not the script may interact with the user, switch
;        layer or reconnect if necessary.  Any AppleEvents will be sent with the
;        corresponding AESend mode supplied.
;    


kOSAModeNeverInteract			EQU		$00000010
kOSAModeCanInteract				EQU		$00000020
kOSAModeAlwaysInteract			EQU		$00000030
kOSAModeDontReconnect			EQU		$00000080
; 
;        This mode flag may be passed to OSACompile, OSAExecute, OSALoadExecute
;        OSACompileExecute, OSADoScript, OSAExecuteEvent, or OSADoEvent to
;        indicate whether or not AppleEvents should be sent with the
;        kAECanSwitchLayer mode flag sent or not. NOTE: This flag is exactly the
;        opposite sense of the AppleEvent flag kAECanSwitchLayer.  This is to
;        provide a more convenient default, i.e. not supplying any mode
;        (kOSAModeNull) means to send events with kAECanSwitchLayer.  Supplying
;        the kOSAModeCantSwitchLayer mode flag will cause AESend to be called
;        without kAECanSwitchLayer.
;    


kOSAModeCantSwitchLayer			EQU		$00000040
; 
;        This mode flag may be passed to OSACompile, OSAExecute, OSALoadExecute
;        OSACompileExecute, OSADoScript, OSAExecuteEvent, or OSADoEvent to
;        indicate whether or not AppleEvents should be sent with the kAEDontRecord
;        mode flag sent or not. NOTE: This flag is exactly the opposite sense of
;        the AppleEvent flag kAEDontRecord.  This is to provide a more convenient
;        default, i.e. not supplying any mode (kOSAModeNull) means to send events
;        with kAEDontRecord.  Supplying the kOSAModeDoRecord mode flag will 
;        cause AESend to be called without kAEDontRecord.
;    


kOSAModeDoRecord				EQU		$00001000
; 
;        This is a mode flag for OSACompile that indicates that a context should
;        be created as the result of compilation. All handler definitions are
;        inserted into the new context, and variables are initialized by
;        evaluating their initial values in a null context (i.e. they must be
;        constant expressions).
;    


kOSAModeCompileIntoContext		EQU		$00000002
; 
;        This is a mode flag for OSACompile that indicates that the previous
;        script ID (input to OSACompile) should be augmented with any new
;        definitions in the sourceData rather than replaced with a new script.
;        This means that the previous script ID must designate a context.
;        The presence of this flag causes the kOSAModeCompileIntoContext flag
;        to be implicitly used, causing any new definitions to be initialized
;        in a null context.
;    


kOSAModeAugmentContext			EQU		$00000004
; 
;        This mode flag may be passed to OSADisplay or OSADoScript to indicate
;        that output only need be human-readable, not re-compilable by OSACompile.
;        If used, output may be arbitrarily "beautified", e.g. quotes may be left
;        off of string values, long lists may have elipses, etc.
;    


kOSAModeDisplayForHumans		EQU		$00000008
; 
;        This mode flag may be passed to OSAStore in the case where the scriptID
;        is a context.  This causes the context to be saved, but not the context's
;        parent context.  When the stored context is loaded back in, the parent
;        will be kOSANullScript.
;    


kOSAModeDontStoreParent			EQU		$00010000
; 
;        This mode flag may be passed to OSAExecuteEvent to cause the event to
;        be dispatched to the direct object of the event. The direct object (or
;        subject attribute if the direct object is a non-object specifier) will
;        be resolved, and the resulting script object will be the recipient of
;        the message. The context argument to OSAExecuteEvent will serve as the
;        root of the lookup/resolution process.
;    


kOSAModeDispatchToDirectObject	EQU		$00020000
; 
;        This mode flag may be passed to OSAExecuteEvent to indicate that
;        components do not have to get the data of object specifier arguments.
;    


kOSAModeDontGetDataForArguments	EQU		$00040000
; **************************************************************************
;    OSA Basic Scripting Interface
;**************************************************************************
;    Scripting components must at least support the Basic Scripting interface.
;*************************************************************************

;         Loading and Storing Scripts:
;
;    These routines allow scripts to be loaded and stored in their internal
;    (possibly compiled, non-text) representation.
;


;  Resource type for scripts 

kOSAScriptResourceType			EQU		'scpt'
; 
;        Default type given to OSAStore which creates "generic" loadable script
;        data descriptors.
;    


typeOSAGenericStorage			EQU		'scpt'

; *  OSALoad()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSALoad(ComponentInstance scriptingComponent, const AEDesc *scriptData, long modeFlags, OSAID *resultingScriptID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSALoad
			move.l              #$000C0001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSALoad
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectLoad, 12);
;    
;        Errors:
;            badComponentInstance        invalid scripting component instance
;            errOSASystemError
;            errOSABadStorageType:       scriptData not for this scripting component
;            errOSACorruptData:          data seems to be corrupt
;            errOSADataFormatObsolete    script data format is no longer supported
;            errOSADataFormatTooNew      script data format is from a newer version
;        
;        ModeFlags:
;            kOSAModePreventGetSource
;    


; *  OSAStore()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAStore(ComponentInstance scriptingComponent, OSAID scriptID, DescType desiredType, long modeFlags, AEDesc *resultingScriptData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAStore
			move.l              #$00100002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAStore
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectStore, 16);
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;            errOSABadStorageType:   desiredType not for this scripting component
;        
;        ModeFlags:
;            kOSAModePreventGetSource
;            kOSAModeDontStoreParent
;    

;  Executing Scripts: 

; *  OSAExecute()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAExecute(ComponentInstance scriptingComponent, OSAID compiledScriptID, OSAID contextID, long modeFlags, OSAID *resultingScriptValueID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAExecute
			move.l              #$00100003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAExecute
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectExecute, 16);
;        This call runs a script.  The contextID represents the environment
;        with which global variables in the script are resolved.  The constant
;        kOSANullScript may be used for the contextID if the application wishes
;        to not deal with context directly (a default one is associated with each
;        scripting component instance).  The resultingScriptValueID is the 
;        result of evaluation, and contains a value which may be displayed using
;        the OSAGetSource call.  The modeFlags convey scripting component
;        specific information.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;            errOSAScriptError:      the executing script got an error
;    
;        ModeFlags:
;            kOSAModeNeverInteract
;            kOSAModeCanInteract
;            kOSAModeAlwaysInteract
;            kOSAModeCantSwitchLayer
;            kOSAModeDontReconnect
;            kOSAModeDoRecord
;    

;  Displaying results: 

; *  OSADisplay()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADisplay(ComponentInstance scriptingComponent, OSAID scriptValueID, DescType desiredType, long modeFlags, AEDesc *resultingText)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADisplay
			move.l              #$00100004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADisplay
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectDisplay, 16);
;        This call is used to convert results (script value IDs) into displayable
;        text. The desiredType should be at least typeChar, and modeFlags are
;        scripting system specific flags to control the formatting of the
;        resulting text. This call differs from OSAGetSource in that (1) it
;        always produces at least typeChar, (2) is only works on script values,
;        (3) it may display it's output in non-compilable form (e.g. without
;        string quotes, elipses inserted in long and/or circular lists, etc.) and
;        (4) it is required by the basic scripting interface.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;            errAECoercionFail:      desiredType not supported by scripting component
;    
;        ModeFlags:
;            kOSAModeDisplayForHumans
;    

;  Getting Error Information: 

; *  OSAScriptError()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAScriptError(ComponentInstance scriptingComponent, OSType selector, DescType desiredType, AEDesc *resultingErrorDescription)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAScriptError
			move.l              #$000C0005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAScriptError
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectScriptError, 12);
;        Whenever script execution returns errOSAExecutionError, this routine
;        may be used to get information about that error.  The selector describes
;        the type of information desired about the error (various selectors are
;        listed below).  The desiredType indicates the data type of the result
;        desired for that selector.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSABadSelector:      selector not supported by scripting component
;            errAECoercionFail:      desiredType not supported by scripting component
;    

;  OSAScriptError selectors: 
; 
;        This selector is used to determine the error number of a script error.
;        These error numbers may be either system error numbers, or error numbers
;        that are scripting component specific.
;        Required desiredTypes:  
;            typeShortInteger
;    


kOSAErrorNumber					EQU		'errn'
; 
;        This selector is used to determine the full error message associated
;        with the error number.  It should include the name of the application
;        which caused the error, as well as the specific error that occurred.
;        This selector is sufficient for simple error reporting (but see
;        kOSAErrorBriefMessage, below).
;        Required desiredTypes:
;            typeChar                    error message string
;    


kOSAErrorMessage				EQU		'errs'
; 
;        This selector is used to determine a brief error message associated with
;        the error number.  This message and should not mention the name of the
;        application which caused the error, any partial results or offending
;        object (see kOSAErrorApp, kOSAErrorPartialResult and
;        kOSAErrorOffendingObject, below).
;        Required desiredTypes:
;            typeChar                    brief error message string
;    

;   0x65727262  

kOSAErrorBriefMessage			EQU		'errb'
; 
;        This selector is used to determine which application actually got the
;        error (if it was the result of an AESend), or the current application
;        if ....
;        Required desiredTypes:
;            typeProcessSerialNumber     PSN of the errant application
;            typeChar                    name of the errant application
;    

;   0x65726170  

kOSAErrorApp					EQU		'erap'
; 
;        This selector is used to determine any partial result returned by an 
;        operation. If an AESend call failed, but a partial result was returned,
;        then the partial result may be returned as an AEDesc.
;        Required desiredTypes:
;            typeBest                    AEDesc of any partial result
;    

;   0x70746c72   

kOSAErrorPartialResult			EQU		'ptlr'
; 
;        This selector is used to determine any object which caused the error
;        that may have been indicated by an application.  The result is an 
;        AEDesc.
;        Required desiredTypes:
;            typeBest                    AEDesc of any offending object
;    

;   0x65726f62   

kOSAErrorOffendingObject		EQU		'erob'
; 
;        This selector is used to determine the type expected by a coercion 
;        operation if a type error occurred.
;    

;   0x65727274   

kOSAErrorExpectedType			EQU		'errt'
; 
;        This selector is used to determine the source text range (start and 
;        end positions) of where the error occurred.
;        Required desiredTypes:
;            typeOSAErrorRange
;    

;   0x65726e67  

kOSAErrorRange					EQU		'erng'
; 
;        An AERecord type containing keyOSASourceStart and keyOSASourceEnd fields
;        of type short.
;    

;   0x65726e67   

typeOSAErrorRange				EQU		'erng'
;  Field of a typeOSAErrorRange record of typeShortInteger 
;   0x73726373    

keyOSASourceStart				EQU		'srcs'
;  Field of a typeOSAErrorRange record of typeShortInteger 
;   0x73726365   

keyOSASourceEnd					EQU		'srce'
;  Disposing Script IDs: 

; *  OSADispose()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADispose(ComponentInstance scriptingComponent, OSAID scriptID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADispose
			move.l              #$00040006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADispose
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectDispose, 4);
;        Disposes a script or context.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;    

;  Getting and Setting Script Information: 

; *  OSASetScriptInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSASetScriptInfo(ComponentInstance scriptingComponent, OSAID scriptID, OSType selector, long value)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSASetScriptInfo
			move.l              #$000C0007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSASetScriptInfo
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectSetScriptInfo, 12);
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;            errOSABadSelector:      selector not supported by scripting component
;                                    or selector not for this scriptID
;    


; *  OSAGetScriptInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAGetScriptInfo(ComponentInstance scriptingComponent, OSAID scriptID, OSType selector, long *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAGetScriptInfo
			move.l              #$000C0008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAGetScriptInfo
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectGetScriptInfo, 12);
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;            errOSABadSelector:      selector not supported by scripting component
;                                    or selector not for this scriptID
;    

;  Manipulating the ActiveProc:
;
;    Scripting systems will supply default values for these procedures if they
;    are not set by the client:
;


; *  NewOSAActiveUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeOSAActiveUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeOSAActiveUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  OSASetActiveProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSASetActiveProc(ComponentInstance scriptingComponent, OSAActiveUPP activeProc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSASetActiveProc
			move.l              #$00080009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSASetActiveProc
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectSetActiveProc, 8);
;        If activeProc is nil, the default activeProc is used.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    


; *  OSAGetActiveProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAGetActiveProc(ComponentInstance scriptingComponent, OSAActiveUPP *activeProc, long *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAGetActiveProc
			move.l              #$0008000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAGetActiveProc
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectGetActiveProc, 8);
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    

; **************************************************************************
;    OSA Optional Compiling Interface
;**************************************************************************
;    Scripting components that support the Compiling interface have the 
;    kOSASupportsCompiling bit set in it's ComponentDescription.
;*************************************************************************


; *  OSAScriptingComponentName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAScriptingComponentName(ComponentInstance scriptingComponent, AEDesc *resultingScriptingComponentName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAScriptingComponentName
			move.l              #$00040102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAScriptingComponentName
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectScriptingComponentName, 4);
;        Given a scripting component, this routine returns the name of that
;        scripting component in a type that is coercable to text (typeChar).
;        The generic scripting component returns the name of the default
;        scripting component.  This name should be sufficient to convey to the
;        user the kind of script (syntax) he is expected to write.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    


; *  OSACompile()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSACompile(ComponentInstance scriptingComponent, const AEDesc *sourceData, long modeFlags, OSAID *previousAndResultingScriptID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSACompile
			move.l              #$000C0103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSACompile
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectCompile, 12);
;        Coerces input desc (possibly text) into a script's internal format.
;        Once compiled, the script is ready to run.  The modeFlags convey
;        scripting component specific information.  The previous script ID
;        (result parameter) is made to refer to the newly compiled script,
;        unless it was originally kOSANullScript.  In this case a new script
;        ID is created and used.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errAECoercionFail:      sourceData is not compilable
;            errOSAScriptError:      sourceData was a bad script (syntax error)
;            errOSAInvalidID:        previousAndResultingCompiledScriptID was not
;                                    valid on input
;    
;        ModeFlags:
;            kOSAModePreventGetSource
;            kOSAModeCompileIntoContext
;            kOSAModeAugmentContext
;            kOSAModeNeverInteract
;            kOSAModeCanInteract
;            kOSAModeAlwaysInteract
;            kOSAModeCantSwitchLayer
;            kOSAModeDontReconnect
;            kOSAModeDoRecord
;    


; *  OSACopyID()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSACopyID(ComponentInstance scriptingComponent, OSAID fromID, OSAID *toID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSACopyID
			move.l              #$00080104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSACopyID
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectCopyID, 8);
;        If toID is a reference to kOSANullScript then it is updated to have a
;        new scriptID value.  This call can be used to perform undo or revert
;        operations on scripts. 
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;    

	IF CALL_NOT_IN_CARBON THEN

; *  OSACopyScript()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSAError OSACopyScript(ComponentInstance scriptingComponent, OSAID fromID, OSAID *toID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSACopyScript
			move.l              #$00080105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSACopyScript
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectCopyScript, 8);
;        Creates a duplicate copy of the script with the given OSAID and returns
;        a new OSAID for it.  Can be used by script editors or debuggers. 
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;    

	ENDIF	; CALL_NOT_IN_CARBON
; **************************************************************************
;    OSA Optional GetSource Interface
;**************************************************************************
;    Scripting components that support the GetSource interface have the 
;    kOSASupportsGetSource bit set in their ComponentDescription.
;*************************************************************************


; *  OSAGetSource()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAGetSource(ComponentInstance scriptingComponent, OSAID scriptID, DescType desiredType, AEDesc *resultingSourceData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAGetSource
			move.l              #$000C0201,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAGetSource
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectGetSource, 12);
;        This routine causes a compiled script to be output in a form (possibly
;        text) such that it is suitable to be passed back to OSACompile.
;
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;            errOSASourceNotAvailable    can't get source for this scriptID
;    

; **************************************************************************
;    OSA Optional AECoercion Interface
;**************************************************************************
;    Scripting components that support the AECoercion interface have the 
;    kOSASupportsAECoercion bit set in their ComponentDescription.
;*************************************************************************


; *  OSACoerceFromDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSACoerceFromDesc(ComponentInstance scriptingComponent, const AEDesc *scriptData, long modeFlags, OSAID *resultingScriptID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSACoerceFromDesc
			move.l              #$000C0301,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSACoerceFromDesc
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectCoerceFromDesc, 12);
;        This routine causes script data to be coerced into a script value.
;        If the scriptData is an AppleEvent, then the resultingScriptID is a
;        compiled script ID (mode flags for OSACompile may be used in this case).
;        Other scriptData descriptors create script value IDs.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    
;        ModeFlags:
;            kOSAModePreventGetSource
;            kOSAModeCompileIntoContext
;            kOSAModeNeverInteract
;            kOSAModeCanInteract
;            kOSAModeAlwaysInteract
;            kOSAModeCantSwitchLayer
;            kOSAModeDontReconnect
;            kOSAModeDoRecord
;    


; *  OSACoerceToDesc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSACoerceToDesc(ComponentInstance scriptingComponent, OSAID scriptID, DescType desiredType, long modeFlags, AEDesc *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSACoerceToDesc
			move.l              #$00100302,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSACoerceToDesc
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectCoerceToDesc, 16);
;        This routine causes a script value to be coerced into any desired form.
;        If the scriptID denotes a compiled script, then it may be coerced to 
;        typeAppleEvent.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;    

; **************************************************************************
;    OSA Optional AESending Interface
;**************************************************************************
;    Scripting components that support the AESending interface have the 
;    kOSASupportsAESending bit set in their ComponentDescription.
;*************************************************************************

; 
;    Scripting systems will supply default values for these procedures if they
;    are not set by the client:
;


; *  OSASetSendProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSASetSendProc(ComponentInstance scriptingComponent, OSASendUPP sendProc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSASetSendProc
			move.l              #$00080401,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSASetSendProc
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectSetSendProc, 8);
;        If sendProc is nil, the default sendProc is used.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    


; *  OSAGetSendProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAGetSendProc(ComponentInstance scriptingComponent, OSASendUPP *sendProc, long *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAGetSendProc
			move.l              #$00080402,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAGetSendProc
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectGetSendProc, 8);
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    


; *  OSASetCreateProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSASetCreateProc(ComponentInstance scriptingComponent, OSACreateAppleEventUPP createProc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSASetCreateProc
			move.l              #$00080403,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSASetCreateProc
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectSetCreateProc, 8);
;        If createProc is nil, the default createProc is used.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    


; *  OSAGetCreateProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAGetCreateProc(ComponentInstance scriptingComponent, OSACreateAppleEventUPP *createProc, long *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAGetCreateProc
			move.l              #$00080404,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAGetCreateProc
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectGetCreateProc, 8);
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    


; *  OSASetDefaultTarget()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSASetDefaultTarget(ComponentInstance scriptingComponent, const AEAddressDesc *target)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSASetDefaultTarget
			move.l              #$00040405,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSASetDefaultTarget
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectSetDefaultTarget, 4);
;        This routine sets the default target application for AE sending.
;        It also establishes the default target from which terminologies come.
;        It is effectively like having an AppleScript "tell" statement around
;        the entire program.  If this routine is not called, or if the target 
;        is a null AEDesc, then the current application is the default target.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    

; **************************************************************************
;    OSA Optional Recording Interface
;**************************************************************************
;    Scripting components that support the Recording interface have the 
;    kOSASupportsRecording bit set in their ComponentDescription.
;*************************************************************************


; *  OSAStartRecording()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAStartRecording(ComponentInstance scriptingComponent, OSAID *compiledScriptToModifyID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAStartRecording
			move.l              #$00040501,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAStartRecording
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectStartRecording, 4);
;        Starts recording.  If compiledScriptToModifyID is kOSANullScript, a
;        new script ID is created and returned.  If the current application has
;        a handler for the kOSARecordedText event, then kOSARecordedText events
;        are sent to the application containing the text of each AppleEvent 
;        recorded.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;            errOSARecordingIsAlreadyOn
;    


; *  OSAStopRecording()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAStopRecording(ComponentInstance scriptingComponent, OSAID compiledScriptID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAStopRecording
			move.l              #$00040502,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAStopRecording
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectStopRecording, 4);
;        If compiledScriptID is not being recorded into or recording is not
;        currently on, no error is returned.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;    

; **************************************************************************
;    OSA Optional Convenience Interface
;**************************************************************************
;    Scripting components that support the Convenience interface have the 
;    kOSASupportsConvenience bit set in their ComponentDescription.
;*************************************************************************


; *  OSALoadExecute()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSALoadExecute(ComponentInstance scriptingComponent, const AEDesc *scriptData, OSAID contextID, long modeFlags, OSAID *resultingScriptValueID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSALoadExecute
			move.l              #$00100601,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSALoadExecute
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectLoadExecute, 16);
;        This routine is effectively equivalent to calling OSALoad followed by
;        OSAExecute.  After execution, the compiled source is disposed.  Only the
;        resulting value ID is retained.
;    
;        Errors:
;            badComponentInstance        invalid scripting component instance
;            errOSASystemError
;            errOSABadStorageType:       scriptData not for this scripting component
;            errOSACorruptData:          data seems to be corrupt
;            errOSADataFormatObsolete    script data format is no longer supported
;            errOSADataFormatTooNew      script data format is from a newer version
;            errOSAInvalidID
;            errOSAScriptError:          the executing script got an error
;    
;        ModeFlags:
;            kOSAModeNeverInteract
;            kOSAModeCanInteract
;            kOSAModeAlwaysInteract
;            kOSAModeCantSwitchLayer
;            kOSAModeDontReconnect
;            kOSAModeDoRecord
;    


; *  OSACompileExecute()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSACompileExecute(ComponentInstance scriptingComponent, const AEDesc *sourceData, OSAID contextID, long modeFlags, OSAID *resultingScriptValueID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSACompileExecute
			move.l              #$00100602,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSACompileExecute
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectCompileExecute, 16);
;        This routine is effectively equivalent to calling OSACompile followed by
;        OSAExecute.  After execution, the compiled source is disposed.  Only the
;        resulting value ID is retained.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errAECoercionFail:      sourceData is not compilable
;            errOSAScriptError:      sourceData was a bad script (syntax error)
;            errOSAInvalidID:        previousAndResultingCompiledScriptID was not
;                                    valid on input
;            errOSAScriptError:      the executing script got an error
;    
;        ModeFlags:
;            kOSAModeNeverInteract
;            kOSAModeCanInteract
;            kOSAModeAlwaysInteract
;            kOSAModeCantSwitchLayer
;            kOSAModeDontReconnect
;            kOSAModeDoRecord
;    


; *  OSADoScript()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADoScript(ComponentInstance scriptingComponent, const AEDesc *sourceData, OSAID contextID, DescType desiredType, long modeFlags, AEDesc *resultingText)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADoScript
			move.l              #$00140603,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADoScript
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectDoScript, 20);
;        This routine is effectively equivalent to calling OSACompile followed by
;        OSAExecute and then OSADisplay.  After execution, the compiled source
;        and the resulting value are is disposed.  Only the resultingText
;        descriptor is retained.  If a script error occur during processing, the 
;        resultingText gets the error message of the error, and errOSAScriptError
;        is returned.  OSAScriptError may still be used to extract more 
;        information about the particular error.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errAECoercionFail:      sourceData is not compilable or 
;                                    desiredType not supported by scripting component
;            errOSAScriptError:      sourceData was a bad script (syntax error)
;            errOSAInvalidID:        previousAndResultingCompiledScriptID was not
;                                    valid on input
;            errOSAScriptError:      the executing script got an error
;    
;        ModeFlags:
;            kOSAModeNeverInteract
;            kOSAModeCanInteract
;            kOSAModeAlwaysInteract
;            kOSAModeCantSwitchLayer
;            kOSAModeDontReconnect
;            kOSAModeDoRecord
;            kOSAModeDisplayForHumans
;    

; **************************************************************************
;    OSA Optional Dialects Interface
;**************************************************************************
;    Scripting components that support the Dialects interface have the 
;    kOSASupportsDialects bit set in their ComponentDescription.
;*************************************************************************

; 
;    These calls allows an scripting component that supports different dialects
;    to dynamically switch between those dialects.  Although this interface is
;    specified, the particular dialect codes are scripting component dependent.
;


; *  OSASetCurrentDialect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSASetCurrentDialect(ComponentInstance scriptingComponent, short dialectCode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSASetCurrentDialect
			move.l              #$00020701,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSASetCurrentDialect
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectSetCurrentDialect, 2);
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSANoSuchDialect:    invalid dialectCode
;    


; *  OSAGetCurrentDialect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAGetCurrentDialect(ComponentInstance scriptingComponent, short *resultingDialectCode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAGetCurrentDialect
			move.l              #$00040702,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAGetCurrentDialect
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectGetCurrentDialect, 4);
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    


; *  OSAAvailableDialects()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAAvailableDialects(ComponentInstance scriptingComponent, AEDesc *resultingDialectInfoList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAAvailableDialects
			move.l              #$00040703,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAAvailableDialects
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectAvailableDialects, 4);
;        This call return an AEList containing information about each of the
;        currently available dialects of a scripting component.  Each item
;        is an AERecord of typeOSADialectInfo that contains at least the fields
;        keyOSADialectName, keyOSADialectCode, KeyOSADialectLangCode and 
;        keyOSADialectScriptCode.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    


; *  OSAGetDialectInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAGetDialectInfo(ComponentInstance scriptingComponent, short dialectCode, OSType selector, AEDesc *resultingDialectInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAGetDialectInfo
			move.l              #$000A0704,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAGetDialectInfo
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectGetDialectInfo, 10);
;        This call gives information about the specified dialect of a scripting
;        component. It returns an AEDesc whose type depends on the selector 
;        specified. Available selectors are the same as the field keys for a
;        dialect info record. The type of AEDesc returned is the same as the 
;        type of the field that has same key as the selector.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSABadSelector
;            errOSANoSuchDialect:    invalid dialectCode
;    


; *  OSAAvailableDialectCodeList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAAvailableDialectCodeList(ComponentInstance scriptingComponent, AEDesc *resultingDialectCodeList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAAvailableDialectCodeList
			move.l              #$00040705,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAAvailableDialectCodeList
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectAvailableDialectCodeList, 4);
;        This is alternative to OSAGetAvailableDialectCodeList. Use this call
;        and  OSAGetDialectInfo to get information on dialects.
;        This call return an AEList containing dialect code for each of the
;        currently available dialects of a scripting component. Each dialect
;        code is a short integer of type typeShortInteger.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;
;        Type of a dialect info record containing at least keyOSADialectName
;        and keyOSADialectCode fields.
;
;        keys for dialect info record, also used as selectors to OSAGetDialectInfo.
;
;        Field of a typeOSADialectInfo record of typeChar.
;        Field of a typeOSADialectInfo record of typeShortInteger.
;        Field of a typeOSADialectInfo record of typeShortInteger.
;        Field of a typeOSADialectInfo record of typeShortInteger.
;    

; **************************************************************************
;    OSA Optional Event Handling Interface
;**************************************************************************
;    Scripting components that support the Event Handling interface have the 
;    kOSASupportsEventHandling bit set in their ComponentDescription.
;*************************************************************************


; *  OSASetResumeDispatchProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSASetResumeDispatchProc(ComponentInstance scriptingComponent, AEEventHandlerUPP resumeDispatchProc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSASetResumeDispatchProc
			move.l              #$00080801,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSASetResumeDispatchProc
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectSetResumeDispatchProc, 8);
;        This function is used to set the ResumeDispatchProc that will be used
;        by OSAExecuteEvent and OSADoEvent if either no event handler can be
;        found in the context, or the context event hander "continues" control
;        onward. The two constants kOSAUseStandardDispatch and kOSANoDispatch
;        may also be passed to this routine indicating that the handler registered
;        in the application with AEInstallEventHandler should be used, or no
;        dispatch should occur, respectively.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    


kOSAUseStandardDispatch			EQU		$FFFFFFFF
; 
;        Special ResumeDispatchProc constant which may be passed to 
;        OSASetResumeDispatchProc indicating that the handler registered
;        in the application with AEInstallEventHandler should be used.
;        
;        NOTE:   Had to remove the cast (AEEventHandlerUPP).  The C compiler
;                doesn't allow pointer types to be assigned to an enum.  All
;                constants must be assigned as enums to translate properly to
;                Pascal.
;    


kOSANoDispatch					EQU		0
; 
;        Special ResumeDispatchProc constant which may be passed to 
;        OSASetResumeDispatchProc indicating that no dispatch should occur.
;        
;        NOTE:   Had to remove the cast (AEEventHandlerUPP).  The C compiler
;                doesn't allow pointer types to be assigned to an enum.  All
;                constants must be assigned as enums to translate properly to
;                Pascal.
;    


kOSADontUsePhac					EQU		$0001
; 
;        Special refCon constant that may be given to OSASetResumeDispatchProc
;        only when kOSAUseStandardDispatch is used as the ResumeDispatchProc.
;        This causes the standard dispatch to be performed, except the phac
;        handler is not called.  This is useful during tinkerability, when
;        the phac handler is used to lookup a context associated with an event's 
;        direct parameter, and call OSAExecuteEvent or OSADoEvent.  Failure to
;        bypass the phac handler would result in an infinite loop.
;    


; *  OSAGetResumeDispatchProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAGetResumeDispatchProc(ComponentInstance scriptingComponent, AEEventHandlerUPP *resumeDispatchProc, long *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAGetResumeDispatchProc
			move.l              #$00080802,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAGetResumeDispatchProc
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectGetResumeDispatchProc, 8);
;        Returns the registered ResumeDispatchProc.  If no ResumeDispatchProc has
;        been registered, then kOSAUseStandardDispatch (the default) is returned.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;    


; *  OSAExecuteEvent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAExecuteEvent(ComponentInstance scriptingComponent, const AppleEvent *theAppleEvent, OSAID contextID, long modeFlags, OSAID *resultingScriptValueID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAExecuteEvent
			move.l              #$00100803,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAExecuteEvent
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectExecuteEvent, 16);
;        This call is similar to OSAExecute except the initial command to
;        execute comes in the form of an AppleEvent.  If the contextID
;        defines any event handlers for that event, they are used to process
;        the event.  If no event handler can be found in the context
;        errAEEventNotHandled is returned.  If an event handler is found and
;        the hander "continues" control onward, the ResumeDispatchProc
;        (registered with OSASetResumeDispatchProc, above) is called given the
;        AppleEvent.  The result is returned as a scriptValueID.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;            errOSAScriptError:      the executing script got an error
;            errAEEventNotHandled:   no handler for event in contextID
;    
;        ModeFlags:
;            kOSAModeNeverInteract
;            kOSAModeCanInteract
;            kOSAModeAlwaysInteract
;            kOSAModeCantSwitchLayer
;            kOSAModeDontReconnect
;            kOSAModeDoRecord
;    


; *  OSADoEvent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADoEvent(ComponentInstance scriptingComponent, const AppleEvent *theAppleEvent, OSAID contextID, long modeFlags, AppleEvent *reply)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADoEvent
			move.l              #$00100804,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADoEvent
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectDoEvent, 16);
;        This call is similar to OSADoScript except the initial command to
;        execute comes in the form of an AppleEvent, and the result is an 
;        AppleEvent reply record.  If the contextID defines any event handlers
;        for that event, they are used to process the event.  If no event handler
;        can be found in the context errAEEventNotHandled is returned.  If an
;        event handler is found and the hander "continues" control onward, the
;        ResumeDispatchProc (registered with OSASetResumeDispatchProc, above) is
;        called given the AppleEvent.  The result is returned in the form of an
;        AppleEvent reply descriptor. If at any time the script gets an error, or
;        if the ResumeDispatchProc returns a reply event indicating an error,
;        then the OSADoEvent call itself returns an error reply (i.e. OSADoEvent
;        should never return errOSAScriptError).  Any error result returned by
;        the ResumeDispatchProc will be returned by OSADoEvent.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;            errAEEventNotHandled:   no handler for event in contextID
;    
;        ModeFlags:
;            kOSAModeNeverInteract
;            kOSAModeCanInteract
;            kOSAModeAlwaysInteract
;            kOSAModeCantSwitchLayer
;            kOSAModeDontReconnect
;            kOSAModeDoRecord
;    


; *  OSAMakeContext()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSAMakeContext(ComponentInstance scriptingComponent, const AEDesc *contextName, OSAID parentContext, OSAID *resultingContextID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSAMakeContext
			move.l              #$000C0805,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSAMakeContext
	ENDIF

; 
;        OSAComponentFunctionInline(kOSASelectMakeContext, 12);
;        Makes a new empty context which may be passed to OSAExecute or 
;        OSAExecuteEvent.  If contextName is typeNull, an unnamed context is
;        created. If parentContext is kOSANullScript then the resulting context
;        does not inherit bindings from any other context.
;    
;        Errors:
;            badComponentInstance    invalid scripting component instance
;            errOSASystemError
;            errOSAInvalidID
;            errAECoercionFail:      contextName is invalid
;    

; 
; * Debugging API
; 

; 
; * Types
; 

; typedef OSAID 						OSADebugSessionRef

; typedef OSAID 						OSADebugCallFrameRef

; 
; * Constants
; 


; typedef UInt32						OSAProgramState
eNotStarted						EQU		0
eRunnable						EQU		1
eRunning						EQU		2
eStopped						EQU		3
eTerminated						EQU		4

; typedef UInt32						OSADebugStepKind
eStepOver						EQU		0
eStepIn							EQU		1
eStepOut						EQU		2
eRun							EQU		3
; 
; * Session Information
; 


keyProgramState					EQU		'dsps'
; 
; * Call Frame Information
; 

StatementRange			RECORD 0
startPos				 ds.l	1				; offset: $0 (0)
endPos					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR

typeStatementRange				EQU		'srng'

keyProcedureName				EQU		'dfnm'				; typeChar 
keyStatementRange				EQU		'dfsr'				; typeStatementRange 
keyLocalsNames					EQU		'dfln'				; typeAEList of typeChar 
keyGlobalsNames					EQU		'dfgn'				; typeAEList of typeChar 
keyParamsNames					EQU		'dfpn'				; typeAEList of typeChar 
; 
; * Sessions
; 


; *  OSADebuggerCreateSession()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerCreateSession(ComponentInstance scriptingComponent, OSAID inScript, OSAID inContext, OSADebugSessionRef *outSession)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerCreateSession
			move.l              #$000C0901,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerCreateSession
	ENDIF


; *  OSADebuggerGetSessionState()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerGetSessionState(ComponentInstance scriptingComponent, OSADebugSessionRef inSession, AERecord *outState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerGetSessionState
			move.l              #$00080902,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerGetSessionState
	ENDIF


; *  OSADebuggerSessionStep()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerSessionStep(ComponentInstance scriptingComponent, OSADebugSessionRef inSession, OSADebugStepKind inKind)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerSessionStep
			move.l              #$00080903,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerSessionStep
	ENDIF


; *  OSADebuggerDisposeSession()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerDisposeSession(ComponentInstance scriptingComponent, OSADebugSessionRef inSession)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerDisposeSession
			move.l              #$00040904,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerDisposeSession
	ENDIF


; *  OSADebuggerGetStatementRanges()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerGetStatementRanges(ComponentInstance scriptingComponent, OSADebugSessionRef inSession, AEDescList *outStatementRangeArray)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerGetStatementRanges
			move.l              #$00080905,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerGetStatementRanges
	ENDIF

;  Returns an array of StatementRange objects.

; *  OSADebuggerGetBreakpoint()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerGetBreakpoint(ComponentInstance scriptingComponent, OSADebugSessionRef inSession, UInt32 inSrcOffset, OSAID *outBreakpoint)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerGetBreakpoint
			move.l              #$000C0910,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerGetBreakpoint
	ENDIF


; *  OSADebuggerSetBreakpoint()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerSetBreakpoint(ComponentInstance scriptingComponent, OSADebugSessionRef inSession, UInt32 inSrcOffset, OSAID inBreakpoint)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerSetBreakpoint
			move.l              #$000C0911,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerSetBreakpoint
	ENDIF


; *  OSADebuggerGetDefaultBreakpoint()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerGetDefaultBreakpoint(ComponentInstance scriptingComponent, OSADebugSessionRef inSession, OSAID *outBreakpoint)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerGetDefaultBreakpoint
			move.l              #$00080912,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerGetDefaultBreakpoint
	ENDIF

; 
; * Call Frames
; 


; *  OSADebuggerGetCurrentCallFrame()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerGetCurrentCallFrame(ComponentInstance scriptingComponent, OSADebugSessionRef inSession, OSADebugCallFrameRef *outCallFrame)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerGetCurrentCallFrame
			move.l              #$00080906,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerGetCurrentCallFrame
	ENDIF


; *  OSADebuggerGetCallFrameState()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerGetCallFrameState(ComponentInstance scriptingComponent, OSADebugCallFrameRef inCallFrame, AERecord *outState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerGetCallFrameState
			move.l              #$00080907,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerGetCallFrameState
	ENDIF


; *  OSADebuggerGetVariable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerGetVariable(ComponentInstance scriptingComponent, OSADebugCallFrameRef inCallFrame, const AEDesc *inVariableName, OSAID *outVariable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerGetVariable
			move.l              #$000C0908,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerGetVariable
	ENDIF


; *  OSADebuggerSetVariable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerSetVariable(ComponentInstance scriptingComponent, OSADebugCallFrameRef inCallFrame, const AEDesc *inVariableName, OSAID inVariable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerSetVariable
			move.l              #$000C0909,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerSetVariable
	ENDIF


; *  OSADebuggerGetPreviousCallFrame()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerGetPreviousCallFrame(ComponentInstance scriptingComponent, OSADebugCallFrameRef inCurrentFrame, OSADebugCallFrameRef *outPrevFrame)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerGetPreviousCallFrame
			move.l              #$0008090A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerGetPreviousCallFrame
	ENDIF


; *  OSADebuggerDisposeCallFrame()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in AppleScriptLib 1.5 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSAError OSADebuggerDisposeCallFrame(ComponentInstance scriptingComponent, OSADebugCallFrameRef inCallFrame)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** Â¬ TARGET_RT_MAC_CFM THEN
		Macro
		_OSADebuggerDisposeCallFrame
			move.l              #$0004090B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OSADebuggerDisposeCallFrame
	ENDIF

	ENDIF ; __OSA__ 


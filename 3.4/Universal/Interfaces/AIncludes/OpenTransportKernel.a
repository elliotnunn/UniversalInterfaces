;
;    File:       OpenTransportKernel.a
;
;    Contains:   Definitions for Open Transport kernel code, such as drivers and protocol modules.
;
;    Version:    Technology: 2.5
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1993-2001 by Apple Computer, Inc. and Mentat Inc., all rights reserved.
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__OPENTRANSPORTKERNEL__') = 'UNDEFINED' THEN
__OPENTRANSPORTKERNEL__ SET 1

	IF &TYPE('OTKERNEL') <> 'UNDEFINED' THEN
	IF ¬ OTKERNEL THEN
	ENDIF
	ENDIF
	OTKERNEL: SET 1

;   We include "OpenTransportProtocol.h", which in turn includes
;   "OpenTransport.h", thereby picking up all the stuff which
;   is shared between client and kernel.


	IF &TYPE('__OPENTRANSPORTPROTOCOL__') = 'UNDEFINED' THEN
	include 'OpenTransportProtocol.a'
	ENDIF
	IF &TYPE('__NAMEREGISTRY__') = 'UNDEFINED' THEN
	include 'NameRegistry.a'
	ENDIF

;  ***** From the Mentat "mistream.h" *****



;   Parts of "mistream.h" that are shared by the client
;   and the kernel are in "OpenTransportProtocol.h".




	IF CALL_NOT_IN_CARBON THEN

; *  allocb()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *allocb(OTByteCount size, OTInt32 pri)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION allocb
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  allocbi()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *allocbi(OTByteCount size, OTInt32 pri, allocbiProc pfv, char *arg, unsigned char *base)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION allocbi
	ENDIF


; *  allocq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern queue_t *allocq(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION allocq
	ENDIF


; *  adjmsg()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 adjmsg(mblk_t *mp, OTInt32 len_param)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION adjmsg
	ENDIF


; *  backq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern queue_t *backq(queue_t *q)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION backq
	ENDIF


; *  bcanput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 bcanput(queue_t *q, OTUInt8Param pri)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION bcanput
	ENDIF


; *  bcanputnext()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 bcanputnext(queue_t *q, OTUInt8Param pri)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION bcanputnext
	ENDIF


; *  bufcall()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 bufcall(OTByteCount memNeeded, OTInt32 pri, bufcallp_t proc, long context)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION bufcall
	ENDIF


; *  canput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 canput(queue_t *q)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION canput
	ENDIF


; *  canputnext()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 canputnext(queue_t *q)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION canputnext
	ENDIF


; *  copyb()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *copyb(mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION copyb
	ENDIF


; *  copymsg()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *copymsg(mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION copymsg
	ENDIF


; *  dupb()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *dupb(mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION dupb
	ENDIF


; *  dupmsg()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *dupmsg(mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION dupmsg
	ENDIF


; *  esballoc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *esballoc(unsigned char *base, OTByteCount size, OTInt32 pri, frtn_t *freeInfo)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION esballoc
	ENDIF


; *  esballoca()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *esballoca(unsigned char *base, OTByteCount size, OTInt32 pri, frtn_t *freeInfo)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION esballoca
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  esbbcall()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 esbbcall(OTInt32 pri, esbbcallProc func, long arg)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION esbbcall
	ENDIF


; *  flushband()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void flushband(queue_t *q, OTUInt8Param pri, OTInt32 flag)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION flushband
	ENDIF


; *  flushq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void flushq(queue_t *q, OTInt32 flag)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION flushq
	ENDIF


; *  freeb()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void freeb(mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION freeb
	ENDIF


; *  freemsg()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void freemsg(mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION freemsg
	ENDIF


; *  freeq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 freeq(queue_t *q)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION freeq
	ENDIF


; *  freezestr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 freezestr(queue_t *q)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION freezestr
	ENDIF


; *  getadmin()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern admin_t getadmin(OTUInt16Param mid)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION getadmin
	ENDIF


; *  getmid()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern unsigned short getmid(char *name)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION getmid
	ENDIF


; *  getq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *getq(queue_t *q)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION getq
	ENDIF


; *  insq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 insq(queue_t *q, mblk_t *emp, mblk_t *nmp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION insq
	ENDIF


; *  linkb()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void linkb(mblk_t *mp1, mblk_t *mp2)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION linkb
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  mpnotify()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 mpnotify(mblk_t *mp, mpnotifyProc pfv, char *arg)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mpnotify
	ENDIF


; *  msgdsize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 msgdsize(const mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION msgdsize
	ENDIF


; *  msgpullup()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *msgpullup(mblk_t *mp, OTInt32 len)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION msgpullup
	ENDIF


; *  pullupmsg()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 pullupmsg(mblk_t *mp, OTInt32 len)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION pullupmsg
	ENDIF


; *  put()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 put(queue_t *q, mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION put
	ENDIF


; *  putbq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 putbq(queue_t *q, mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION putbq
	ENDIF


; *  putctl()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 putctl(queue_t *q, OTInt32 mType)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION putctl
	ENDIF


; *  putnextctl()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 putnextctl(queue_t *q, OTInt32 mType)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION putnextctl
	ENDIF


; *  putctl1()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 putctl1(queue_t *q, OTInt32 mType, OTInt32 c)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION putctl1
	ENDIF


; *  putnextctl1()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 putnextctl1(queue_t *q, OTInt32 mType, OTInt32 c)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION putnextctl1
	ENDIF


; *  putctl2()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 putctl2(queue_t *q, OTInt32 mType, OTInt32 c1, OTInt32 c2)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION putctl2
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	IF &TYPE('puthere') = 'UNDEFINED' THEN
	IF CALL_NOT_IN_CARBON THEN

; *  puthere()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 puthere(queue_t *q, mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION puthere
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF
	IF CALL_NOT_IN_CARBON THEN

; *  putnext()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 putnext(queue_t *q, mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION putnext
	ENDIF


; *  putq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 putq(queue_t *q, mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION putq
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  qenable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void qenable(queue_t *q)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION qenable
	ENDIF


; *  qprocson()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void qprocson(queue_t *q)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION qprocson
	ENDIF


; *  qprocsoff()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void qprocsoff(queue_t *q)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION qprocsoff
	ENDIF


; *  qreply()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 qreply(queue_t *q, mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION qreply
	ENDIF


; *  qsize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 qsize(queue_t *q)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION qsize
	ENDIF


; *  rmvb()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *rmvb(mblk_t *mp, mblk_t *bp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION rmvb
	ENDIF


; *  rmvq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void rmvq(queue_t *q, mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION rmvq
	ENDIF

;  prototype for strlog in "strlog.h" section, below 

; *  strqget()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 strqget(queue_t *q, qfields_t what, OTUInt8Param pri, long *valp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION strqget
	ENDIF


; *  strqset()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 strqset(queue_t *q, qfields_t what, OTUInt8Param pri, long val)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION strqset
	ENDIF


; *  testb()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 testb(OTByteCount size, OTInt32 pri)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION testb
	ENDIF


; *  unbufcall()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void unbufcall(OTInt32 id)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION unbufcall
	ENDIF


; *  unfreezestr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void unfreezestr(queue_t *q, OTInt32 oldpri)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION unfreezestr
	ENDIF


; *  unlinkb()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *unlinkb(mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION unlinkb
	ENDIF

;  ***** From the Mentat "strlog.h" *****



; *  strlog()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 strlog(OTInt32 mid, OTInt32 sid, OTInt32 level, OTUInt32 flags, char *fmt, ...)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION strlog
	ENDIF

;  ***** Printing Functions *****

	ENDIF	; CALL_NOT_IN_CARBON

kOTPrintOnly					EQU		0
kOTPrintThenStop				EQU		1
	IF CALL_NOT_IN_CARBON THEN

; *  OTKernelPrintf()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 OTKernelPrintf(OTInt32 toDo, char *fmt, ...)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTKernelPrintf
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

CE_CONT							EQU		0					; Does kOTPrintOnly   
CE_NOTE							EQU		0					; Just print 
CE_WARN							EQU		1					; Does kOTPrintThenStop  
CE_PANIC						EQU		2					; Does System Error 107  
	IF CALL_NOT_IN_CARBON THEN

; *  cmn_err()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void cmn_err(OTInt32 errType, char *fmt, ...)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION cmn_err
	ENDIF


; *  mi_sprintf()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 mi_sprintf(char *buf, char *fmt, ...)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_sprintf
	ENDIF

;  Create sprintf and printf functions that will work in STREAM modules.

;  ***** FIIK *****

;  ••• useful header comment please •••


;   Function to convert the "long" value that comes back in some of the
;   netbufs as a result code to the equivalent OSStatus



	ENDIF	; CALL_NOT_IN_CARBON
; typedef long 							OTError

	IF CALL_NOT_IN_CARBON THEN

; *  OTErrorToOSStatus()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OSStatus OTErrorToOSStatus(OTError err)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTErrorToOSStatus
	ENDIF

;  ***** STREAMS Plug-in Interface ****


;   Synchronization level codes.  These are supplied to modsw_install and
;   stored in the appropriate tables.  sth_osr_open and
;   sth_ipush use these to set up synch queue subordination for new devices
;   and modules.



	ENDIF	; CALL_NOT_IN_CARBON

SQLVL_QUEUE						EQU		1
SQLVL_QUEUEPAIR					EQU		2
SQLVL_MODULE					EQU		3
SQLVL_GLOBAL					EQU		4
SQLVL_DEFAULT					EQU		3
;  The install_info structure.

install_info			RECORD 0
install_str				 ds.l	1				; offset: $0 (0)		;  Streamtab pointer.     
install_flags			 ds.l	1				; offset: $4 (4)
install_sqlvl			 ds.l	1				; offset: $8 (8)		;  Synchronization level. 
install_buddy			 ds.l	1				; offset: $C (12)		;  Shared writer list buddy 
ref_load				 ds.l	1				; offset: $10 (16)		;  Set to 0             
ref_count				 ds.l	1				; offset: $14 (20)		;  set to 0             
sizeof					 EQU *					; size:   $18 (24)
						ENDR
;   Flags used in the install_flags field

kOTModIsDriver					EQU		$00000001
kOTModIsModule					EQU		$00000002
kOTModNoWriter					EQU		$00000010
kOTModUpperIsTPI				EQU		$00001000
kOTModUpperIsDLPI				EQU		$00002000
kOTModLowerIsTPI				EQU		$00004000
kOTModLowerIsDLPI				EQU		$00008000
kOTModGlobalContext				EQU		$00800000			; This flag says you don't want per-context globals
kOTModUsesInterrupts			EQU		$08000000			; This flag is only valid if kOTModIsDriver is set and the driver is a PCI-card driver using the Name Registry
kOTModIsComplexDriver			EQU		$20000000			; This flag is only valid if kOTModIsDriver is set.
kOTModIsFilter					EQU		$40000000			; This flag is only valid if kOTModIsModule is set.
;  Typedef for the GetOTInstallInfo function


;   Your module must export this function, and return a pointer to the
;   install_info structure for the module.



;  Typedef for the InitStreamModule function

;   Your module can optionally export this function.  It will be called 
;   whenever your module is about to be loaded into a stream for the
;   first time, or if it is about to be reloaded after having been 
;   unloaded. Return false if your module should NOT be loaded.
;   For STREAMS modules, the void* parameter will be NULL.  For drivers, it
;   will be the same cookie parameter that was used for registering the module.
;   For PCI card drivers, this will be a pointer to the OTPCIInfo structure,
;   which can also be interpreted as a RegEntryIDPtr.



;  Typedef for the TerminateStreamModule function

;   Your module can optionally export this function.  It will be called 
;   whenever your module has been closed for the last time (i.e. no other 
;   outstanding instances of the module exist).



;  Equates for shared library prefixes

;  ***** Majors and Minors *****

;  Functions for dealing with major and minor device numbers

; typedef UInt16 						major_t

; typedef UInt16 						minor_t


;   This is the first minor number that Apple OT drivers use for CLONEOPENs.
;   Minor numbers 0 through 9 are reserved for use by the modules
;   for various control streams.  Note that Mentat drivers, which
;   use mi_open_comm, start minor numbers from 5.



kFirstMinorNumber				EQU		10
;  ***** Logging Macros *****

	IF CALL_NOT_IN_CARBON THEN

; *  OTStrlog()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void OTStrlog(queue_t *q, OTInt32 lvl, OTInt32 flags, const char *str)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTStrlog
	ENDIF

;  These are enums for the level value

	ENDIF	; CALL_NOT_IN_CARBON

kOTLvlFatal						EQU		0
kOTLvlNonfatal					EQU		1
kOTLvlExtFatal					EQU		2
kOTLvlExtNonfatal				EQU		3
kOTLvlUserErr					EQU		4
kOTLvlInfoErr					EQU		5
kOTLvlInfoOnly					EQU		6

;  ***** TPI Additions *****


;   Extra OTCommand codes that may appear on your module queue.
;   These are extensions to the TPI specification for Open Transport.
;   T_PRIVATE_REQ is the first available TPI message number for private
;   use by modules (assuming you don't want to be confused by standard
;   TPI messages).





kOTT_TIMER_REQ					EQU		80					; Timer event                   
kOTT_MIB_REQ					EQU		81					; Request module's MIB             
kOTT_MIB_ACK					EQU		82					; The module's MIB is available   
kOTT_PRIVATE_REQ				EQU		90					; The first private request available    
T_MIB_req				RECORD 0
PRIM_type				 ds.l	1				; offset: $0 (0)		;  Always T_MIB_REQ 
sizeof					 EQU *					; size:   $4 (4)
						ENDR
T_MIB_ack				RECORD 0
PRIM_type				 ds.l	1				; offset: $0 (0)		;  Always T_MIB_ACK   
MIB_length				 ds.l	1				; offset: $4 (4)		;  MIB length          
MIB_offset				 ds.l	1				; offset: $8 (8)		;  MIB Offset         
sizeof					 EQU *					; size:   $C (12)
						ENDR
T_stream_timer			RECORD 0
PRIM_type				 ds.l	1				; offset: $0 (0)		;  Always T_TIMER_REQ 
USER_long				 ds.l	1				; offset: $4 (4)
						 ORG 4
USER_ptr				 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  ***** Kernel Port Stuff *****

;   Kernel port record, which is a direct analogue of
;   the OTPortRecord in "OpenTransport.h".  Note that
;   when working with TPortRecord's, you're always
;   working with OT's one true copy of the record,
;   whereas when working with OTPortRecord's, you're
;   always working with a copy.



TPortRecord				RECORD 0
fLink					 ds		OTLink			; offset: $0 (0)
fPortName				 ds.l	1				; offset: $4 (4)
fModuleName				 ds.l	1				; offset: $8 (8)
fResourceInfo			 ds.l	1				; offset: $C (12)
fSlotID					 ds.l	1				; offset: $10 (16)
fAlias					 ds.l	1				; offset: $14 (20)
fNumChildren			 ds.l	1				; offset: $18 (24)
fChildPorts				 ds.l	1				; offset: $1C (28)
fPortFlags				 ds.l	1				; offset: $20 (32)
fInfoFlags				 ds.l	1				; offset: $24 (36)
fCapabilities			 ds.l	1				; offset: $28 (40)
fRef					 ds.l	1				; offset: $2C (44)
fStreamtab				 ds.l	1				; offset: $30 (48)
fContext				 ds.l	1				; offset: $34 (52)
fExtra					 ds.l	1				; offset: $38 (56)
sizeof					 EQU *					; size:   $3C (60)
						ENDR
;  Port utilities

;   These routines can be used by kernel code to register, find and iterate
;   through the various ports on the machine.  Do not confuse these with
;   the client-side routines, defined in "OpenTransport.h".




;   Register a port. The name the port was registered under is returned in
;   the fPortName field.  This routine allocates a TPortRecord and
;   copies the supplied OTPortRecord into it.


	IF CALL_NOT_IN_CARBON THEN

; *  OTRegisterPort()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OSStatus OTRegisterPort(OTPortRecord *portInfo, void *ref)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTRegisterPort
	ENDIF


;   Unregister the port with the given name (If you re-register the
;   port, it may get a different name - use OTChangePortState if
;   that is not desireable).  Since a single OTPortRef can be registered
;   with several names, the API needs to use the portName rather than
;   the OTPortRef to disambiguate.



; *  OTUnregisterPort()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OSStatus OTUnregisterPort(const char *portName, void **refPtr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTUnregisterPort
	ENDIF

;  Change the state of the port.

; *  OTChangePortState()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OSStatus OTChangePortState(OTPortRef portRef, OTEventCode theChange, OTResult why)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTChangePortState
	ENDIF

;  Find the TPortRecord for a given Port Name

; *  OTFindPort()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern TPortRecord *OTFindPort(const char *portName)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTFindPort
	ENDIF

;  Find the "nth" TPortRecord

; *  OTGetIndexedPort()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern TPortRecord *OTGetIndexedPort(OTItemCount index)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTGetIndexedPort
	ENDIF


;   Find another port that is active and conflicts with
;   the port described by "ref"



; *  OTFindPortConflict()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern TPortRecord *OTFindPortConflict(OTPortRef ref)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTFindPortConflict
	ENDIF

;  Other ways of finding the port

; *  OTFindPortByRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern TPortRecord *OTFindPortByRef(OTPortRef ref)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTFindPortByRef
	ENDIF


; *  OTFindPortByDev()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern TPortRecord *OTFindPortByDev(dev_t dev)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTFindPortByDev
	ENDIF

;  ***** Port Scanners *****

;  Shared library definitions


;   Prefix for Open Transport port scanners.
;   Your port-scanning ASLM function set must use the prefix kOTPortScannerPrefix.




;   The kOTPortScannerInterfaceID define is what you need to add to your
;   export file for the "interfaceID = " clause.  




;  OTScanPorts entry point.

;  Your port-scanning function must be exported by the name "OTScanPorts".

;  Selectors for the scanType parameter to PortScanProcPtr.

	ENDIF	; CALL_NOT_IN_CARBON

kOTInitialScan					EQU		0
kOTScanAfterSleep				EQU		1
;  PortScanProcPtr is the typedef for the scanning function.


;   Memory allocation for port persistent data, such as the
;   memory referenced by the ref parameter you pass to
;   OTRegisterPort.


	IF CALL_NOT_IN_CARBON THEN

; *  OTAllocPortMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void *OTAllocPortMem(OTByteCount size)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTAllocPortMem
	ENDIF


; *  OTFreePortMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void OTFreePortMem(void *mem)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTFreePortMem
	ENDIF

;  ***** Interrupt Control Functions ****

	ENDIF	; CALL_NOT_IN_CARBON
	IF TARGET_CPU_68K THEN

;   MPS_INTR_STATE saves the current interrupt state
;   Its definition changes with the definition
;   of mps_intr_enable/disable, so this typedef is
;   also inside the TARGET_CPU_68K conditional.


; typedef UInt8 						MPS_INTR_STATE

;  Disable interrupts and save the state
	IF OTDEBUG THEN
	IF CALL_NOT_IN_CARBON THEN

; *  mps_intr_disable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mps_intr_disable(MPS_INTR_STATE *oldState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	oldState        => A0
		Macro
		_mps_intr_disable
			dc.w            	$40C0
			dc.w            	$E040
			dc.w            	$007C
			dc.w            	$0600
			dc.w            	$027C
			dc.w            	$FEFF
			dc.w            	$1080
			dc.w            	$0200
			dc.w            	$0070
			dc.w            	$0C00
			dc.w            	$0070
			dc.w            	$6602
			dc.w            	$A9FF
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mps_intr_disable
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ELSE
	IF CALL_NOT_IN_CARBON THEN

; *  mps_intr_disable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mps_intr_disable(MPS_INTR_STATE *oldState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	oldState        => A0
		Macro
		_mps_intr_disable
			dc.w            	$40C0
			dc.w            	$E040
			dc.w            	$007C
			dc.w            	$0600
			dc.w            	$027C
			dc.w            	$FEFF
			dc.w            	$1080
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mps_intr_disable
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF	; OTDEBUG

;   move sr,d0
;   asr.w #8,d0
;   ori #$600,sr
;   andi #$FEFF,sr
;   move.b d0,(a0)
;   #if OTDEBUG
;       andi.b #$70,d0
;       cmpi.b #$70,d0
;       bne.s @3
;       DebugBreak
;   #endif


;  Enable interrupts from the saved state
	IF OTDEBUG THEN
	IF CALL_NOT_IN_CARBON THEN

; *  mps_intr_enable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mps_intr_enable(MPS_INTR_STATE *oldState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	oldState        => A0
		Macro
		_mps_intr_enable
			dc.w            	$40C0
			dc.w            	$0240
			dc.w            	$0700
			dc.w            	$0C40
			dc.w            	$0600
			dc.w            	$6702
			dc.w            	$A9FF
			dc.w            	$1010
			dc.w            	$0200
			dc.w            	$0070
			dc.w            	$0C00
			dc.w            	$0070
			dc.w            	$6602
			dc.w            	$A9FF
			dc.w            	$1010
			dc.w            	$E140
			dc.w            	$46C0
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mps_intr_enable
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ELSE
	IF CALL_NOT_IN_CARBON THEN

; *  mps_intr_enable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mps_intr_enable(MPS_INTR_STATE *oldState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	oldState        => A0
		Macro
		_mps_intr_enable
			move.b              (A0),D0
			dc.w            	$E140
			dc.w            	$46C0
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mps_intr_enable
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF	; OTDEBUG

;   #if OTDEBUG
;       move sr,d0
;       andi.w #$700,d0
;       cmpi.w #$600,d0
;       beq.s @2
;       DebugBreak
;   #endif
;   move.b (a0),d0
;   #if OTDEBUG
;       andi.b #$70,d0
;       cmpi.b #$70,d0
;       bne.s @3
;       DebugBreak
;       move.b (a0),d0
;   #endif
;   asl.w #8,d0
;   move d0,sr


	ELSE
; typedef UInt8 						MPS_INTR_STATE

	IF CALL_NOT_IN_CARBON THEN

; *  mps_intr_disable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mps_intr_disable(MPS_INTR_STATE *oldState)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mps_intr_disable
	ENDIF


; *  mps_intr_enable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mps_intr_enable(MPS_INTR_STATE *oldState)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mps_intr_enable
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF	; TARGET_CPU_68K
;  ***** Timer Functions *****

kOTMinimumTimerValue			EQU		8					; 8 milliseconds is the minimum timeout value
	IF CALL_NOT_IN_CARBON THEN

; *  mi_timer_alloc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_timer_alloc(queue_t *q, OTByteCount size)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_timer_alloc
	ENDIF


; *  mi_timer_free()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mi_timer_free(mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_timer_free
	ENDIF


; *  mi_timer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mi_timer(mblk_t *mp, unsigned long milliSeconds)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_timer
	ENDIF


; *  mi_timer_cancel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Boolean mi_timer_cancel(mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_timer_cancel
	ENDIF


; *  mi_timer_valid()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Boolean mi_timer_valid(mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_timer_valid
	ENDIF


; *  mi_timer_q_switch()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_timer_q_switch(mblk_t *mp, queue_t *q, mblk_t *new_mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_timer_q_switch
	ENDIF

;  ***** Driver Deferred Task Extras *****


;   This routine is used by a driver at interrupt time to schedule
;   a deferred task to run their interrupt processing code.



; *  OTScheduleDriverDeferredTask()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Boolean OTScheduleDriverDeferredTask(long dtCookie)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTScheduleDriverDeferredTask
	ENDIF

;  ***** Driver Memory Routines *****


;   These routines are different from the
;   similarly named routines in "OpenTransport.h" because they allocate
;   memory in the OT kernel pool.  See Technote •••• "Understanding
;   Open Transport Memory Management" for details.




;   This is the typedef for a function that will be called when a message
;   created by OTAllocMsg is destroyed.



	ENDIF	; CALL_NOT_IN_CARBON

;   This function creates a message which points to "size" bytes of data
;   at "buf".  When the message is freed, the EsbFreeProcPtr function "func"
;   will be called with the argument "arg".
;   NOTE: This function allows users of your buffer to modify the buffer.


	IF CALL_NOT_IN_CARBON THEN

; *  OTAllocMsg()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *OTAllocMsg(void *buf, OTByteCount size, EsbFreeProcPtr func, void *arg)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTAllocMsg
	ENDIF


;   Routines to allocate and free memory in your modules (these are
;   interrupt-time safe!).




; *  OTAllocMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void *OTAllocMem(OTByteCount size)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTAllocMem
	ENDIF


; *  OTFreeMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void OTFreeMem(void *mem)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTFreeMem
	ENDIF


; *  OTReallocMem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void *OTReallocMem(void *ptr, OTByteCount newSize)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION OTReallocMem
	ENDIF


;   Also, make sure that calling traditional "C" allocation routines
;   will not compile.



;  ***** Kernel Memory Utilities *****


; *  mi_bcmp()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 mi_bcmp(const char *first, const char *second, OTByteCount nBytes)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_bcmp
	ENDIF

;  Standard STREAMS memory utilities.


;   Standard STREAMS bcopy, bzero, & bcmp take char* parameters.
;   The BCOPY, BZERO, and BCMP routines take void* so that we do not have
;   to cast all the pointers.




; *******************************************************************************
;** Some helpful utilites from Mentat
;*******************************************************************************

;  Routines to calculate various sizes of STREAM messages

;  Useful macros for STREAMS copy in and out.

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  mps_become_writer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mps_become_writer(queue_t *q, mblk_t *mp, OTWriterProcPtr proc)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mps_become_writer
	ENDIF


; *  drv_priv()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 drv_priv(cred *credp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION drv_priv
	ENDIF


; *  mi_allocq()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern queue_t *mi_allocq(streamtab *st)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_allocq
	ENDIF


; *  mi_tpi_ack_alloc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_ack_alloc(mblk_t *mp, OTByteCount size, long primType)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_ack_alloc
	ENDIF


; *  mi_tpi_conn_con()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_conn_con(mblk_t *trailer_mp, char *src, OTByteCount src_length, char *opt, OTByteCount opt_length)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_conn_con
	ENDIF


; *  mi_tpi_conn_ind()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_conn_ind(mblk_t *trailer_mp, char *src, OTByteCount src_length, char *opt, OTByteCount opt_length, OTInt32 seqnum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_conn_ind
	ENDIF


; *  mi_tpi_conn_req()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_conn_req(mblk_t *trailer_mp, char *dest, OTByteCount dest_length, char *opt, OTByteCount opt_length)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_conn_req
	ENDIF


; *  mi_tpi_data_ind()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_data_ind(mblk_t *trailer_mp, OTInt32 flags, long ptype)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_data_ind
	ENDIF


; *  mi_tpi_data_req()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_data_req(mblk_t *trailer_mp, OTInt32 flags, long pttype)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_data_req
	ENDIF


; *  mi_tpi_discon_ind()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_discon_ind(mblk_t *trailer_mp, OTInt32 reason, OTInt32 seqnum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_discon_ind
	ENDIF


; *  mi_tpi_discon_req()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_discon_req(mblk_t *trailer_mp, OTInt32 seqnum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_discon_req
	ENDIF


; *  mi_tpi_err_ack_alloc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_err_ack_alloc(mblk_t *mp, OTInt32 tlierr, OTInt32 unixerr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_err_ack_alloc
	ENDIF


; *  mi_tpi_exdata_ind()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_exdata_ind(mblk_t *trailer_mp, OTInt32 flags, long ptype)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_exdata_ind
	ENDIF


; *  mi_tpi_exdata_req()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_exdata_req(mblk_t *trailer_mp, OTInt32 flags, long ptype)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_exdata_req
	ENDIF


; *  mi_tpi_info_req()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_info_req(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_info_req
	ENDIF


; *  mi_tpi_ok_ack_alloc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_ok_ack_alloc(mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_ok_ack_alloc
	ENDIF


; *  mi_tpi_ordrel_ind()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_ordrel_ind(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_ordrel_ind
	ENDIF


; *  mi_tpi_ordrel_req()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_ordrel_req(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_ordrel_req
	ENDIF


; *  mi_tpi_uderror_ind()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_uderror_ind(char *dest, OTByteCount dest_length, char *opt, OTByteCount opt_length, OTInt32 error)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_uderror_ind
	ENDIF


; *  mi_tpi_unitdata_ind()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_unitdata_ind(mblk_t *trailer_mp, char *src, OTByteCount src_length, char *opt, OTByteCount opt_length)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_unitdata_ind
	ENDIF


; *  mi_tpi_unitdata_req()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_tpi_unitdata_req(mblk_t *trailer_mp, char *dst, OTByteCount dst_length, char *opt, OTByteCount opt_length)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_tpi_unitdata_req
	ENDIF


; *  mi_reuse_proto()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_reuse_proto(mblk_t *toReuse, OTByteCount sizeDesired, OTBooleanParam keepOnError)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_reuse_proto
	ENDIF


; *  mi_reallocb()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_reallocb(mblk_t *old_mp, OTByteCount new_size)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_reallocb
	ENDIF


; *  mi_set_sth_hiwat()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Boolean mi_set_sth_hiwat(queue_t *q, OTByteCount size)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_set_sth_hiwat
	ENDIF


; *  mi_set_sth_lowat()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Boolean mi_set_sth_lowat(queue_t *q, OTByteCount size)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_set_sth_lowat
	ENDIF


; *  mi_set_sth_maxblk()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Boolean mi_set_sth_maxblk(queue_t *q, OTByteCount size)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_set_sth_maxblk
	ENDIF


; *  mi_set_sth_wroff()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Boolean mi_set_sth_wroff(queue_t *q, OTByteCount size)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_set_sth_wroff
	ENDIF


; *  mi_offset_param()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern UInt8 *mi_offset_param(mblk_t *mp, long offset, long len)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_offset_param
	ENDIF


; *  mi_offset_paramc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern UInt8 *mi_offset_paramc(mblk_t *mp, long offset, long len)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_offset_paramc
	ENDIF


; *  mi_open_detached()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern char *mi_open_detached(char **mi_opp_orig, OTByteCount size, dev_t *devp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_open_detached
	ENDIF


; *  mi_open_comm()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 mi_open_comm(char **mi_opp_orig, OTByteCount size, queue_t *q, dev_t *dev, OTInt32 flag, OTInt32 sflag, cred_t *credp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_open_comm
	ENDIF


; *  mi_close_comm()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 mi_close_comm(char **mi_opp_orig, queue_t *q)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_close_comm
	ENDIF


; *  mi_bufcall()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mi_bufcall(queue_t *q, OTByteCount size, OTInt32 pri)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_bufcall
	ENDIF


; *  mi_detach()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mi_detach(queue_t *q, char *ptr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_detach
	ENDIF


; *  mi_close_detached()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mi_close_detached(char **mi_opp_orig, char *ptr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_close_detached
	ENDIF


; *  mi_next_ptr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern char *mi_next_ptr(char *ptr)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_next_ptr
	ENDIF


; *  mi_copyin()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mi_copyin(queue_t *q, mblk_t *mp, char *uaddr, OTByteCount len)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_copyin
	ENDIF


; *  mi_copyout()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mi_copyout(queue_t *q, mblk_t *mp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_copyout
	ENDIF


; *  mi_copyout_alloc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern mblk_t *mi_copyout_alloc(queue_t *q, mblk_t *mp, char *uaddr, OTByteCount len)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_copyout_alloc
	ENDIF


; *  mi_copy_done()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mi_copy_done(queue_t *q, mblk_t *mp, OTInt32 err)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_copy_done
	ENDIF


; *  mi_copy_set_rval()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void mi_copy_set_rval(mblk_t *mp, OTInt32 rval)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_copy_set_rval
	ENDIF


; *  mi_copy_state()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OTInt32 mi_copy_state(queue_t *q, mblk_t *mp, mblk_t **mpp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION mi_copy_state
	ENDIF

;  ***** PCI-Specific Stuff

;  This is the cookie that is passed to your STREAM Module.

	ENDIF	; CALL_NOT_IN_CARBON
OTPCIInfo				RECORD 0
fTheID					 ds		RegEntryID		; offset: $0 (0)
fConfigurationInfo		 ds.l	1				; offset: $10 (16)
fConfigurationLength	 ds.l	1				; offset: $14 (20)
sizeof					 EQU *					; size:   $18 (24)
						ENDR
;  Driver Description

;   All PCI card drivers should have the following bits set in their
;   install_info structure:
;   
;   o kOTModIsDriver.
;   
;   They should NEVER have the kOTModPushAlways or the kOTModIsModule
;   flags set.
;   The kOTModIsLowerMux bits should be set if the driver is a lower
;   multiplexor, although Open Transport does nothing with the information
;   today.
;   The kOTModUpperIsDLPI bit should be set if the driver uses the DLPI message
;   specification.  The kOTModUpperIsTPI bit should be set if the driver uses
;   the TPI message specification.




;   Macro to put together the driverServices.service[x].serviceType field:
;   xxxxxddd dddddddd ffffffff xxxxxxTD
;   where "d" is the device type for Open Transport,
;   the lower two bits are whether the driver is TPI or DLPI,
;   and the "f" bits are the framing option flags.
;   and all other bits should be 0




;   Typedef for the ValidateHardware function.  This function will be
;   called only once, at system boot time, before installing your driver
;   into the Open Transport module registry.
;   The param pointer will is a OTPCIInfo pointer - don't be changing the
;   values there!




;   Your driver can return this value if it loaded correctly
;   but wants to stay resident, presumably because it's hooked
;   itself irrevokably into some other system service.



kOTPCINoErrorStayLoaded			EQU		1

;   Some descriptors we use - these should eventually show up
;   in system header files somewhere.




;   Maximum # of services support by Open Transport.  If your module
;   exports more than this # of services, Open Transport will not be
;   able to use the module.





kMaxServices					EQU		20

	ENDIF ; __OPENTRANSPORTKERNEL__ 


;
;    File:       Processes.a
;
;    Contains:   Process Manager Interfaces.
;
;    Version:    Technology: Mac OS 9
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1989-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__PROCESSES__') = 'UNDEFINED' THEN
__PROCESSES__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__EVENTS__') = 'UNDEFINED' THEN
	include 'Events.a'
	ENDIF
	IF &TYPE('__FILES__') = 'UNDEFINED' THEN
	include 'Files.a'
	ENDIF
	IF &TYPE('__TEXTCOMMON__') = 'UNDEFINED' THEN
	include 'TextCommon.a'
	ENDIF
	IF &TYPE('__CFSTRING__') = 'UNDEFINED' THEN
	include 'CFString.a'
	ENDIF
;  type for unique process identifier 
ProcessSerialNumber		RECORD 0
highLongOfPSN			 ds.l	1				; offset: $0 (0)
lowLongOfPSN			 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct ProcessSerialNumber *	ProcessSerialNumberPtr


															; Process identifier - Various reserved process serial numbers 
kNoProcess						EQU		0
kSystemProcess					EQU		1
kCurrentProcess					EQU		2
;  Definition of the parameter block passed to _Launch 
;  Typedef and flags for launchControlFlags field
; typedef unsigned short 				LaunchFlags


launchContinue					EQU		$4000
launchNoFileFlags				EQU		$0800
launchUseMinimum				EQU		$0400
launchDontSwitch				EQU		$0200
launchAllow24Bit				EQU		$0100
launchInhibitDaemon				EQU		$0080
;  Format for first AppleEvent to pass to new process.  The size of the overall
;  buffer variable: the message body immediately follows the messageLength 
AppParameters			RECORD 0
theMsgEvent				 ds		EventRecord		; offset: $0 (0)
eventRefCon				 ds.l	1				; offset: $10 (16)
messageLength			 ds.l	1				; offset: $14 (20)
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct AppParameters *		AppParametersPtr

;  Parameter block to _Launch 
LaunchParamBlockRec		RECORD 0
reserved1				 ds.l	1				; offset: $0 (0)
reserved2				 ds.w	1				; offset: $4 (4)
launchBlockID			 ds.w	1				; offset: $6 (6)
launchEPBLength			 ds.l	1				; offset: $8 (8)
launchFileFlags			 ds.w	1				; offset: $C (12)
launchControlFlags		 ds.w	1				; offset: $E (14)
launchAppSpec			 ds.l	1				; offset: $10 (16)
launchProcessSN			 ds		ProcessSerialNumber ; offset: $14 (20)
launchPreferredSize		 ds.l	1				; offset: $1C (28)
launchMinimumSize		 ds.l	1				; offset: $20 (32)
launchAvailableSize		 ds.l	1				; offset: $24 (36)
launchAppParameters		 ds.l	1				; offset: $28 (40)
sizeof					 EQU *					; size:   $2C (44)
						ENDR
; typedef struct LaunchParamBlockRec *	LaunchPBPtr

;  Set launchBlockID to extendedBlock to specify that extensions exist.
; Set launchEPBLength to extendedBlockLen for compatibility.

extendedBlock					EQU		$4C43				; 'LC' 
extendedBlockLen				EQU		32

															; Definition of the information block returned by GetProcessInformation 
modeReserved					EQU		$01000000
modeControlPanel				EQU		$00080000
modeLaunchDontSwitch			EQU		$00040000
modeDeskAccessory				EQU		$00020000
modeMultiLaunch					EQU		$00010000
modeNeedSuspendResume			EQU		$00004000
modeCanBackground				EQU		$00001000
modeDoesActivateOnFGSwitch		EQU		$00000800
modeOnlyBackground				EQU		$00000400
modeGetFrontClicks				EQU		$00000200
modeGetAppDiedMsg				EQU		$00000100
mode32BitCompatible				EQU		$00000080
modeHighLevelEventAware			EQU		$00000040
modeLocalAndRemoteHLEvents		EQU		$00000020
modeStationeryAware				EQU		$00000010
modeUseTextEditServices			EQU		$00000008
modeDisplayManagerAware			EQU		$00000004

;   Record returned by GetProcessInformation
;    When calling GetProcessInformation(), the input ProcesInfoRec
;    should have the processInfoLength set to sizeof(ProcessInfoRec),
;    the processName field set to nil or a pointer to a Str255, and
;    processAppSpec set to nil or a pointer to an FSSpec.  If
;    processName or processAppSpec are not specified, this routine
;    will very likely write data to whatever random location in memory
;    these happen to point to, which is not a good thing.


ProcessInfoRec			RECORD 0
processInfoLength		 ds.l	1				; offset: $0 (0)
processName				 ds.l	1				; offset: $4 (4)
processNumber			 ds		ProcessSerialNumber ; offset: $8 (8)
processType				 ds.l	1				; offset: $10 (16)
processSignature		 ds.l	1				; offset: $14 (20)
processMode				 ds.l	1				; offset: $18 (24)
processLocation			 ds.l	1				; offset: $1C (28)
processSize				 ds.l	1				; offset: $20 (32)
processFreeMem			 ds.l	1				; offset: $24 (36)
processLauncher			 ds		ProcessSerialNumber ; offset: $28 (40)
processLaunchDate		 ds.l	1				; offset: $30 (48)
processActiveTime		 ds.l	1				; offset: $34 (52)
processAppSpec			 ds.l	1				; offset: $38 (56)
sizeof					 EQU *					; size:   $3C (60)
						ENDR
; typedef struct ProcessInfoRec *		ProcessInfoRecPtr


;    Some applications assumed the size of a ProcessInfoRec would never change,
;    which has caused problems trying to return additional information.  In
;    the future, we will add fields to ProcessInfoExtendedRec when necessary,
;    and callers which wish to access 'more' data than originally was present
;    in ProcessInfoRec should allocate space for a ProcessInfoExtendedRec,
;    fill in the processInfoLength ( and processName and processAppSpec ptrs ),
;    then coerce this to a ProcessInfoRecPtr in the call to
;    GetProcessInformation().


ProcessInfoExtendedRec	RECORD 0
processInfoLength		 ds.l	1				; offset: $0 (0)
processName				 ds.l	1				; offset: $4 (4)
processNumber			 ds		ProcessSerialNumber ; offset: $8 (8)
processType				 ds.l	1				; offset: $10 (16)
processSignature		 ds.l	1				; offset: $14 (20)
processMode				 ds.l	1				; offset: $18 (24)
processLocation			 ds.l	1				; offset: $1C (28)
processSize				 ds.l	1				; offset: $20 (32)
processFreeMem			 ds.l	1				; offset: $24 (36)
processLauncher			 ds		ProcessSerialNumber ; offset: $28 (40)
processLaunchDate		 ds.l	1				; offset: $30 (48)
processActiveTime		 ds.l	1				; offset: $34 (52)
processAppSpec			 ds.l	1				; offset: $38 (56)
processTempMemTotal		 ds.l	1				; offset: $3C (60)
processPurgeableTempMemTotal  ds.l 1			; offset: $40 (64)
sizeof					 EQU *					; size:   $44 (68)
						ENDR
; typedef struct ProcessInfoExtendedRec * ProcessInfoExtendedRecPtr

;  Record corresponding to the SIZE resource definition 
SizeResourceRec			RECORD 0
flags					 ds.w	1				; offset: $0 (0)
preferredHeapSize		 ds.l	1				; offset: $2 (2)
minimumHeapSize			 ds.l	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct SizeResourceRec *		SizeResourceRecPtr

; typedef SizeResourceRecPtr *			SizeResourceRecHandle


;    Applications and background applications can control when they are asked to quit
;    by the system at restart/shutdown by setting these bits in a 'quit' ( 0 ) resource
;    in their application's resource fork.  Applications without a 'quit' ( 0 ) will
;    be quit at kQuitAtNormalTime mask.



kQuitBeforeNormalTimeMask		EQU		1
kQuitAtNormalTimeMask			EQU		2
kQuitBeforeFBAsQuitMask			EQU		4
kQuitBeforeShellQuitsMask		EQU		8
kQuitBeforeTerminatorAppQuitsMask EQU	16
kQuitNeverMask					EQU		32
kQuitOptionsMask				EQU		$7F
kQuitNotQuitDuringInstallMask	EQU		$0100
kQuitNotQuitDuringLogoutMask	EQU		$0200


; *  LaunchApplication()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr LaunchApplication(LaunchPBPtr LaunchParams)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	LaunchParams    => A0
		; returns:
		;	OSErr           <= D0
		_LaunchApplication:	OPWORD	$A9F2
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LaunchApplication
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  LaunchDeskAccessory()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr LaunchDeskAccessory(const FSSpec *pFileSpec, ConstStr255Param pDAName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LaunchDeskAccessory
			move.w              #$0036,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LaunchDeskAccessory
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  [Mac]GetCurrentProcess()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr GetCurrentProcess(ProcessSerialNumber *PSN)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetCurrentProcess
			move.w              #$0037,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetCurrentProcess
	ENDIF


; *  GetFrontProcess()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr GetFrontProcess(ProcessSerialNumber *PSN)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetFrontProcess
			moveq           	#-1,D0
			move.l              D0,-(sp)
			move.w              #$0039,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetFrontProcess
	ENDIF


; *  GetNextProcess()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr GetNextProcess(ProcessSerialNumber *PSN)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetNextProcess
			move.w              #$0038,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetNextProcess
	ENDIF


; *  GetProcessInformation()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr GetProcessInformation(const ProcessSerialNumber *PSN, ProcessInfoRec *info)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetProcessInformation
			move.w              #$003A,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetProcessInformation
	ENDIF


; *  SetFrontProcess()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr SetFrontProcess(const ProcessSerialNumber *PSN)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetFrontProcess
			move.w              #$003B,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetFrontProcess
	ENDIF


; *  WakeUpProcess()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr WakeUpProcess(const ProcessSerialNumber *PSN)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_WakeUpProcess
			move.w              #$003C,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION WakeUpProcess
	ENDIF


; *  SameProcess()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr SameProcess(const ProcessSerialNumber *PSN1, const ProcessSerialNumber *PSN2, Boolean *result)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SameProcess
			move.w              #$003D,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SameProcess
	ENDIF

;   ExitToShell was previously in SegLoad.h

; *  ExitToShell()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void ExitToShell(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_ExitToShell:	OPWORD	$A9F4
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ExitToShell
	ENDIF


;   LaunchControlPanel is similar to LaunchDeskAccessory, but for Control Panel files instead.
;   It launches a control panel in an application shell maintained by the Process Manager.


	IF CALL_NOT_IN_CARBON THEN

; *  LaunchControlPanel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 9.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr LaunchControlPanel(const FSSpec *pFileSpec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_LaunchControlPanel
			move.w              #$007B,-(sp)
			dc.w            	$A88F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION LaunchControlPanel
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON

; *  GetApplicationTextEncoding()
; *  
; *  Summary:
; *    Returns the application text encoding for Resource Manager
; *    resources.
; *  
; *  Discussion:
; *    The application text encoding is used when you create a
; *    CFStringRef from text stored in Resource Manager resources, which
; *    typically uses one of the Mac encodings such as MacRoman or
; *    MacJapanese.
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        in CarbonLib 1.2 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal TextEncoding GetApplicationTextEncoding(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetApplicationTextEncoding
	ENDIF


; *  GetApplicationScript()
; *  
; *  Summary:
; *    Returns the application script.
; *  
; *  Discussion:
; *    The application script is used when you need a ScriptCode to pass
; *    to some other API, such as UseThemeFont.
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal ScriptCode GetApplicationScript(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetApplicationScript
	ENDIF


; *  GetProcessBundleLocation()
; *  
; *  Summary:
; *    Retrieve the filesystem location of the process bundle, or
; *    executable if unbundled.
; *  
; *  Discussion:
; *    Retrieves a reference to the filesystem location of the specified
; *    application.  For an application that is packaged as an app
; *    bundle, this will be the app bundle directory; otherwise it will
; *    be the location of the executable itself.
; *  
; *  Parameters:
; *    
; *    psn:
; *      Serial number of the target process
; *    
; *    location:
; *      Location of the bundle or executable, as an FSRef
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus GetProcessBundleLocation(const ProcessSerialNumber *psn, FSRef *location)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetProcessBundleLocation
	ENDIF


; *  CopyProcessName()
; *  
; *  Summary:
; *    Get a copy of the name of a process.
; *  
; *  Discussion:
; *    Use this call to get the name of a process as a CFString.  The
; *    name returned is a copy, so the caller must CFRelease the name
; *    when finished with it.  The difference between this call and the
; *    processName field filled in by GetProcessInformation is that the
; *    name here is a CFString, and thus is capable of representing a
; *    multi-lingual name, whereas previously only a mac-encoded string
; *    was possible.
; *  
; *  Parameters:
; *    
; *    psn:
; *      Serial number of the target process
; *    
; *    name:
; *      CFString representing the name of the process (must be released
; *      by caller with CFRelease)
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus CopyProcessName(const ProcessSerialNumber *psn, CFStringRef *name)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION CopyProcessName
	ENDIF

;  Values of the 'message' parameter to a Control Panel 'cdev' 

initDev							EQU		0					;Time for cdev to initialize itself
hitDev							EQU		1					;Hit on one of my items
closeDev						EQU		2					;Close yourself
nulDev							EQU		3					;Null event
updateDev						EQU		4					;Update event
activDev						EQU		5					;Activate event
deactivDev						EQU		6					;Deactivate event
keyEvtDev						EQU		7					;Key down/auto key
macDev							EQU		8					;Decide whether or not to show up
undoDev							EQU		9
cutDev							EQU		10
copyDev							EQU		11
pasteDev						EQU		12
clearDev						EQU		13
cursorDev						EQU		14
;  Special values a Control Panel 'cdev' can return 

cdevGenErr						EQU		-1					;General error; gray cdev w/o alert
cdevMemErr						EQU		0					;Memory shortfall; alert user please
cdevResErr						EQU		1					;Couldn't get a needed resource; alert
cdevUnset						EQU		3					; cdevValue is initialized to this
;  Control Panel Default Proc 
	IF CALL_NOT_IN_CARBON THEN

; *  NewControlPanelDefUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeControlPanelDefUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeControlPanelDefUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

	ENDIF	; CALL_NOT_IN_CARBON

	ENDIF ; __PROCESSES__ 


;
;    File:       QuickTimeComponents.a
;
;    Contains:   QuickTime Interfaces.
;
;    Version:    Technology: QuickTime 5.0.1
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1990-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__QUICKTIMECOMPONENTS__') = 'UNDEFINED' THEN
__QUICKTIMECOMPONENTS__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF
	IF &TYPE('__COMPONENTS__') = 'UNDEFINED' THEN
	include 'Components.a'
	ENDIF
	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF
	IF &TYPE('__VIDEO__') = 'UNDEFINED' THEN
	include 'Video.a'
	ENDIF
	IF &TYPE('__SOUND__') = 'UNDEFINED' THEN
	include 'Sound.a'
	ENDIF
	IF &TYPE('__IMAGECOMPRESSION__') = 'UNDEFINED' THEN
	include 'ImageCompression.a'
	ENDIF
	IF &TYPE('__MOVIES__') = 'UNDEFINED' THEN
	include 'Movies.a'
	ENDIF
	IF &TYPE('__QUICKTIMEMUSIC__') = 'UNDEFINED' THEN
	include 'QuickTimeMusic.a'
	ENDIF


clockComponentType				EQU		'clok'
systemTickClock					EQU		'tick'				; subtype: 60ths since boot   
systemSecondClock				EQU		'seco'				; subtype: seconds since 1904       
systemMillisecondClock			EQU		'mill'				; subtype: 1000ths since boot       
systemMicrosecondClock			EQU		'micr'				; subtype: 1000000ths since boot 

kClockRateIsLinear				EQU		1
kClockImplementsCallBacks		EQU		2
kClockCanHandleIntermittentSound EQU	4					; sound clocks only 
; * These are Clock procedures *

; *  ClockGetTime()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult ClockGetTime(ComponentInstance aClock, TimeRecord *out)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockGetTime
			move.l              #$00040001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockGetTime
	ENDIF



; *  ClockNewCallBack()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal QTCallBack ClockNewCallBack(ComponentInstance aClock, TimeBase tb, short callBackType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockNewCallBack
			move.l              #$00060002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockNewCallBack
	ENDIF


; *  ClockDisposeCallBack()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult ClockDisposeCallBack(ComponentInstance aClock, QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockDisposeCallBack
			move.l              #$00040003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockDisposeCallBack
	ENDIF


; *  ClockCallMeWhen()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult ClockCallMeWhen(ComponentInstance aClock, QTCallBack cb, long param1, long param2, long param3)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockCallMeWhen
			move.l              #$00100004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockCallMeWhen
	ENDIF


; *  ClockCancelCallBack()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult ClockCancelCallBack(ComponentInstance aClock, QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockCancelCallBack
			move.l              #$00040005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockCancelCallBack
	ENDIF


; *  ClockRateChanged()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult ClockRateChanged(ComponentInstance aClock, QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockRateChanged
			move.l              #$00040006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockRateChanged
	ENDIF


; *  ClockTimeChanged()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult ClockTimeChanged(ComponentInstance aClock, QTCallBack cb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockTimeChanged
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockTimeChanged
	ENDIF


; *  ClockSetTimeBase()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult ClockSetTimeBase(ComponentInstance aClock, TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockSetTimeBase
			move.l              #$00040008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockSetTimeBase
	ENDIF


; *  ClockStartStopChanged()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult ClockStartStopChanged(ComponentInstance aClock, QTCallBack cb, Boolean startChanged, Boolean stopChanged)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockStartStopChanged
			move.l              #$00080009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockStartStopChanged
	ENDIF


; *  ClockGetRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult ClockGetRate(ComponentInstance aClock, Fixed *rate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_ClockGetRate
			move.l              #$0004000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION ClockGetRate
	ENDIF





StandardCompressionType			EQU		'scdi'
StandardCompressionSubType		EQU		'imag'
StandardCompressionSubTypeSound	EQU		'soun'

;   Preference flags.

scListEveryCodec				EQU		$00000002
scAllowZeroFrameRate			EQU		$00000004
scAllowZeroKeyFrameRate			EQU		$00000008
scShowBestDepth					EQU		$00000010
scUseMovableModal				EQU		$00000020
scDisableFrameRateItem			EQU		$00000040
scShowDataRateAsKilobits		EQU		$00000080

;   Possible test flags for setting test image.

scPreferCropping				EQU		$01
scPreferScaling					EQU		$02
scPreferScalingAndCropping		EQU		$03
scDontDetermineSettingsFromTestImage EQU $04

;   Dimensions of the image preview box.

scTestImageWidth				EQU		80
scTestImageHeight				EQU		80
;   Possible items returned by hookProc.

scOKItem						EQU		1
scCancelItem					EQU		2
scCustomItem					EQU		3
;   Result returned when user cancelled.

scUserCancelled					EQU		1


;   Get/SetInfo structures.

SCSpatialSettings		RECORD 0
codecType				 ds.l	1				; offset: $0 (0)
codec					 ds.l	1				; offset: $4 (4)
depth					 ds.w	1				; offset: $8 (8)
spatialQuality			 ds.l	1				; offset: $A (10)
sizeof					 EQU *					; size:   $E (14)
						ENDR
SCTemporalSettings		RECORD 0
temporalQuality			 ds.l	1				; offset: $0 (0)
frameRate				 ds.l	1				; offset: $4 (4)
keyFrameRate			 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
SCDataRateSettings		RECORD 0
dataRate				 ds.l	1				; offset: $0 (0)
frameDuration			 ds.l	1				; offset: $4 (4)
minSpatialQuality		 ds.l	1				; offset: $8 (8)
minTemporalQuality		 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
SCExtendedProcs			RECORD 0
filterProc				 ds.l	1				; offset: $0 (0)
hookProc				 ds.l	1				; offset: $4 (4)
refcon					 ds.l	1				; offset: $8 (8)
customName				 ds		Str31			; offset: $C (12)
sizeof					 EQU *					; size:   $2C (44)
						ENDR
;   Get/SetInfo selectors

scSpatialSettingsType			EQU		'sptl'				; pointer to SCSpatialSettings struct
scTemporalSettingsType			EQU		'tprl'				; pointer to SCTemporalSettings struct
scDataRateSettingsType			EQU		'drat'				; pointer to SCDataRateSettings struct
scColorTableType				EQU		'clut'				; pointer to CTabHandle
scProgressProcType				EQU		'prog'				; pointer to ProgressRecord struct
scExtendedProcsType				EQU		'xprc'				; pointer to SCExtendedProcs struct
scPreferenceFlagsType			EQU		'pref'				; pointer to long
scSettingsStateType				EQU		'ssta'				; pointer to Handle
scSequenceIDType				EQU		'sequ'				; pointer to ImageSequence
scWindowPositionType			EQU		'wndw'				; pointer to Point
scCodecFlagsType				EQU		'cflg'				; pointer to CodecFlags
scCodecSettingsType				EQU		'cdec'				; pointer to Handle
scForceKeyValueType				EQU		'ksim'				; pointer to long
scSoundSampleRateType			EQU		'ssrt'				; pointer to UnsignedFixed
scSoundSampleSizeType			EQU		'ssss'				; pointer to short
scSoundChannelCountType			EQU		'sscc'				; pointer to short
scSoundCompressionType			EQU		'ssct'				; pointer to OSType
scCompressionListType			EQU		'ctyl'				; pointer to OSType Handle
scCodecManufacturerType			EQU		'cmfr'				; pointer to OSType
;   scTypeNotFoundErr returned by Get/SetInfo when type cannot be found.


SCParams				RECORD 0
flags					 ds.l	1				; offset: $0 (0)
theCodecType			 ds.l	1				; offset: $4 (4)
theCodec				 ds.l	1				; offset: $8 (8)
spatialQuality			 ds.l	1				; offset: $C (12)
temporalQuality			 ds.l	1				; offset: $10 (16)
depth					 ds.w	1				; offset: $14 (20)
frameRate				 ds.l	1				; offset: $16 (22)
keyFrameRate			 ds.l	1				; offset: $1A (26)
reserved1				 ds.l	1				; offset: $1E (30)
reserved2				 ds.l	1				; offset: $22 (34)
sizeof					 EQU *					; size:   $26 (38)
						ENDR

scGetCompression				EQU		1
scShowMotionSettings			EQU		$00000001
scSettingsChangedItem			EQU		-1

scCompressFlagIgnoreIdenticalFrames EQU	1
;  QTAtomTypes for atoms found in settings atom containers

kQTSettingsVideo				EQU		'vide'				; Container for video/image compression related atoms (Get/SetInfo selectors)
kQTSettingsSound				EQU		'soun'				; Container for sound compression related atoms (Get/SetInfo selectors)
kQTSettingsComponentVersion		EQU		'vers'				; . Version of component that wrote settings (QTSettingsVersionAtomRecord)
;  Format of 'vers' atom found in settings atom containers
QTSettingsVersionAtomRecord RECORD 0
componentVersion		 ds.l	1				; offset: $0 (0)		;  standard compression component version
flags					 ds.w	1				; offset: $4 (4)		;  low bit is 1 if little endian platform, 0 if big endian platform
reserved				 ds.w	1				; offset: $6 (6)		;  should be 0
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; * These are Progress procedures *

; *  SCGetCompressionExtended()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCGetCompressionExtended(ComponentInstance ci, SCParams *params, Point where, SCModalFilterUPP filterProc, SCModalHookUPP hookProc, long refcon, StringPtr customName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCGetCompressionExtended
			move.l              #$00180001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCGetCompressionExtended
	ENDIF


; *  SCPositionRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCPositionRect(ComponentInstance ci, Rect *rp, Point *where)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCPositionRect
			move.l              #$00080002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCPositionRect
	ENDIF


; *  SCPositionDialog()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCPositionDialog(ComponentInstance ci, short id, Point *where)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCPositionDialog
			move.l              #$00060003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCPositionDialog
	ENDIF


; *  SCSetTestImagePictHandle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCSetTestImagePictHandle(ComponentInstance ci, PicHandle testPict, Rect *testRect, short testFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSetTestImagePictHandle
			move.l              #$000A0004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSetTestImagePictHandle
	ENDIF


; *  SCSetTestImagePictFile()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCSetTestImagePictFile(ComponentInstance ci, short testFileRef, Rect *testRect, short testFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSetTestImagePictFile
			move.l              #$00080005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSetTestImagePictFile
	ENDIF


; *  SCSetTestImagePixMap()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCSetTestImagePixMap(ComponentInstance ci, PixMapHandle testPixMap, Rect *testRect, short testFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSetTestImagePixMap
			move.l              #$000A0006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSetTestImagePixMap
	ENDIF


; *  SCGetBestDeviceRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCGetBestDeviceRect(ComponentInstance ci, Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCGetBestDeviceRect
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCGetBestDeviceRect
	ENDIF



; *  SCRequestImageSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCRequestImageSettings(ComponentInstance ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCRequestImageSettings
			move.l              #$0000000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCRequestImageSettings
	ENDIF


; *  SCCompressImage()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCCompressImage(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, ImageDescriptionHandle *desc, Handle *data)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressImage
			move.l              #$0010000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressImage
	ENDIF


; *  SCCompressPicture()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCCompressPicture(ComponentInstance ci, PicHandle srcPicture, PicHandle dstPicture)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressPicture
			move.l              #$0008000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressPicture
	ENDIF


; *  SCCompressPictureFile()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCCompressPictureFile(ComponentInstance ci, short srcRefNum, short dstRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressPictureFile
			move.l              #$0004000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressPictureFile
	ENDIF


; *  SCRequestSequenceSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCRequestSequenceSettings(ComponentInstance ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCRequestSequenceSettings
			move.l              #$0000000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCRequestSequenceSettings
	ENDIF


; *  SCCompressSequenceBegin()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCCompressSequenceBegin(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, ImageDescriptionHandle *desc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressSequenceBegin
			move.l              #$000C000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressSequenceBegin
	ENDIF


; *  SCCompressSequenceFrame()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCCompressSequenceFrame(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, Handle *data, long *dataSize, short *notSyncFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressSequenceFrame
			move.l              #$00140010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressSequenceFrame
	ENDIF


; *  SCCompressSequenceEnd()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCCompressSequenceEnd(ComponentInstance ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressSequenceEnd
			move.l              #$00000011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressSequenceEnd
	ENDIF


; *  SCDefaultPictHandleSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCDefaultPictHandleSettings(ComponentInstance ci, PicHandle srcPicture, short motion)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCDefaultPictHandleSettings
			move.l              #$00060012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCDefaultPictHandleSettings
	ENDIF


; *  SCDefaultPictFileSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCDefaultPictFileSettings(ComponentInstance ci, short srcRef, short motion)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCDefaultPictFileSettings
			move.l              #$00040013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCDefaultPictFileSettings
	ENDIF


; *  SCDefaultPixMapSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCDefaultPixMapSettings(ComponentInstance ci, PixMapHandle src, short motion)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCDefaultPixMapSettings
			move.l              #$00060014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCDefaultPixMapSettings
	ENDIF


; *  SCGetInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCGetInfo(ComponentInstance ci, OSType infoType, void *info)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCGetInfo
			move.l              #$00080015,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCGetInfo
	ENDIF


; *  SCSetInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCSetInfo(ComponentInstance ci, OSType infoType, void *info)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSetInfo
			move.l              #$00080016,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSetInfo
	ENDIF


; *  SCNewGWorld()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCNewGWorld(ComponentInstance ci, GWorldPtr *gwp, Rect *rp, GWorldFlags flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCNewGWorld
			move.l              #$000C0017,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCNewGWorld
	ENDIF


; *  SCSetCompressFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCSetCompressFlags(ComponentInstance ci, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSetCompressFlags
			move.l              #$00040018,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSetCompressFlags
	ENDIF


; *  SCGetCompressFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCGetCompressFlags(ComponentInstance ci, long *flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCGetCompressFlags
			move.l              #$00040019,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCGetCompressFlags
	ENDIF


; *  SCGetSettingsAsText()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCGetSettingsAsText(ComponentInstance ci, Handle *text)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCGetSettingsAsText
			move.l              #$0004001A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCGetSettingsAsText
	ENDIF


; *  SCGetSettingsAsAtomContainer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCGetSettingsAsAtomContainer(ComponentInstance ci, QTAtomContainer *settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCGetSettingsAsAtomContainer
			move.l              #$0004001B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCGetSettingsAsAtomContainer
	ENDIF


; *  SCSetSettingsFromAtomContainer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SCSetSettingsFromAtomContainer(ComponentInstance ci, QTAtomContainer settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSetSettingsFromAtomContainer
			move.l              #$0004001C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSetSettingsFromAtomContainer
	ENDIF

;  Note: if you're using SCCompressSequenceFrameAsync with a scForceKeyValue setting, you must call SCAsyncIdle occasionally at main task time. 

; *  SCCompressSequenceFrameAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult SCCompressSequenceFrameAsync(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, Handle *data, long *dataSize, short *notSyncFlag, ICMCompletionProcRecordPtr asyncCompletionProc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCCompressSequenceFrameAsync
			move.l              #$0018001D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCCompressSequenceFrameAsync
	ENDIF


; *  SCAsyncIdle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult SCAsyncIdle(ComponentInstance ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCAsyncIdle
			move.l              #$0000001E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCAsyncIdle
	ENDIF





TweenComponentType				EQU		'twen'
; typedef ComponentInstance 			TweenerComponent


; *  TweenerInitialize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult TweenerInitialize(TweenerComponent tc, QTAtomContainer container, QTAtom tweenAtom, QTAtom dataAtom)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TweenerInitialize
			move.l              #$000C0001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TweenerInitialize
	ENDIF


; *  TweenerDoTween()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult TweenerDoTween(TweenerComponent tc, TweenRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TweenerDoTween
			move.l              #$00040002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TweenerDoTween
	ENDIF


; *  TweenerReset()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult TweenerReset(TweenerComponent tc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TweenerReset
			move.l              #$00000003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TweenerReset
	ENDIF




TCSourceRefNameType				EQU		'name'

tcDropFrame						EQU		$01
tc24HourMax						EQU		$02
tcNegTimesOK					EQU		$04
tcCounter						EQU		$08
TimeCodeDef				RECORD 0
flags					 ds.l	1				; offset: $0 (0)		;  drop-frame, etc.
fTimeScale				 ds.l	1				; offset: $4 (4)		;  time scale of frameDuration (eg. 2997)
frameDuration			 ds.l	1				; offset: $8 (8)		;  duration of each frame (eg. 100)
numFrames				 ds.b	1				; offset: $C (12)		;  frames/sec for timecode (eg. 30) OR frames/tick for counter mode
padding					 ds.b	1				; offset: $D (13)		;  unused padding byte
sizeof					 EQU *					; size:   $E (14)
						ENDR

tctNegFlag						EQU		$80					; negative bit is in minutes
TimeCodeTime			RECORD 0
hours					 ds.b	1				; offset: $0 (0)
minutes					 ds.b	1				; offset: $1 (1)
seconds					 ds.b	1				; offset: $2 (2)
frames					 ds.b	1				; offset: $3 (3)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
TimeCodeCounter			RECORD 0
counter					 ds.l	1				; offset: $0 (0)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
TimeCodeDescription		RECORD 0
descSize				 ds.l	1				; offset: $0 (0)		;  standard sample description header
dataFormat				 ds.l	1				; offset: $4 (4)
resvd1					 ds.l	1				; offset: $8 (8)
resvd2					 ds.w	1				; offset: $C (12)
dataRefIndex			 ds.w	1				; offset: $E (14)
flags					 ds.l	1				; offset: $10 (16)		;  timecode specific stuff
timeCodeDef				 ds		TimeCodeDef		; offset: $14 (20)
srcRef					 ds.l	1				; offset: $22 (34) <-- really an array of length one
sizeof					 EQU *					; size:   $26 (38)
						ENDR
; typedef struct TimeCodeDescription *	TimeCodeDescriptionPtr

; typedef TimeCodeDescriptionPtr *		TimeCodeDescriptionHandle


tcdfShowTimeCode				EQU		$01

TCTextOptions			RECORD 0
txFont					 ds.w	1				; offset: $0 (0)
txFace					 ds.w	1				; offset: $2 (2)
txSize					 ds.w	1				; offset: $4 (4)
pad						 ds.w	1				; offset: $6 (6)		;  let's make it longword aligned - thanks.. 
foreColor				 ds		RGBColor		; offset: $8 (8)
backColor				 ds		RGBColor		; offset: $E (14)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct TCTextOptions *		TCTextOptionsPtr


; *  TCGetCurrentTimeCode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal HandlerError TCGetCurrentTimeCode(MediaHandler mh, long *frameNum, TimeCodeDef *tcdef, TimeCodeRecord *tcrec, UserData *srcRefH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCGetCurrentTimeCode
			move.l              #$00100101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCGetCurrentTimeCode
	ENDIF


; *  TCGetTimeCodeAtTime()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal HandlerError TCGetTimeCodeAtTime(MediaHandler mh, TimeValue mediaTime, long *frameNum, TimeCodeDef *tcdef, TimeCodeRecord *tcdata, UserData *srcRefH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCGetTimeCodeAtTime
			move.l              #$00140102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCGetTimeCodeAtTime
	ENDIF


; *  TCTimeCodeToString()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal HandlerError TCTimeCodeToString(MediaHandler mh, TimeCodeDef *tcdef, TimeCodeRecord *tcrec, StringPtr tcStr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCTimeCodeToString
			move.l              #$000C0103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCTimeCodeToString
	ENDIF


; *  TCTimeCodeToFrameNumber()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal HandlerError TCTimeCodeToFrameNumber(MediaHandler mh, TimeCodeDef *tcdef, TimeCodeRecord *tcrec, long *frameNumber)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCTimeCodeToFrameNumber
			move.l              #$000C0104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCTimeCodeToFrameNumber
	ENDIF


; *  TCFrameNumberToTimeCode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal HandlerError TCFrameNumberToTimeCode(MediaHandler mh, long frameNumber, TimeCodeDef *tcdef, TimeCodeRecord *tcrec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCFrameNumberToTimeCode
			move.l              #$000C0105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCFrameNumberToTimeCode
	ENDIF


; *  TCGetSourceRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal HandlerError TCGetSourceRef(MediaHandler mh, TimeCodeDescriptionHandle tcdH, UserData *srefH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCGetSourceRef
			move.l              #$00080106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCGetSourceRef
	ENDIF


; *  TCSetSourceRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal HandlerError TCSetSourceRef(MediaHandler mh, TimeCodeDescriptionHandle tcdH, UserData srefH)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCSetSourceRef
			move.l              #$00080107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCSetSourceRef
	ENDIF


; *  TCSetTimeCodeFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal HandlerError TCSetTimeCodeFlags(MediaHandler mh, long flags, long flagsMask)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCSetTimeCodeFlags
			move.l              #$00080108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCSetTimeCodeFlags
	ENDIF


; *  TCGetTimeCodeFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal HandlerError TCGetTimeCodeFlags(MediaHandler mh, long *flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCGetTimeCodeFlags
			move.l              #$00040109,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCGetTimeCodeFlags
	ENDIF


; *  TCSetDisplayOptions()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal HandlerError TCSetDisplayOptions(MediaHandler mh, TCTextOptionsPtr textOptions)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCSetDisplayOptions
			move.l              #$0004010A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCSetDisplayOptions
	ENDIF


; *  TCGetDisplayOptions()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal HandlerError TCGetDisplayOptions(MediaHandler mh, TCTextOptionsPtr textOptions)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TCGetDisplayOptions
			move.l              #$0004010B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TCGetDisplayOptions
	ENDIF



; typedef ComponentInstance 			MovieImportComponent

; typedef ComponentInstance 			MovieExportComponent


MovieImportType					EQU		'eat '
MovieExportType					EQU		'spit'

canMovieImportHandles			EQU		$01
canMovieImportFiles				EQU		$02
hasMovieImportUserInterface		EQU		$04
canMovieExportHandles			EQU		$08
canMovieExportFiles				EQU		$10
hasMovieExportUserInterface		EQU		$20
movieImporterIsXMLBased			EQU		$20
dontAutoFileMovieImport			EQU		$40
canMovieExportAuxDataHandle		EQU		$80
canMovieImportValidateHandles	EQU		$0100
canMovieImportValidateFile		EQU		$0200
dontRegisterWithEasyOpen		EQU		$0400
canMovieImportInPlace			EQU		$0800
movieImportSubTypeIsFileExtension EQU	$1000
canMovieImportPartial			EQU		$2000
hasMovieImportMIMEList			EQU		$4000
canMovieImportAvoidBlocking		EQU		$8000
canMovieExportFromProcedures	EQU		$8000
canMovieExportValidateMovie		EQU		$00010000
movieExportNeedsResourceFork	EQU		$00020000
canMovieImportDataReferences	EQU		$00040000
movieExportMustGetSourceMediaType EQU	$00080000
canMovieImportWithIdle			EQU		$00100000
canMovieImportValidateDataReferences EQU $00200000
reservedForUseByGraphicsImporters EQU	$00800000

movieImportCreateTrack			EQU		1
movieImportInParallel			EQU		2
movieImportMustUseTrack			EQU		4
movieImportWithIdle				EQU		16

movieImportResultUsedMultipleTracks EQU	8
movieImportResultNeedIdles		EQU		32
movieImportResultComplete		EQU		64

kMovieExportTextOnly			EQU		0
kMovieExportAbsoluteTime		EQU		1
kMovieExportRelativeTime		EQU		2

kMIDIImportSilenceBefore		EQU		$01
kMIDIImportSilenceAfter			EQU		$02
kMIDIImport20Playable			EQU		$04
kMIDIImportWantLyrics			EQU		$08


kQTMediaConfigResourceType		EQU		'mcfg'
kQTMediaConfigResourceVersion	EQU		2
kQTMediaGroupResourceType		EQU		'mgrp'
kQTMediaGroupResourceVersion	EQU		1


kQTMediaMIMEInfoHasChanged		EQU		$00000002			; the MIME type(s) is(are) new or has changed since the last time
															;  someone asked about it
kQTMediaFileInfoHasChanged		EQU		$00000004			; the file extension(s) is(are) new or has changed since the last time
															;  anyone asked about it
kQTMediaConfigCanUseApp			EQU		$00040000			; this MIME type can be configured to use app
kQTMediaConfigCanUsePlugin		EQU		$00080000			; this MIME type can be configured to use plug-in
kQTMediaConfigUNUSED			EQU		$00100000			; currently unused
kQTMediaConfigBinaryFile		EQU		$00800000			; file should be transfered in binary mode
kQTMediaConfigTextFile			EQU		0					; not a bit, defined for clarity
kQTMediaConfigMacintoshFile		EQU		$01000000			; file's resource fork is significant
kQTMediaConfigAssociateByDefault EQU	$08000000			; take this file association by default
kQTMediaConfigUseAppByDefault	EQU		$10000000			; use the app by default for this MIME type
kQTMediaConfigUsePluginByDefault EQU	$20000000			; use the plug-in by default for this MIME type
kQTMediaConfigDefaultsMask		EQU		$30000000
kQTMediaConfigDefaultsShift		EQU		12					; ((flags & kQTMediaConfigDefaultsMask) >> kQTMediaConfigDefaultsShift) to get default setting

;  mime type group constants for groupID field of 'mcfg' resource

kQTMediaConfigStreamGroupID		EQU		'strm'
kQTMediaConfigInteractiveGroupID EQU	'intr'
kQTMediaConfigVideoGroupID		EQU		'eyes'
kQTMediaConfigAudioGroupID		EQU		'ears'
kQTMediaConfigMPEGGroupID		EQU		'mpeg'
kQTMediaConfigMP3GroupID		EQU		'mp3 '
kQTMediaConfigImageGroupID		EQU		'ogle'
kQTMediaConfigMiscGroupID		EQU		'misc'
;  file type group constants for groupID field of 'mcfg' resource

kQTMediaInfoNetGroup			EQU		'net '
kQTMediaInfoWinGroup			EQU		'win '
kQTMediaInfoMacGroup			EQU		'mac '
kQTMediaInfoMiscGroup			EQU		$3F3F3F3F			; '????'



kMimeInfoMimeTypeTag			EQU		'mime'
kMimeInfoFileExtensionTag		EQU		'ext '
kMimeInfoDescriptionTag			EQU		'desc'
kMimeInfoGroupTag				EQU		'grop'
kMimeInfoDoNotOverrideExistingFileTypeAssociation EQU 'nofa'

kQTFileTypeAIFF					EQU		'AIFF'
kQTFileTypeAIFC					EQU		'AIFC'
kQTFileTypeDVC					EQU		'dvc!'
kQTFileTypeMIDI					EQU		'Midi'
kQTFileTypePicture				EQU		'PICT'
kQTFileTypeMovie				EQU		'MooV'
kQTFileTypeText					EQU		'TEXT'
kQTFileTypeWave					EQU		'WAVE'
kQTFileTypeSystemSevenSound		EQU		'sfil'
kQTFileTypeMuLaw				EQU		'ULAW'
kQTFileTypeAVI					EQU		'VfW '
kQTFileTypeSoundDesignerII		EQU		'Sd2f'
kQTFileTypeAudioCDTrack			EQU		'trak'
kQTFileTypePICS					EQU		'PICS'
kQTFileTypeGIF					EQU		'GIFf'
kQTFileTypePNG					EQU		'PNGf'
kQTFileTypeTIFF					EQU		'TIFF'
kQTFileTypePhotoShop			EQU		'8BPS'
kQTFileTypeSGIImage				EQU		'.SGI'
kQTFileTypeBMP					EQU		'BMPf'
kQTFileTypeJPEG					EQU		'JPEG'
kQTFileTypeJFIF					EQU		'JPEG'
kQTFileTypeMacPaint				EQU		'PNTG'
kQTFileTypeTargaImage			EQU		'TPIC'
kQTFileTypeQuickDrawGXPicture	EQU		'qdgx'
kQTFileTypeQuickTimeImage		EQU		'qtif'
kQTFileType3DMF					EQU		'3DMF'
kQTFileTypeFLC					EQU		'FLC '
kQTFileTypeFlash				EQU		'SWFL'
kQTFileTypeFlashPix				EQU		'FPix'
;  QTAtomTypes for atoms in import/export settings containers

kQTSettingsDVExportNTSC			EQU		'dvcv'				; True is export as NTSC, false is export as PAL. (Boolean)
kQTSettingsDVExportLockedAudio	EQU		'lock'				; True if audio locked to video. (Boolean)
kQTSettingsEffect				EQU		'effe'				; Parent atom whose contents are atoms of an effects description
kQTSettingsGraphicsFileImportSequence EQU 'sequ'			; Parent atom of graphic file movie import component
kQTSettingsGraphicsFileImportSequenceEnabled EQU 'enab'		; . If true, import numbered image sequence (Boolean)
kQTSettingsMovieExportEnableVideo EQU	'envi'				; Enable exporting of video track (Boolean)
kQTSettingsMovieExportEnableSound EQU	'enso'				; Enable exporting of sound track (Boolean)
kQTSettingsMovieExportSaveOptions EQU	'save'				; Parent atom of save options
kQTSettingsMovieExportSaveForInternet EQU 'fast'			; . Save for Internet
kQTSettingsMovieExportSaveCompressedMovie EQU 'cmpm'		; . Save compressed movie resource
kQTSettingsMIDI					EQU		'MIDI'				; MIDI import related container
kQTSettingsMIDISettingFlags		EQU		'sttg'				; . MIDI import settings (UInt32)
kQTSettingsText					EQU		'text'				; Text related container
kQTSettingsTextDescription		EQU		'desc'				; . Text import settings (TextDescription record)
kQTSettingsTextSize				EQU		'size'				; . Width/height to create during import (FixedPoint)
kQTSettingsTextSettingFlags		EQU		'sttg'				; . Text export settings (UInt32)
kQTSettingsTextTimeFraction		EQU		'timf'				; . Movie time fraction for export (UInt32)
kQTSettingsTime					EQU		'time'				; Time related container
kQTSettingsTimeDuration			EQU		'dura'				; . Time related container
kQTSettingsAudioCDTrack			EQU		'trak'				; Audio CD track related container
kQTSettingsAudioCDTrackRateShift EQU	'rshf'				; . Rate shift to be performed (SInt16)



MovieExportGetDataParams RECORD 0
recordSize				 ds.l	1				; offset: $0 (0)
trackID					 ds.l	1				; offset: $4 (4)
sourceTimeScale			 ds.l	1				; offset: $8 (8)
requestedTime			 ds.l	1				; offset: $C (12)
actualTime				 ds.l	1				; offset: $10 (16)
dataPtr					 ds.l	1				; offset: $14 (20)
dataSize				 ds.l	1				; offset: $18 (24)
desc					 ds.l	1				; offset: $1C (28)
descType				 ds.l	1				; offset: $20 (32)
descSeed				 ds.l	1				; offset: $24 (36)
requestedSampleCount	 ds.l	1				; offset: $28 (40)
actualSampleCount		 ds.l	1				; offset: $2C (44)
durationPerSample		 ds.l	1				; offset: $30 (48)
sampleFlags				 ds.l	1				; offset: $34 (52)
sizeof					 EQU *					; size:   $38 (56)
						ENDR

kQTPresetsListResourceType		EQU		'stg#'
kQTPresetsPlatformListResourceType EQU	'stgp'

kQTPresetInfoIsDivider			EQU		1
QTPresetInfo			RECORD 0
presetKey				 ds.l	1				; offset: $0 (0)		;  unique key for this preset in presetsArray 
presetFlags				 ds.l	1				; offset: $4 (4)		;  flags about this preset 
settingsResourceType	 ds.l	1				; offset: $8 (8)		;  resource type of settings resource 
settingsResourceID		 ds.w	1				; offset: $C (12)		;  resource id of settings resource 
padding1				 ds.w	1				; offset: $E (14)
nameStringListID		 ds.w	1				; offset: $10 (16)		;  name string list resource id 
nameStringIndex			 ds.w	1				; offset: $12 (18)		;  name string index 
infoStringListID		 ds.w	1				; offset: $14 (20)		;  info string list resource id 
infoStringIndex			 ds.w	1				; offset: $16 (22)		;  info string index 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
QTPresetListRecord		RECORD 0
flags					 ds.l	1				; offset: $0 (0)		;  flags for whole list 
count					 ds.l	1				; offset: $4 (4)		;  number of elements in presetsArray 
reserved				 ds.l	1				; offset: $8 (8)
presetsArray			 ds		QTPresetInfo	; offset: $C (12) <-- really an array of length one ;  info about each preset 
sizeof					 EQU *					; size:   $24 (36)
						ENDR

kQTMovieExportSourceInfoResourceType EQU 'src#'
kQTMovieExportSourceInfoIsMediaType EQU	$00000001
kQTMovieExportSourceInfoIsMediaCharacteristic EQU $00000002
kQTMovieExportSourceInfoIsSourceType EQU $00000004
QTMovieExportSourceInfo	RECORD 0
mediaType				 ds.l	1				; offset: $0 (0)		;  Media type of source 
minCount				 ds.w	1				; offset: $4 (4)		;  min number of sources of this kind required, zero if none required 
maxCount				 ds.w	1				; offset: $6 (6)		;  max number of sources of this kind allowed, -1 if unlimited allowed 
flags					 ds.l	1				; offset: $8 (8)		;  reserved for flags 
sizeof					 EQU *					; size:   $C (12)
						ENDR
QTMovieExportSourceRecord RECORD 0
count					 ds.l	1				; offset: $0 (0)
reserved				 ds.l	1				; offset: $4 (4)
sourceArray				 ds		QTMovieExportSourceInfo ; offset: $8 (8) <-- really an array of length one
sizeof					 EQU *					; size:   $14 (20)
						ENDR

; *  NewSCModalFilterUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewSCModalHookUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewMovieExportGetDataUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewMovieExportGetPropertyUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSCModalFilterUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSCModalHookUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeMovieExportGetDataUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeMovieExportGetPropertyUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSCModalFilterUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSCModalHookUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeMovieExportGetDataUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeMovieExportGetPropertyUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  MovieImportHandle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportHandle(MovieImportComponent ci, Handle dataH, Movie theMovie, Track targetTrack, Track *usedTrack, TimeValue atTime, TimeValue *addedDuration, long inFlags, long *outFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportHandle
			move.l              #$00200001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportHandle
	ENDIF


; *  MovieImportFile()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportFile(MovieImportComponent ci, const FSSpec *theFile, Movie theMovie, Track targetTrack, Track *usedTrack, TimeValue atTime, TimeValue *addedDuration, long inFlags, long *outFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportFile
			move.l              #$00200002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportFile
	ENDIF


; *  MovieImportSetSampleDuration()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportSetSampleDuration(MovieImportComponent ci, TimeValue duration, TimeScale scale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetSampleDuration
			move.l              #$00080003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetSampleDuration
	ENDIF


; *  MovieImportSetSampleDescription()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportSetSampleDescription(MovieImportComponent ci, SampleDescriptionHandle desc, OSType mediaType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetSampleDescription
			move.l              #$00080004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetSampleDescription
	ENDIF


; *  MovieImportSetMediaFile()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportSetMediaFile(MovieImportComponent ci, AliasHandle alias)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetMediaFile
			move.l              #$00040005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetMediaFile
	ENDIF


; *  MovieImportSetDimensions()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportSetDimensions(MovieImportComponent ci, Fixed width, Fixed height)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetDimensions
			move.l              #$00080006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetDimensions
	ENDIF


; *  MovieImportSetChunkSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportSetChunkSize(MovieImportComponent ci, long chunkSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetChunkSize
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetChunkSize
	ENDIF


; *  MovieImportSetProgressProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportSetProgressProc(MovieImportComponent ci, MovieProgressUPP proc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetProgressProc
			move.l              #$00080008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetProgressProc
	ENDIF


; *  MovieImportSetAuxiliaryData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportSetAuxiliaryData(MovieImportComponent ci, Handle data, OSType handleType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetAuxiliaryData
			move.l              #$00080009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetAuxiliaryData
	ENDIF


; *  MovieImportSetFromScrap()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportSetFromScrap(MovieImportComponent ci, Boolean fromScrap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetFromScrap
			move.l              #$0002000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetFromScrap
	ENDIF


; *  MovieImportDoUserDialog()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportDoUserDialog(MovieImportComponent ci, const FSSpec *theFile, Handle theData, Boolean *canceled)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportDoUserDialog
			move.l              #$000C000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportDoUserDialog
	ENDIF


; *  MovieImportSetDuration()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportSetDuration(MovieImportComponent ci, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetDuration
			move.l              #$0004000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetDuration
	ENDIF


; *  MovieImportGetAuxiliaryDataType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportGetAuxiliaryDataType(MovieImportComponent ci, OSType *auxType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetAuxiliaryDataType
			move.l              #$0004000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetAuxiliaryDataType
	ENDIF


; *  MovieImportValidate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportValidate(MovieImportComponent ci, const FSSpec *theFile, Handle theData, Boolean *valid)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportValidate
			move.l              #$000C000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportValidate
	ENDIF


; *  MovieImportGetFileType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportGetFileType(MovieImportComponent ci, OSType *fileType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetFileType
			move.l              #$0004000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetFileType
	ENDIF


; *  MovieImportDataRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportDataRef(MovieImportComponent ci, Handle dataRef, OSType dataRefType, Movie theMovie, Track targetTrack, Track *usedTrack, TimeValue atTime, TimeValue *addedDuration, long inFlags, long *outFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportDataRef
			move.l              #$00240010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportDataRef
	ENDIF


; *  MovieImportGetSampleDescription()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportGetSampleDescription(MovieImportComponent ci, SampleDescriptionHandle *desc, OSType *mediaType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetSampleDescription
			move.l              #$00080011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetSampleDescription
	ENDIF


; *  MovieImportGetMIMETypeList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportGetMIMETypeList(MovieImportComponent ci, QTAtomContainer *mimeInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetMIMETypeList
			move.l              #$00040012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetMIMETypeList
	ENDIF


; *  MovieImportSetOffsetAndLimit()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportSetOffsetAndLimit(MovieImportComponent ci, unsigned long offset, unsigned long limit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetOffsetAndLimit
			move.l              #$00080013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetOffsetAndLimit
	ENDIF


; *  MovieImportGetSettingsAsAtomContainer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportGetSettingsAsAtomContainer(MovieImportComponent ci, QTAtomContainer *settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetSettingsAsAtomContainer
			move.l              #$00040014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetSettingsAsAtomContainer
	ENDIF


; *  MovieImportSetSettingsFromAtomContainer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieImportSetSettingsFromAtomContainer(MovieImportComponent ci, QTAtomContainer settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetSettingsFromAtomContainer
			move.l              #$00040015,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetSettingsFromAtomContainer
	ENDIF


; *  MovieImportSetOffsetAndLimit64()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult MovieImportSetOffsetAndLimit64(MovieImportComponent ci, const wide *offset, const wide *limit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetOffsetAndLimit64
			move.l              #$00080016,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetOffsetAndLimit64
	ENDIF


; *  MovieImportIdle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult MovieImportIdle(MovieImportComponent ci, long inFlags, long *outFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportIdle
			move.l              #$00080017,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportIdle
	ENDIF


; *  MovieImportValidateDataRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult MovieImportValidateDataRef(MovieImportComponent ci, Handle dataRef, OSType dataRefType, UInt8 *valid)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportValidateDataRef
			move.l              #$000C0018,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportValidateDataRef
	ENDIF


; *  MovieImportGetLoadState()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.1 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.1 and later
; 

;
; pascal ComponentResult MovieImportGetLoadState(MovieImportComponent ci, long *importerLoadState)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetLoadState
			move.l              #$00040019,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetLoadState
	ENDIF


; *  MovieImportGetMaxLoadedTime()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.1 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.1 and later
; 

;
; pascal ComponentResult MovieImportGetMaxLoadedTime(MovieImportComponent ci, TimeValue *time)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetMaxLoadedTime
			move.l              #$0004001A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetMaxLoadedTime
	ENDIF


; *  MovieImportEstimateCompletionTime()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult MovieImportEstimateCompletionTime(MovieImportComponent ci, TimeRecord *time)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportEstimateCompletionTime
			move.l              #$0004001B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportEstimateCompletionTime
	ENDIF


; *  MovieImportSetDontBlock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult MovieImportSetDontBlock(MovieImportComponent ci, Boolean dontBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportSetDontBlock
			move.l              #$0002001C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportSetDontBlock
	ENDIF


; *  MovieImportGetDontBlock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult MovieImportGetDontBlock(MovieImportComponent ci, Boolean *willBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieImportGetDontBlock
			move.l              #$0004001D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieImportGetDontBlock
	ENDIF


; *  MovieExportToHandle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportToHandle(MovieExportComponent ci, Handle dataH, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportToHandle
			move.l              #$00140080,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportToHandle
	ENDIF


; *  MovieExportToFile()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportToFile(MovieExportComponent ci, const FSSpec *theFile, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportToFile
			move.l              #$00140081,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportToFile
	ENDIF


; *  MovieExportGetAuxiliaryData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportGetAuxiliaryData(MovieExportComponent ci, Handle dataH, OSType *handleType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportGetAuxiliaryData
			move.l              #$00080083,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportGetAuxiliaryData
	ENDIF


; *  MovieExportSetProgressProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportSetProgressProc(MovieExportComponent ci, MovieProgressUPP proc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportSetProgressProc
			move.l              #$00080084,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportSetProgressProc
	ENDIF


; *  MovieExportSetSampleDescription()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportSetSampleDescription(MovieExportComponent ci, SampleDescriptionHandle desc, OSType mediaType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportSetSampleDescription
			move.l              #$00080085,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportSetSampleDescription
	ENDIF


; *  MovieExportDoUserDialog()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportDoUserDialog(MovieExportComponent ci, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration, Boolean *canceled)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportDoUserDialog
			move.l              #$00140086,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportDoUserDialog
	ENDIF


; *  MovieExportGetCreatorType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportGetCreatorType(MovieExportComponent ci, OSType *creator)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportGetCreatorType
			move.l              #$00040087,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportGetCreatorType
	ENDIF


; *  MovieExportToDataRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportToDataRef(MovieExportComponent ci, Handle dataRef, OSType dataRefType, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportToDataRef
			move.l              #$00180088,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportToDataRef
	ENDIF


; *  MovieExportFromProceduresToDataRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportFromProceduresToDataRef(MovieExportComponent ci, Handle dataRef, OSType dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportFromProceduresToDataRef
			move.l              #$00080089,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportFromProceduresToDataRef
	ENDIF


; *  MovieExportAddDataSource()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportAddDataSource(MovieExportComponent ci, OSType trackType, TimeScale scale, long *trackID, MovieExportGetPropertyUPP getPropertyProc, MovieExportGetDataUPP getDataProc, void *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportAddDataSource
			move.l              #$0018008A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportAddDataSource
	ENDIF


; *  MovieExportValidate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportValidate(MovieExportComponent ci, Movie theMovie, Track onlyThisTrack, Boolean *valid)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportValidate
			move.l              #$000C008B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportValidate
	ENDIF


; *  MovieExportGetSettingsAsAtomContainer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportGetSettingsAsAtomContainer(MovieExportComponent ci, QTAtomContainer *settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportGetSettingsAsAtomContainer
			move.l              #$0004008C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportGetSettingsAsAtomContainer
	ENDIF


; *  MovieExportSetSettingsFromAtomContainer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportSetSettingsFromAtomContainer(MovieExportComponent ci, QTAtomContainer settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportSetSettingsFromAtomContainer
			move.l              #$0004008D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportSetSettingsFromAtomContainer
	ENDIF


; *  MovieExportGetFileNameExtension()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportGetFileNameExtension(MovieExportComponent ci, OSType *extension)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportGetFileNameExtension
			move.l              #$0004008E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportGetFileNameExtension
	ENDIF


; *  MovieExportGetShortFileTypeString()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportGetShortFileTypeString(MovieExportComponent ci, Str255 typeString)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportGetShortFileTypeString
			move.l              #$0004008F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportGetShortFileTypeString
	ENDIF


; *  MovieExportGetSourceMediaType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportGetSourceMediaType(MovieExportComponent ci, OSType *mediaType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportGetSourceMediaType
			move.l              #$00040090,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportGetSourceMediaType
	ENDIF


; *  MovieExportSetGetMoviePropertyProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult MovieExportSetGetMoviePropertyProc(MovieExportComponent ci, MovieExportGetPropertyUPP getPropertyProc, void *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportSetGetMoviePropertyProc
			move.l              #$00080091,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportSetGetMoviePropertyProc
	ENDIF

     IF ¬ TARGET_CPU_PPC THEN 
;  Text Export Display Info data structure
TextDisplayData			RECORD 0
displayFlags			 ds.l	1				; offset: $0 (0)
textJustification		 ds.l	1				; offset: $4 (4)
bgColor					 ds		RGBColor		; offset: $8 (8)
textBox					 ds		Rect			; offset: $E (14)
beginHilite				 ds.w	1				; offset: $16 (22)
endHilite				 ds.w	1				; offset: $18 (24)
hiliteColor				 ds		RGBColor		; offset: $1A (26)
doHiliteColor			 ds.b	1				; offset: $20 (32)
filler					 ds.b	1				; offset: $21 (33)
scrollDelayDur			 ds.l	1				; offset: $22 (34)
dropShadowOffset		 ds		Point			; offset: $26 (38)
dropShadowTransparency	 ds.w	1				; offset: $2A (42)
sizeof					 EQU *					; size:   $2C (44)
						ENDR
    ENDIF
; typedef ComponentInstance 			TextExportComponent

; typedef ComponentInstance 			GraphicImageMovieImportComponent


; *  TextExportGetDisplayData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult TextExportGetDisplayData(TextExportComponent ci, TextDisplayData *textDisplay)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextExportGetDisplayData
			move.l              #$00040100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextExportGetDisplayData
	ENDIF


; *  TextExportGetTimeFraction()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult TextExportGetTimeFraction(TextExportComponent ci, long *movieTimeFraction)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextExportGetTimeFraction
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextExportGetTimeFraction
	ENDIF


; *  TextExportSetTimeFraction()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult TextExportSetTimeFraction(TextExportComponent ci, long movieTimeFraction)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextExportSetTimeFraction
			move.l              #$00040102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextExportSetTimeFraction
	ENDIF


; *  TextExportGetSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult TextExportGetSettings(TextExportComponent ci, long *setting)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextExportGetSettings
			move.l              #$00040103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextExportGetSettings
	ENDIF


; *  TextExportSetSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult TextExportSetSettings(TextExportComponent ci, long setting)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_TextExportSetSettings
			move.l              #$00040104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION TextExportSetSettings
	ENDIF



; *  MIDIImportGetSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MIDIImportGetSettings(TextExportComponent ci, long *setting)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MIDIImportGetSettings
			move.l              #$00040100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MIDIImportGetSettings
	ENDIF


; *  MIDIImportSetSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MIDIImportSetSettings(TextExportComponent ci, long setting)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MIDIImportSetSettings
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MIDIImportSetSettings
	ENDIF


; *  MovieExportNewGetDataAndPropertiesProcs()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportNewGetDataAndPropertiesProcs(MovieExportComponent ci, OSType trackType, TimeScale *scale, Movie theMovie, Track theTrack, TimeValue startTime, TimeValue duration, MovieExportGetPropertyUPP *getPropertyProc, MovieExportGetDataUPP *getDataProc, void **refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportNewGetDataAndPropertiesProcs
			move.l              #$00240100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportNewGetDataAndPropertiesProcs
	ENDIF


; *  MovieExportDisposeGetDataAndPropertiesProcs()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult MovieExportDisposeGetDataAndPropertiesProcs(MovieExportComponent ci, MovieExportGetPropertyUPP getPropertyProc, MovieExportGetDataUPP getDataProc, void *refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_MovieExportDisposeGetDataAndPropertiesProcs
			move.l              #$000C0101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION MovieExportDisposeGetDataAndPropertiesProcs
	ENDIF


movieExportUseConfiguredSettings EQU	'ucfg'				; pointer to Boolean
movieExportWidth				EQU		'wdth'				; pointer to Fixed
movieExportHeight				EQU		'hegt'				; pointer to Fixed
movieExportDuration				EQU		'dura'				; pointer to TimeRecord
movieExportVideoFilter			EQU		'iflt'				; pointer to QTAtomContainer
movieExportTimeScale			EQU		'tmsc'				; pointer to TimeScale

; *  GraphicsImageImportSetSequenceEnabled()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult GraphicsImageImportSetSequenceEnabled(GraphicImageMovieImportComponent ci, Boolean enable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GraphicsImageImportSetSequenceEnabled
			move.l              #$00020100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GraphicsImageImportSetSequenceEnabled
	ENDIF


; *  GraphicsImageImportGetSequenceEnabled()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult GraphicsImageImportGetSequenceEnabled(GraphicImageMovieImportComponent ci, Boolean *enable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GraphicsImageImportGetSequenceEnabled
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GraphicsImageImportGetSequenceEnabled
	ENDIF












; ***************
;
;    File Preview Components
;
;**************

; typedef ComponentInstance 			pnotComponent


pnotComponentWantsEvents		EQU		1
pnotComponentNeedsNoCache		EQU		2

ShowFilePreviewComponentType	EQU		'pnot'
CreateFilePreviewComponentType	EQU		'pmak'

; *  PreviewShowData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult PreviewShowData(pnotComponent p, OSType dataType, Handle data, const Rect *inHere)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PreviewShowData
			move.l              #$000C0001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PreviewShowData
	ENDIF


; *  PreviewMakePreview()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult PreviewMakePreview(pnotComponent p, OSType *previewType, Handle *previewResult, const FSSpec *sourceFile, ICMProgressProcRecordPtr progress)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PreviewMakePreview
			move.l              #$00100002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PreviewMakePreview
	ENDIF


; *  PreviewMakePreviewReference()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult PreviewMakePreviewReference(pnotComponent p, OSType *previewType, short *resID, const FSSpec *sourceFile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PreviewMakePreviewReference
			move.l              #$000C0003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PreviewMakePreviewReference
	ENDIF


; *  PreviewEvent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult PreviewEvent(pnotComponent p, EventRecord *e, Boolean *handledEvent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_PreviewEvent
			move.l              #$00080004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION PreviewEvent
	ENDIF



; typedef ComponentInstance 			DataCompressorComponent

; typedef ComponentInstance 			DataDecompressorComponent

; typedef ComponentInstance 			DataCodecComponent


DataCompressorComponentType		EQU		'dcom'
DataDecompressorComponentType	EQU		'ddec'
AppleDataCompressorSubType		EQU		'adec'
zlibDataCompressorSubType		EQU		'zlib'

; * These are DataCodec procedures *

; *  DataCodecDecompress()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataCodecDecompress(DataCodecComponent dc, void *srcData, UInt32 srcSize, void *dstData, UInt32 dstBufferSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecDecompress
			move.l              #$00100001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecDecompress
	ENDIF


; *  DataCodecGetCompressBufferSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataCodecGetCompressBufferSize(DataCodecComponent dc, UInt32 srcSize, UInt32 *dstSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecGetCompressBufferSize
			move.l              #$00080002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecGetCompressBufferSize
	ENDIF


; *  DataCodecCompress()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataCodecCompress(DataCodecComponent dc, void *srcData, UInt32 srcSize, void *dstData, UInt32 dstBufferSize, UInt32 *actualDstSize, UInt32 *decompressSlop)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecCompress
			move.l              #$00180003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecCompress
	ENDIF


; *  DataCodecBeginInterruptSafe()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataCodecBeginInterruptSafe(DataCodecComponent dc, unsigned long maxSrcSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecBeginInterruptSafe
			move.l              #$00040004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecBeginInterruptSafe
	ENDIF


; *  DataCodecEndInterruptSafe()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataCodecEndInterruptSafe(DataCodecComponent dc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecEndInterruptSafe
			move.l              #$00000005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecEndInterruptSafe
	ENDIF


; *  DataCodecDecompressPartial()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataCodecDecompressPartial(DataCodecComponent dc, void **next_in, unsigned long *avail_in, unsigned long *total_in, void **next_out, unsigned long *avail_out, unsigned long *total_out, Boolean *didFinish)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecDecompressPartial
			move.l              #$001C0006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecDecompressPartial
	ENDIF


; *  DataCodecCompressPartial()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataCodecCompressPartial(DataCodecComponent dc, void **next_in, unsigned long *avail_in, unsigned long *total_in, void **next_out, unsigned long *avail_out, unsigned long *total_out, Boolean tryToFinish, Boolean *didFinish)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataCodecCompressPartial
			move.l              #$001E0007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataCodecCompressPartial
	ENDIF






kDataHCanRead					EQU		$00000001
kDataHSpecialRead				EQU		$00000002
kDataHSpecialReadFile			EQU		$00000004
kDataHCanWrite					EQU		$00000008
kDataHSpecialWrite				EQU		$10
kDataHSpecialWriteFile			EQU		$20
kDataHCanStreamingWrite			EQU		$40
kDataHMustCheckDataRef			EQU		$80
;  Data reference records for specific data ref types
HandleDataRefRecord		RECORD 0
dataHndl				 ds.l	1				; offset: $0 (0)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct HandleDataRefRecord *	HandleDataRefPtr

; typedef HandleDataRefPtr *			HandleDataRef

PointerDataRefRecord	RECORD 0
data					 ds.l	1				; offset: $0 (0)
dataLength				 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct PointerDataRefRecord *	PointerDataRefPtr

; typedef PointerDataRefPtr *			PointerDataRef

;  Data reference extensions

kDataRefExtensionChokeSpeed		EQU		'chok'
kDataRefExtensionFileName		EQU		'fnam'
kDataRefExtensionMIMEType		EQU		'mime'
kDataRefExtensionMacOSFileType	EQU		'ftyp'
kDataRefExtensionInitializationData EQU	'data'

kDataHChokeToMovieDataRate		EQU		$01					; param is 0
kDataHChokeToParam				EQU		$02					; param is bytes per second
DataHChokeAtomRecord	RECORD 0
flags					 ds.l	1				; offset: $0 (0)		;  one of kDataHChokeTo constants
param					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR

DataHVolumeListRecord	RECORD 0
vRefNum					 ds.w	1				; offset: $0 (0)
flags					 ds.l	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct DataHVolumeListRecord * DataHVolumeListPtr

; typedef DataHVolumeListPtr *			DataHVolumeList


kDataHExtendedSchedule			EQU		'xtnd'
DataHScheduleRecord		RECORD 0
timeNeededBy			 ds		TimeRecord		; offset: $0 (0)
extendedID				 ds.l	1				; offset: $10 (16)		;  always is kDataHExtendedSchedule
extendedVers			 ds.l	1				; offset: $14 (20)		;  always set to 0
priority				 ds.l	1				; offset: $18 (24)		;  100.0 or more means must have. lower numbers…
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct DataHScheduleRecord *	DataHSchedulePtr

;  Flags for DataHGetInfoFlags

kDataHInfoFlagNeverStreams		EQU		$01					; set if this data handler doesn't stream
kDataHInfoFlagCanUpdateDataRefs	EQU		$02					; set if this data handler might update data reference
kDataHInfoFlagNeedsNetworkBandwidth EQU	$04					; set if this data handler may need to occupy the network

;  Types for DataHGetFileTypeOrdering

kDataHFileTypeMacOSFileType		EQU		'ftyp'
kDataHFileTypeExtension			EQU		'fext'
kDataHFileTypeMIME				EQU		'mime'
; typedef OSType *						DataHFileTypeOrderingPtr

; typedef DataHFileTypeOrderingPtr *	DataHFileTypeOrderingHandle



; *  DataHGetData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetData(DataHandler dh, Handle h, long hOffset, long offset, long size)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetData
			move.l              #$00100002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetData
	ENDIF


; *  DataHPutData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHPutData(DataHandler dh, Handle h, long hOffset, long *offset, long size)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHPutData
			move.l              #$00100003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHPutData
	ENDIF


; *  DataHFlushData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHFlushData(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHFlushData
			move.l              #$00000004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHFlushData
	ENDIF


; *  DataHOpenForWrite()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHOpenForWrite(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHOpenForWrite
			move.l              #$00000005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHOpenForWrite
	ENDIF


; *  DataHCloseForWrite()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHCloseForWrite(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHCloseForWrite
			move.l              #$00000006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHCloseForWrite
	ENDIF



; *  DataHOpenForRead()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHOpenForRead(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHOpenForRead
			move.l              #$00000008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHOpenForRead
	ENDIF


; *  DataHCloseForRead()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHCloseForRead(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHCloseForRead
			move.l              #$00000009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHCloseForRead
	ENDIF


; *  DataHSetDataRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHSetDataRef(DataHandler dh, Handle dataRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetDataRef
			move.l              #$0004000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetDataRef
	ENDIF


; *  DataHGetDataRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetDataRef(DataHandler dh, Handle *dataRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataRef
			move.l              #$0004000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataRef
	ENDIF


; *  DataHCompareDataRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHCompareDataRef(DataHandler dh, Handle dataRef, Boolean *equal)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHCompareDataRef
			move.l              #$0008000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHCompareDataRef
	ENDIF


; *  DataHTask()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHTask(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHTask
			move.l              #$0000000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHTask
	ENDIF


; *  DataHScheduleData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHScheduleData(DataHandler dh, Ptr PlaceToPutDataPtr, long FileOffset, long DataSize, long RefCon, DataHSchedulePtr scheduleRec, DataHCompletionUPP CompletionRtn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHScheduleData
			move.l              #$0018000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHScheduleData
	ENDIF


; *  DataHFinishData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHFinishData(DataHandler dh, Ptr PlaceToPutDataPtr, Boolean Cancel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHFinishData
			move.l              #$0006000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHFinishData
	ENDIF


; *  DataHFlushCache()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHFlushCache(DataHandler dh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHFlushCache
			move.l              #$00000010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHFlushCache
	ENDIF


; *  DataHResolveDataRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHResolveDataRef(DataHandler dh, Handle theDataRef, Boolean *wasChanged, Boolean userInterfaceAllowed)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHResolveDataRef
			move.l              #$000A0011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHResolveDataRef
	ENDIF


; *  DataHGetFileSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetFileSize(DataHandler dh, long *fileSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFileSize
			move.l              #$00040012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFileSize
	ENDIF


; *  DataHCanUseDataRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHCanUseDataRef(DataHandler dh, Handle dataRef, long *useFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHCanUseDataRef
			move.l              #$00080013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHCanUseDataRef
	ENDIF


; *  DataHGetVolumeList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetVolumeList(DataHandler dh, DataHVolumeList *volumeList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetVolumeList
			move.l              #$00040014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetVolumeList
	ENDIF


; *  DataHWrite()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHWrite(DataHandler dh, Ptr data, long offset, long size, DataHCompletionUPP completion, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHWrite
			move.l              #$00140015,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHWrite
	ENDIF


; *  DataHPreextend()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHPreextend(DataHandler dh, unsigned long maxToAdd, unsigned long *spaceAdded)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHPreextend
			move.l              #$00080016,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHPreextend
	ENDIF


; *  DataHSetFileSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHSetFileSize(DataHandler dh, long fileSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetFileSize
			move.l              #$00040017,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetFileSize
	ENDIF


; *  DataHGetFreeSpace()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetFreeSpace(DataHandler dh, unsigned long *freeSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFreeSpace
			move.l              #$00040018,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFreeSpace
	ENDIF


; *  DataHCreateFile()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHCreateFile(DataHandler dh, OSType creator, Boolean deleteExisting)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHCreateFile
			move.l              #$00060019,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHCreateFile
	ENDIF


; *  DataHGetPreferredBlockSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetPreferredBlockSize(DataHandler dh, long *blockSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetPreferredBlockSize
			move.l              #$0004001A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetPreferredBlockSize
	ENDIF


; *  DataHGetDeviceIndex()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetDeviceIndex(DataHandler dh, long *deviceIndex)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDeviceIndex
			move.l              #$0004001B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDeviceIndex
	ENDIF


; *  DataHIsStreamingDataHandler()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHIsStreamingDataHandler(DataHandler dh, Boolean *yes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHIsStreamingDataHandler
			move.l              #$0004001C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHIsStreamingDataHandler
	ENDIF


; *  DataHGetDataInBuffer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetDataInBuffer(DataHandler dh, long startOffset, long *size)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataInBuffer
			move.l              #$0008001D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataInBuffer
	ENDIF


; *  DataHGetScheduleAheadTime()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetScheduleAheadTime(DataHandler dh, long *millisecs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetScheduleAheadTime
			move.l              #$0004001E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetScheduleAheadTime
	ENDIF


; *  DataHSetCacheSizeLimit()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHSetCacheSizeLimit(DataHandler dh, Size cacheSizeLimit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetCacheSizeLimit
			move.l              #$0004001F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetCacheSizeLimit
	ENDIF


; *  DataHGetCacheSizeLimit()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetCacheSizeLimit(DataHandler dh, Size *cacheSizeLimit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetCacheSizeLimit
			move.l              #$00040020,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetCacheSizeLimit
	ENDIF


; *  DataHGetMovie()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetMovie(DataHandler dh, Movie *theMovie, short *id)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetMovie
			move.l              #$00080021,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetMovie
	ENDIF


; *  DataHAddMovie()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHAddMovie(DataHandler dh, Movie theMovie, short *id)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHAddMovie
			move.l              #$00080022,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHAddMovie
	ENDIF


; *  DataHUpdateMovie()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHUpdateMovie(DataHandler dh, Movie theMovie, short id)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHUpdateMovie
			move.l              #$00060023,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHUpdateMovie
	ENDIF


; *  DataHDoesBuffer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHDoesBuffer(DataHandler dh, Boolean *buffersReads, Boolean *buffersWrites)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHDoesBuffer
			move.l              #$00080024,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHDoesBuffer
	ENDIF


; *  DataHGetFileName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetFileName(DataHandler dh, Str255 str)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFileName
			move.l              #$00040025,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFileName
	ENDIF


; *  DataHGetAvailableFileSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetAvailableFileSize(DataHandler dh, long *fileSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetAvailableFileSize
			move.l              #$00040026,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetAvailableFileSize
	ENDIF


; *  DataHGetMacOSFileType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetMacOSFileType(DataHandler dh, OSType *fileType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetMacOSFileType
			move.l              #$00040027,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetMacOSFileType
	ENDIF


; *  DataHGetMIMEType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetMIMEType(DataHandler dh, Str255 mimeType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetMIMEType
			move.l              #$00040028,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetMIMEType
	ENDIF


; *  DataHSetDataRefWithAnchor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHSetDataRefWithAnchor(DataHandler dh, Handle anchorDataRef, OSType dataRefType, Handle dataRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetDataRefWithAnchor
			move.l              #$000C0029,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetDataRefWithAnchor
	ENDIF


; *  DataHGetDataRefWithAnchor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHGetDataRefWithAnchor(DataHandler dh, Handle anchorDataRef, OSType dataRefType, Handle *dataRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataRefWithAnchor
			move.l              #$000C002A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataRefWithAnchor
	ENDIF


; *  DataHSetMacOSFileType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHSetMacOSFileType(DataHandler dh, OSType fileType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetMacOSFileType
			move.l              #$0004002B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetMacOSFileType
	ENDIF


; *  DataHSetTimeBase()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHSetTimeBase(DataHandler dh, TimeBase tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetTimeBase
			move.l              #$0004002C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetTimeBase
	ENDIF


; *  DataHGetInfoFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult DataHGetInfoFlags(DataHandler dh, UInt32 *flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetInfoFlags
			move.l              #$0004002D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetInfoFlags
	ENDIF


; *  DataHScheduleData64()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult DataHScheduleData64(DataHandler dh, Ptr PlaceToPutDataPtr, const wide *FileOffset, long DataSize, long RefCon, DataHSchedulePtr scheduleRec, DataHCompletionUPP CompletionRtn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHScheduleData64
			move.l              #$0018002E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHScheduleData64
	ENDIF


; *  DataHWrite64()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult DataHWrite64(DataHandler dh, Ptr data, const wide *offset, long size, DataHCompletionUPP completion, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHWrite64
			move.l              #$0014002F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHWrite64
	ENDIF


; *  DataHGetFileSize64()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult DataHGetFileSize64(DataHandler dh, wide *fileSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFileSize64
			move.l              #$00040030,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFileSize64
	ENDIF


; *  DataHPreextend64()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult DataHPreextend64(DataHandler dh, const wide *maxToAdd, wide *spaceAdded)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHPreextend64
			move.l              #$00080031,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHPreextend64
	ENDIF


; *  DataHSetFileSize64()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult DataHSetFileSize64(DataHandler dh, const wide *fileSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetFileSize64
			move.l              #$00040032,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetFileSize64
	ENDIF


; *  DataHGetFreeSpace64()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult DataHGetFreeSpace64(DataHandler dh, wide *freeSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFreeSpace64
			move.l              #$00040033,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFreeSpace64
	ENDIF


; *  DataHAppend64()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult DataHAppend64(DataHandler dh, void *data, wide *fileOffset, unsigned long size)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHAppend64
			move.l              #$000C0034,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHAppend64
	ENDIF


; *  DataHReadAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult DataHReadAsync(DataHandler dh, void *dataPtr, UInt32 dataSize, const wide *dataOffset, DataHCompletionUPP completion, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHReadAsync
			move.l              #$00140035,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHReadAsync
	ENDIF


; *  DataHPollRead()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult DataHPollRead(DataHandler dh, void *dataPtr, UInt32 *dataSizeSoFar)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHPollRead
			move.l              #$00080036,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHPollRead
	ENDIF


; *  DataHGetDataAvailability()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult DataHGetDataAvailability(DataHandler dh, long offset, long len, long *missing_offset, long *missing_len)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataAvailability
			move.l              #$00100037,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataAvailability
	ENDIF


; *  DataHGetFileSizeAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult DataHGetFileSizeAsync(DataHandler dh, wide *fileSize, DataHCompletionUPP completionRtn, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFileSizeAsync
			move.l              #$000C003A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFileSizeAsync
	ENDIF


; *  DataHGetDataRefAsType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.1 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.1 and later
; 

;
; pascal ComponentResult DataHGetDataRefAsType(DataHandler dh, OSType requestedType, Handle *dataRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataRefAsType
			move.l              #$0008003B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataRefAsType
	ENDIF


; *  DataHSetDataRefExtension()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.1 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.1 and later
; 

;
; pascal ComponentResult DataHSetDataRefExtension(DataHandler dh, Handle extension, OSType idType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetDataRefExtension
			move.l              #$0008003C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetDataRefExtension
	ENDIF


; *  DataHGetDataRefExtension()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.1 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.1 and later
; 

;
; pascal ComponentResult DataHGetDataRefExtension(DataHandler dh, Handle *extension, OSType idType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataRefExtension
			move.l              #$0008003D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataRefExtension
	ENDIF


; *  DataHGetMovieWithFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.1 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.1 and later
; 

;
; pascal ComponentResult DataHGetMovieWithFlags(DataHandler dh, Movie *theMovie, short *id, short flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetMovieWithFlags
			move.l              #$000A003E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetMovieWithFlags
	ENDIF



; *  DataHGetFileTypeOrdering()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult DataHGetFileTypeOrdering(DataHandler dh, DataHFileTypeOrderingHandle *orderingListHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetFileTypeOrdering
			move.l              #$00040040,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetFileTypeOrdering
	ENDIF

;  flags for DataHCreateFileWithFlags

kDataHCreateFileButDontCreateResFile EQU $00000001

; *  DataHCreateFileWithFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult DataHCreateFileWithFlags(DataHandler dh, OSType creator, Boolean deleteExisting, UInt32 flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHCreateFileWithFlags
			move.l              #$000A0041,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHCreateFileWithFlags
	ENDIF


; *  DataHGetMIMETypeAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult DataHGetMIMETypeAsync(DataHandler dh, Str255 mimeType, DataHCompletionUPP completionRtn, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetMIMETypeAsync
			move.l              #$000C0042,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetMIMETypeAsync
	ENDIF


; *  DataHGetInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0.1 and later
; *    CarbonLib:        not available in CarbonLib 1.x, is availble on Mac OS X after version 10.0
; *    Mac OS X:         in after version 10.0
; *    Windows:          in qtmlClient.lib 5.0.1 and later
; 

;
; pascal ComponentResult DataHGetInfo(DataHandler dh, OSType what, void *info)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetInfo
			move.l              #$00080043,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetInfo
	ENDIF


; *  DataHPlaybackHints()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult DataHPlaybackHints(DataHandler dh, long flags, unsigned long minFileOffset, unsigned long maxFileOffset, long bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHPlaybackHints
			move.l              #$00100103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHPlaybackHints
	ENDIF


; *  DataHPlaybackHints64()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.1 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.1 and later
; 

;
; pascal ComponentResult DataHPlaybackHints64(DataHandler dh, long flags, const wide *minFileOffset, const wide *maxFileOffset, long bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHPlaybackHints64
			move.l              #$0010010E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHPlaybackHints64
	ENDIF

;  Symbolic constants for DataHGetDataRate

kDataHGetDataRateInfiniteRate	EQU		$7FFFFFFF			; all the data arrived instantaneously

; *  DataHGetDataRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult DataHGetDataRate(DataHandler dh, long flags, long *bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHGetDataRate
			move.l              #$00080110,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHGetDataRate
	ENDIF

;  Flags for DataHSetTimeHints

kDataHSetTimeHintsSkipBandwidthRequest EQU $01				; set if this data handler should use the network without requesting bandwidth

; *  DataHSetTimeHints()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult DataHSetTimeHints(DataHandler dh, long flags, long bandwidthPriority, TimeScale scale, TimeValue minTime, TimeValue maxTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_DataHSetTimeHints
			move.l              #$00140111,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DataHSetTimeHints
	ENDIF





;  Standard type for video digitizers 

videoDigitizerComponentType		EQU		'vdig'
vdigInterfaceRev				EQU		2
;  Input Format Standards 

ntscIn							EQU		0					; current input format 
currentIn						EQU		0					; ntsc input format 
palIn							EQU		1					; pal input format 
secamIn							EQU		2					; secam input format 
ntscReallyIn					EQU		3					; ntsc input format 
;  Input Formats 

compositeIn						EQU		0					; input is composite format 
sVideoIn						EQU		1					; input is sVideo format 
rgbComponentIn					EQU		2					; input is rgb component format 
rgbComponentSyncIn				EQU		3					; input is rgb component format (sync on green?)
yuvComponentIn					EQU		4					; input is yuv component format 
yuvComponentSyncIn				EQU		5					; input is yuv component format (sync on green?) 
tvTunerIn						EQU		6
sdiIn							EQU		7

;  Video Digitizer PlayThru States 

vdPlayThruOff					EQU		0
vdPlayThruOn					EQU		1
;  Input Color Space Modes 

vdDigitizerBW					EQU		0					; black and white 
vdDigitizerRGB					EQU		1					; rgb color 
;  Phase Lock Loop Modes 

vdBroadcastMode					EQU		0					; Broadcast / Laser Disk video mode 
vdVTRMode						EQU		1					; VCR / Magnetic media mode 
;  Field Select Options 

vdUseAnyField					EQU		0					; Digitizers choice on field use 
vdUseOddField					EQU		1					; Use odd field for half size vert and smaller 
vdUseEvenField					EQU		2					; Use even field for half size vert and smaller 
;  vdig types 

vdTypeBasic						EQU		0					; basic, no clipping 
vdTypeAlpha						EQU		1					; supports clipping with alpha channel 
vdTypeMask						EQU		2					; supports clipping with mask plane 
vdTypeKey						EQU		3					; supports clipping with key color(s) 


;  Digitizer Input Capability/Current Flags 

digiInDoesNTSC					EQU		$00000001			; digitizer supports NTSC input format 
digiInDoesPAL					EQU		$00000002			; digitizer supports PAL input format 
digiInDoesSECAM					EQU		$00000004			; digitizer supports SECAM input format 
digiInDoesGenLock				EQU		$00000080			; digitizer does genlock 
digiInDoesComposite				EQU		$00000100			; digitizer supports composite input type 
digiInDoesSVideo				EQU		$00000200			; digitizer supports S-Video input type 
digiInDoesComponent				EQU		$00000400			; digitizer supports component = rgb, input type 
digiInVTR_Broadcast				EQU		$00000800			; digitizer can differentiate between the two 
digiInDoesColor					EQU		$00001000			; digitizer supports color 
digiInDoesBW					EQU		$00002000			; digitizer supports black & white 
															; Digitizer Input Current Flags = these are valid only during active operating conditions,   
digiInSignalLock				EQU		$80000000			; digitizer detects input signal is locked, this bit = horiz lock || vertical lock 

;  Digitizer Output Capability/Current Flags 

digiOutDoes1					EQU		$00000001			; digitizer supports 1 bit pixels 
digiOutDoes2					EQU		$00000002			; digitizer supports 2 bit pixels 
digiOutDoes4					EQU		$00000004			; digitizer supports 4 bit pixels 
digiOutDoes8					EQU		$00000008			; digitizer supports 8 bit pixels 
digiOutDoes16					EQU		$00000010			; digitizer supports 16 bit pixels 
digiOutDoes32					EQU		$00000020			; digitizer supports 32 bit pixels 
digiOutDoesDither				EQU		$00000040			; digitizer dithers in indexed modes 
digiOutDoesStretch				EQU		$00000080			; digitizer can arbitrarily stretch 
digiOutDoesShrink				EQU		$00000100			; digitizer can arbitrarily shrink 
digiOutDoesMask					EQU		$00000200			; digitizer can mask to clipping regions 
digiOutDoesDouble				EQU		$00000800			; digitizer can stretch to exactly double size 
digiOutDoesQuad					EQU		$00001000			; digitizer can stretch exactly quadruple size 
digiOutDoesQuarter				EQU		$00002000			; digitizer can shrink to exactly quarter size 
digiOutDoesSixteenth			EQU		$00004000			; digitizer can shrink to exactly sixteenth size 
digiOutDoesRotate				EQU		$00008000			; digitizer supports rotate transformations 
digiOutDoesHorizFlip			EQU		$00010000			; digitizer supports horizontal flips Sx < 0 
digiOutDoesVertFlip				EQU		$00020000			; digitizer supports vertical flips Sy < 0 
digiOutDoesSkew					EQU		$00040000			; digitizer supports skew = shear,twist, 
digiOutDoesBlend				EQU		$00080000
digiOutDoesWarp					EQU		$00100000
digiOutDoesHW_DMA				EQU		$00200000			; digitizer not constrained to local device 
digiOutDoesHWPlayThru			EQU		$00400000			; digitizer doesn't need time to play thru 
digiOutDoesILUT					EQU		$00800000			; digitizer does inverse LUT for index modes 
digiOutDoesKeyColor				EQU		$01000000			; digitizer does key color functions too 
digiOutDoesAsyncGrabs			EQU		$02000000			; digitizer supports async grabs 
digiOutDoesUnreadableScreenBits	EQU		$04000000			; playthru doesn't generate readable bits on screen
digiOutDoesCompress				EQU		$08000000			; supports alternate output data types 
digiOutDoesCompressOnly			EQU		$10000000			; can't provide raw frames anywhere 
digiOutDoesPlayThruDuringCompress EQU	$20000000			; digi can do playthru while providing compressed data 
digiOutDoesCompressPartiallyVisible EQU	$40000000			; digi doesn't need all bits visible on screen to do hardware compress 
digiOutDoesNotNeedCopyOfCompressData EQU $80000000			; digi doesn't need any bufferization when providing compressed data 
;  Types 
; typedef ComponentInstance 			VideoDigitizerComponent

; typedef ComponentResult 				VideoDigitizerError

DigitizerInfo			RECORD 0
vdigType				 ds.w	1				; offset: $0 (0)
inputCapabilityFlags	 ds.l	1				; offset: $2 (2)
outputCapabilityFlags	 ds.l	1				; offset: $6 (6)
inputCurrentFlags		 ds.l	1				; offset: $A (10)
outputCurrentFlags		 ds.l	1				; offset: $E (14)
slot					 ds.w	1				; offset: $12 (18)		;  temporary for connection purposes 
gdh						 ds.l	1				; offset: $14 (20)		;  temporary for digitizers that have preferred screen 
maskgdh					 ds.l	1				; offset: $18 (24)		;  temporary for digitizers that have mask planes 
minDestHeight			 ds.w	1				; offset: $1C (28)		;  Smallest resizable height 
minDestWidth			 ds.w	1				; offset: $1E (30)		;  Smallest resizable width 
maxDestHeight			 ds.w	1				; offset: $20 (32)		;  Largest resizable height 
maxDestWidth			 ds.w	1				; offset: $22 (34)		;  Largest resizable width 
blendLevels				 ds.w	1				; offset: $24 (36)		;  Number of blend levels supported (2 if 1 bit mask) 
reserved				 ds.l	1				; offset: $26 (38)		;  reserved 
sizeof					 EQU *					; size:   $2A (42)
						ENDR
VdigType				RECORD 0
digType					 ds.l	1				; offset: $0 (0)
reserved				 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
VdigTypeList			RECORD 0
count					 ds.w	1				; offset: $0 (0)
list					 ds		VdigType		; offset: $2 (2) <-- really an array of length one
sizeof					 EQU *					; size:   $A (10)
						ENDR
VdigBufferRec			RECORD 0
dest					 ds.l	1				; offset: $0 (0)
location				 ds		Point			; offset: $4 (4)
reserved				 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
VdigBufferRecList		RECORD 0
count					 ds.w	1				; offset: $0 (0)
matrix					 ds.l	1				; offset: $2 (2)
mask					 ds.l	1				; offset: $6 (6)
list					 ds		VdigBufferRec	; offset: $A (10) <-- really an array of length one
sizeof					 EQU *					; size:   $16 (22)
						ENDR
; typedef struct VdigBufferRecList *	VdigBufferRecListPtr

; typedef VdigBufferRecListPtr *		VdigBufferRecListHandle

VDCompressionList		RECORD 0
codec					 ds.l	1				; offset: $0 (0)
cType					 ds.l	1				; offset: $4 (4)
typeName				 ds		Str63			; offset: $8 (8)
name					 ds		Str63			; offset: $48 (72)
formatFlags				 ds.l	1				; offset: $88 (136)
compressFlags			 ds.l	1				; offset: $8C (140)
reserved				 ds.l	1				; offset: $90 (144)
sizeof					 EQU *					; size:   $94 (148)
						ENDR
; typedef struct VDCompressionList *	VDCompressionListPtr

; typedef VDCompressionListPtr *		VDCompressionListHandle


dmaDepth1						EQU		1
dmaDepth2						EQU		2
dmaDepth4						EQU		4
dmaDepth8						EQU		8
dmaDepth16						EQU		16
dmaDepth32						EQU		32
dmaDepth2Gray					EQU		64
dmaDepth4Gray					EQU		128
dmaDepth8Gray					EQU		256

kVDIGControlledFrameRate		EQU		-1


; *  VDGetMaxSrcRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetMaxSrcRect(VideoDigitizerComponent ci, short inputStd, Rect *maxSrcRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetMaxSrcRect
			move.l              #$00060001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetMaxSrcRect
	ENDIF


; *  VDGetActiveSrcRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetActiveSrcRect(VideoDigitizerComponent ci, short inputStd, Rect *activeSrcRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetActiveSrcRect
			move.l              #$00060002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetActiveSrcRect
	ENDIF


; *  VDSetDigitizerRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetDigitizerRect(VideoDigitizerComponent ci, Rect *digitizerRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetDigitizerRect
			move.l              #$00040003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetDigitizerRect
	ENDIF


; *  VDGetDigitizerRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetDigitizerRect(VideoDigitizerComponent ci, Rect *digitizerRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetDigitizerRect
			move.l              #$00040004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetDigitizerRect
	ENDIF


; *  VDGetVBlankRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetVBlankRect(VideoDigitizerComponent ci, short inputStd, Rect *vBlankRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetVBlankRect
			move.l              #$00060005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetVBlankRect
	ENDIF


; *  VDGetMaskPixMap()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetMaskPixMap(VideoDigitizerComponent ci, PixMapHandle maskPixMap)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetMaskPixMap
			move.l              #$00040006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetMaskPixMap
	ENDIF


; *  VDGetPlayThruDestination()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetPlayThruDestination(VideoDigitizerComponent ci, PixMapHandle *dest, Rect *destRect, MatrixRecord *m, RgnHandle *mask)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetPlayThruDestination
			move.l              #$00100008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetPlayThruDestination
	ENDIF


; *  VDUseThisCLUT()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDUseThisCLUT(VideoDigitizerComponent ci, CTabHandle colorTableHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDUseThisCLUT
			move.l              #$00040009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDUseThisCLUT
	ENDIF


; *  VDSetInputGammaValue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetInputGammaValue(VideoDigitizerComponent ci, Fixed channel1, Fixed channel2, Fixed channel3)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetInputGammaValue
			move.l              #$000C000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetInputGammaValue
	ENDIF


; *  VDGetInputGammaValue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetInputGammaValue(VideoDigitizerComponent ci, Fixed *channel1, Fixed *channel2, Fixed *channel3)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetInputGammaValue
			move.l              #$000C000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetInputGammaValue
	ENDIF


; *  VDSetBrightness()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetBrightness(VideoDigitizerComponent ci, unsigned short *brightness)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetBrightness
			move.l              #$0004000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetBrightness
	ENDIF


; *  VDGetBrightness()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetBrightness(VideoDigitizerComponent ci, unsigned short *brightness)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetBrightness
			move.l              #$0004000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetBrightness
	ENDIF


; *  VDSetContrast()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetContrast(VideoDigitizerComponent ci, unsigned short *contrast)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetContrast
			move.l              #$0004000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetContrast
	ENDIF


; *  VDSetHue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetHue(VideoDigitizerComponent ci, unsigned short *hue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetHue
			move.l              #$0004000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetHue
	ENDIF


; *  VDSetSharpness()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetSharpness(VideoDigitizerComponent ci, unsigned short *sharpness)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetSharpness
			move.l              #$00040010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetSharpness
	ENDIF


; *  VDSetSaturation()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetSaturation(VideoDigitizerComponent ci, unsigned short *saturation)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetSaturation
			move.l              #$00040011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetSaturation
	ENDIF


; *  VDGetContrast()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetContrast(VideoDigitizerComponent ci, unsigned short *contrast)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetContrast
			move.l              #$00040012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetContrast
	ENDIF


; *  VDGetHue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetHue(VideoDigitizerComponent ci, unsigned short *hue)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetHue
			move.l              #$00040013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetHue
	ENDIF


; *  VDGetSharpness()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetSharpness(VideoDigitizerComponent ci, unsigned short *sharpness)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetSharpness
			move.l              #$00040014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetSharpness
	ENDIF


; *  VDGetSaturation()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetSaturation(VideoDigitizerComponent ci, unsigned short *saturation)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetSaturation
			move.l              #$00040015,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetSaturation
	ENDIF


; *  VDGrabOneFrame()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGrabOneFrame(VideoDigitizerComponent ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGrabOneFrame
			move.l              #$00000016,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGrabOneFrame
	ENDIF


; *  VDGetMaxAuxBuffer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetMaxAuxBuffer(VideoDigitizerComponent ci, PixMapHandle *pm, Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetMaxAuxBuffer
			move.l              #$00080017,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetMaxAuxBuffer
	ENDIF


; *  VDGetDigitizerInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetDigitizerInfo(VideoDigitizerComponent ci, DigitizerInfo *info)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetDigitizerInfo
			move.l              #$00040019,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetDigitizerInfo
	ENDIF


; *  VDGetCurrentFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetCurrentFlags(VideoDigitizerComponent ci, long *inputCurrentFlag, long *outputCurrentFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetCurrentFlags
			move.l              #$0008001A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetCurrentFlags
	ENDIF


; *  VDSetKeyColor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetKeyColor(VideoDigitizerComponent ci, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetKeyColor
			move.l              #$0004001B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetKeyColor
	ENDIF


; *  VDGetKeyColor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetKeyColor(VideoDigitizerComponent ci, long *index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetKeyColor
			move.l              #$0004001C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetKeyColor
	ENDIF


; *  VDAddKeyColor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDAddKeyColor(VideoDigitizerComponent ci, long *index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDAddKeyColor
			move.l              #$0004001D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDAddKeyColor
	ENDIF


; *  VDGetNextKeyColor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetNextKeyColor(VideoDigitizerComponent ci, long index)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetNextKeyColor
			move.l              #$0004001E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetNextKeyColor
	ENDIF


; *  VDSetKeyColorRange()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetKeyColorRange(VideoDigitizerComponent ci, RGBColor *minRGB, RGBColor *maxRGB)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetKeyColorRange
			move.l              #$0008001F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetKeyColorRange
	ENDIF


; *  VDGetKeyColorRange()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetKeyColorRange(VideoDigitizerComponent ci, RGBColor *minRGB, RGBColor *maxRGB)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetKeyColorRange
			move.l              #$00080020,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetKeyColorRange
	ENDIF


; *  VDSetDigitizerUserInterrupt()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetDigitizerUserInterrupt(VideoDigitizerComponent ci, long flags, VdigIntUPP userInterruptProc, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetDigitizerUserInterrupt
			move.l              #$000C0021,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetDigitizerUserInterrupt
	ENDIF


; *  VDSetInputColorSpaceMode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetInputColorSpaceMode(VideoDigitizerComponent ci, short colorSpaceMode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetInputColorSpaceMode
			move.l              #$00020022,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetInputColorSpaceMode
	ENDIF


; *  VDGetInputColorSpaceMode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetInputColorSpaceMode(VideoDigitizerComponent ci, short *colorSpaceMode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetInputColorSpaceMode
			move.l              #$00040023,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetInputColorSpaceMode
	ENDIF


; *  VDSetClipState()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetClipState(VideoDigitizerComponent ci, short clipEnable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetClipState
			move.l              #$00020024,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetClipState
	ENDIF


; *  VDGetClipState()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetClipState(VideoDigitizerComponent ci, short *clipEnable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetClipState
			move.l              #$00040025,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetClipState
	ENDIF


; *  VDSetClipRgn()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetClipRgn(VideoDigitizerComponent ci, RgnHandle clipRegion)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetClipRgn
			move.l              #$00040026,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetClipRgn
	ENDIF


; *  VDClearClipRgn()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDClearClipRgn(VideoDigitizerComponent ci, RgnHandle clipRegion)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDClearClipRgn
			move.l              #$00040027,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDClearClipRgn
	ENDIF


; *  VDGetCLUTInUse()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetCLUTInUse(VideoDigitizerComponent ci, CTabHandle *colorTableHandle)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetCLUTInUse
			move.l              #$00040028,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetCLUTInUse
	ENDIF


; *  VDSetPLLFilterType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetPLLFilterType(VideoDigitizerComponent ci, short pllType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetPLLFilterType
			move.l              #$00020029,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetPLLFilterType
	ENDIF


; *  VDGetPLLFilterType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetPLLFilterType(VideoDigitizerComponent ci, short *pllType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetPLLFilterType
			move.l              #$0004002A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetPLLFilterType
	ENDIF


; *  VDGetMaskandValue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetMaskandValue(VideoDigitizerComponent ci, unsigned short blendLevel, long *mask, long *value)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetMaskandValue
			move.l              #$000A002B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetMaskandValue
	ENDIF


; *  VDSetMasterBlendLevel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetMasterBlendLevel(VideoDigitizerComponent ci, unsigned short *blendLevel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetMasterBlendLevel
			move.l              #$0004002C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetMasterBlendLevel
	ENDIF


; *  VDSetPlayThruDestination()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetPlayThruDestination(VideoDigitizerComponent ci, PixMapHandle dest, RectPtr destRect, MatrixRecordPtr m, RgnHandle mask)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetPlayThruDestination
			move.l              #$0010002D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetPlayThruDestination
	ENDIF


; *  VDSetPlayThruOnOff()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetPlayThruOnOff(VideoDigitizerComponent ci, short state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetPlayThruOnOff
			move.l              #$0002002E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetPlayThruOnOff
	ENDIF


; *  VDSetFieldPreference()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetFieldPreference(VideoDigitizerComponent ci, short fieldFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetFieldPreference
			move.l              #$0002002F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetFieldPreference
	ENDIF


; *  VDGetFieldPreference()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetFieldPreference(VideoDigitizerComponent ci, short *fieldFlag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetFieldPreference
			move.l              #$00040030,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetFieldPreference
	ENDIF


; *  VDPreflightDestination()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDPreflightDestination(VideoDigitizerComponent ci, Rect *digitizerRect, PixMap **dest, RectPtr destRect, MatrixRecordPtr m)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDPreflightDestination
			move.l              #$00100032,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDPreflightDestination
	ENDIF


; *  VDPreflightGlobalRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDPreflightGlobalRect(VideoDigitizerComponent ci, GrafPtr theWindow, Rect *globalRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDPreflightGlobalRect
			move.l              #$00080033,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDPreflightGlobalRect
	ENDIF


; *  VDSetPlayThruGlobalRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetPlayThruGlobalRect(VideoDigitizerComponent ci, GrafPtr theWindow, Rect *globalRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetPlayThruGlobalRect
			move.l              #$00080034,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetPlayThruGlobalRect
	ENDIF


; *  VDSetInputGammaRecord()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetInputGammaRecord(VideoDigitizerComponent ci, VDGamRecPtr inputGammaPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetInputGammaRecord
			move.l              #$00040035,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetInputGammaRecord
	ENDIF


; *  VDGetInputGammaRecord()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetInputGammaRecord(VideoDigitizerComponent ci, VDGamRecPtr *inputGammaPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetInputGammaRecord
			move.l              #$00040036,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetInputGammaRecord
	ENDIF


; *  VDSetBlackLevelValue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetBlackLevelValue(VideoDigitizerComponent ci, unsigned short *blackLevel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetBlackLevelValue
			move.l              #$00040037,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetBlackLevelValue
	ENDIF


; *  VDGetBlackLevelValue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetBlackLevelValue(VideoDigitizerComponent ci, unsigned short *blackLevel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetBlackLevelValue
			move.l              #$00040038,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetBlackLevelValue
	ENDIF


; *  VDSetWhiteLevelValue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetWhiteLevelValue(VideoDigitizerComponent ci, unsigned short *whiteLevel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetWhiteLevelValue
			move.l              #$00040039,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetWhiteLevelValue
	ENDIF


; *  VDGetWhiteLevelValue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetWhiteLevelValue(VideoDigitizerComponent ci, unsigned short *whiteLevel)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetWhiteLevelValue
			move.l              #$0004003A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetWhiteLevelValue
	ENDIF


; *  VDGetVideoDefaults()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetVideoDefaults(VideoDigitizerComponent ci, unsigned short *blackLevel, unsigned short *whiteLevel, unsigned short *brightness, unsigned short *hue, unsigned short *saturation, unsigned short *contrast, unsigned short *sharpness)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetVideoDefaults
			move.l              #$001C003B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetVideoDefaults
	ENDIF


; *  VDGetNumberOfInputs()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetNumberOfInputs(VideoDigitizerComponent ci, short *inputs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetNumberOfInputs
			move.l              #$0004003C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetNumberOfInputs
	ENDIF


; *  VDGetInputFormat()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetInputFormat(VideoDigitizerComponent ci, short input, short *format)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetInputFormat
			move.l              #$0006003D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetInputFormat
	ENDIF


; *  VDSetInput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetInput(VideoDigitizerComponent ci, short input)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetInput
			move.l              #$0002003E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetInput
	ENDIF


; *  VDGetInput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetInput(VideoDigitizerComponent ci, short *input)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetInput
			move.l              #$0004003F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetInput
	ENDIF


; *  VDSetInputStandard()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetInputStandard(VideoDigitizerComponent ci, short inputStandard)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetInputStandard
			move.l              #$00020040,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetInputStandard
	ENDIF


; *  VDSetupBuffers()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetupBuffers(VideoDigitizerComponent ci, VdigBufferRecListHandle bufferList)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetupBuffers
			move.l              #$00040041,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetupBuffers
	ENDIF


; *  VDGrabOneFrameAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGrabOneFrameAsync(VideoDigitizerComponent ci, short buffer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGrabOneFrameAsync
			move.l              #$00020042,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGrabOneFrameAsync
	ENDIF


; *  VDDone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDDone(VideoDigitizerComponent ci, short buffer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDDone
			move.l              #$00020043,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDDone
	ENDIF


; *  VDSetCompression()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetCompression(VideoDigitizerComponent ci, OSType compressType, short depth, Rect *bounds, CodecQ spatialQuality, CodecQ temporalQuality, long keyFrameRate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetCompression
			move.l              #$00160044,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetCompression
	ENDIF


; *  VDCompressOneFrameAsync()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDCompressOneFrameAsync(VideoDigitizerComponent ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDCompressOneFrameAsync
			move.l              #$00000045,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDCompressOneFrameAsync
	ENDIF


; *  VDCompressDone()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDCompressDone(VideoDigitizerComponent ci, Boolean *done, Ptr *theData, long *dataSize, UInt8 *similarity, TimeRecord *t)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDCompressDone
			move.l              #$00140046,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDCompressDone
	ENDIF


; *  VDReleaseCompressBuffer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDReleaseCompressBuffer(VideoDigitizerComponent ci, Ptr bufferAddr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDReleaseCompressBuffer
			move.l              #$00040047,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDReleaseCompressBuffer
	ENDIF


; *  VDGetImageDescription()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetImageDescription(VideoDigitizerComponent ci, ImageDescriptionHandle desc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetImageDescription
			move.l              #$00040048,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetImageDescription
	ENDIF


; *  VDResetCompressSequence()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDResetCompressSequence(VideoDigitizerComponent ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDResetCompressSequence
			move.l              #$00000049,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDResetCompressSequence
	ENDIF


; *  VDSetCompressionOnOff()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetCompressionOnOff(VideoDigitizerComponent ci, Boolean state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetCompressionOnOff
			move.l              #$0002004A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetCompressionOnOff
	ENDIF


; *  VDGetCompressionTypes()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetCompressionTypes(VideoDigitizerComponent ci, VDCompressionListHandle h)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetCompressionTypes
			move.l              #$0004004B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetCompressionTypes
	ENDIF


; *  VDSetTimeBase()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetTimeBase(VideoDigitizerComponent ci, TimeBase t)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetTimeBase
			move.l              #$0004004C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetTimeBase
	ENDIF


; *  VDSetFrameRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetFrameRate(VideoDigitizerComponent ci, Fixed framesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetFrameRate
			move.l              #$0004004D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetFrameRate
	ENDIF


; *  VDGetDataRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetDataRate(VideoDigitizerComponent ci, long *milliSecPerFrame, Fixed *framesPerSecond, long *bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetDataRate
			move.l              #$000C004E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetDataRate
	ENDIF


; *  VDGetSoundInputDriver()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetSoundInputDriver(VideoDigitizerComponent ci, Str255 soundDriverName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetSoundInputDriver
			move.l              #$0004004F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetSoundInputDriver
	ENDIF


; *  VDGetDMADepths()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetDMADepths(VideoDigitizerComponent ci, long *depthArray, long *preferredDepth)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetDMADepths
			move.l              #$00080050,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetDMADepths
	ENDIF


; *  VDGetPreferredTimeScale()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetPreferredTimeScale(VideoDigitizerComponent ci, TimeScale *preferred)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetPreferredTimeScale
			move.l              #$00040051,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetPreferredTimeScale
	ENDIF


; *  VDReleaseAsyncBuffers()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDReleaseAsyncBuffers(VideoDigitizerComponent ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDReleaseAsyncBuffers
			move.l              #$00000052,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDReleaseAsyncBuffers
	ENDIF

;  83 is reserved for compatibility reasons 

; *  VDSetDataRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetDataRate(VideoDigitizerComponent ci, long bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetDataRate
			move.l              #$00040054,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetDataRate
	ENDIF


; *  VDGetTimeCode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetTimeCode(VideoDigitizerComponent ci, TimeRecord *atTime, void *timeCodeFormat, void *timeCodeTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetTimeCode
			move.l              #$000C0055,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetTimeCode
	ENDIF


; *  VDUseSafeBuffers()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDUseSafeBuffers(VideoDigitizerComponent ci, Boolean useSafeBuffers)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDUseSafeBuffers
			move.l              #$00020056,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDUseSafeBuffers
	ENDIF


; *  VDGetSoundInputSource()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetSoundInputSource(VideoDigitizerComponent ci, long videoInput, long *soundInput)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetSoundInputSource
			move.l              #$00080057,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetSoundInputSource
	ENDIF


; *  VDGetCompressionTime()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetCompressionTime(VideoDigitizerComponent ci, OSType compressionType, short depth, Rect *srcRect, CodecQ *spatialQuality, CodecQ *temporalQuality, unsigned long *compressTime)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetCompressionTime
			move.l              #$00160058,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetCompressionTime
	ENDIF


; *  VDSetPreferredPacketSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetPreferredPacketSize(VideoDigitizerComponent ci, long preferredPacketSizeInBytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetPreferredPacketSize
			move.l              #$00040059,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetPreferredPacketSize
	ENDIF


; *  VDSetPreferredImageDimensions()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetPreferredImageDimensions(VideoDigitizerComponent ci, long width, long height)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetPreferredImageDimensions
			move.l              #$0008005A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetPreferredImageDimensions
	ENDIF


; *  VDGetPreferredImageDimensions()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetPreferredImageDimensions(VideoDigitizerComponent ci, long *width, long *height)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetPreferredImageDimensions
			move.l              #$0008005B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetPreferredImageDimensions
	ENDIF


; *  VDGetInputName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDGetInputName(VideoDigitizerComponent ci, long videoInput, Str255 name)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDGetInputName
			move.l              #$0008005C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDGetInputName
	ENDIF


; *  VDSetDestinationPort()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.1 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal VideoDigitizerError VDSetDestinationPort(VideoDigitizerComponent ci, CGrafPtr destPort)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_VDSetDestinationPort
			move.l              #$0004005D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION VDSetDestinationPort
	ENDIF




xmlParseComponentType			EQU		'pars'
xmlParseComponentSubType		EQU		'xml '

xmlIdentifierInvalid			EQU		0
xmlIdentifierUnrecognized		EQU		$FFFFFFFF
xmlContentTypeInvalid			EQU		0
xmlContentTypeElement			EQU		1
xmlContentTypeCharData			EQU		2

elementFlagAlwaysSelfContained	EQU		$00000001			;    Element doesn't have contents or closing tag even if it doesn't end with />, as in the HTML <img> tag
elementFlagPreserveWhiteSpace	EQU		$00000002			;  Preserve whitespace in content, default is to remove it 
xmlParseFlagAllowUppercase		EQU		$00000001			;    Entities and attributes do not have to be lowercase (strict XML), but can be upper or mixed case as in HTML
xmlParseFlagAllowUnquotedAttributeValues EQU $00000002		;    Attributes values do not have to be enclosed in quotes (strict XML), but can be left unquoted if they contain no spaces
xmlParseFlagEventParseOnly		EQU		$00000004			;    Do event parsing only

attributeValueKindCharString	EQU		0
attributeValueKindInteger		EQU		$00000001			;    Number
attributeValueKindPercent		EQU		$00000002			;    Number or percent
attributeValueKindBoolean		EQU		$00000004			;    "true" or "false"
attributeValueKindOnOff			EQU		$00000008			;    "on" or "off"
attributeValueKindColor			EQU		$00000010			;    Either "#rrggbb" or a color name
attributeValueKindEnum			EQU		$00000020			;    one of a number of strings; the enum strings are passed as a zero-separated, double-zero-terminated C string in the attributeKindValueInfo param
attributeValueKindCaseSensEnum	EQU		$00000040			;    one of a number of strings; the enum strings are passed as for attributeValueKindEnum, but the values are case-sensitive
MAX_ATTRIBUTE_VALUE_KIND		EQU		$00000040

nameSpaceIDNone					EQU		0
;   A Parsed XML attribute value, one of number/percent, boolean/on-off, color, or enumerated type
XMLAttributeValue		RECORD 0
number					 ds.l	1				; offset: $0 (0)		;     The value when valueKind is attributeValueKindInteger or attributeValueKindPercent
						 ORG 0
boolean					 ds.b	1				; offset: $0 (0)		;     The value when valueKind is attributeValueKindBoolean or attributeValueKindOnOff
						 ORG 0
color					 ds		RGBColor		; offset: $0 (0)		;     The value when valueKind is attributeValueKindColor
						 ORG 0
enumType				 ds.l	1				; offset: $0 (0)		;     The value when valueKind is attributeValueKindEnum
						 ORG 6
sizeof					 EQU *					; size:   $6 (6)
						ENDR
;   An XML attribute-value pair
XMLAttribute			RECORD 0
identifier				 ds.l	1				; offset: $0 (0)		;     Tokenized identifier, if the attribute name was recognized by the parser
name					 ds.l	1				; offset: $4 (4)		;     Attribute name, Only present if identifier == xmlIdentifierUnrecognized
valueKind				 ds.l	1				; offset: $8 (8)		;     Type of parsed value, if the value was recognized and parsed; otherwise, attributeValueKindCharString
value					 ds		XMLAttributeValue ; offset: $C (12)		;     Parsed attribute value
valueStr				 ds.l	1				; offset: $12 (18)		;     Always present
sizeof					 EQU *					; size:   $16 (22)
						ENDR
; typedef struct XMLAttribute *			XMLAttributePtr

;   Forward struct declarations for recursively-defined tree structure


; typedef XMLContent *					XMLContentPtr


;    An XML Element, i.e.
;        <element attr="value" attr="value" ...> [contents] </element>
;    or
;        <element attr="value" attr="value" .../>


XMLElement				RECORD 0
identifier				 ds.l	1				; offset: $0 (0)		;     Tokenized identifier, if the element name was recognized by the parser
name					 ds.l	1				; offset: $4 (4)		;     Element name, only present if identifier == xmlIdentifierUnrecognized
attributes				 ds.l	1				; offset: $8 (8)		;     Array of attributes, terminated with an attribute with identifier == xmlIdentifierInvalid
contents				 ds.l	1				; offset: $C (12)		;     Array of contents, terminated with a content with kind == xmlIdentifierInvalid
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct XMLElement *			XMLElementPtr


;    The content of an XML element is a series of parts, each of which may be either another element
;    or simply character data.


XMLElementContent		RECORD 0
element					 ds		XMLElement		; offset: $0 (0)		;     The contents when the content kind is xmlContentTypeElement
						 ORG 0
charData				 ds.l	1				; offset: $0 (0)		;     The contents when the content kind is xmlContentTypeCharData
						 ORG 16
sizeof					 EQU *					; size:   $10 (16)
						ENDR
XMLContent				RECORD 0
kind					 ds.l	1				; offset: $0 (0)
actualContent			 ds		XMLElementContent ; offset: $4 (4)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
XMLDocRecord			RECORD 0
xmlDataStorage			 ds.l	1				; offset: $0 (0)		;     opaque storage
rootElement				 ds		XMLElement		; offset: $4 (4)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct XMLDocRecord *			XMLDoc

; callback routines for event parsing

; *  XMLParseDataRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseDataRef(ComponentInstance aParser, Handle dataRef, OSType dataRefType, long parseFlags, XMLDoc *document)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseDataRef
			move.l              #$00100001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseDataRef
	ENDIF

;   Parses the XML file pointed to by dataRef, returning a XMLDoc parse tree

; *  XMLParseFile()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseFile(ComponentInstance aParser, ConstFSSpecPtr fileSpec, long parseFlags, XMLDoc *document)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseFile
			move.l              #$000C0002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseFile
	ENDIF

;   Parses the XML file pointed to by fileSpec, returning a XMLDoc parse tree

; *  XMLParseDisposeXMLDoc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseDisposeXMLDoc(ComponentInstance aParser, XMLDoc document)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseDisposeXMLDoc
			move.l              #$00040003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseDisposeXMLDoc
	ENDIF

;   Disposes of a XMLDoc parse tree

; *  XMLParseGetDetailedParseError()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseGetDetailedParseError(ComponentInstance aParser, long *errorLine, StringPtr errDesc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseGetDetailedParseError
			move.l              #$00080004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseGetDetailedParseError
	ENDIF


;    Returns a more detailed description of the error and the line in which it occurred, if a
;    file failed to parse properly.



; *  XMLParseAddElement()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseAddElement(ComponentInstance aParser, char *elementName, UInt32 nameSpaceID, UInt32 *elementID, long elementFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseAddElement
			move.l              #$00100005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseAddElement
	ENDIF


;    Tell the parser of an element to be recognized. The tokenized element unique identifier is
;    passed in *elementID, unless *elementID is zero, whereupon a unique ID is generated and returned.
;    Thus, a valid element identifier can never be zero.



; *  XMLParseAddAttribute()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseAddAttribute(ComponentInstance aParser, UInt32 elementID, UInt32 nameSpaceID, char *attributeName, UInt32 *attributeID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseAddAttribute
			move.l              #$00100006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseAddAttribute
	ENDIF


;    Tells the parser of an attribute for the specified element. The tokenized attribute unique
;    ID is passed in *attributeID, unless *attributeID is zero, whereupon a unique ID is generated and
;    returned. Thus, a valid attribute identifier can never be zero.



; *  XMLParseAddMultipleAttributes()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseAddMultipleAttributes(ComponentInstance aParser, UInt32 elementID, UInt32 *nameSpaceIDs, char *attributeNames, UInt32 *attributeIDs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseAddMultipleAttributes
			move.l              #$00100007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseAddMultipleAttributes
	ENDIF


;    Tells the parser of several attributes for the specified element. The attributes are passed
;    as a zero-delimited, double-zero-terminated C string in attributeNames, and the attribute
;    IDs are passed in on attributeIDs as an array; if any attributeIDs are zero, unique IDs
;    are generated for those and returned



; *  XMLParseAddAttributeAndValue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseAddAttributeAndValue(ComponentInstance aParser, UInt32 elementID, UInt32 nameSpaceID, char *attributeName, UInt32 *attributeID, UInt32 attributeValueKind, void *attributeValueKindInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseAddAttributeAndValue
			move.l              #$00180008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseAddAttributeAndValue
	ENDIF


;    Tells the parser of an attribute, which may have a particular type of value, for the
;    specified element. Params are as in XMLParseAddAttribute, plus all the kinds of values
;    the attribute may have are passed in attributeValueKind, and optional additional information
;    required to tokenize the particular kind of attribute is passed in attributeValueKindInfo



; *  XMLParseAddMultipleAttributesAndValues()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseAddMultipleAttributesAndValues(ComponentInstance aParser, UInt32 elementID, UInt32 *nameSpaceIDs, char *attributeNames, UInt32 *attributeIDs, UInt32 *attributeValueKinds, void **attributeValueKindInfos)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseAddMultipleAttributesAndValues
			move.l              #$00180009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseAddMultipleAttributesAndValues
	ENDIF


;    Tells the parser of several attributes, which may have a particular type of value, for the
;    specified element. Params are as in XMLParseAddMultipleAttributes, plus all the kinds of values
;    the attributes may have are passed in attributeValueKinds, and optional additional information
;    required to tokenize the particular kind of attributes is passed in attributeValueKindInfos



; *  XMLParseAddAttributeValueKind()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseAddAttributeValueKind(ComponentInstance aParser, UInt32 elementID, UInt32 attributeID, UInt32 attributeValueKind, void *attributeValueKindInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseAddAttributeValueKind
			move.l              #$0010000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseAddAttributeValueKind
	ENDIF


;    Tells the parser that the particular attribute may have an additional kind of
;    value, as specified by attributeValueKind and attributeValueKindInfo



; *  XMLParseAddNameSpace()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseAddNameSpace(ComponentInstance aParser, char *nameSpaceURL, UInt32 *nameSpaceID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseAddNameSpace
			move.l              #$0008000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseAddNameSpace
	ENDIF


;    Tell the parser of a namespace to be recognized. The tokenized namespace unique identifier is
;    passed in *nameSpaceID, unless *nameSpaceID is zero, whereupon a unique ID is generated and returned.
;    Thus, a valid nameSpaceID identifier can never be zero.



; *  XMLParseSetOffsetAndLimit()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseSetOffsetAndLimit(ComponentInstance aParser, UInt32 offset, UInt32 limit)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseSetOffsetAndLimit
			move.l              #$0008000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseSetOffsetAndLimit
	ENDIF

;   Specifies the offset and limit for reading from the dataref to be used when parsing

; *  XMLParseSetEventParseRefCon()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseSetEventParseRefCon(ComponentInstance aParser, long refcon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseSetEventParseRefCon
			move.l              #$0004000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseSetEventParseRefCon
	ENDIF

;   Set the event parse refcon

; *  XMLParseSetStartDocumentHandler()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseSetStartDocumentHandler(ComponentInstance aParser, StartDocumentHandlerUPP startDocument)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseSetStartDocumentHandler
			move.l              #$0004000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseSetStartDocumentHandler
	ENDIF

;   Set the start document handler UPP for event parsing

; *  XMLParseSetEndDocumentHandler()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseSetEndDocumentHandler(ComponentInstance aParser, EndDocumentHandlerUPP endDocument)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseSetEndDocumentHandler
			move.l              #$0004000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseSetEndDocumentHandler
	ENDIF

;   Set the end document handler UPP for event parsing

; *  XMLParseSetStartElementHandler()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseSetStartElementHandler(ComponentInstance aParser, StartElementHandlerUPP startElement)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseSetStartElementHandler
			move.l              #$00040010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseSetStartElementHandler
	ENDIF

;   Set the start element handler UPP for event parsing

; *  XMLParseSetEndElementHandler()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseSetEndElementHandler(ComponentInstance aParser, EndElementHandlerUPP endElement)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseSetEndElementHandler
			move.l              #$00040011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseSetEndElementHandler
	ENDIF

;   Set the end element handler UPP for event parsing

; *  XMLParseSetCharDataHandler()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseSetCharDataHandler(ComponentInstance aParser, CharDataHandlerUPP charData)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseSetCharDataHandler
			move.l              #$00040012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseSetCharDataHandler
	ENDIF

;   Set the character data handler UPP for event parsing

; *  XMLParseSetPreprocessInstructionHandler()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseSetPreprocessInstructionHandler(ComponentInstance aParser, PreprocessInstructionHandlerUPP preprocessInstruction)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseSetPreprocessInstructionHandler
			move.l              #$00040013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseSetPreprocessInstructionHandler
	ENDIF

;   Set the preprocess instruction handler UPP for event parsing

; *  XMLParseSetCommentHandler()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult XMLParseSetCommentHandler(ComponentInstance aParser, CommentHandlerUPP comment)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_XMLParseSetCommentHandler
			move.l              #$00040014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION XMLParseSetCommentHandler
	ENDIF

;   Set the comment handler UPP for event parsing
; 
;    Helper Macros
;    
;        These macros allow you to easily add entities and attributes to the parser
;        in an error free manner when the identifiers are defined in a particular manner.
;        For these to work, you must define the identifiers as follows:
;        
;        For entities, they must be defined as element_elementName, as in:
;        
;            enum
;            {
;                element_xml =   1,      //  "xml"
;                element_head,           //  "head"
;                element_body            //  "body"
;            };
;            
;        If the element name has characters that are illegal in an identifier,
;        some of the macros support that, but the identifier must not contain
;        the illegal characters:
;        
;            enum
;            {
;                element_rootlayout      //  "root-layout"
;            }
;            
;        For attribute names, similar rules apply except that they must be defined
;        as attr_attributeName, as in:
;            
;            enum
;            {
;                attr_src    =   1,      //  "src"
;                attr_href,
;                attr_width,
;                attr_height
;            }
;            
;        Finally, the existence of local variables elementID and attributeID is required.
;


;    Adds the specified element to the parser, i.e. XML_ADD_ELEMENT(head) adds the element "head" with
;    a unique identifier of element_head



;    Adds the specified element to the parser, not using the same string to generate the identifier and
;    the element name. Use for element names that contain characters which are illegal in identifiers,
;    i.e XML_ADD_COMPLEX_ELEMENT("root-layout",rootlayout) adds the element "root-layout" with a unique
;    identifier of element_rootlayout



;    Adds the specified attribute to the current element in the parser, i.e. XML_ADD_ATTRIBUTE(src)
;    adds the attribute "src" to the current element, and identifies it by attr_src



;    Adds the specified attribute to the current element in the parser, i.e. XML_ADD_ATTRIBUTE(element_img, src)
;    adds the attribute "src" to the element_img element, and identifies it by attr_src
;    Adds the specified attribute to the current element in the parser, not using the same string to
;    generate the identifier and the element name. Use for attribute names that contain characters which
;    are illegal in identifiers, i.e XML_ADD_COMPLEX_ATTRIBUTE("http-equiv",httpequiv) adds the element
;    "http-equiv" with a unique identifier of attr_httpequiv




; 
;    General Sequence Grab stuff
;

; typedef ComponentInstance 			SeqGrabComponent

; typedef ComponentInstance 			SGChannel


SeqGrabComponentType			EQU		'barg'
SeqGrabChannelType				EQU		'sgch'
SeqGrabPanelType				EQU		'sgpn'
SeqGrabCompressionPanelType		EQU		'cmpr'
SeqGrabSourcePanelType			EQU		'sour'

seqGrabToDisk					EQU		1
seqGrabToMemory					EQU		2
seqGrabDontUseTempMemory		EQU		4
seqGrabAppendToFile				EQU		8
seqGrabDontAddMovieResource		EQU		16
seqGrabDontMakeMovie			EQU		32
seqGrabPreExtendFile			EQU		64
seqGrabDataProcIsInterruptSafe	EQU		128
seqGrabDataProcDoesOverlappingReads EQU	256
; typedef unsigned long 				SeqGrabDataOutputEnum


seqGrabRecord					EQU		1
seqGrabPreview					EQU		2
seqGrabPlayDuringRecord			EQU		4
; typedef unsigned long 				SeqGrabUsageEnum


seqGrabHasBounds				EQU		1
seqGrabHasVolume				EQU		2
seqGrabHasDiscreteSamples		EQU		4
seqGrabDoNotBufferizeData		EQU		8
seqGrabCanMoveWindowWhileRecording EQU	16
; typedef unsigned long 				SeqGrabChannelInfoEnum

SGOutputRecord			RECORD 0
data					 ds.l	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct SGOutputRecord *		SGOutput

SeqGrabFrameInfo		RECORD 0
frameOffset				 ds.l	1				; offset: $0 (0)
frameTime				 ds.l	1				; offset: $4 (4)
frameSize				 ds.l	1				; offset: $8 (8)
frameChannel			 ds.l	1				; offset: $C (12)
frameRefCon				 ds.l	1				; offset: $10 (16)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct SeqGrabFrameInfo *		SeqGrabFrameInfoPtr

SeqGrabExtendedFrameInfo RECORD 0
frameOffset				 ds		wide			; offset: $0 (0)
frameTime				 ds.l	1				; offset: $8 (8)
frameSize				 ds.l	1				; offset: $C (12)
frameChannel			 ds.l	1				; offset: $10 (16)
frameRefCon				 ds.l	1				; offset: $14 (20)
frameOutput				 ds.l	1				; offset: $18 (24)
sizeof					 EQU *					; size:   $1C (28)
						ENDR
; typedef struct SeqGrabExtendedFrameInfo * SeqGrabExtendedFrameInfoPtr


grabPictOffScreen				EQU		1
grabPictIgnoreClip				EQU		2
grabPictCurrentImage			EQU		4

sgFlagControlledGrab			EQU		$01
sgFlagAllowNonRGBPixMaps		EQU		$02
SGDeviceName			RECORD 0
name					 ds		Str63			; offset: $0 (0)
icon					 ds.l	1				; offset: $40 (64)
flags					 ds.l	1				; offset: $44 (68)
refCon					 ds.l	1				; offset: $48 (72)
reserved				 ds.l	1				; offset: $4C (76)		;  zero
sizeof					 EQU *					; size:   $50 (80)
						ENDR

sgDeviceNameFlagDeviceUnavailable EQU	$01
SGDeviceListRecord		RECORD 0
count					 ds.w	1				; offset: $0 (0)
selectedIndex			 ds.w	1				; offset: $2 (2)
reserved				 ds.l	1				; offset: $4 (4)		;  zero
entry					 ds		SGDeviceName	; offset: $8 (8) <-- really an array of length one
sizeof					 EQU *					; size:   $58 (88)
						ENDR
; typedef struct SGDeviceListRecord *	SGDeviceListPtr

; typedef SGDeviceListPtr *				SGDeviceList


sgDeviceListWithIcons			EQU		$01
sgDeviceListDontCheckAvailability EQU	$02

seqGrabWriteAppend				EQU		0
seqGrabWriteReserve				EQU		1
seqGrabWriteFill				EQU		2

seqGrabUnpause					EQU		0
seqGrabPause					EQU		1
seqGrabPauseForMenu				EQU		3

channelFlagDontOpenResFile		EQU		2
channelFlagHasDependency		EQU		4

sgPanelFlagForPanel				EQU		1

seqGrabSettingsPreviewOnly		EQU		1

channelPlayNormal				EQU		0
channelPlayFast					EQU		1
channelPlayHighQuality			EQU		2
channelPlayAllData				EQU		4


; *  SGInitialize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGInitialize(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGInitialize
			move.l              #$00000001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGInitialize
	ENDIF


; *  SGSetDataOutput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetDataOutput(SeqGrabComponent s, const FSSpec *movieFile, long whereFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetDataOutput
			move.l              #$00080002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetDataOutput
	ENDIF


; *  SGGetDataOutput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetDataOutput(SeqGrabComponent s, FSSpec *movieFile, long *whereFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetDataOutput
			move.l              #$00080003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetDataOutput
	ENDIF


; *  SGSetGWorld()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetGWorld(SeqGrabComponent s, CGrafPtr gp, GDHandle gd)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetGWorld
			move.l              #$00080004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetGWorld
	ENDIF


; *  SGGetGWorld()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetGWorld(SeqGrabComponent s, CGrafPtr *gp, GDHandle *gd)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetGWorld
			move.l              #$00080005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetGWorld
	ENDIF


; *  SGNewChannel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGNewChannel(SeqGrabComponent s, OSType channelType, SGChannel *ref)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGNewChannel
			move.l              #$00080006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGNewChannel
	ENDIF


; *  SGDisposeChannel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGDisposeChannel(SeqGrabComponent s, SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGDisposeChannel
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGDisposeChannel
	ENDIF


; *  SGStartPreview()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGStartPreview(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGStartPreview
			move.l              #$00000010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGStartPreview
	ENDIF


; *  SGStartRecord()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGStartRecord(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGStartRecord
			move.l              #$00000011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGStartRecord
	ENDIF


; *  SGIdle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGIdle(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGIdle
			move.l              #$00000012,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGIdle
	ENDIF


; *  SGStop()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGStop(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGStop
			move.l              #$00000013,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGStop
	ENDIF


; *  SGPause()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPause(SeqGrabComponent s, Byte pause)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPause
			move.l              #$00020014,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPause
	ENDIF


; *  SGPrepare()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPrepare(SeqGrabComponent s, Boolean prepareForPreview, Boolean prepareForRecord)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPrepare
			move.l              #$00040015,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPrepare
	ENDIF


; *  SGRelease()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGRelease(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGRelease
			move.l              #$00000016,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGRelease
	ENDIF


; *  SGGetMovie()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal Movie SGGetMovie(SeqGrabComponent s)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetMovie
			move.l              #$00000017,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetMovie
	ENDIF


; *  SGSetMaximumRecordTime()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetMaximumRecordTime(SeqGrabComponent s, unsigned long ticks)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetMaximumRecordTime
			move.l              #$00040018,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetMaximumRecordTime
	ENDIF


; *  SGGetMaximumRecordTime()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetMaximumRecordTime(SeqGrabComponent s, unsigned long *ticks)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetMaximumRecordTime
			move.l              #$00040019,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetMaximumRecordTime
	ENDIF


; *  SGGetStorageSpaceRemaining()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetStorageSpaceRemaining(SeqGrabComponent s, unsigned long *bytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetStorageSpaceRemaining
			move.l              #$0004001A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetStorageSpaceRemaining
	ENDIF


; *  SGGetTimeRemaining()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetTimeRemaining(SeqGrabComponent s, long *ticksLeft)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetTimeRemaining
			move.l              #$0004001B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetTimeRemaining
	ENDIF


; *  SGGrabPict()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGrabPict(SeqGrabComponent s, PicHandle *p, const Rect *bounds, short offscreenDepth, long grabPictFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGrabPict
			move.l              #$000E001C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGrabPict
	ENDIF


; *  SGGetLastMovieResID()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetLastMovieResID(SeqGrabComponent s, short *resID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetLastMovieResID
			move.l              #$0004001D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetLastMovieResID
	ENDIF


; *  SGSetFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetFlags(SeqGrabComponent s, long sgFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetFlags
			move.l              #$0004001E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetFlags
	ENDIF


; *  SGGetFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetFlags(SeqGrabComponent s, long *sgFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetFlags
			move.l              #$0004001F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetFlags
	ENDIF


; *  SGSetDataProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetDataProc(SeqGrabComponent s, SGDataUPP proc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetDataProc
			move.l              #$00080020,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetDataProc
	ENDIF


; *  SGNewChannelFromComponent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGNewChannelFromComponent(SeqGrabComponent s, SGChannel *newChannel, Component sgChannelComponent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGNewChannelFromComponent
			move.l              #$00080021,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGNewChannelFromComponent
	ENDIF


; *  SGDisposeDeviceList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGDisposeDeviceList(SeqGrabComponent s, SGDeviceList list)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGDisposeDeviceList
			move.l              #$00040022,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGDisposeDeviceList
	ENDIF


; *  SGAppendDeviceListToMenu()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGAppendDeviceListToMenu(SeqGrabComponent s, SGDeviceList list, MenuRef mh)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAppendDeviceListToMenu
			move.l              #$00080023,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAppendDeviceListToMenu
	ENDIF


; *  SGSetSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetSettings(SeqGrabComponent s, UserData ud, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetSettings
			move.l              #$00080024,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetSettings
	ENDIF


; *  SGGetSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetSettings(SeqGrabComponent s, UserData *ud, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetSettings
			move.l              #$00080025,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetSettings
	ENDIF


; *  SGGetIndChannel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetIndChannel(SeqGrabComponent s, short index, SGChannel *ref, OSType *chanType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetIndChannel
			move.l              #$000A0026,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetIndChannel
	ENDIF


; *  SGUpdate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGUpdate(SeqGrabComponent s, RgnHandle updateRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGUpdate
			move.l              #$00040027,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGUpdate
	ENDIF


; *  SGGetPause()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetPause(SeqGrabComponent s, Byte *paused)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetPause
			move.l              #$00040028,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetPause
	ENDIF

; typedef const Component *				ConstComponentListPtr


; *  SGSettingsDialog()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSettingsDialog(SeqGrabComponent s, SGChannel c, short numPanels, ConstComponentListPtr panelList, long flags, SGModalFilterUPP proc, long procRefNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSettingsDialog
			move.l              #$00160029,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSettingsDialog
	ENDIF


; *  SGGetAlignmentProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetAlignmentProc(SeqGrabComponent s, ICMAlignmentProcRecordPtr alignmentProc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetAlignmentProc
			move.l              #$0004002A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetAlignmentProc
	ENDIF


; *  SGSetChannelSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetChannelSettings(SeqGrabComponent s, SGChannel c, UserData ud, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelSettings
			move.l              #$000C002B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelSettings
	ENDIF


; *  SGGetChannelSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetChannelSettings(SeqGrabComponent s, SGChannel c, UserData *ud, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelSettings
			move.l              #$000C002C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelSettings
	ENDIF


; *  SGGetMode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetMode(SeqGrabComponent s, Boolean *previewMode, Boolean *recordMode)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetMode
			move.l              #$0008002D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetMode
	ENDIF


; *  SGSetDataRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetDataRef(SeqGrabComponent s, Handle dataRef, OSType dataRefType, long whereFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetDataRef
			move.l              #$000C002E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetDataRef
	ENDIF


; *  SGGetDataRef()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetDataRef(SeqGrabComponent s, Handle *dataRef, OSType *dataRefType, long *whereFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetDataRef
			move.l              #$000C002F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetDataRef
	ENDIF


; *  SGNewOutput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGNewOutput(SeqGrabComponent s, Handle dataRef, OSType dataRefType, long whereFlags, SGOutput *sgOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGNewOutput
			move.l              #$00100030,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGNewOutput
	ENDIF


; *  SGDisposeOutput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGDisposeOutput(SeqGrabComponent s, SGOutput sgOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGDisposeOutput
			move.l              #$00040031,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGDisposeOutput
	ENDIF


; *  SGSetOutputFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetOutputFlags(SeqGrabComponent s, SGOutput sgOut, long whereFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetOutputFlags
			move.l              #$00080032,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetOutputFlags
	ENDIF


; *  SGSetChannelOutput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetChannelOutput(SeqGrabComponent s, SGChannel c, SGOutput sgOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelOutput
			move.l              #$00080033,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelOutput
	ENDIF


; *  SGGetDataOutputStorageSpaceRemaining()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetDataOutputStorageSpaceRemaining(SeqGrabComponent s, SGOutput sgOut, unsigned long *space)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetDataOutputStorageSpaceRemaining
			move.l              #$00080034,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetDataOutputStorageSpaceRemaining
	ENDIF


; *  SGHandleUpdateEvent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGHandleUpdateEvent(SeqGrabComponent s, const EventRecord *event, Boolean *handled)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGHandleUpdateEvent
			move.l              #$00080035,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGHandleUpdateEvent
	ENDIF


; *  SGSetOutputNextOutput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetOutputNextOutput(SeqGrabComponent s, SGOutput sgOut, SGOutput nextOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetOutputNextOutput
			move.l              #$00080036,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetOutputNextOutput
	ENDIF


; *  SGGetOutputNextOutput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetOutputNextOutput(SeqGrabComponent s, SGOutput sgOut, SGOutput *nextOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetOutputNextOutput
			move.l              #$00080037,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetOutputNextOutput
	ENDIF


; *  SGSetOutputMaximumOffset()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetOutputMaximumOffset(SeqGrabComponent s, SGOutput sgOut, const wide *maxOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetOutputMaximumOffset
			move.l              #$00080038,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetOutputMaximumOffset
	ENDIF


; *  SGGetOutputMaximumOffset()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetOutputMaximumOffset(SeqGrabComponent s, SGOutput sgOut, wide *maxOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetOutputMaximumOffset
			move.l              #$00080039,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetOutputMaximumOffset
	ENDIF


; *  SGGetOutputDataReference()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetOutputDataReference(SeqGrabComponent s, SGOutput sgOut, Handle *dataRef, OSType *dataRefType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetOutputDataReference
			move.l              #$000C003A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetOutputDataReference
	ENDIF


; *  SGWriteExtendedMovieData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGWriteExtendedMovieData(SeqGrabComponent s, SGChannel c, Ptr p, long len, wide *offset, SGOutput *sgOut)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGWriteExtendedMovieData
			move.l              #$0014003B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGWriteExtendedMovieData
	ENDIF


; *  SGGetStorageSpaceRemaining64()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult SGGetStorageSpaceRemaining64(SeqGrabComponent s, wide *bytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetStorageSpaceRemaining64
			move.l              #$0004003C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetStorageSpaceRemaining64
	ENDIF


; *  SGGetDataOutputStorageSpaceRemaining64()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult SGGetDataOutputStorageSpaceRemaining64(SeqGrabComponent s, SGOutput sgOut, wide *space)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetDataOutputStorageSpaceRemaining64
			move.l              #$0008003D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetDataOutputStorageSpaceRemaining64
	ENDIF

; 
;    calls from Channel to seqGrab
;


; *  SGWriteMovieData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGWriteMovieData(SeqGrabComponent s, SGChannel c, Ptr p, long len, long *offset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGWriteMovieData
			move.l              #$00100100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGWriteMovieData
	ENDIF


; *  SGAddFrameReference()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGAddFrameReference(SeqGrabComponent s, SeqGrabFrameInfoPtr frameInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAddFrameReference
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAddFrameReference
	ENDIF


; *  SGGetNextFrameReference()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetNextFrameReference(SeqGrabComponent s, SeqGrabFrameInfoPtr frameInfo, TimeValue *frameDuration, long *frameNumber)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetNextFrameReference
			move.l              #$000C0102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetNextFrameReference
	ENDIF


; *  SGGetTimeBase()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetTimeBase(SeqGrabComponent s, TimeBase *tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetTimeBase
			move.l              #$00040103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetTimeBase
	ENDIF


; *  SGSortDeviceList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSortDeviceList(SeqGrabComponent s, SGDeviceList list)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSortDeviceList
			move.l              #$00040104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSortDeviceList
	ENDIF


; *  SGAddMovieData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGAddMovieData(SeqGrabComponent s, SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAddMovieData
			move.l              #$001A0105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAddMovieData
	ENDIF


; *  SGChangedSource()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGChangedSource(SeqGrabComponent s, SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChangedSource
			move.l              #$00040106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChangedSource
	ENDIF


; *  SGAddExtendedFrameReference()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGAddExtendedFrameReference(SeqGrabComponent s, SeqGrabExtendedFrameInfoPtr frameInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAddExtendedFrameReference
			move.l              #$00040107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAddExtendedFrameReference
	ENDIF


; *  SGGetNextExtendedFrameReference()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetNextExtendedFrameReference(SeqGrabComponent s, SeqGrabExtendedFrameInfoPtr frameInfo, TimeValue *frameDuration, long *frameNumber)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetNextExtendedFrameReference
			move.l              #$000C0108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetNextExtendedFrameReference
	ENDIF


; *  SGAddExtendedMovieData()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGAddExtendedMovieData(SeqGrabComponent s, SGChannel c, Ptr p, long len, wide *offset, long chRefCon, TimeValue time, short writeType, SGOutput *whichOutput)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAddExtendedMovieData
			move.l              #$001E0109,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAddExtendedMovieData
	ENDIF


; *  SGAddOutputDataRefToMedia()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGAddOutputDataRefToMedia(SeqGrabComponent s, SGOutput sgOut, Media theMedia, SampleDescriptionHandle desc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAddOutputDataRefToMedia
			move.l              #$000C010A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAddOutputDataRefToMedia
	ENDIF



; ** Sequence Grab CHANNEL Component Stuff **


; *  SGSetChannelUsage()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetChannelUsage(SGChannel c, long usage)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelUsage
			move.l              #$00040080,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelUsage
	ENDIF


; *  SGGetChannelUsage()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetChannelUsage(SGChannel c, long *usage)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelUsage
			move.l              #$00040081,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelUsage
	ENDIF


; *  SGSetChannelBounds()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetChannelBounds(SGChannel c, const Rect *bounds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelBounds
			move.l              #$00040082,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelBounds
	ENDIF


; *  SGGetChannelBounds()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetChannelBounds(SGChannel c, Rect *bounds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelBounds
			move.l              #$00040083,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelBounds
	ENDIF


; *  SGSetChannelVolume()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetChannelVolume(SGChannel c, short volume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelVolume
			move.l              #$00020084,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelVolume
	ENDIF


; *  SGGetChannelVolume()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetChannelVolume(SGChannel c, short *volume)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelVolume
			move.l              #$00040085,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelVolume
	ENDIF


; *  SGGetChannelInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetChannelInfo(SGChannel c, long *channelInfo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelInfo
			move.l              #$00040086,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelInfo
	ENDIF


; *  SGSetChannelPlayFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetChannelPlayFlags(SGChannel c, long playFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelPlayFlags
			move.l              #$00040087,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelPlayFlags
	ENDIF


; *  SGGetChannelPlayFlags()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetChannelPlayFlags(SGChannel c, long *playFlags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelPlayFlags
			move.l              #$00040088,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelPlayFlags
	ENDIF


; *  SGSetChannelMaxFrames()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetChannelMaxFrames(SGChannel c, long frameCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelMaxFrames
			move.l              #$00040089,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelMaxFrames
	ENDIF


; *  SGGetChannelMaxFrames()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetChannelMaxFrames(SGChannel c, long *frameCount)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelMaxFrames
			move.l              #$0004008A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelMaxFrames
	ENDIF


; *  SGSetChannelRefCon()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetChannelRefCon(SGChannel c, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelRefCon
			move.l              #$0004008B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelRefCon
	ENDIF


; *  SGSetChannelClip()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetChannelClip(SGChannel c, RgnHandle theClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelClip
			move.l              #$0004008C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelClip
	ENDIF


; *  SGGetChannelClip()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetChannelClip(SGChannel c, RgnHandle *theClip)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelClip
			move.l              #$0004008D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelClip
	ENDIF


; *  SGGetChannelSampleDescription()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetChannelSampleDescription(SGChannel c, Handle sampleDesc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelSampleDescription
			move.l              #$0004008E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelSampleDescription
	ENDIF


; *  SGGetChannelDeviceList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetChannelDeviceList(SGChannel c, long selectionFlags, SGDeviceList *list)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelDeviceList
			move.l              #$0008008F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelDeviceList
	ENDIF


; *  SGSetChannelDevice()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetChannelDevice(SGChannel c, StringPtr name)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelDevice
			move.l              #$00040090,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelDevice
	ENDIF


; *  SGSetChannelMatrix()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetChannelMatrix(SGChannel c, const MatrixRecord *m)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetChannelMatrix
			move.l              #$00040091,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetChannelMatrix
	ENDIF


; *  SGGetChannelMatrix()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetChannelMatrix(SGChannel c, MatrixRecord *m)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelMatrix
			move.l              #$00040092,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelMatrix
	ENDIF


; *  SGGetChannelTimeScale()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetChannelTimeScale(SGChannel c, TimeScale *scale)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelTimeScale
			move.l              #$00040093,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelTimeScale
	ENDIF


; *  SGChannelPutPicture()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGChannelPutPicture(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelPutPicture
			move.l              #$00000094,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelPutPicture
	ENDIF


; *  SGChannelSetRequestedDataRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGChannelSetRequestedDataRate(SGChannel c, long bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelSetRequestedDataRate
			move.l              #$00040095,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelSetRequestedDataRate
	ENDIF


; *  SGChannelGetRequestedDataRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGChannelGetRequestedDataRate(SGChannel c, long *bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelGetRequestedDataRate
			move.l              #$00040096,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelGetRequestedDataRate
	ENDIF


; *  SGChannelSetDataSourceName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGChannelSetDataSourceName(SGChannel c, ConstStr255Param name, ScriptCode scriptTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelSetDataSourceName
			move.l              #$00060097,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelSetDataSourceName
	ENDIF


; *  SGChannelGetDataSourceName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGChannelGetDataSourceName(SGChannel c, Str255 name, ScriptCode *scriptTag)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelGetDataSourceName
			move.l              #$00080098,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelGetDataSourceName
	ENDIF


; *  SGChannelSetCodecSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult SGChannelSetCodecSettings(SGChannel c, Handle settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelSetCodecSettings
			move.l              #$00040099,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelSetCodecSettings
	ENDIF


; *  SGChannelGetCodecSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult SGChannelGetCodecSettings(SGChannel c, Handle *settings)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGChannelGetCodecSettings
			move.l              #$0004009A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGChannelGetCodecSettings
	ENDIF


; *  SGGetChannelTimeBase()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 4.0 and later
; *    CarbonLib:        in CarbonLib 1.0.2 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 4.0 and later
; 

;
; pascal ComponentResult SGGetChannelTimeBase(SGChannel c, TimeBase *tb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetChannelTimeBase
			move.l              #$0004009B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetChannelTimeBase
	ENDIF

; 
;    calls from seqGrab to Channel
;


; *  SGInitChannel()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGInitChannel(SGChannel c, SeqGrabComponent owner)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGInitChannel
			move.l              #$00040180,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGInitChannel
	ENDIF


; *  SGWriteSamples()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGWriteSamples(SGChannel c, Movie m, AliasHandle theFile)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGWriteSamples
			move.l              #$00080181,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGWriteSamples
	ENDIF


; *  SGGetDataRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetDataRate(SGChannel c, long *bytesPerSecond)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetDataRate
			move.l              #$00040182,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetDataRate
	ENDIF


; *  SGAlignChannelRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGAlignChannelRect(SGChannel c, Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAlignChannelRect
			move.l              #$00040183,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAlignChannelRect
	ENDIF

; 
;    Dorky dialog panel calls
;


; *  SGPanelGetDitl()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelGetDitl(SeqGrabComponent s, Handle *ditl)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelGetDitl
			move.l              #$00040200,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelGetDitl
	ENDIF


; *  SGPanelGetTitle()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelGetTitle(SeqGrabComponent s, Str255 title)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelGetTitle
			move.l              #$00040201,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelGetTitle
	ENDIF


; *  SGPanelCanRun()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelCanRun(SeqGrabComponent s, SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelCanRun
			move.l              #$00040202,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelCanRun
	ENDIF


; *  SGPanelInstall()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelInstall(SeqGrabComponent s, SGChannel c, DialogRef d, short itemOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelInstall
			move.l              #$000A0203,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelInstall
	ENDIF


; *  SGPanelEvent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelEvent(SeqGrabComponent s, SGChannel c, DialogRef d, short itemOffset, const EventRecord *theEvent, short *itemHit, Boolean *handled)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelEvent
			move.l              #$00160204,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelEvent
	ENDIF


; *  SGPanelItem()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelItem(SeqGrabComponent s, SGChannel c, DialogRef d, short itemOffset, short itemNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelItem
			move.l              #$000C0205,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelItem
	ENDIF


; *  SGPanelRemove()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelRemove(SeqGrabComponent s, SGChannel c, DialogRef d, short itemOffset)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelRemove
			move.l              #$000A0206,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelRemove
	ENDIF


; *  SGPanelSetGrabber()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelSetGrabber(SeqGrabComponent s, SeqGrabComponent sg)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelSetGrabber
			move.l              #$00040207,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelSetGrabber
	ENDIF


; *  SGPanelSetResFile()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelSetResFile(SeqGrabComponent s, short resRef)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelSetResFile
			move.l              #$00020208,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelSetResFile
	ENDIF


; *  SGPanelGetSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelGetSettings(SeqGrabComponent s, SGChannel c, UserData *ud, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelGetSettings
			move.l              #$000C0209,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelGetSettings
	ENDIF


; *  SGPanelSetSettings()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelSetSettings(SeqGrabComponent s, SGChannel c, UserData ud, long flags)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelSetSettings
			move.l              #$000C020A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelSetSettings
	ENDIF


; *  SGPanelValidateInput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelValidateInput(SeqGrabComponent s, Boolean *ok)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelValidateInput
			move.l              #$0004020B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelValidateInput
	ENDIF


; *  SGPanelSetEventFilter()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGPanelSetEventFilter(SeqGrabComponent s, SGModalFilterUPP proc, long refCon)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGPanelSetEventFilter
			move.l              #$0008020C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGPanelSetEventFilter
	ENDIF


; ** Sequence Grab VIDEO CHANNEL Component Stuff **
; 
;    Video stuff
;

SGCompressInfo			RECORD 0
buffer					 ds.l	1				; offset: $0 (0)
bufferSize				 ds.l	1				; offset: $4 (4)
similarity				 ds.b	1				; offset: $8 (8)
reserved				 ds.b	1				; offset: $9 (9)
sizeof					 EQU *					; size:   $A (10)
						ENDR
VideoBottles			RECORD 0
procCount				 ds.w	1				; offset: $0 (0)
grabProc				 ds.l	1				; offset: $2 (2)
grabCompleteProc		 ds.l	1				; offset: $6 (6)
displayProc				 ds.l	1				; offset: $A (10)
compressProc			 ds.l	1				; offset: $E (14)
compressCompleteProc	 ds.l	1				; offset: $12 (18)
addFrameProc			 ds.l	1				; offset: $16 (22)
transferFrameProc		 ds.l	1				; offset: $1A (26)
grabCompressCompleteProc  ds.l	1				; offset: $1E (30)
displayCompressProc		 ds.l	1				; offset: $22 (34)
sizeof					 EQU *					; size:   $26 (38)
						ENDR

; *  SGGetSrcVideoBounds()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetSrcVideoBounds(SGChannel c, Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetSrcVideoBounds
			move.l              #$00040100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetSrcVideoBounds
	ENDIF


; *  SGSetVideoRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetVideoRect(SGChannel c, const Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetVideoRect
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetVideoRect
	ENDIF


; *  SGGetVideoRect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetVideoRect(SGChannel c, Rect *r)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetVideoRect
			move.l              #$00040102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetVideoRect
	ENDIF


; *  SGGetVideoCompressorType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetVideoCompressorType(SGChannel c, OSType *compressorType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetVideoCompressorType
			move.l              #$00040103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetVideoCompressorType
	ENDIF


; *  SGSetVideoCompressorType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetVideoCompressorType(SGChannel c, OSType compressorType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetVideoCompressorType
			move.l              #$00040104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetVideoCompressorType
	ENDIF


; *  SGSetVideoCompressor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetVideoCompressor(SGChannel c, short depth, CompressorComponent compressor, CodecQ spatialQuality, CodecQ temporalQuality, long keyFrameRate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetVideoCompressor
			move.l              #$00120105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetVideoCompressor
	ENDIF


; *  SGGetVideoCompressor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetVideoCompressor(SGChannel c, short *depth, CompressorComponent *compressor, CodecQ *spatialQuality, CodecQ *temporalQuality, long *keyFrameRate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetVideoCompressor
			move.l              #$00140106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetVideoCompressor
	ENDIF


; *  SGGetVideoDigitizerComponent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentInstance SGGetVideoDigitizerComponent(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetVideoDigitizerComponent
			move.l              #$00000107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetVideoDigitizerComponent
	ENDIF


; *  SGSetVideoDigitizerComponent()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetVideoDigitizerComponent(SGChannel c, ComponentInstance vdig)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetVideoDigitizerComponent
			move.l              #$00040108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetVideoDigitizerComponent
	ENDIF


; *  SGVideoDigitizerChanged()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGVideoDigitizerChanged(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGVideoDigitizerChanged
			move.l              #$00000109,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGVideoDigitizerChanged
	ENDIF


; *  SGSetVideoBottlenecks()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetVideoBottlenecks(SGChannel c, VideoBottles *vb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetVideoBottlenecks
			move.l              #$0004010A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetVideoBottlenecks
	ENDIF


; *  SGGetVideoBottlenecks()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetVideoBottlenecks(SGChannel c, VideoBottles *vb)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetVideoBottlenecks
			move.l              #$0004010B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetVideoBottlenecks
	ENDIF


; *  SGGrabFrame()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGrabFrame(SGChannel c, short bufferNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGrabFrame
			move.l              #$0002010C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGrabFrame
	ENDIF


; *  SGGrabFrameComplete()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGrabFrameComplete(SGChannel c, short bufferNum, Boolean *done)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGrabFrameComplete
			move.l              #$0006010D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGrabFrameComplete
	ENDIF


; *  SGDisplayFrame()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGDisplayFrame(SGChannel c, short bufferNum, const MatrixRecord *mp, RgnHandle clipRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGDisplayFrame
			move.l              #$000A010E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGDisplayFrame
	ENDIF


; *  SGCompressFrame()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGCompressFrame(SGChannel c, short bufferNum)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGCompressFrame
			move.l              #$0002010F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGCompressFrame
	ENDIF


; *  SGCompressFrameComplete()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGCompressFrameComplete(SGChannel c, short bufferNum, Boolean *done, SGCompressInfo *ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGCompressFrameComplete
			move.l              #$000A0110,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGCompressFrameComplete
	ENDIF


; *  SGAddFrame()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGAddFrame(SGChannel c, short bufferNum, TimeValue atTime, TimeScale scale, const SGCompressInfo *ci)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGAddFrame
			move.l              #$000E0111,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGAddFrame
	ENDIF


; *  SGTransferFrameForCompress()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGTransferFrameForCompress(SGChannel c, short bufferNum, const MatrixRecord *mp, RgnHandle clipRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGTransferFrameForCompress
			move.l              #$000A0112,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGTransferFrameForCompress
	ENDIF


; *  SGSetCompressBuffer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetCompressBuffer(SGChannel c, short depth, const Rect *compressSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetCompressBuffer
			move.l              #$00060113,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetCompressBuffer
	ENDIF


; *  SGGetCompressBuffer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetCompressBuffer(SGChannel c, short *depth, Rect *compressSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetCompressBuffer
			move.l              #$00080114,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetCompressBuffer
	ENDIF


; *  SGGetBufferInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetBufferInfo(SGChannel c, short bufferNum, PixMapHandle *bufferPM, Rect *bufferRect, GWorldPtr *compressBuffer, Rect *compressBufferRect)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetBufferInfo
			move.l              #$00120115,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetBufferInfo
	ENDIF


; *  SGSetUseScreenBuffer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetUseScreenBuffer(SGChannel c, Boolean useScreenBuffer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetUseScreenBuffer
			move.l              #$00020116,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetUseScreenBuffer
	ENDIF


; *  SGGetUseScreenBuffer()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetUseScreenBuffer(SGChannel c, Boolean *useScreenBuffer)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetUseScreenBuffer
			move.l              #$00040117,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetUseScreenBuffer
	ENDIF


; *  SGGrabCompressComplete()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGrabCompressComplete(SGChannel c, Boolean *done, SGCompressInfo *ci, TimeRecord *tr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGrabCompressComplete
			move.l              #$000C0118,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGrabCompressComplete
	ENDIF


; *  SGDisplayCompress()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGDisplayCompress(SGChannel c, Ptr dataPtr, ImageDescriptionHandle desc, MatrixRecord *mp, RgnHandle clipRgn)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGDisplayCompress
			move.l              #$00100119,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGDisplayCompress
	ENDIF


; *  SGSetFrameRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetFrameRate(SGChannel c, Fixed frameRate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetFrameRate
			move.l              #$0004011A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetFrameRate
	ENDIF


; *  SGGetFrameRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetFrameRate(SGChannel c, Fixed *frameRate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetFrameRate
			move.l              #$0004011B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetFrameRate
	ENDIF



; *  SGSetPreferredPacketSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetPreferredPacketSize(SGChannel c, long preferredPacketSizeInBytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetPreferredPacketSize
			move.l              #$00040121,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetPreferredPacketSize
	ENDIF


; *  SGGetPreferredPacketSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetPreferredPacketSize(SGChannel c, long *preferredPacketSizeInBytes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetPreferredPacketSize
			move.l              #$00040122,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetPreferredPacketSize
	ENDIF


; *  SGSetUserVideoCompressorList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetUserVideoCompressorList(SGChannel c, Handle compressorTypes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetUserVideoCompressorList
			move.l              #$00040123,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetUserVideoCompressorList
	ENDIF


; *  SGGetUserVideoCompressorList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetUserVideoCompressorList(SGChannel c, Handle *compressorTypes)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetUserVideoCompressorList
			move.l              #$00040124,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetUserVideoCompressorList
	ENDIF

; ** Sequence Grab SOUND CHANNEL Component Stuff **

; 
;    Sound stuff
;


; *  SGSetSoundInputDriver()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetSoundInputDriver(SGChannel c, ConstStr255Param driverName)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetSoundInputDriver
			move.l              #$00040100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetSoundInputDriver
	ENDIF


; *  SGGetSoundInputDriver()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal long SGGetSoundInputDriver(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetSoundInputDriver
			move.l              #$00000101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetSoundInputDriver
	ENDIF


; *  SGSoundInputDriverChanged()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSoundInputDriverChanged(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSoundInputDriverChanged
			move.l              #$00000102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSoundInputDriverChanged
	ENDIF


; *  SGSetSoundRecordChunkSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetSoundRecordChunkSize(SGChannel c, long seconds)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetSoundRecordChunkSize
			move.l              #$00040103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetSoundRecordChunkSize
	ENDIF


; *  SGGetSoundRecordChunkSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal long SGGetSoundRecordChunkSize(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetSoundRecordChunkSize
			move.l              #$00000104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetSoundRecordChunkSize
	ENDIF


; *  SGSetSoundInputRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetSoundInputRate(SGChannel c, Fixed rate)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetSoundInputRate
			move.l              #$00040105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetSoundInputRate
	ENDIF


; *  SGGetSoundInputRate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal Fixed SGGetSoundInputRate(SGChannel c)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetSoundInputRate
			move.l              #$00000106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetSoundInputRate
	ENDIF


; *  SGSetSoundInputParameters()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetSoundInputParameters(SGChannel c, short sampleSize, short numChannels, OSType compressionType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetSoundInputParameters
			move.l              #$00080107,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetSoundInputParameters
	ENDIF


; *  SGGetSoundInputParameters()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetSoundInputParameters(SGChannel c, short *sampleSize, short *numChannels, OSType *compressionType)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetSoundInputParameters
			move.l              #$000C0108,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetSoundInputParameters
	ENDIF


; *  SGSetAdditionalSoundRates()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetAdditionalSoundRates(SGChannel c, Handle rates)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetAdditionalSoundRates
			move.l              #$00040109,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetAdditionalSoundRates
	ENDIF


; *  SGGetAdditionalSoundRates()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetAdditionalSoundRates(SGChannel c, Handle *rates)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetAdditionalSoundRates
			move.l              #$0004010A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetAdditionalSoundRates
	ENDIF

; 
;    Text stuff
;


; *  SGSetFontName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetFontName(SGChannel c, StringPtr pstr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetFontName
			move.l              #$00040100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetFontName
	ENDIF


; *  SGSetFontSize()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetFontSize(SGChannel c, short fontSize)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetFontSize
			move.l              #$00020101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetFontSize
	ENDIF


; *  SGSetTextForeColor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetTextForeColor(SGChannel c, RGBColor *theColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetTextForeColor
			move.l              #$00040102,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetTextForeColor
	ENDIF


; *  SGSetTextBackColor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetTextBackColor(SGChannel c, RGBColor *theColor)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetTextBackColor
			move.l              #$00040103,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetTextBackColor
	ENDIF


; *  SGSetJustification()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetJustification(SGChannel c, short just)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetJustification
			move.l              #$00020104,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetJustification
	ENDIF


; *  SGGetTextReturnToSpaceValue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetTextReturnToSpaceValue(SGChannel c, short *rettospace)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetTextReturnToSpaceValue
			move.l              #$00040105,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetTextReturnToSpaceValue
	ENDIF


; *  SGSetTextReturnToSpaceValue()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetTextReturnToSpaceValue(SGChannel c, short rettospace)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetTextReturnToSpaceValue
			move.l              #$00020106,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetTextReturnToSpaceValue
	ENDIF

; 
;    Music stuff
;


; *  SGGetInstrument()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGGetInstrument(SGChannel c, ToneDescription *td)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGGetInstrument
			move.l              #$00040100,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGGetInstrument
	ENDIF


; *  SGSetInstrument()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 2.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult SGSetInstrument(SGChannel c, ToneDescription *td)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SGSetInstrument
			move.l              #$00040101,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SGSetInstrument
	ENDIF



sgChannelAtom					EQU		'chan'
sgChannelSettingsAtom			EQU		'ctom'
sgChannelDescription			EQU		'cdsc'
sgChannelSettings				EQU		'cset'

sgDeviceNameType				EQU		'name'
sgUsageType						EQU		'use '
sgPlayFlagsType					EQU		'plyf'
sgClipType						EQU		'clip'
sgMatrixType					EQU		'mtrx'
sgVolumeType					EQU		'volu'

sgPanelSettingsAtom				EQU		'ptom'
sgPanelDescription				EQU		'pdsc'
sgPanelSettings					EQU		'pset'

sgcSoundCompressionType			EQU		'scmp'
sgcSoundSampleRateType			EQU		'srat'
sgcSoundChannelCountType		EQU		'schn'
sgcSoundSampleSizeType			EQU		'ssiz'
sgcSoundInputType				EQU		'sinp'
sgcSoundGainType				EQU		'gain'

sgcVideoHueType					EQU		'hue '
sgcVideoSaturationType			EQU		'satr'
sgcVideoContrastType			EQU		'trst'
sgcVideoSharpnessType			EQU		'shrp'
sgcVideoBrigtnessType			EQU		'brit'
sgcVideoBlackLevelType			EQU		'blkl'
sgcVideoWhiteLevelType			EQU		'whtl'
sgcVideoInputType				EQU		'vinp'
sgcVideoFormatType				EQU		'vstd'
sgcVideoFilterType				EQU		'vflt'
sgcVideoRectType				EQU		'vrct'
sgcVideoDigitizerType			EQU		'vdig'



; typedef ComponentInstance 			QTVideoOutputComponent

;  Component type and subtype enumerations

QTVideoOutputComponentType		EQU		'vout'
QTVideoOutputComponentBaseSubType EQU	'base'

;  QTVideoOutput Component flags


kQTVideoOutputDontDisplayToUser	EQU		$00000001
;  Display mode atom types


kQTVODisplayModeItem			EQU		'qdmi'
kQTVODimensions					EQU		'dimn'				; atom contains two longs - pixel count - width, height
kQTVOResolution					EQU		'resl'				; atom contains two Fixed - hRes, vRes in dpi
kQTVORefreshRate				EQU		'refr'				; atom contains one Fixed - refresh rate in Hz
kQTVOPixelType					EQU		'pixl'				; atom contains one OSType - pixel format of mode
kQTVOName						EQU		'name'				; atom contains string (no length byte) - name of mode for display to user
kQTVODecompressors				EQU		'deco'				; atom contains other atoms indicating supported decompressors
															; kQTVODecompressors sub-atoms
kQTVODecompressorType			EQU		'dety'				; atom contains one OSType - decompressor type code
kQTVODecompressorContinuous		EQU		'cont'				; atom contains one Boolean - true if this type is displayed continuously
kQTVODecompressorComponent		EQU		'cmpt'				; atom contains one Component - component id of decompressor
; * These are QTVideoOutput procedures *

; *  QTVideoOutputGetDisplayModeList()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputGetDisplayModeList(QTVideoOutputComponent vo, QTAtomContainer *outputs)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetDisplayModeList
			move.l              #$00040001,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetDisplayModeList
	ENDIF


; *  QTVideoOutputGetCurrentClientName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputGetCurrentClientName(QTVideoOutputComponent vo, Str255 str)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetCurrentClientName
			move.l              #$00040002,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetCurrentClientName
	ENDIF


; *  QTVideoOutputSetClientName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputSetClientName(QTVideoOutputComponent vo, ConstStr255Param str)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputSetClientName
			move.l              #$00040003,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputSetClientName
	ENDIF


; *  QTVideoOutputGetClientName()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputGetClientName(QTVideoOutputComponent vo, Str255 str)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetClientName
			move.l              #$00040004,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetClientName
	ENDIF


; *  QTVideoOutputBegin()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputBegin(QTVideoOutputComponent vo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputBegin
			move.l              #$00000005,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputBegin
	ENDIF


; *  QTVideoOutputEnd()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputEnd(QTVideoOutputComponent vo)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputEnd
			move.l              #$00000006,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputEnd
	ENDIF


; *  QTVideoOutputSetDisplayMode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputSetDisplayMode(QTVideoOutputComponent vo, long displayModeID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputSetDisplayMode
			move.l              #$00040007,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputSetDisplayMode
	ENDIF


; *  QTVideoOutputGetDisplayMode()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputGetDisplayMode(QTVideoOutputComponent vo, long *displayModeID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetDisplayMode
			move.l              #$00040008,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetDisplayMode
	ENDIF


; *  QTVideoOutputCustomConfigureDisplay()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputCustomConfigureDisplay(QTVideoOutputComponent vo, ModalFilterUPP filter)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputCustomConfigureDisplay
			move.l              #$00040009,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputCustomConfigureDisplay
	ENDIF


; *  QTVideoOutputSaveState()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputSaveState(QTVideoOutputComponent vo, QTAtomContainer *state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputSaveState
			move.l              #$0004000A,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputSaveState
	ENDIF


; *  QTVideoOutputRestoreState()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputRestoreState(QTVideoOutputComponent vo, QTAtomContainer state)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputRestoreState
			move.l              #$0004000B,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputRestoreState
	ENDIF


; *  QTVideoOutputGetGWorld()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputGetGWorld(QTVideoOutputComponent vo, GWorldPtr *gw)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetGWorld
			move.l              #$0004000C,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetGWorld
	ENDIF


; *  QTVideoOutputGetGWorldParameters()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputGetGWorldParameters(QTVideoOutputComponent vo, Ptr *baseAddr, long *rowBytes, CTabHandle *colorTable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetGWorldParameters
			move.l              #$000C000D,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetGWorldParameters
	ENDIF


; *  QTVideoOutputGetIndSoundOutput()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputGetIndSoundOutput(QTVideoOutputComponent vo, long index, Component *outputComponent)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetIndSoundOutput
			move.l              #$0008000E,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetIndSoundOutput
	ENDIF


; *  QTVideoOutputGetClock()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputGetClock(QTVideoOutputComponent vo, ComponentInstance *clock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetClock
			move.l              #$0004000F,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetClock
	ENDIF


; *  QTVideoOutputSetEchoPort()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 3.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 3.0 and later
; 

;
; pascal ComponentResult QTVideoOutputSetEchoPort(QTVideoOutputComponent vo, CGrafPtr echoPort)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputSetEchoPort
			move.l              #$00040010,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputSetEchoPort
	ENDIF


; *  QTVideoOutputGetIndImageDecompressor()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in QuickTimeLib 5.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; *    Windows:          in qtmlClient.lib 5.0 and later
; 

;
; pascal ComponentResult QTVideoOutputGetIndImageDecompressor(QTVideoOutputComponent vo, long index, Component *codec)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_QTVideoOutputGetIndImageDecompressor
			move.l              #$00080011,-(sp)
			moveq           	#0,D0
			dc.w            	$A82A
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION QTVideoOutputGetIndImageDecompressor
	ENDIF

;  UPP call backs 

; *  NewDataHCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewVdigIntUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewStartDocumentHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewEndDocumentHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewStartElementHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewEndElementHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewCharDataHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewPreprocessInstructionHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewCommentHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewSGDataUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewSGModalFilterUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewSGGrabBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewSGGrabCompleteBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewSGDisplayBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewSGCompressBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewSGCompressCompleteBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewSGAddFrameBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewSGTransferFrameBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewSGGrabCompressCompleteBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  NewSGDisplayCompressBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeDataHCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeVdigIntUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeStartDocumentHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeEndDocumentHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeStartElementHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeEndElementHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeCharDataHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposePreprocessInstructionHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeCommentHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSGDataUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSGModalFilterUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSGGrabBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSGGrabCompleteBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSGDisplayBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSGCompressBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSGCompressCompleteBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSGAddFrameBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSGTransferFrameBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSGGrabCompressCompleteBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSGDisplayCompressBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeDataHCompletionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeVdigIntUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeStartDocumentHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeEndDocumentHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeStartElementHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeEndElementHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeCharDataHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokePreprocessInstructionHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeCommentHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSGDataUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSGModalFilterUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSGGrabBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSGGrabCompleteBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSGDisplayBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSGCompressBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSGCompressCompleteBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSGAddFrameBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSGTransferFrameBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSGGrabCompressCompleteBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSGDisplayCompressBottleUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 


	ENDIF ; __QUICKTIMECOMPONENTS__ 


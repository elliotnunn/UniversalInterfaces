;
;    File:       SCSI.a
;
;    Contains:   SCSI Family Interfaces.
;
;    Version:    Technology: SCSI 4.3
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1986-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__SCSI__') = 'UNDEFINED' THEN
__SCSI__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN
	include 'MixedMode.a'
	ENDIF

	IF &TYPE('__APPLEDISKPARTITIONS__') = 'UNDEFINED' THEN
	include 'AppleDiskPartitions.a'
	ENDIF
;  SCSI Manager errors. These are generated by Inside Mac IV calls only. 

scCommErr						EQU		2					; communications error, operation timeout 
scArbNBErr						EQU		3					; arbitration timeout waiting for not BSY 
scBadParmsErr					EQU		4					; bad parameter or TIB opcode 
scPhaseErr						EQU		5					; SCSI bus not in correct phase for attempted operation 
scCompareErr					EQU		6					; data compare error 
scMgrBusyErr					EQU		7					; SCSI Manager busy  
scSequenceErr					EQU		8					; attempted operation is out of sequence 
scBusTOErr						EQU		9					; CPU bus timeout 
scComplPhaseErr					EQU		10					; SCSI bus wasn't in Status phase 
;  TIB opcodes 

scInc							EQU		1
scNoInc							EQU		2
scAdd							EQU		3
scMove							EQU		4
scLoop							EQU		5
scNop							EQU		6
scStop							EQU		7
scComp							EQU		8
;  
; * All disk partition structures and definitions are now in the 
; * AppleDiskPartitions.h/p/a files.
; 

;  TIB instruction 
SCSIInstr				RECORD 0
scOpcode				 ds.w	1				; offset: $0 (0)
scParam1				 ds.l	1				; offset: $2 (2)
scParam2				 ds.l	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $A (10)
						ENDR
;  SCSI Phases (used by SIMs to support the Original SCSI Manager 

kDataOutPhase					EQU		0					; Encoded MSG, C/D, I/O bits 
kDataInPhase					EQU		1
kCommandPhase					EQU		2
kStatusPhase					EQU		3
kPhaseIllegal0					EQU		4
kPhaseIllegal1					EQU		5
kMessageOutPhase				EQU		6
kMessageInPhase					EQU		7
kBusFreePhase					EQU		8					; Additional Phases 
kArbitratePhase					EQU		9
kSelectPhase					EQU		10
kMessageInPhaseNACK				EQU		11					; Message In Phase with ACK hanging on the bus 
	IF CALL_NOT_IN_CARBON THEN

; *  SCSIReset()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIReset(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSIReset
			clr.w               -(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIReset
	ENDIF


; *  SCSIGet()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIGet(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSIGet
			move.w              #$0001,-(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIGet
	ENDIF


; *  SCSISelect()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSISelect(short targetID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSISelect
			move.w              #$0002,-(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSISelect
	ENDIF


; *  SCSICmd()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSICmd(Ptr buffer, short count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSICmd
			move.w              #$0003,-(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSICmd
	ENDIF


; *  SCSIRead()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIRead(Ptr tibPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSIRead
			move.w              #$0005,-(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIRead
	ENDIF


; *  SCSIRBlind()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIRBlind(Ptr tibPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSIRBlind
			move.w              #$0008,-(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIRBlind
	ENDIF


; *  SCSIWrite()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIWrite(Ptr tibPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSIWrite
			move.w              #$0006,-(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIWrite
	ENDIF


; *  SCSIWBlind()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIWBlind(Ptr tibPtr)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSIWBlind
			move.w              #$0009,-(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIWBlind
	ENDIF


; *  SCSIComplete()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIComplete(short *stat, short *message, unsigned long wait)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSIComplete
			move.w              #$0004,-(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIComplete
	ENDIF


; *  SCSIStat()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal short SCSIStat(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSIStat
			move.w              #$000A,-(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIStat
	ENDIF


; *  SCSISelAtn()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSISelAtn(short targetID)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSISelAtn
			move.w              #$000B,-(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSISelAtn
	ENDIF


; *  SCSIMsgIn()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIMsgIn(short *message)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSIMsgIn
			move.w              #$000C,-(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIMsgIn
	ENDIF


; *  SCSIMsgOut()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIMsgOut(short message)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SCSIMsgOut
			move.w              #$000D,-(sp)
			dc.w            	$A815
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIMsgOut
	ENDIF


	ENDIF	; CALL_NOT_IN_CARBON

scsiVERSION						EQU		43

; 
; * SCSI Callback Procedure Prototypes. Several of these are only callable
; * from SCSI Manager 4.3 SIM and XPT contexts. 
; 

;  SCSIInterruptPollProcPtr is obsolete (use SCSIInterruptProcPtr) but still here for compatibility 
	IF CALL_NOT_IN_CARBON THEN

; *  NewAENCallbackUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewSIMInitUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewSIMActionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewSCSIUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewSCSIMakeCallbackUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewSCSIInterruptPollUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewSCSIInterruptUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeAENCallbackUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeSIMInitUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeSIMActionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeSCSIUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeSCSIMakeCallbackUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeSCSIInterruptPollUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeSCSIInterruptUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeAENCallbackUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeSIMInitUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeSIMActionUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeSCSIUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeSCSIMakeCallbackUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeSCSIInterruptPollUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeSCSIInterruptUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

	ENDIF	; CALL_NOT_IN_CARBON
; 
; * SCSI Completion routine callback for SCSIAction.
; 


; *  NewSCSICallbackUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  DisposeSCSICallbackUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 


; *  InvokeSCSICallbackUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in version 10.0 or later
; 



;  
;   SCSI Manager 4.3 function codes 
; 


SCSINop							EQU		$00					; Execute nothing                          
SCSIExecIO						EQU		$01					; Execute the specified IO                  
SCSIBusInquiry					EQU		$03					; Get parameters for entire path of HBAs           
SCSIReleaseQ					EQU		$04					; Release the frozen SIM queue for particular LUN      
SCSIAbortCommand				EQU		$10					; Abort the selected Control Block             
SCSIResetBus					EQU		$11					; Reset the SCSI bus                         
SCSIResetDevice					EQU		$12					; Reset the SCSI device                      
SCSITerminateIO					EQU		$13					; Terminate any pending IO                    
;  Not available in Carbon on X 

SCSIGetVirtualIDInfo			EQU		$80					; Find out which bus old ID is on                
SCSILoadDriver					EQU		$82					; Load a driver for a device ident             
SCSIOldCall						EQU		$84					; XPT->SIM private call for old-API            
SCSICreateRefNumXref			EQU		$85					; Register a DeviceIdent to drvr RefNum xref          
SCSILookupRefNumXref			EQU		$86					; Get DeviceIdent to drvr RefNum xref              
SCSIRemoveRefNumXref			EQU		$87					; Remove a DeviceIdent to drvr RefNum xref        
SCSIRegisterWithNewXPT			EQU		$88					; XPT has changed - SIM needs to re-register itself  

vendorUnique					EQU		$C0					; 0xC0 thru 0xFF 

;  Allocation length defines for some of the fields 

handshakeDataLength				EQU		8					; Handshake data length 
maxCDBLength					EQU		16					; Space for the CDB bytes/pointer 
vendorIDLength					EQU		16					; ASCII string len for Vendor ID  
;  Define DeviceIdent structure 
DeviceIdent				RECORD 0
diReserved				 ds.b	1				; offset: $0 (0)		;  reserved           
bus						 ds.b	1				; offset: $1 (1)		;  SCSI - Bus Number   
targetID				 ds.b	1				; offset: $2 (2)		;  SCSI - Target SCSI ID  
LUN						 ds.b	1				; offset: $3 (3)		;  SCSI - LUN            
sizeof					 EQU *					; size:   $4 (4)
						ENDR
;  Constants for the diReserved field of DeviceIdent 
;  used to distinguish whether the DeviceIdent holds 
;  information about a SCSI device (kBusTypeSCSI)    
;  or an ATA device (kBusTypeATA).  The other        
;  constants are pretty much deprecated.  Let me     
;  know if you see any.                              

kBusTypeSCSI					EQU		0
kBusTypeATA						EQU		1
kBusTypePCMCIA					EQU		2
kBusTypeMediaBay				EQU		3
;  If diReserved indicates that a DeviceIdent is     
;  really for ATA, you can cast it to DeviceIdentATA 
;  to get at the important fields.                   
DeviceIdentATA			RECORD 0
diReserved				 ds.b	1				; offset: $0 (0)
busNum					 ds.b	1				; offset: $1 (1)
devNum					 ds.b	1				; offset: $2 (2)
diReserved2				 ds.b	1				; offset: $3 (3)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
;  for use with Apple Patch Driver used during booting
PatchDescriptor			RECORD 0
patchSig				 ds.l	1				; offset: $0 (0)		;  The patches signature                
majorVers				 ds.w	1				; offset: $4 (4)		;  The major version number of the      
;  patch                                
minorVers				 ds.w	1				; offset: $6 (6)		;  The minor version number of the      
;  patch                                
flags					 ds.l	1				; offset: $8 (8)		;  Reqired/Optional, etc.               
patchOffset				 ds.l	1				; offset: $C (12)		;  Block offset to the beginning of     
;  the patch                            
patchSize				 ds.l	1				; offset: $10 (16)		;  Actual size of the patch in bytes    
patchCRC				 ds.l	1				; offset: $14 (20)		;  As calculated by the SCSI drivers    
;  CRC code                             
patchDescriptorLen		 ds.l	1				; offset: $18 (24)		;  Total length of the descriptor       
;  (must be >= 61 bytes)                
patchName				 ds.b	33				; offset: $1C (28)		;  Pascal string with a short           
;  description of the patch             
patchVendor				 ds.b	1				; offset: $3D (61) <-- really an array of length one ;  The first byte of a pascal string    
;  for the patch Vendor. Any amount     
;  of data may follow the string.       
sizeof					 EQU *					; size:   $3E (62)
						ENDR
;  Constants for the flags field of PatchDescriptor. 

kRequiredPatch					EQU		$00000001			; Patch must succeed to continue booting. 

PatchList				RECORD 0
numPatchBlocks			 ds.w	1				; offset: $0 (0)		;  The number of disk blocks        
;  to hold patch descriptions       
numPatches				 ds.w	1				; offset: $2 (2)		;  The number of patches            
thePatch				 ds		PatchDescriptor ; offset: $4 (4) <-- really an array of length one ;  An array with one patch          
;  per element                      
sizeof					 EQU *					; size:   $42 (66)
						ENDR
;  signature of a Patch entry point


;  Command Descriptor Block structure 
CDB						RECORD 0
cdbPtr					 ds.l	1				; offset: $0 (0)		;  pointer to the CDB, or 
						 ORG 0
cdbBytes				 ds.b	16				; offset: $0 (0)		;  the actual CDB to send 
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef union CDB *					CDBPtr

;  Scatter/gather list element (Deprecated for MacOS8) 
SGRecord				RECORD 0
SGAddr					 ds.l	1				; offset: $0 (0)
SGCount					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
SCSIHdr					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		;  (internal use, must be nil on entry)   
scsiReserved1			 ds.w	1				; offset: $4 (4)		;  ->     reserved for input          
scsiPBLength			 ds.w	1				; offset: $6 (6)		;  -> Length of the entire PB        
scsiFunctionCode		 ds.b	1				; offset: $8 (8)		;  -> function selector           
scsiReserved2			 ds.b	1				; offset: $9 (9)		;  <-     reserved for output          
scsiResult				 ds.w	1				; offset: $A (10)		;  <- Returned result               
scsiDevice				 ds		DeviceIdent		; offset: $C (12)		;  -> Device Identifier (bus+target+lun)
scsiCompletion			 ds.l	1				; offset: $10 (16)		;  -> Callback on completion function     
scsiFlags				 ds.l	1				; offset: $14 (20)		;  -> assorted flags            
scsiDriverStorage		 ds.l	1				; offset: $18 (24)		;  <> Ptr for driver private use   
scsiXPTprivate			 ds.l	1				; offset: $1C (28)		;  private field for use in XPT      
scsiReserved3			 ds.l	1				; offset: $20 (32)		;  reserved                    
sizeof					 EQU *					; size:   $24 (36)
						ENDR
SCSI_PB					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		;  (internal use, must be nil on entry)   
scsiReserved1			 ds.w	1				; offset: $4 (4)		;  ->     reserved for input          
scsiPBLength			 ds.w	1				; offset: $6 (6)		;  -> Length of the entire PB        
scsiFunctionCode		 ds.b	1				; offset: $8 (8)		;  -> function selector           
scsiReserved2			 ds.b	1				; offset: $9 (9)		;  <-     reserved for output          
scsiResult				 ds.w	1				; offset: $A (10)		;  <- Returned result               
scsiDevice				 ds		DeviceIdent		; offset: $C (12)		;  -> Device Identifier (bus+target+lun)
scsiCompletion			 ds.l	1				; offset: $10 (16)		;  -> Callback on completion function     
scsiFlags				 ds.l	1				; offset: $14 (20)		;  -> assorted flags            
scsiDriverStorage		 ds.l	1				; offset: $18 (24)		;  <> Ptr for driver private use   
scsiXPTprivate			 ds.l	1				; offset: $1C (28)		;  private field for use in XPT      
scsiReserved3			 ds.l	1				; offset: $20 (32)		;  reserved                    
sizeof					 EQU *					; size:   $24 (36)
						ENDR
SCSI_IO					RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		;  (internal use, must be nil on entry)   
scsiReserved1			 ds.w	1				; offset: $4 (4)		;  ->     reserved for input          
scsiPBLength			 ds.w	1				; offset: $6 (6)		;  -> Length of the entire PB        
scsiFunctionCode		 ds.b	1				; offset: $8 (8)		;  -> function selector           
scsiReserved2			 ds.b	1				; offset: $9 (9)		;  <-     reserved for output          
scsiResult				 ds.w	1				; offset: $A (10)		;  <- Returned result               
scsiDevice				 ds		DeviceIdent		; offset: $C (12)		;  -> Device Identifier (bus+target+lun)
scsiCompletion			 ds.l	1				; offset: $10 (16)		;  -> Callback on completion function     
scsiFlags				 ds.l	1				; offset: $14 (20)		;  -> assorted flags            
scsiDriverStorage		 ds.l	1				; offset: $18 (24)		;  <> Ptr for driver private use   
scsiXPTprivate			 ds.l	1				; offset: $1C (28)		;  private field for use in XPT      
scsiReserved3			 ds.l	1				; offset: $20 (32)		;  reserved                    
scsiResultFlags			 ds.w	1				; offset: $24 (36)		;  <- Flags which modify the scsiResult field     
scsiReserved3pt5		 ds.w	1				; offset: $26 (38)		;  -> Reserved                           
scsiDataPtr				 ds.l	1				; offset: $28 (40)		;  -> Pointer to the data buffer or the S/G list      
scsiDataLength			 ds.l	1				; offset: $2C (44)		;  -> Data transfer length                   
scsiSensePtr			 ds.l	1				; offset: $30 (48)		;  -> Ptr to autosense data buffer            
scsiSenseLength			 ds.b	1				; offset: $34 (52)		;  -> size of the autosense buffer              
scsiCDBLength			 ds.b	1				; offset: $35 (53)		;  -> Number of bytes for the CDB               
scsiSGListCount			 ds.w	1				; offset: $36 (54)		;  -> num of scatter gather list entries           
scsiReserved4			 ds.l	1				; offset: $38 (56)		;  <-     reserved for output                   
scsiSCSIstatus			 ds.b	1				; offset: $3C (60)		;  <- Returned scsi device status               
scsiSenseResidual		 ds.b	1				; offset: $3D (61)		;  <- Autosense residual length             
scsiReserved5			 ds.w	1				; offset: $3E (62)		;  <-     reserved for output                 
scsiDataResidual		 ds.l	1				; offset: $40 (64)		;  <- Returned Transfer residual length          
scsiCDB					 ds		CDB				; offset: $44 (68)		;  -> Actual CDB or pointer to CDB            
scsiTimeout				 ds.l	1				; offset: $54 (84)		;  -> Timeout value (Time Mgr format) (CAM timeout) 
scsiReserved5pt5		 ds.l	1				; offset: $58 (88)		;  -> Reserved                           
scsiReserved5pt6		 ds.w	1				; offset: $5C (92)		;  -> Reserved                           
scsiIOFlags				 ds.w	1				; offset: $5E (94)		;  -> additional I/O flags                      
scsiTagAction			 ds.b	1				; offset: $60 (96)		;  -> What to do for tag queuing                
scsiReserved6			 ds.b	1				; offset: $61 (97)		;  ->     reserved for input                   
scsiReserved7			 ds.w	1				; offset: $62 (98)		;  ->     reserved for input                   
scsiSelectTimeout		 ds.w	1				; offset: $64 (100)		;  -> Select timeout value                 
scsiDataType			 ds.b	1				; offset: $66 (102)		;  -> Data description type (i.e. buffer, TIB, S/G)   
scsiTransferType		 ds.b	1				; offset: $67 (103)		;  -> Transfer type (i.e. Blind vs Polled)       
scsiReserved8			 ds.l	1				; offset: $68 (104)		;  ->     reserved for input                  
scsiReserved9			 ds.l	1				; offset: $6C (108)		;  ->     reserved for input                  
scsiHandshake			 ds.w	8				; offset: $70 (112)		;  -> handshaking points (null term'd)    
scsiReserved10			 ds.l	1				; offset: $80 (128)		;  ->     reserved for input                  
scsiReserved11			 ds.l	1				; offset: $84 (132)		;  ->   reserved for input                   
scsiCommandLink			 ds.l	1				; offset: $88 (136)		;  -> Ptr to the next PB in linked cmd chain      
scsiSIMpublics			 ds.b	8				; offset: $8C (140)		;  ->     reserved for input to 3rd-party SIMs     
scsiAppleReserved6		 ds.b	8				; offset: $94 (148)		;  -> reserved for input                     
;  XPT layer privates (for old-API emulation) 
scsiCurrentPhase		 ds.w	1				; offset: $9C (156)		;  <- phase upon completing old call            
scsiSelector			 ds.w	1				; offset: $9E (158)		;  -> selector specified in old calls            
scsiOldCallResult		 ds.w	1				; offset: $A0 (160)		;  <- result of old call                     
scsiSCSImessage			 ds.b	1				; offset: $A2 (162)		;  <- Returned scsi device message (for SCSIComplete)
XPTprivateFlags			 ds.b	1				; offset: $A3 (163)		;  <> various flags                       
XPTextras				 ds.b	12				; offset: $A4 (164)		;                               
sizeof					 EQU *					; size:   $B0 (176)
						ENDR
SCSIExecIOPB			RECORD 0
f						 ds		SCSI_IO
sizeof					 EQU *					; size:   $B0 (176)
						ENDR


;  Bus inquiry PB 
SCSIBusInquiryPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		;  (internal use, must be nil on entry)   
scsiReserved1			 ds.w	1				; offset: $4 (4)		;  ->     reserved for input          
scsiPBLength			 ds.w	1				; offset: $6 (6)		;  -> Length of the entire PB        
scsiFunctionCode		 ds.b	1				; offset: $8 (8)		;  -> function selector           
scsiReserved2			 ds.b	1				; offset: $9 (9)		;  <-     reserved for output          
scsiResult				 ds.w	1				; offset: $A (10)		;  <- Returned result               
scsiDevice				 ds		DeviceIdent		; offset: $C (12)		;  -> Device Identifier (bus+target+lun)
scsiCompletion			 ds.l	1				; offset: $10 (16)		;  -> Callback on completion function     
scsiFlags				 ds.l	1				; offset: $14 (20)		;  -> assorted flags            
scsiDriverStorage		 ds.l	1				; offset: $18 (24)		;  <> Ptr for driver private use   
scsiXPTprivate			 ds.l	1				; offset: $1C (28)		;  private field for use in XPT      
scsiReserved3			 ds.l	1				; offset: $20 (32)		;  reserved                    
scsiEngineCount			 ds.w	1				; offset: $24 (36)		;  <- Number of engines on HBA                
scsiMaxTransferType		 ds.w	1				; offset: $26 (38)		;  <- Number of transfer types for this HBA      
scsiDataTypes			 ds.l	1				; offset: $28 (40)		;  <- which data types are supported by this SIM  
scsiIOpbSize			 ds.w	1				; offset: $2C (44)		;  <- Size of SCSI_IO PB for this SIM/HBA          
scsiMaxIOpbSize			 ds.w	1				; offset: $2E (46)		;  <- Size of max SCSI_IO PB for all SIM/HBAs        
scsiFeatureFlags		 ds.l	1				; offset: $30 (48)		;  <- Supported features flags field           
scsiVersionNumber		 ds.b	1				; offset: $34 (52)		;  <- Version number for the SIM/HBA           
scsiHBAInquiry			 ds.b	1				; offset: $35 (53)		;  <- Mimic of INQ byte 7 for the HBA           
scsiTargetModeFlags		 ds.b	1				; offset: $36 (54)		;  <- Flags for target mode support           
scsiScanFlags			 ds.b	1				; offset: $37 (55)		;  <- Scan related feature flags            
scsiSIMPrivatesPtr		 ds.l	1				; offset: $38 (56)		;  <- Ptr to SIM private data area              
scsiSIMPrivatesSize		 ds.l	1				; offset: $3C (60)		;  <- Size of SIM private data area           
scsiAsyncFlags			 ds.l	1				; offset: $40 (64)		;  <- Event cap. for Async Callback           
scsiHiBusID				 ds.b	1				; offset: $44 (68)		;  <- Highest path ID in the subsystem         
scsiInitiatorID			 ds.b	1				; offset: $45 (69)		;  <- ID of the HBA on the SCSI bus           
scsiBIReserved0			 ds.w	1				; offset: $46 (70)		;                                   
scsiBIReserved1			 ds.l	1				; offset: $48 (72)		;  <-                                
scsiFlagsSupported		 ds.l	1				; offset: $4C (76)		;  <- which scsiFlags are supported           
scsiIOFlagsSupported	 ds.w	1				; offset: $50 (80)		;  <- which scsiIOFlags are supported           
scsiWeirdStuff			 ds.w	1				; offset: $52 (82)		;  <-                               
scsiMaxTarget			 ds.w	1				; offset: $54 (84)		;  <- maximum Target number supported           
scsiMaxLUN				 ds.w	1				; offset: $56 (86)		;  <- maximum Logical Unit number supported    
scsiSIMVendor			 ds.b	16				; offset: $58 (88)		;  <- Vendor ID of SIM (or XPT if bus<FF)        
scsiHBAVendor			 ds.b	16				; offset: $68 (104)		;  <- Vendor ID of the HBA                
scsiControllerFamily	 ds.b	16				; offset: $78 (120)		;  <- Family of SCSI Controller           
scsiControllerType		 ds.b	16				; offset: $88 (136)		;  <- Specific Model of SCSI Controller used  
scsiXPTversion			 ds.b	4				; offset: $98 (152)		;  <- version number of XPT              
scsiSIMversion			 ds.b	4				; offset: $9C (156)		;  <- version number of SIM              
scsiHBAversion			 ds.b	4				; offset: $A0 (160)		;  <- version number of HBA              
scsiHBAslotType			 ds.b	1				; offset: $A4 (164)		;  <- type of "slot" that this HBA is in       
scsiHBAslotNumber		 ds.b	1				; offset: $A5 (165)		;  <- slot number of this HBA                  
scsiSIMsRsrcID			 ds.w	1				; offset: $A6 (166)		;  <- resource ID of this SIM                  
scsiBIReserved3			 ds.w	1				; offset: $A8 (168)		;  <-                               
scsiAdditionalLength	 ds.w	1				; offset: $AA (170)		;  <- additional BusInquiry PB len              
sizeof					 EQU *					; size:   $AC (172)
						ENDR
;  Abort SIM Request PB 
SCSIAbortCommandPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		;  (internal use, must be nil on entry)   
scsiReserved1			 ds.w	1				; offset: $4 (4)		;  ->     reserved for input          
scsiPBLength			 ds.w	1				; offset: $6 (6)		;  -> Length of the entire PB        
scsiFunctionCode		 ds.b	1				; offset: $8 (8)		;  -> function selector           
scsiReserved2			 ds.b	1				; offset: $9 (9)		;  <-     reserved for output          
scsiResult				 ds.w	1				; offset: $A (10)		;  <- Returned result               
scsiDevice				 ds		DeviceIdent		; offset: $C (12)		;  -> Device Identifier (bus+target+lun)
scsiCompletion			 ds.l	1				; offset: $10 (16)		;  -> Callback on completion function     
scsiFlags				 ds.l	1				; offset: $14 (20)		;  -> assorted flags            
scsiDriverStorage		 ds.l	1				; offset: $18 (24)		;  <> Ptr for driver private use   
scsiXPTprivate			 ds.l	1				; offset: $1C (28)		;  private field for use in XPT      
scsiReserved3			 ds.l	1				; offset: $20 (32)		;  reserved                    
scsiIOptr				 ds.l	1				; offset: $24 (36)		;  Pointer to the PB to abort        
sizeof					 EQU *					; size:   $28 (40)
						ENDR
;  Terminate I/O Process Request PB 
SCSITerminateIOPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		;  (internal use, must be nil on entry)   
scsiReserved1			 ds.w	1				; offset: $4 (4)		;  ->     reserved for input          
scsiPBLength			 ds.w	1				; offset: $6 (6)		;  -> Length of the entire PB        
scsiFunctionCode		 ds.b	1				; offset: $8 (8)		;  -> function selector           
scsiReserved2			 ds.b	1				; offset: $9 (9)		;  <-     reserved for output          
scsiResult				 ds.w	1				; offset: $A (10)		;  <- Returned result               
scsiDevice				 ds		DeviceIdent		; offset: $C (12)		;  -> Device Identifier (bus+target+lun)
scsiCompletion			 ds.l	1				; offset: $10 (16)		;  -> Callback on completion function     
scsiFlags				 ds.l	1				; offset: $14 (20)		;  -> assorted flags            
scsiDriverStorage		 ds.l	1				; offset: $18 (24)		;  <> Ptr for driver private use   
scsiXPTprivate			 ds.l	1				; offset: $1C (28)		;  private field for use in XPT      
scsiReserved3			 ds.l	1				; offset: $20 (32)		;  reserved                    
scsiIOptr				 ds.l	1				; offset: $24 (36)		;  Pointer to the PB to terminate        
sizeof					 EQU *					; size:   $28 (40)
						ENDR
;  Reset SCSI Bus PB 
SCSIResetBusPB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		;  (internal use, must be nil on entry)   
scsiReserved1			 ds.w	1				; offset: $4 (4)		;  ->     reserved for input          
scsiPBLength			 ds.w	1				; offset: $6 (6)		;  -> Length of the entire PB        
scsiFunctionCode		 ds.b	1				; offset: $8 (8)		;  -> function selector           
scsiReserved2			 ds.b	1				; offset: $9 (9)		;  <-     reserved for output          
scsiResult				 ds.w	1				; offset: $A (10)		;  <- Returned result               
scsiDevice				 ds		DeviceIdent		; offset: $C (12)		;  -> Device Identifier (bus+target+lun)
scsiCompletion			 ds.l	1				; offset: $10 (16)		;  -> Callback on completion function     
scsiFlags				 ds.l	1				; offset: $14 (20)		;  -> assorted flags            
scsiDriverStorage		 ds.l	1				; offset: $18 (24)		;  <> Ptr for driver private use   
scsiXPTprivate			 ds.l	1				; offset: $1C (28)		;  private field for use in XPT      
scsiReserved3			 ds.l	1				; offset: $20 (32)		;  reserved                    
sizeof					 EQU *					; size:   $24 (36)
						ENDR
;  Reset SCSI Device PB 
SCSIResetDevicePB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		;  (internal use, must be nil on entry)   
scsiReserved1			 ds.w	1				; offset: $4 (4)		;  ->     reserved for input          
scsiPBLength			 ds.w	1				; offset: $6 (6)		;  -> Length of the entire PB        
scsiFunctionCode		 ds.b	1				; offset: $8 (8)		;  -> function selector           
scsiReserved2			 ds.b	1				; offset: $9 (9)		;  <-     reserved for output          
scsiResult				 ds.w	1				; offset: $A (10)		;  <- Returned result               
scsiDevice				 ds		DeviceIdent		; offset: $C (12)		;  -> Device Identifier (bus+target+lun)
scsiCompletion			 ds.l	1				; offset: $10 (16)		;  -> Callback on completion function     
scsiFlags				 ds.l	1				; offset: $14 (20)		;  -> assorted flags            
scsiDriverStorage		 ds.l	1				; offset: $18 (24)		;  <> Ptr for driver private use   
scsiXPTprivate			 ds.l	1				; offset: $1C (28)		;  private field for use in XPT      
scsiReserved3			 ds.l	1				; offset: $20 (32)		;  reserved                    
sizeof					 EQU *					; size:   $24 (36)
						ENDR
;  Release SIM Queue PB 
SCSIReleaseQPB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		;  (internal use, must be nil on entry)   
scsiReserved1			 ds.w	1				; offset: $4 (4)		;  ->     reserved for input          
scsiPBLength			 ds.w	1				; offset: $6 (6)		;  -> Length of the entire PB        
scsiFunctionCode		 ds.b	1				; offset: $8 (8)		;  -> function selector           
scsiReserved2			 ds.b	1				; offset: $9 (9)		;  <-     reserved for output          
scsiResult				 ds.w	1				; offset: $A (10)		;  <- Returned result               
scsiDevice				 ds		DeviceIdent		; offset: $C (12)		;  -> Device Identifier (bus+target+lun)
scsiCompletion			 ds.l	1				; offset: $10 (16)		;  -> Callback on completion function     
scsiFlags				 ds.l	1				; offset: $14 (20)		;  -> assorted flags            
scsiDriverStorage		 ds.l	1				; offset: $18 (24)		;  <> Ptr for driver private use   
scsiXPTprivate			 ds.l	1				; offset: $1C (28)		;  private field for use in XPT      
scsiReserved3			 ds.l	1				; offset: $20 (32)		;  reserved                    
sizeof					 EQU *					; size:   $24 (36)
						ENDR
;  SCSI Get Virtual ID Info PB 
SCSIGetVirtualIDInfoPB	RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		;  (internal use, must be nil on entry)   
scsiReserved1			 ds.w	1				; offset: $4 (4)		;  ->     reserved for input          
scsiPBLength			 ds.w	1				; offset: $6 (6)		;  -> Length of the entire PB        
scsiFunctionCode		 ds.b	1				; offset: $8 (8)		;  -> function selector           
scsiReserved2			 ds.b	1				; offset: $9 (9)		;  <-     reserved for output          
scsiResult				 ds.w	1				; offset: $A (10)		;  <- Returned result               
scsiDevice				 ds		DeviceIdent		; offset: $C (12)		;  -> Device Identifier (bus+target+lun)
scsiCompletion			 ds.l	1				; offset: $10 (16)		;  -> Callback on completion function     
scsiFlags				 ds.l	1				; offset: $14 (20)		;  -> assorted flags            
scsiDriverStorage		 ds.l	1				; offset: $18 (24)		;  <> Ptr for driver private use   
scsiXPTprivate			 ds.l	1				; offset: $1C (28)		;  private field for use in XPT      
scsiReserved3			 ds.l	1				; offset: $20 (32)		;  reserved                    
scsiOldCallID			 ds.w	1				; offset: $24 (36)		;  -> SCSI ID of device in question   
scsiExists				 ds.b	1				; offset: $26 (38)		;  <- true if device exists        
filler					 ds.b	1				; offset: $27 (39)
sizeof					 EQU *					; size:   $28 (40)
						ENDR
;  Create/Lookup/Remove RefNum for Device PB 
SCSIDriverPB			RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		;  (internal use, must be nil on entry)   
scsiReserved1			 ds.w	1				; offset: $4 (4)		;  ->     reserved for input          
scsiPBLength			 ds.w	1				; offset: $6 (6)		;  -> Length of the entire PB        
scsiFunctionCode		 ds.b	1				; offset: $8 (8)		;  -> function selector           
scsiReserved2			 ds.b	1				; offset: $9 (9)		;  <-     reserved for output          
scsiResult				 ds.w	1				; offset: $A (10)		;  <- Returned result               
scsiDevice				 ds		DeviceIdent		; offset: $C (12)		;  -> Device Identifier (bus+target+lun)
scsiCompletion			 ds.l	1				; offset: $10 (16)		;  -> Callback on completion function     
scsiFlags				 ds.l	1				; offset: $14 (20)		;  -> assorted flags            
scsiDriverStorage		 ds.l	1				; offset: $18 (24)		;  <> Ptr for driver private use   
scsiXPTprivate			 ds.l	1				; offset: $1C (28)		;  private field for use in XPT      
scsiReserved3			 ds.l	1				; offset: $20 (32)		;  reserved                    
scsiDriver				 ds.w	1				; offset: $24 (36)		;  -> DriverRefNum, For SetDriver, <- For GetNextDriver 
scsiDriverFlags			 ds.w	1				; offset: $26 (38)		;  <> Details of driver/device       
scsiNextDevice			 ds		DeviceIdent		; offset: $28 (40)		;  <- DeviceIdent of the NEXT Item in the list  
sizeof					 EQU *					; size:   $2C (44)
						ENDR
;  Load Driver PB 
SCSILoadDriverPB		RECORD 0
qLink					 ds.l	1				; offset: $0 (0)		;  (internal use, must be nil on entry)   
scsiReserved1			 ds.w	1				; offset: $4 (4)		;  ->     reserved for input          
scsiPBLength			 ds.w	1				; offset: $6 (6)		;  -> Length of the entire PB        
scsiFunctionCode		 ds.b	1				; offset: $8 (8)		;  -> function selector           
scsiReserved2			 ds.b	1				; offset: $9 (9)		;  <-     reserved for output          
scsiResult				 ds.w	1				; offset: $A (10)		;  <- Returned result               
scsiDevice				 ds		DeviceIdent		; offset: $C (12)		;  -> Device Identifier (bus+target+lun)
scsiCompletion			 ds.l	1				; offset: $10 (16)		;  -> Callback on completion function     
scsiFlags				 ds.l	1				; offset: $14 (20)		;  -> assorted flags            
scsiDriverStorage		 ds.l	1				; offset: $18 (24)		;  <> Ptr for driver private use   
scsiXPTprivate			 ds.l	1				; offset: $1C (28)		;  private field for use in XPT      
scsiReserved3			 ds.l	1				; offset: $20 (32)		;  reserved                    
scsiLoadedRefNum		 ds.w	1				; offset: $24 (36)		;  <- SIM returns refnum of driver      
scsiDiskLoadFailed		 ds.b	1				; offset: $26 (38)		;  -> if true, indicates call after failure to load 
filler					 ds.b	1				; offset: $27 (39)
sizeof					 EQU *					; size:   $28 (40)
						ENDR

;  Defines for the scsiTransferType field 

scsiTransferBlind				EQU		0
scsiTransferPolled				EQU		1

scsiErrorBase					EQU		-7936

scsiRequestInProgress			EQU		1					; 1   = PB request is in progress          
															; Execution failed  00-2F 
scsiRequestAborted				EQU		-7934				; -7934 = PB request aborted by the host        
scsiUnableToAbort				EQU		-7933				; -7933 = Unable to Abort PB request          
scsiNonZeroStatus				EQU		-7932				; -7932 = PB request completed with an err   
scsiUnused05					EQU		-7931				; -7931 =                        
scsiUnused06					EQU		-7930				; -7930 =                        
scsiUnused07					EQU		-7929				; -7929 =                        
scsiUnused08					EQU		-7928				; -7928 =                        
scsiUnableToTerminate			EQU		-7927				; -7927 = Unable to Terminate I/O PB req        
scsiSelectTimeout				EQU		-7926				; -7926 = Target selection timeout        
scsiCommandTimeout				EQU		-7925				; -7925 = Command timeout              
scsiIdentifyMessageRejected		EQU		-7924				; -7924 =                        
scsiMessageRejectReceived		EQU		-7923				; -7923 = Message reject received           
scsiSCSIBusReset				EQU		-7922				; -7922 = SCSI bus reset sent/received    
scsiParityError					EQU		-7921				; -7921 = Uncorrectable parity error occured     
scsiAutosenseFailed				EQU		-7920				; -7920 = Autosense: Request sense cmd fail  
scsiUnused11					EQU		-7919				; -7919 =                        
scsiDataRunError				EQU		-7918				; -7918 = Data overrun/underrun error     
scsiUnexpectedBusFree			EQU		-7917				; -7917 = Unexpected BUS free              
scsiSequenceFailed				EQU		-7916				; -7916 = Target bus phase sequence failure  
scsiWrongDirection				EQU		-7915				; -7915 = Data phase was in wrong direction  
scsiUnused16					EQU		-7914				; -7914 =                        
scsiBDRsent						EQU		-7913				; -7913 = A SCSI BDR msg was sent to target  
scsiTerminated					EQU		-7912				; -7912 = PB request terminated by the host  
scsiNoNexus						EQU		-7911				; -7911 = Nexus is not established        
scsiCDBReceived					EQU		-7910				; -7910 = The SCSI CDB has been received        
															; Couldn't begin execution  30-3F 
scsiTooManyBuses				EQU		-7888				; -7888 = Register failed because we're full 
scsiBusy						EQU		-7887				; -7887 = SCSI subsystem is busy           
scsiProvideFail					EQU		-7886				; -7886 = Unable to provide requ. capability 
scsiDeviceNotThere				EQU		-7885				; -7885 = SCSI device not installed/there    
scsiNoHBA						EQU		-7884				; -7884 = No HBA detected Error           
scsiDeviceConflict				EQU		-7883				; -7883 = sorry, max 1 refNum per DeviceIdent    
scsiNoSuchXref					EQU		-7882				; -7882 = no such RefNum xref              
scsiQLinkInvalid				EQU		-7881				; -7881 = pre-linked PBs not supported      
															;   (The QLink field was nonzero)          
															; Parameter errors  40-7F 
scsiPBLengthError				EQU		-7872				; -7872 = (scsiPBLength is insuf'ct/invalid  
scsiFunctionNotAvailable		EQU		-7871				; -7871 = The requ. func is not available    
scsiRequestInvalid				EQU		-7870				; -7870 = PB request is invalid           
scsiBusInvalid					EQU		-7869				; -7869 = Bus ID supplied is invalid        
scsiTIDInvalid					EQU		-7868				; -7868 = Target ID supplied is invalid      
scsiLUNInvalid					EQU		-7867				; -7867 = LUN supplied is invalid         
scsiIDInvalid					EQU		-7866				; -7866 = The initiator ID is invalid     
scsiDataTypeInvalid				EQU		-7865				; -7865 = scsiDataType requested not supported 
scsiTransferTypeInvalid			EQU		-7864				; -7864 = scsiTransferType field is too high     
scsiCDBLengthInvalid			EQU		-7863				; -7863 = scsiCDBLength field is too big        
;  New errors for SCSI Family         

scsiUnused74					EQU		-7862				; -7862 =                          
scsiUnused75					EQU		-7861				; -7861 =                          
scsiBadDataLength				EQU		-7860				; -7860 = a zero data length in PB        
scsiPartialPrepared				EQU		-7859				; -7859 = could not do full prepare mem for I/O
scsiInvalidMsgType				EQU		-7858				; -7858 = Invalid message type (internal)       
scsiUnused79					EQU		-7857				; -7857 =                              
scsiBadConnID					EQU		-7856				; -7856 = Bad Connection ID                
scsiUnused81					EQU		-7855				; -7855 =                          
scsiIOInProgress				EQU		-7854				; -7854 = Can't close conn, IO in prog      
scsiTargetReserved				EQU		-7853				; -7853 = Target already reserved          
scsiUnused84					EQU		-7852				; -7852 =                          
scsiUnused85					EQU		-7851				; -7851 =                          
scsiBadConnType					EQU		-7850				; -7850 = Bad connection type              
scsiCannotLoadPlugin			EQU		-7849				; -7849 = No matching service category      
;  +++ 
; 
; * scsiFamilyInternalError and scsiPluginInternalError are intended to handle consistency check failures.
; * For example, if the family stores a record on a lookaside queue, but does not find that record
; * it can use this error to report this failure. SCSI Manager 4.3 uses dsIOCoreErr in a few places,
; * but this is probably not the best error. In general, internal errors should be reported as bugs.
; *
; * The following range of errors is provided for third-party (non-Apple) SCSI SIM and device driver vendors.
; * In general, they would be used for error conditions that are not covered by the standardized errors.
; * They should not normally be conveyed to normal applications, but might be used for communication between
; * a plug-in and a vendor-provided device driver (for example, to manage RAID hot-swapping).
; *
; * Note: I don't know how many SCSI errors are reserved in the error code architecture. Don't assume that
; * we'll actually get sixteen, but we should reserve at least one.
; 


scsiFamilyInternalError			EQU		-7849				; -7849 = Internal consistency check failed  
scsiPluginInternalError			EQU		-7848				; -7848 = Internal consistency check failed  
scsiVendorSpecificErrorBase		EQU		-7808				; ??    = Start of third-party error range     
scsiVendorSpecificErrorCount	EQU		16					; Number of third-party errors             
;  --- 

scsiExecutionErrors				EQU		-7936
scsiNotExecutedErrors			EQU		-7888
scsiParameterErrors				EQU		-7872
;  Defines for the scsiResultFlags field 

scsiSIMQFrozen					EQU		$0001				; The SIM queue is frozen w/this err        
scsiAutosenseValid				EQU		$0002				; Autosense data valid for target         
scsiBusNotFree					EQU		$0004				; At time of callback, SCSI bus is not free  
;  Defines for the bit numbers of the scsiFlags field in the PB header for the SCSIExecIO function 

kbSCSIDisableAutosense			EQU		29					; Disable auto sense feature               
kbSCSIFlagReservedA				EQU		28					;                             
kbSCSIFlagReserved0				EQU		27					;                             
kbSCSICDBLinked					EQU		26					; The PB contains a linked CDB             
kbSCSIQEnable					EQU		25					; Target queue actions are enabled          
kbSCSICDBIsPointer				EQU		24					; The CDB field contains a pointer          
kbSCSIFlagReserved1				EQU		23					;                               
kbSCSIInitiateSyncData			EQU		22					; Attempt Sync data xfer and SDTR          
kbSCSIDisableSyncData			EQU		21					; Disable sync, go to async            
kbSCSISIMQHead					EQU		20					; Place PB at the head of SIM Q          
kbSCSISIMQFreeze				EQU		19					; Return the SIM Q to frozen state          
kbSCSISIMQNoFreeze				EQU		18					; Disallow SIM Q freezing                 
kbSCSIDoDisconnect				EQU		17					; Definitely do disconnect               
kbSCSIDontDisconnect			EQU		16					; Definitely don't disconnect              
kbSCSIDataReadyForDMA			EQU		15					; Data buffer(s) are ready for DMA          
kbSCSIFlagReserved3				EQU		14					;                               
kbSCSIDataPhysical				EQU		13					; SG/Buffer data ptrs are physical          
kbSCSISensePhysical				EQU		12					; Autosense buffer ptr is physical          
kbSCSIFlagReserved5				EQU		11					;                               
kbSCSIFlagReserved6				EQU		10					;                               
kbSCSIFlagReserved7				EQU		9					;                               
kbSCSIFlagReserved8				EQU		8					;                               
kbSCSIDataBufferValid			EQU		7					; Data buffer valid                 
kbSCSIStatusBufferValid			EQU		6					; Status buffer valid                 
kbSCSIMessageBufferValid		EQU		5					; Message buffer valid                
kbSCSIFlagReserved9				EQU		4					;                             
;  Defines for the bit masks of the scsiFlags field 

scsiDirectionMask				EQU		$C0000000			; Data direction mask                 
scsiDirectionNone				EQU		$C0000000			; Data direction (11: no data)          
scsiDirectionReserved			EQU		$00000000			; Data direction (00: reserved)       
scsiDirectionOut				EQU		$80000000			; Data direction (10: DATA OUT)       
scsiDirectionIn					EQU		$40000000			; Data direction (01: DATA IN)          
scsiDisableAutosense			EQU		$20000000			; Disable auto sense feature          
scsiFlagReservedA				EQU		$10000000			;                           
scsiFlagReserved0				EQU		$08000000			;                           
scsiCDBLinked					EQU		$04000000			; The PB contains a linked CDB          
scsiQEnable						EQU		$02000000			; Target queue actions are enabled      
scsiCDBIsPointer				EQU		$01000000			; The CDB field contains a pointer      
scsiFlagReserved1				EQU		$00800000			;                           
scsiInitiateSyncData			EQU		$00400000			; Attempt Sync data xfer and SDTR         
scsiDisableSyncData				EQU		$00200000			; Disable sync, go to async          
scsiSIMQHead					EQU		$00100000			; Place PB at the head of SIM Q       
scsiSIMQFreeze					EQU		$00080000			; Return the SIM Q to frozen state      
scsiSIMQNoFreeze				EQU		$00040000			; Disallow SIM Q freezing              
scsiDoDisconnect				EQU		$00020000			; Definitely do disconnect             
scsiDontDisconnect				EQU		$00010000			; Definitely don't disconnect          
scsiDataReadyForDMA				EQU		$00008000			; Data buffer(s) are ready for DMA      
scsiFlagReserved3				EQU		$00004000			;  
scsiDataPhysical				EQU		$00002000			; SG/Buffer data ptrs are physical      
scsiSensePhysical				EQU		$00001000			; Autosense buffer ptr is physical      
scsiFlagReserved5				EQU		$00000800			;                         
scsiFlagReserved6				EQU		$00000400			;                           
scsiFlagReserved7				EQU		$00000200			;                           
scsiFlagReserved8				EQU		$00000100			;                           
;  bit masks for the scsiIOFlags field in SCSIExecIOPB 

scsiNoParityCheck				EQU		$0002				; disable parity checking                 
scsiDisableSelectWAtn			EQU		$0004				; disable select w/Atn                    
scsiSavePtrOnDisconnect			EQU		$0008				; do SaveDataPointer upon Disconnect msg          
scsiNoBucketIn					EQU		$0010				; don’t bit bucket in during this I/O           
scsiNoBucketOut					EQU		$0020				; don’t bit bucket out during this I/O        
scsiDisableWide					EQU		$0040				; disable wide transfer negotiation           
scsiInitiateWide				EQU		$0080				; initiate wide transfer negotiation           
scsiRenegotiateSense			EQU		$0100				; renegotiate sync/wide before issuing autosense     
scsiDisableDiscipline			EQU		$0200				; disable parameter checking on SCSIExecIO calls 
scsiIOFlagReserved0080			EQU		$0080				;                                
scsiIOFlagReserved8000			EQU		$8000				;                                  
;  Defines for the Bus Inquiry PB fields. 
;  scsiHBAInquiry field bits 

scsiBusMDP						EQU		$80					; Supports Modify Data Pointer message               
scsiBusWide32					EQU		$40					; Supports 32 bit wide SCSI                    
scsiBusWide16					EQU		$20					; Supports 16 bit wide SCSI                    
scsiBusSDTR						EQU		$10					; Supports Sync Data Transfer Req message              
scsiBusLinkedCDB				EQU		$08					; Supports linked CDBs                         
scsiBusTagQ						EQU		$02					; Supports tag queue message                    
scsiBusSoftReset				EQU		$01					; Supports soft reset                           
;  Defines for the scsiDataType field 

scsiDataBuffer					EQU		0					; single contiguous buffer supplied            
scsiDataTIB						EQU		1					; TIB supplied (ptr in scsiDataPtr)           
scsiDataSG						EQU		2					; scatter/gather list supplied             
scsiDataIOTable					EQU		3					;#(7/11/95) Prepared by Block Storage         
;  scsiDataTypes field bits  
;   bits 0->15 Apple-defined, 16->30 3rd-party unique, 31 = reserved 

scsiBusDataTIB					EQU		$02					; TIB supplied (ptr in scsiDataPtr)   
scsiBusDataBuffer				EQU		$01					; single contiguous buffer supplied      
scsiBusDataSG					EQU		$04					; scatter/gather list supplied        
scsiBusDataIOTable				EQU		$08					; (2/6/95) Prepare Memory for IO
scsiBusDataReserved				EQU		$80000000			;                            
;  scsiScanFlags field bits 

scsiBusScansDevices				EQU		$80					; Bus scans for and maintains device list         
scsiBusScansOnInit				EQU		$40					; Bus scans performed at power-up/reboot        
scsiBusLoadsROMDrivers			EQU		$20					; may load ROM drivers to support targets       
;  scsiFeatureFlags field bits 

scsiBusLVD						EQU		$00000400			; HBA is Low Voltage Differential Bus         
scsiBusUltra3SCSI				EQU		$00000200			; HBA supports Ultra3 SCSI               
scsiBusUltra2SCSI				EQU		$00000100			; HBA supports Ultra2 SCSI               
scsiBusInternalExternalMask		EQU		$000000C0			; bus internal/external mask           
scsiBusInternalExternalUnknown	EQU		$00000000			; not known whether bus is inside or outside     
scsiBusInternalExternal			EQU		$000000C0			; bus goes inside and outside the box       
scsiBusInternal					EQU		$00000080			; bus goes inside the box                
scsiBusExternal					EQU		$00000040			; bus goes outside the box             
scsiBusCacheCoherentDMA			EQU		$00000020			; DMA is cache coherent                
scsiBusOldCallCapable			EQU		$00000010			; SIM is old call capable                
scsiBusUltraSCSI				EQU		$00000008			; HBA supports Ultra SCSI                 
scsiBusDifferential				EQU		$00000004			; Single Ended (0) or Differential (1)    
scsiBusFastSCSI					EQU		$00000002			; HBA supports fast SCSI                  
scsiBusDMAavailable				EQU		$00000001			; DMA is available                  
;  scsiWeirdStuff field bits 

scsiOddDisconnectUnsafeRead1	EQU		$0001				; Disconnects on odd byte boundries are unsafe with DMA and/or blind reads 
scsiOddDisconnectUnsafeWrite1	EQU		$0002				; Disconnects on odd byte boundries are unsafe with DMA and/or blind writes 
scsiBusErrorsUnsafe				EQU		$0004				; Non-handshaked delays or disconnects during blind transfers may cause a crash 
scsiRequiresHandshake			EQU		$0008				; Non-handshaked delays or disconnects during blind transfers may cause data corruption 
scsiTargetDrivenSDTRSafe		EQU		$0010				; Targets which initiate synchronous negotiations are supported 
scsiOddCountForPhysicalUnsafe	EQU		$0020				; If using physical addrs all counts must be even, and disconnects must be on even boundries 
scsiAbortCmdFixed				EQU		$0040				; Set if abort command is fixed to properly make callbacks 
scsiMeshACKTimingFixed			EQU		$0080				; Set if bug allowing Mesh to release ACK prematurely is fixed 
;  scsiHBAslotType values 

scsiMotherboardBus				EQU		$00					; A built in Apple supplied bus            
scsiNuBus						EQU		$01					; A SIM on a NuBus card                   
scsiPDSBus						EQU		$03					;    "  on a PDS card                    
scsiPCIBus						EQU		$04					;    "  on a PCI bus card                   
scsiPCMCIABus					EQU		$05					;    "  on a PCMCIA card                  
scsiFireWireBridgeBus			EQU		$06					;    "  connected through a FireWire bridge   
scsiUSBBus						EQU		$07					;    "  connected on a USB bus               
;  Defines for the scsiDriverFlags field (in SCSIDriverPB) 

scsiDeviceSensitive				EQU		$0001				; Only driver should access this device          
scsiDeviceNoOldCallAccess		EQU		$0002				; no old call access to this device            
;   SIMInitInfo PB 
;  directions are for SCSIRegisterBus call ( -> parm, <- result)            
SIMInitInfo				RECORD 0
SIMstaticPtr			 ds.l	1				; offset: $0 (0)		;  <- alloc. ptr to the SIM's static vars           
staticSize				 ds.l	1				; offset: $4 (4)		;  -> num bytes SIM needs for static vars           
SIMInit					 ds.l	1				; offset: $8 (8)		;  -> pointer to the SIM init routine               
SIMAction				 ds.l	1				; offset: $C (12)		;  -> pointer to the SIM action routine           
SIM_ISR					 ds.l	1				; offset: $10 (16)		;       reserved                           
SIMInterruptPoll		 ds.l	1				; offset: $14 (20)		;  -> pointer to the SIM interrupt poll routine      
NewOldCall				 ds.l	1				; offset: $18 (24)		;  -> pointer to the SIM NewOldCall routine          
ioPBSize				 ds.w	1				; offset: $1C (28)		;  -> size of SCSI_IO_PBs required for this SIM      
oldCallCapable			 ds.b	1				; offset: $1E (30)		;  -> true if this SIM can handle old-API calls      
simInfoUnused1			 ds.b	1				; offset: $1F (31)		;       reserved                             
simInternalUse			 ds.l	1				; offset: $20 (32)		;  xx not affected or viewed by XPT               
XPT_ISR					 ds.l	1				; offset: $24 (36)		;     reserved                             
EnteringSIM				 ds.l	1				; offset: $28 (40)		;  <- ptr to the EnteringSIM routine            
ExitingSIM				 ds.l	1				; offset: $2C (44)		;  <- ptr to the ExitingSIM routine               
MakeCallback			 ds.l	1				; offset: $30 (48)		;  <- the XPT layer’s SCSIMakeCallback routine            
busID					 ds.w	1				; offset: $34 (52)		;  <- bus number for the registered bus             
simSlotNumber			 ds.b	1				; offset: $36 (54)		;  <- Magic cookie to place in scsiHBASlotNumber (PCI)    
simSRsrcID				 ds.b	1				; offset: $37 (55)		;  <- Magic cookie to place in scsiSIMsRsrcID  (PCI)  
simRegEntry				 ds.l	1				; offset: $38 (56)		;  -> The SIM's RegEntryIDPtr            (PCI)  
sizeof					 EQU *					; size:   $3C (60)
						ENDR
;  Glue between SCSI calls and SCSITrap format 

xptSCSIAction					EQU		$0001
xptSCSIRegisterBus				EQU		$0002
xptSCSIDeregisterBus			EQU		$0003
xptSCSIReregisterBus			EQU		$0004
xptSCSIKillXPT					EQU		$0005				; kills Mini-XPT after transition 
xptSCSIInitialize				EQU		$000A				; Initialize the SCSI manager 
; 
; * SCSI bus status. These values are returned by the SCSI target in the status phase.
; * They are not related to Macintosh status values (except that values other than
; * scsiStatusGood will result in scsiResult set to scsiNonZeroStatus).
; 


scsiStatGood					EQU		$00					; Good Status
scsiStatCheckCondition			EQU		$02					; Check Condition
scsiStatConditionMet			EQU		$04					; Condition Met
scsiStatBusy					EQU		$08					; Busy
scsiStatIntermediate			EQU		$10					; Intermediate
scsiStatIntermedMet				EQU		$14					; Intermediate - Condition Met
scsiStatResvConflict			EQU		$18					; Reservation conflict
scsiStatTerminated				EQU		$22					; Command terminated
scsiStatQFull					EQU		$28					; Queue full
;  SCSI messages

kCmdCompleteMsg					EQU		0
kExtendedMsg					EQU		1					; 0x01
kSaveDataPointerMsg				EQU		2					; 0x02
kRestorePointersMsg				EQU		3					; 0x03
kDisconnectMsg					EQU		4					; 0x04
kInitiatorDetectedErrorMsg		EQU		5					; 0x05
kAbortMsg						EQU		6					; 0x06
kMsgRejectMsg					EQU		7					; 0x07
kNoOperationMsg					EQU		8					; 0x08
kMsgParityErrorMsg				EQU		9					; 0x09
kLinkedCmdCompleteMsg			EQU		10					; 0x0a
kLinkedCmdCompleteWithFlagMsg	EQU		11					; 0x0b
kBusDeviceResetMsg				EQU		12					; 0x0c
kAbortTagMsg					EQU		13					; 0x0d
kClearQueueMsg					EQU		14					; 0x0e
kInitiateRecoveryMsg			EQU		15					; 0x0f
kReleaseRecoveryMsg				EQU		16					; 0x10
kTerminateIOProcessMsg			EQU		17					; 0x11
kSimpleQueueTag					EQU		$20					; 0x20
kHeadOfQueueTagMsg				EQU		$21					; 0x21
kOrderedQueueTagMsg				EQU		$22					; 0x22
kIgnoreWideResidueMsg			EQU		$23					; 0x23

;  moveq #kSCSIx, D0;  _SCSIAtomic 

; *  SCSIAction()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSErr SCSIAction(SCSI_PB *parameterBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	parameterBlock  => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_SCSIAction
			moveq           	#1,D0
			dc.w            	$A089
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIAction
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  SCSIRegisterBus()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIRegisterBus(SIMInitInfo *parameterBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	parameterBlock  => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_SCSIRegisterBus
			moveq           	#2,D0
			dc.w            	$A089
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIRegisterBus
	ENDIF


; *  SCSIDeregisterBus()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIDeregisterBus(SCSI_PB *parameterBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	parameterBlock  => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_SCSIDeregisterBus
			moveq           	#3,D0
			dc.w            	$A089
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIDeregisterBus
	ENDIF


; *  SCSIReregisterBus()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIReregisterBus(SIMInitInfo *parameterBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	parameterBlock  => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_SCSIReregisterBus
			moveq           	#4,D0
			dc.w            	$A089
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIReregisterBus
	ENDIF


; *  SCSIKillXPT()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr SCSIKillXPT(SIMInitInfo *parameterBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	parameterBlock  => A0
		; returns:
		;	OSErr           <= D0
		Macro
		_SCSIKillXPT
			moveq           	#5,D0
			dc.w            	$A089
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SCSIKillXPT
	ENDIF



	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF ; __SCSI__ 


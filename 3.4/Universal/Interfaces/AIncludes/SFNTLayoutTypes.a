;
;    File:       SFNTLayoutTypes.a
;
;    Contains:   SFNT file layout structures and constants.
;
;    Version:    Technology: Mac OS 8
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  Â© 1994-2001 by Apple Computer, Inc., all rights reserved.
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__SFNTLAYOUTTYPES__') = 'UNDEFINED' THEN
__SFNTLAYOUTTYPES__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF

;  ----------------------------------------------------------------------------------------- 
;  CONSTANTS 
; 
;    The following values can be used to set run feature values. Note that unless the
;    feature is defaulted differently in different fonts, the zero value for the
;    selectors represents the default value.  Check the following URL site for further info:
;    "http://fonts.apple.com/Registry"
;




; *  Summary:
; *    Feature types
; 


kAllTypographicFeaturesType		EQU		0
kLigaturesType					EQU		1
kCursiveConnectionType			EQU		2
kLetterCaseType					EQU		3
kVerticalSubstitutionType		EQU		4
kLinguisticRearrangementType	EQU		5
kNumberSpacingType				EQU		6
kSmartSwashType					EQU		8
kDiacriticsType					EQU		9
kVerticalPositionType			EQU		10
kFractionsType					EQU		11
kOverlappingCharactersType		EQU		13
kTypographicExtrasType			EQU		14
kMathematicalExtrasType			EQU		15
kOrnamentSetsType				EQU		16
kCharacterAlternativesType		EQU		17
kDesignComplexityType			EQU		18
kStyleOptionsType				EQU		19
kCharacterShapeType				EQU		20
kNumberCaseType					EQU		21
kTextSpacingType				EQU		22
kTransliterationType			EQU		23
kAnnotationType					EQU		24
kKanaSpacingType				EQU		25
kIdeographicSpacingType			EQU		26
kUnicodeDecompositionType		EQU		27
kRubyKanaType					EQU		28
kCJKSymbolAlternativesType		EQU		29
kIdeographicAlternativesType	EQU		30
kCJKVerticalRomanPlacementType	EQU		31
kItalicCJKRomanType				EQU		32
kCJKRomanSpacingType			EQU		103
kLastFeatureType				EQU		-1


; *  Summary:
; *    Selectors for feature type kAllTypographicFeaturesType
; 


kAllTypeFeaturesOnSelector		EQU		0
kAllTypeFeaturesOffSelector		EQU		1



; *  Summary:
; *    Selectors for feature type kLigaturesType
; 


kRequiredLigaturesOnSelector	EQU		0
kRequiredLigaturesOffSelector	EQU		1
kCommonLigaturesOnSelector		EQU		2
kCommonLigaturesOffSelector		EQU		3
kRareLigaturesOnSelector		EQU		4
kRareLigaturesOffSelector		EQU		5
kLogosOnSelector				EQU		6
kLogosOffSelector				EQU		7
kRebusPicturesOnSelector		EQU		8
kRebusPicturesOffSelector		EQU		9
kDiphthongLigaturesOnSelector	EQU		10
kDiphthongLigaturesOffSelector	EQU		11
kSquaredLigaturesOnSelector		EQU		12
kSquaredLigaturesOffSelector	EQU		13
kAbbrevSquaredLigaturesOnSelector EQU	14
kAbbrevSquaredLigaturesOffSelector EQU	15
kSymbolLigaturesOnSelector		EQU		16
kSymbolLigaturesOffSelector		EQU		17


; *  Summary:
; *    Selectors for feature type kCursiveConnectionType
; 


kUnconnectedSelector			EQU		0
kPartiallyConnectedSelector		EQU		1
kCursiveSelector				EQU		2


; *  Summary:
; *    Selectors for feature type kLetterCaseType
; 


kUpperAndLowerCaseSelector		EQU		0
kAllCapsSelector				EQU		1
kAllLowerCaseSelector			EQU		2
kSmallCapsSelector				EQU		3
kInitialCapsSelector			EQU		4
kInitialCapsAndSmallCapsSelector EQU	5


; *  Summary:
; *    Selectors for feature type kVerticalSubstitutionType
; 


kSubstituteVerticalFormsOnSelector EQU	0
kSubstituteVerticalFormsOffSelector EQU	1


; *  Summary:
; *    Selectors for feature type kLinguisticRearrangementType
; 


kLinguisticRearrangementOnSelector EQU	0
kLinguisticRearrangementOffSelector EQU	1


; *  Summary:
; *    Selectors for feature type kNumberSpacingType
; 


kMonospacedNumbersSelector		EQU		0
kProportionalNumbersSelector	EQU		1
kThirdWidthNumbersSelector		EQU		2
kQuarterWidthNumbersSelector	EQU		3


; *  Summary:
; *    Selectors for feature type kSmartSwashType
; 


kWordInitialSwashesOnSelector	EQU		0
kWordInitialSwashesOffSelector	EQU		1
kWordFinalSwashesOnSelector		EQU		2
kWordFinalSwashesOffSelector	EQU		3
kLineInitialSwashesOnSelector	EQU		4
kLineInitialSwashesOffSelector	EQU		5
kLineFinalSwashesOnSelector		EQU		6
kLineFinalSwashesOffSelector	EQU		7
kNonFinalSwashesOnSelector		EQU		8
kNonFinalSwashesOffSelector		EQU		9


; *  Summary:
; *    Selectors for feature type kDiacriticsType
; 


kShowDiacriticsSelector			EQU		0
kHideDiacriticsSelector			EQU		1
kDecomposeDiacriticsSelector	EQU		2


; *  Summary:
; *    Selectors for feature type kVerticalPositionType
; 


kNormalPositionSelector			EQU		0
kSuperiorsSelector				EQU		1
kInferiorsSelector				EQU		2
kOrdinalsSelector				EQU		3


; *  Summary:
; *    Selectors for feature type kFractionsType
; 


kNoFractionsSelector			EQU		0
kVerticalFractionsSelector		EQU		1
kDiagonalFractionsSelector		EQU		2


; *  Summary:
; *    Selectors for feature type kOverlappingCharactersType
; 


kPreventOverlapOnSelector		EQU		0
kPreventOverlapOffSelector		EQU		1


; *  Summary:
; *    Selectors for feature type kTypographicExtrasType
; 


kHyphensToEmDashOnSelector		EQU		0
kHyphensToEmDashOffSelector		EQU		1
kHyphenToEnDashOnSelector		EQU		2
kHyphenToEnDashOffSelector		EQU		3
kSlashedZeroOnSelector			EQU		4
kSlashedZeroOffSelector			EQU		5
kFormInterrobangOnSelector		EQU		6
kFormInterrobangOffSelector		EQU		7
kSmartQuotesOnSelector			EQU		8
kSmartQuotesOffSelector			EQU		9
kPeriodsToEllipsisOnSelector	EQU		10
kPeriodsToEllipsisOffSelector	EQU		11


; *  Summary:
; *    Selectors for feature type kMathematicalExtrasType
; 


kHyphenToMinusOnSelector		EQU		0
kHyphenToMinusOffSelector		EQU		1
kAsteriskToMultiplyOnSelector	EQU		2
kAsteriskToMultiplyOffSelector	EQU		3
kSlashToDivideOnSelector		EQU		4
kSlashToDivideOffSelector		EQU		5
kInequalityLigaturesOnSelector	EQU		6
kInequalityLigaturesOffSelector	EQU		7
kExponentsOnSelector			EQU		8
kExponentsOffSelector			EQU		9


; *  Summary:
; *    Selectors for feature type kOrnamentSetsType
; 


kNoOrnamentsSelector			EQU		0
kDingbatsSelector				EQU		1
kPiCharactersSelector			EQU		2
kFleuronsSelector				EQU		3
kDecorativeBordersSelector		EQU		4
kInternationalSymbolsSelector	EQU		5
kMathSymbolsSelector			EQU		6


; *  Summary:
; *    Selectors for feature type kCharacterAlternativesType
; 


kNoAlternatesSelector			EQU		0


; *  Summary:
; *    Selectors for feature type kDesignComplexityType
; 


kDesignLevel1Selector			EQU		0
kDesignLevel2Selector			EQU		1
kDesignLevel3Selector			EQU		2
kDesignLevel4Selector			EQU		3
kDesignLevel5Selector			EQU		4


; *  Summary:
; *    Selectors for feature type kStyleOptionsType
; 


kNoStyleOptionsSelector			EQU		0
kDisplayTextSelector			EQU		1
kEngravedTextSelector			EQU		2
kIlluminatedCapsSelector		EQU		3
kTitlingCapsSelector			EQU		4
kTallCapsSelector				EQU		5


; *  Summary:
; *    Selectors for feature type kCharacterShapeType
; 


kTraditionalCharactersSelector	EQU		0
kSimplifiedCharactersSelector	EQU		1
kJIS1978CharactersSelector		EQU		2
kJIS1983CharactersSelector		EQU		3
kJIS1990CharactersSelector		EQU		4
kTraditionalAltOneSelector		EQU		5
kTraditionalAltTwoSelector		EQU		6
kTraditionalAltThreeSelector	EQU		7
kTraditionalAltFourSelector		EQU		8
kTraditionalAltFiveSelector		EQU		9
kExpertCharactersSelector		EQU		10


; *  Summary:
; *    Selectors for feature type kNumberCaseType
; 


kLowerCaseNumbersSelector		EQU		0
kUpperCaseNumbersSelector		EQU		1


; *  Summary:
; *    Selectors for feature type kTextSpacingType
; 


kProportionalTextSelector		EQU		0
kMonospacedTextSelector			EQU		1
kHalfWidthTextSelector			EQU		2


; *  Summary:
; *    Selectors for feature type kTransliterationType
; 


kNoTransliterationSelector		EQU		0
kHanjaToHangulSelector			EQU		1
kHiraganaToKatakanaSelector		EQU		2
kKatakanaToHiraganaSelector		EQU		3
kKanaToRomanizationSelector		EQU		4
kRomanizationToHiraganaSelector	EQU		5
kRomanizationToKatakanaSelector	EQU		6
kHanjaToHangulAltOneSelector	EQU		7
kHanjaToHangulAltTwoSelector	EQU		8
kHanjaToHangulAltThreeSelector	EQU		9


; *  Summary:
; *    Selectors for feature type kAnnotationType
; 


kNoAnnotationSelector			EQU		0
kBoxAnnotationSelector			EQU		1
kRoundedBoxAnnotationSelector	EQU		2
kCircleAnnotationSelector		EQU		3
kInvertedCircleAnnotationSelector EQU	4
kParenthesisAnnotationSelector	EQU		5
kPeriodAnnotationSelector		EQU		6
kRomanNumeralAnnotationSelector	EQU		7
kDiamondAnnotationSelector		EQU		8
kInvertedBoxAnnotationSelector	EQU		9
kInvertedRoundedBoxAnnotationSelector EQU 10


; *  Summary:
; *    Selectors for feature type kKanaSpacingType
; 


kFullWidthKanaSelector			EQU		0
kProportionalKanaSelector		EQU		1


; *  Summary:
; *    Selectors for feature type kIdeographicSpacingType
; 


kFullWidthIdeographsSelector	EQU		0
kProportionalIdeographsSelector	EQU		1
kHalfWidthIdeographsSelector	EQU		2


; *  Summary:
; *    Selectors for feature type kUnicodeDecompositionType
; 


kCanonicalCompositionOnSelector	EQU		0
kCanonicalCompositionOffSelector EQU	1
kCompatibilityCompositionOnSelector EQU	2
kCompatibilityCompositionOffSelector EQU 3
kTranscodingCompositionOnSelector EQU	4
kTranscodingCompositionOffSelector EQU	5


; *  Summary:
; *    Selectors for feature type kRubyKanaType
; 


kNoRubyKanaSelector				EQU		0
kRubyKanaSelector				EQU		1


; *  Summary:
; *    Selectors for feature type kCJKSymbolAlternativesType
; 


kNoCJKSymbolAlternativesSelector EQU	0
kCJKSymbolAltOneSelector		EQU		1
kCJKSymbolAltTwoSelector		EQU		2
kCJKSymbolAltThreeSelector		EQU		3
kCJKSymbolAltFourSelector		EQU		4
kCJKSymbolAltFiveSelector		EQU		5


; *  Summary:
; *    Selectors for feature type kIdeographicAlternativesType
; 


kNoIdeographicAlternativesSelector EQU	0
kIdeographicAltOneSelector		EQU		1
kIdeographicAltTwoSelector		EQU		2
kIdeographicAltThreeSelector	EQU		3
kIdeographicAltFourSelector		EQU		4
kIdeographicAltFiveSelector		EQU		5


; *  Summary:
; *    Selectors for feature type kCJKVerticalRomanPlacementType
; 


kCJKVerticalRomanCenteredSelector EQU	0
kCJKVerticalRomanHBaselineSelector EQU	1


; *  Summary:
; *    Selectors for feature type kItalicCJKRomanType
; 


kNoCJKItalicRomanSelector		EQU		0
kCJKItalicRomanSelector			EQU		1


; *  Summary:
; *    Selectors for feature type kCJKRomanSpacingType
; 


kHalfWidthCJKRomanSelector		EQU		0
kProportionalCJKRomanSelector	EQU		1
kDefaultCJKRomanSelector		EQU		2
kFullWidthCJKRomanSelector		EQU		3
;  --------------------------------------------------------------------------- 
;  ---------------- Table Specific Typedefs and Constants -------------------- 
;  --------------------------------------------------------------------------- 
;  FORMATS FOR TABLE: lookup tables - used within various other tables 

kSFNTLookupSimpleArray			EQU		0					; a simple array indexed by glyph code 
kSFNTLookupSegmentSingle		EQU		2					; segment mapping to single value 
kSFNTLookupSegmentArray			EQU		4					; segment mapping to lookup array 
kSFNTLookupSingleTable			EQU		6					; sorted list of glyph, value pairs 
kSFNTLookupTrimmedArray			EQU		8					; a simple trimmed array indexed by glyph code 
; typedef UInt16 						SFNTLookupTableFormat

; typedef UInt16 						SFNTLookupValue

; typedef UInt16 						SFNTLookupOffset

; typedef UInt32 						SFNTLookupKind

; 
;    A BinarySearchHeader defines the five standard fields needed to perform quick
;    lookups in a lookup table (note that using UInt16s, and not ItemCounts or
;    similar types, is important here, since these tables are in fonts, and the
;    documented font formats specify 16-bit quantities).
;

SFNTLookupBinarySearchHeader RECORD 0
unitSize				 ds.w	1				; offset: $0 (0)		;  size of a unit in bytes 
nUnits					 ds.w	1				; offset: $2 (2)		;  number of units in table 
searchRange				 ds.w	1				; offset: $4 (4)		;  (largest power of two <= nUnits) * unitSize 
entrySelector			 ds.w	1				; offset: $6 (6)		;  log2 (largest power of two <= nUnits) 
rangeShift				 ds.w	1				; offset: $8 (8)		;  (nUnits - largest power of two <= nUnits) * unitSize 
sizeof					 EQU *					; size:   $A (10)
						ENDR
;  A format 0 lookup table maps all glyphs in the font to lookup values 
SFNTLookupArrayHeader	RECORD 0
lookupValues			 ds.w	1				; offset: $0 (0) <-- really an array of length one
sizeof					 EQU *					; size:   $2 (2)
						ENDR
;  A format 8 lookup table maps some range of glyphs in the font to lookup values 
SFNTLookupTrimmedArrayHeader RECORD 0
firstGlyph				 ds.w	1				; offset: $0 (0)
count					 ds.w	1				; offset: $2 (2)
valueArray				 ds.w	1				; offset: $4 (4) <-- really an array of length one
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; 
;    Format 2 and format 4 lookup tables map ranges of glyphs to either single lookup
;    values (format 2), or per-glyph lookup values (format 4). Since both formats
;    use the same kind of data, only one unified set of segment-related structures
;    is defined.
;

SFNTLookupSegment		RECORD 0
lastGlyph				 ds.w	1				; offset: $0 (0)
firstGlyph				 ds.w	1				; offset: $2 (2)
value					 ds.w	1				; offset: $4 (4) <-- really an array of length one
sizeof					 EQU *					; size:   $6 (6)
						ENDR
SFNTLookupSegmentHeader	RECORD 0
binSearch				 ds		SFNTLookupBinarySearchHeader ; offset: $0 (0)
segments				 ds		SFNTLookupSegment ; offset: $A (10) <-- really an array of length one
sizeof					 EQU *					; size:   $10 (16)
						ENDR
;  A format 6 lookup table maps single glyphs to lookup values. 
SFNTLookupSingle		RECORD 0
glyph					 ds.w	1				; offset: $0 (0)
value					 ds.w	1				; offset: $2 (2) <-- really an array of length one
sizeof					 EQU *					; size:   $4 (4)
						ENDR
SFNTLookupSingleHeader	RECORD 0
binSearch				 ds		SFNTLookupBinarySearchHeader ; offset: $0 (0)
entries					 ds		SFNTLookupSingle ; offset: $A (10) <-- really an array of length one
sizeof					 EQU *					; size:   $E (14)
						ENDR
;  The format-specific part of the subtable header 
SFNTLookupFormatSpecificHeader RECORD 0
theArray				 ds		SFNTLookupArrayHeader ; offset: $0 (0)
						 ORG 0
segment					 ds		SFNTLookupSegmentHeader ; offset: $0 (0)
						 ORG 0
single					 ds		SFNTLookupSingleHeader ; offset: $0 (0)
						 ORG 0
trimmedArray			 ds		SFNTLookupTrimmedArrayHeader ; offset: $0 (0)
						 ORG 16
sizeof					 EQU *					; size:   $10 (16)
						ENDR
;  The overall subtable header 
SFNTLookupTable			RECORD 0
format					 ds.w	1				; offset: $0 (0)		;  table format 
fsHeader				 ds		SFNTLookupFormatSpecificHeader ; offset: $2 (2) ;  format specific header 
sizeof					 EQU *					; size:   $12 (18)
						ENDR
; typedef struct SFNTLookupTable *		SFNTLookupTablePtr

; typedef SFNTLookupTablePtr *			SFNTLookupTableHandle

;  --------------------------------------------------------------------------- 
;  GENERAL FORMATS FOR STATE TABLES -- prefix "ST" 

kSTClassEndOfText				EQU		0
kSTClassOutOfBounds				EQU		1
kSTClassDeletedGlyph			EQU		2
kSTClassEndOfLine				EQU		3
kSTSetMark						EQU		$8000
kSTNoAdvance					EQU		$4000
kSTMarkEnd						EQU		$2000
kSTLigActionMask				EQU		$3FFF
kSTRearrVerbMask				EQU		$000F
; typedef UInt8 						STClass

; typedef UInt8 						STEntryIndex

STHeader				RECORD 0
filler					 ds.b	1				; offset: $0 (0)
nClasses				 ds.b	1				; offset: $1 (1)
classTableOffset		 ds.w	1				; offset: $2 (2)
stateArrayOffset		 ds.w	1				; offset: $4 (4)
entryTableOffset		 ds.w	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
STClassTable			RECORD 0
firstGlyph				 ds.w	1				; offset: $0 (0)
nGlyphs					 ds.w	1				; offset: $2 (2)
classes					 ds.b	1				; offset: $4 (4) <-- really an array of length one
						 ORG 6
sizeof					 EQU *					; size:   $6 (6)
						ENDR
STEntryZero				RECORD 0
newState				 ds.w	1				; offset: $0 (0)
flags					 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
STEntryOne				RECORD 0
newState				 ds.w	1				; offset: $0 (0)
flags					 ds.w	1				; offset: $2 (2)
offset1					 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
STEntryTwo				RECORD 0
newState				 ds.w	1				; offset: $0 (0)
flags					 ds.w	1				; offset: $2 (2)
offset1					 ds.w	1				; offset: $4 (4)
offset2					 ds.w	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  --------------------------------------------------------------------------- 
;  GENERAL FORMATS FOR STATE TABLES to be used with 'morx' tables -- prefix "STX" 

kSTXHasLigAction				EQU		$2000
; typedef UInt16 						STXClass

; typedef UInt16 						STXStateIndex

; typedef UInt16 						STXEntryIndex

STXHeader				RECORD 0
nClasses				 ds.l	1				; offset: $0 (0)
classTableOffset		 ds.l	1				; offset: $4 (4)
stateArrayOffset		 ds.l	1				; offset: $8 (8)
entryTableOffset		 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
STXClassTable			RECORD 0
f						 ds		SFNTLookupTable
sizeof					 EQU *					; size:   $12 (18)
						ENDR


STXEntryZero			RECORD 0
newState				 ds.w	1				; offset: $0 (0)
flags					 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
STXEntryOne				RECORD 0
newState				 ds.w	1				; offset: $0 (0)
flags					 ds.w	1				; offset: $2 (2)
index1					 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
STXEntryTwo				RECORD 0
newState				 ds.w	1				; offset: $0 (0)
flags					 ds.w	1				; offset: $2 (2)
index1					 ds.w	1				; offset: $4 (4)
index2					 ds.w	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  --------------------------------------------------------------------------- 
;  FORMATS FOR TABLE: 'lcar' 
;  CONSTANTS 

kLCARTag						EQU		$6C636172			; 'lcar' 
kLCARCurrentVersion				EQU		$00010000			; current version number for 'lcar' table 
kLCARLinearFormat				EQU		0
kLCARCtlPointFormat				EQU		1
;  TYPES 
LcarCaretClassEntry		RECORD 0
count					 ds.w	1				; offset: $0 (0)
partials				 ds.w	1				; offset: $2 (2) <-- really an array of length one ;  these are either FUnits or control-point numbers 
sizeof					 EQU *					; size:   $4 (4)
						ENDR
LcarCaretTable			RECORD 0
version					 ds.l	1				; offset: $0 (0)
format					 ds.w	1				; offset: $4 (4)
lookup					 ds		SFNTLookupTable ; offset: $6 (6)
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct LcarCaretTable *		LcarCaretTablePtr

;  --------------------------------------------------------------------------- 
;  FORMATS FOR TABLE: 'just' 
;  CONSTANTS 

kJUSTTag						EQU		$6A757374			; 'just' 
kJUSTCurrentVersion				EQU		$00010000
kJUSTStandardFormat				EQU		0
kJUSTnoGlyphcode				EQU		$FFFF				; used in a pcConditionalAddAction 
kJUSTpcDecompositionAction		EQU		0
kJUSTpcUnconditionalAddAction	EQU		1
kJUSTpcConditionalAddAction		EQU		2
kJUSTpcGlyphStretchAction		EQU		3
kJUSTpcDuctilityAction			EQU		4
kJUSTpcGlyphRepeatAddAction		EQU		5
;  Justification priority levels 

kJUSTKashidaPriority			EQU		0
kJUSTSpacePriority				EQU		1
kJUSTLetterPriority				EQU		2
kJUSTNullPriority				EQU		3
kJUSTPriorityCount				EQU		4
;  Justification flags 

kJUSTOverridePriority			EQU		$8000
kJUSTOverrideLimits				EQU		$4000
kJUSTOverrideUnlimited			EQU		$2000
kJUSTUnlimited					EQU		$1000
kJUSTPriorityMask				EQU		$0003
;  TYPES 
; typedef UInt16 						JustPCActionType

; typedef UInt16 						JustificationFlags

;  A JustPCDecompositionAction defines a ligature decomposition action. 
JustPCDecompositionAction RECORD 0
lowerLimit				 ds.l	1				; offset: $0 (0)
upperLimit				 ds.l	1				; offset: $4 (4)
order					 ds.w	1				; offset: $8 (8)
count					 ds.w	1				; offset: $A (10)
glyphs					 ds.w	1				; offset: $C (12) <-- really an array of length one
sizeof					 EQU *					; size:   $E (14)
						ENDR
;  A JUSTPCUnconditionalAddAction defines an unconditional glyph add action. 
; typedef UInt16 						JustPCUnconditionalAddAction

; 
;    A JUSTPCConditionalAddAction defines a glyph substitution and add action. If the addGlyph
;    is equal to kJUSTnoGlyphcode, then no glyph will be added, and the justification for
;    the line will be redone.
;

JustPCConditionalAddAction RECORD 0
substThreshhold			 ds.l	1				; offset: $0 (0)		;  threshhold of growth factor at which subst occurs 
addGlyph				 ds.w	1				; offset: $4 (4)
substGlyph				 ds.w	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  A PCDuctilityAction defines a ductile axis along which the glyph will be varied. 
JustPCDuctilityAction	RECORD 0
ductilityAxis			 ds.l	1				; offset: $0 (0)
minimumLimit			 ds.l	1				; offset: $4 (4)
noStretchValue			 ds.l	1				; offset: $8 (8)
maximumLimit			 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; 
;    A PCGlyphRepetitionAction defines a glyph which will not be stretched or otherwise
;    transformed, but rather which will be emplaced however many times are needed to fill
;    the needed gap.
;

JustPCGlyphRepeatAddAction RECORD 0
flags					 ds.w	1				; offset: $0 (0)
glyph					 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
;  PCActionSubrecords contain the actual postcompensation actions. 
JustPCActionSubrecord	RECORD 0
theClass				 ds.w	1				; offset: $0 (0)		;  justification class value associated with this rec 
theType					 ds.w	1				; offset: $2 (2)
length					 ds.l	1				; offset: $4 (4)
data					 ds.l	1				; offset: $8 (8)		;  not really a UInt32; cast as ptr to appropriate action 
sizeof					 EQU *					; size:   $C (12)
						ENDR
;  The set of postcompensation records is defined in a PCAction struct. 
JustPCAction			RECORD 0
actionCount				 ds.l	1				; offset: $0 (0)		;  long for alignment purposes 
actions					 ds		JustPCActionSubrecord ; offset: $4 (4) <-- really an array of length one
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; 
;    JustWidthDeltaEntry is the justification table entry structure.  The justClass value (which is
;    actually limited to 7 bits by the state table structure) is defined as a long for PPC alignment reasons.
;

JustWidthDeltaEntry		RECORD 0
justClass				 ds.l	1				; offset: $0 (0)
beforeGrowLimit			 ds.l	1				; offset: $4 (4)		;  ems AW can grow by at most on LT 
beforeShrinkLimit		 ds.l	1				; offset: $8 (8)		;  ems AW can shrink by at most on LT 
afterGrowLimit			 ds.l	1				; offset: $C (12)		;  ems AW can grow by at most on RB 
afterShrinkLimit		 ds.l	1				; offset: $10 (16)		;  ems AW can shrink by at most on RB 
growFlags				 ds.w	1				; offset: $14 (20)		;  flags controlling grow case 
shrinkFlags				 ds.w	1				; offset: $16 (22)		;  flags controlling shrink case 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
JustWidthDeltaGroup		RECORD 0
count					 ds.l	1				; offset: $0 (0)
entries					 ds		JustWidthDeltaEntry ; offset: $4 (4) <-- really an array of length one
sizeof					 EQU *					; size:   $1C (28)
						ENDR
;  Overall structure of a postcompensation table is defined in PostcompTable. 
JustPostcompTable		RECORD 0
lookupTable				 ds		SFNTLookupTable ; offset: $0 (0)
;  action records here 
sizeof					 EQU *					; size:   $12 (18)
						ENDR
JustDirectionTable		RECORD 0
justClass				 ds.w	1				; offset: $0 (0)		;  offset to state table (0=none) 
widthDeltaClusters		 ds.w	1				; offset: $2 (2)		;  offset to clusters 
postcomp				 ds.w	1				; offset: $4 (4)		;  offset to postcomp table (0=none) 
lookup					 ds		SFNTLookupTable ; offset: $6 (6)
sizeof					 EQU *					; size:   $18 (24)
						ENDR
JustTable				RECORD 0
version					 ds.l	1				; offset: $0 (0)
format					 ds.w	1				; offset: $4 (4)
horizHeaderOffset		 ds.w	1				; offset: $6 (6)
vertHeaderOffset		 ds.w	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $A (10)
						ENDR
;  --------------------------------------------------------------------------- 
;  FORMATS FOR TABLE: 'opbd' 
;  CONSTANTS 

kOPBDTag						EQU		$6F706264			; 'opbd' 
kOPBDCurrentVersion				EQU		$00010000
kOPBDDistanceFormat				EQU		0
kOPBDControlPointFormat			EQU		1
;  TYPES 
; typedef UInt16 						OpbdTableFormat

; 
;    The OpbdSideValues struct is the lookup result from the FindSingle call for the
;    optical tables. It contains the 4 FUnit values that are relevant to the specified
;    glyph, or the 4 control gxPoint values.
;

OpbdSideValues			RECORD 0
leftSideShift			 ds.w	1				; offset: $0 (0)
topSideShift			 ds.w	1				; offset: $2 (2)
rightSideShift			 ds.w	1				; offset: $4 (4)
bottomSideShift			 ds.w	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
OpbdTable				RECORD 0
version					 ds.l	1				; offset: $0 (0)
format					 ds.w	1				; offset: $4 (4)
lookupTable				 ds		SFNTLookupTable ; offset: $6 (6)
sizeof					 EQU *					; size:   $18 (24)
						ENDR
;  --------------------------------------------------------------------------- 
;  FORMATS FOR TABLE: 'mort' 
;  CONSTANTS 

kMORTTag						EQU		$6D6F7274			; 'mort' 
kMORTCurrentVersion				EQU		$00010000			; current version number for 'mort' table 
															; Coverage masks 
kMORTCoverVertical				EQU		$8000
kMORTCoverDescending			EQU		$4000
kMORTCoverIgnoreVertical		EQU		$2000
kMORTCoverTypeMask				EQU		$000F				; Subtable types 
kMORTRearrangementType			EQU		0
kMORTContextualType				EQU		1
kMORTLigatureType				EQU		2
kMORTSwashType					EQU		4
kMORTInsertionType				EQU		5					; Ligature subtable constants 
kMORTLigLastAction				EQU		$80000000
kMORTLigStoreLigature			EQU		$40000000
kMORTLigFormOffsetMask			EQU		$3FFFFFFF
kMORTLigFormOffsetShift			EQU		2					; Rearrangement subtable actions 
kMORTraNoAction					EQU		0					;    no action   
kMORTraxA						EQU		1					;      Ax => xA    
kMORTraDx						EQU		2					;      xD => Dx    
kMORTraDxA						EQU		3					;     AxD => DxA   
kMORTraxAB						EQU		4					;   ABx => xAB   
kMORTraxBA						EQU		5					;   ABx => xBA   
kMORTraCDx						EQU		6					;   xCD => CDx   
kMORTraDCx						EQU		7					;   xCD => DCx   
kMORTraCDxA						EQU		8					;  AxCD => CDxA  
kMORTraDCxA						EQU		9					;  AxCD => DCxA  
kMORTraDxAB						EQU		10					;  ABxD => DxAB  
kMORTraDxBA						EQU		11					;  ABxD => DxBA  
kMORTraCDxAB					EQU		12					; ABxCD => CDxAB 
kMORTraCDxBA					EQU		13					; ABxCD => CDxBA 
kMORTraDCxAB					EQU		14					; ABxCD => DCxAB 
kMORTraDCxBA					EQU		15					; ABxCD => DCxBA 
															; Insertion subtable constants 
kMORTDoInsertionsBefore			EQU		$80
kMORTIsSplitVowelPiece			EQU		$40
kMORTInsertionsCountMask		EQU		$3F
kMORTCurrInsertKashidaLike		EQU		$2000
kMORTMarkInsertKashidaLike		EQU		$1000
kMORTCurrInsertBefore			EQU		$0800
kMORTMarkInsertBefore			EQU		$0400
kMORTMarkJustTableCountMask		EQU		$3F80
kMORTMarkJustTableCountShift	EQU		7					; JustTableIndex for marked character 
kMORTCurrJustTableCountMask		EQU		$007F
kMORTCurrJustTableCountShift	EQU		0					; JustTableIndex for current character 
kMORTCurrInsertCountMask		EQU		$03E0
kMORTCurrInsertCountShift		EQU		5					; count to insert after current glyphRec 
kMORTMarkInsertCountMask		EQU		$001F
kMORTMarkInsertCountShift		EQU		0					; count to insert after marked glyphRec 
;  TYPES 
; typedef UInt32 						MortSubtableMaskFlags

; typedef UInt32 						MortLigatureActionEntry

MortRearrangementSubtable RECORD 0
header					 ds		STHeader		; offset: $0 (0)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
MortContextualSubtable	RECORD 0
header					 ds		STHeader		; offset: $0 (0)
substitutionTableOffset	 ds.w	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $A (10)
						ENDR
MortLigatureSubtable	RECORD 0
header					 ds		STHeader		; offset: $0 (0)
ligatureActionTableOffset  ds.w	1				; offset: $8 (8)
componentTableOffset	 ds.w	1				; offset: $A (10)
ligatureTableOffset		 ds.w	1				; offset: $C (12)
sizeof					 EQU *					; size:   $E (14)
						ENDR
MortSwashSubtable		RECORD 0
lookup					 ds		SFNTLookupTable ; offset: $0 (0)
sizeof					 EQU *					; size:   $12 (18)
						ENDR
MortInsertionSubtable	RECORD 0
header					 ds		STHeader		; offset: $0 (0)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
MortSpecificSubtable	RECORD 0
rearrangement			 ds		MortRearrangementSubtable ; offset: $0 (0)
						 ORG 0
contextual				 ds		MortContextualSubtable ; offset: $0 (0)
						 ORG 0
ligature				 ds		MortLigatureSubtable ; offset: $0 (0)
						 ORG 0
swash					 ds		MortSwashSubtable ; offset: $0 (0)
						 ORG 0
insertion				 ds		MortInsertionSubtable ; offset: $0 (0)
						 ORG 18
sizeof					 EQU *					; size:   $12 (18)
						ENDR
MortSubtable			RECORD 0
length					 ds.w	1				; offset: $0 (0)
coverage				 ds.w	1				; offset: $2 (2)
flags					 ds.l	1				; offset: $4 (4)
u						 ds		MortSpecificSubtable ; offset: $8 (8)
sizeof					 EQU *					; size:   $1A (26)
						ENDR
MortFeatureEntry		RECORD 0
featureType				 ds.w	1				; offset: $0 (0)
featureSelector			 ds.w	1				; offset: $2 (2)
enableFlags				 ds.l	1				; offset: $4 (4)
disableFlags			 ds.l	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $C (12)
						ENDR
MortChain				RECORD 0
defaultFlags			 ds.l	1				; offset: $0 (0)		;  default flags for this chain 
length					 ds.l	1				; offset: $4 (4)		;  byte length of this chain 
nFeatures				 ds.w	1				; offset: $8 (8)		;  number of feature entries 
nSubtables				 ds.w	1				; offset: $A (10)		;  number of subtables 
featureEntries			 ds		MortFeatureEntry ; offset: $C (12) <-- really an array of length one
;  the subtables follow 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
MortTable				RECORD 0
version					 ds.l	1				; offset: $0 (0)
nChains					 ds.l	1				; offset: $4 (4)
chains					 ds		MortChain		; offset: $8 (8) <-- really an array of length one
sizeof					 EQU *					; size:   $20 (32)
						ENDR
;  --------------------------------------------------------------------------- 
;  FORMATS FOR TABLE: 'morx' (version 2 and beyond metamorphosis tables) 
;  CONSTANTS 

kMORXTag						EQU		$6D6F7278			; 'morx' 
kMORXCurrentVersion				EQU		$00020000			; version number for current 'morx' table 
															; Coverage masks 
kMORXCoverVertical				EQU		$80000000
kMORXCoverDescending			EQU		$40000000
kMORXCoverIgnoreVertical		EQU		$20000000
kMORXCoverTypeMask				EQU		$000000FF
;  TYPES 
MorxRearrangementSubtable RECORD 0
header					 ds		STXHeader		; offset: $0 (0)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
MorxContextualSubtable	RECORD 0
header					 ds		STXHeader		; offset: $0 (0)
substitutionTableOffset	 ds.l	1				; offset: $10 (16)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
MorxLigatureSubtable	RECORD 0
header					 ds		STXHeader		; offset: $0 (0)
ligatureActionTableOffset  ds.l	1				; offset: $10 (16)
componentTableOffset	 ds.l	1				; offset: $14 (20)
ligatureTableOffset		 ds.l	1				; offset: $18 (24)
sizeof					 EQU *					; size:   $1C (28)
						ENDR
MorxInsertionSubtable	RECORD 0
header					 ds		STXHeader		; offset: $0 (0)
insertionGlyphTableOffset  ds.l	1				; offset: $10 (16)
sizeof					 EQU *					; size:   $14 (20)
						ENDR
MorxSpecificSubtable	RECORD 0
rearrangement			 ds		MorxRearrangementSubtable ; offset: $0 (0)
						 ORG 0
contextual				 ds		MorxContextualSubtable ; offset: $0 (0)
						 ORG 0
ligature				 ds		MorxLigatureSubtable ; offset: $0 (0)
						 ORG 0
swash					 ds		MortSwashSubtable ; offset: $0 (0)
						 ORG 0
insertion				 ds		MorxInsertionSubtable ; offset: $0 (0)
						 ORG 28
sizeof					 EQU *					; size:   $1C (28)
						ENDR
MorxSubtable			RECORD 0
length					 ds.l	1				; offset: $0 (0)
coverage				 ds.l	1				; offset: $4 (4)
flags					 ds.l	1				; offset: $8 (8)
u						 ds		MorxSpecificSubtable ; offset: $C (12)
sizeof					 EQU *					; size:   $28 (40)
						ENDR
MorxChain				RECORD 0
defaultFlags			 ds.l	1				; offset: $0 (0)		;  default flags for this chain 
length					 ds.l	1				; offset: $4 (4)		;  byte length of this chain 
nFeatures				 ds.l	1				; offset: $8 (8)		;  number of feature entries 
nSubtables				 ds.l	1				; offset: $C (12)		;  number of subtables 
featureEntries			 ds		MortFeatureEntry ; offset: $10 (16) <-- really an array of length one
;  the subtables follow 
sizeof					 EQU *					; size:   $1C (28)
						ENDR
MorxTable				RECORD 0
version					 ds.l	1				; offset: $0 (0)
nChains					 ds.l	1				; offset: $4 (4)
chains					 ds		MorxChain		; offset: $8 (8) <-- really an array of length one
sizeof					 EQU *					; size:   $24 (36)
						ENDR
;  --------------------------------------------------------------------------- 
;  FORMATS FOR TABLE: 'prop' 
;  CONSTANTS 

kPROPTag						EQU		$70726F70			; 'prop' 
kPROPCurrentVersion				EQU		$00020000			; current version number for 'prop' table 
kPROPPairOffsetShift			EQU		8
kPROPPairOffsetSign				EQU		7
kPROPIsFloaterMask				EQU		$8000				; glyph is floater 
kPROPCanHangLTMask				EQU		$4000				; glyph can hang left/top 
kPROPCanHangRBMask				EQU		$2000				; glyph can hang right/bottom 
kPROPUseRLPairMask				EQU		$1000				; if glyph lands in RL streak, use paired glyph 
kPROPPairOffsetMask				EQU		$0F00				; 4-bit signed offset to other pair member 
kPROPRightConnectMask			EQU		$0080				; glyph connects to glyph on right 
kPROPZeroReserved				EQU		$0060				; must be zero 
kPROPDirectionMask				EQU		$001F				; direction bits 
;  These are the Unicode direction classes (plus the Special European Number class). 

kPROPLDirectionClass			EQU		0					; Left-to-Right 
kPROPRDirectionClass			EQU		1					; Right-to-Left 
kPROPALDirectionClass			EQU		2					; Right-to-Left Arabic Letter 
kPROPENDirectionClass			EQU		3					; European Number 
kPROPESDirectionClass			EQU		4					; European Number Seperator 
kPROPETDirectionClass			EQU		5					; European Number Terminator 
kPROPANDirectionClass			EQU		6					; Arabic Number 
kPROPCSDirectionClass			EQU		7					; Common Number Seperator 
kPROPPSDirectionClass			EQU		8					; Paragraph Seperator (also referred to as Block Separator) 
kPROPSDirectionClass			EQU		9					; Segment Seperator 
kPROPWSDirectionClass			EQU		10					; Whitespace 
kPROPONDirectionClass			EQU		11					; Other Neutral 
kPROPSENDirectionClass			EQU		12					; Special European Number (not a Unicode class) 
kPROPLREDirectionClass			EQU		13					; Left-to-Right Embeding 
kPROPLRODirectionClass			EQU		14					; Left-to-Right Override 
kPROPRLEDirectionClass			EQU		15					; Right-to-Left Embeding 
kPROPRLODirectionClass			EQU		16					; Right-to-Left Override 
kPROPPDFDirectionClass			EQU		17					; Pop Directional Format 
kPROPNSMDirectionClass			EQU		18					; Non-Spacing Mark 
kPROPBNDirectionClass			EQU		19					; Boundary Neutral 
kPROPNumDirectionClasses		EQU		20					; Number of Unicode directional types + Special European Number 
;  TYPES 
; typedef UInt16 						PropCharProperties

PropTable				RECORD 0
version					 ds.l	1				; offset: $0 (0)
format					 ds.w	1				; offset: $4 (4)
defaultProps			 ds.w	1				; offset: $6 (6)
lookup					 ds		SFNTLookupTable ; offset: $8 (8)
sizeof					 EQU *					; size:   $1A (26)
						ENDR
PropLookupSegment		RECORD 0
lastGlyph				 ds.w	1				; offset: $0 (0)
firstGlyph				 ds.w	1				; offset: $2 (2)
value					 ds.w	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $6 (6)
						ENDR
PropLookupSingle		RECORD 0
glyph					 ds.w	1				; offset: $0 (0)
props					 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
;  --------------------------------------------------------------------------- 
;  FORMATS FOR TABLE: 'trak' 
;  CONSTANTS 

kTRAKTag						EQU		$7472616B			; 'trak' 
kTRAKCurrentVersion				EQU		$00010000			; current version number for 'trak' table 
kTRAKUniformFormat				EQU		0					;    kTRAKPerGlyphFormat         = 2
;  TYPES 
; typedef SInt16 						TrakValue

TrakTableEntry			RECORD 0
track					 ds.l	1				; offset: $0 (0)
nameTableIndex			 ds.w	1				; offset: $4 (4)
sizesOffset				 ds.w	1				; offset: $6 (6)		;  offset to array of TrackingValues 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
TrakTableData			RECORD 0
nTracks					 ds.w	1				; offset: $0 (0)
nSizes					 ds.w	1				; offset: $2 (2)
sizeTableOffset			 ds.l	1				; offset: $4 (4)
trakTable				 ds		TrakTableEntry ; offset: $8 (8) <-- really an array of length one
sizeof					 EQU *					; size:   $10 (16)
						ENDR
TrakTable				RECORD 0
version					 ds.l	1				; offset: $0 (0)
format					 ds.w	1				; offset: $4 (4)
horizOffset				 ds.w	1				; offset: $6 (6)
vertOffset				 ds.w	1				; offset: $8 (8)
sizeof					 EQU *					; size:   $A (10)
						ENDR
;  --------------------------------------------------------------------------- 
;  FORMATS FOR TABLE: 'kern' 
;  CONSTANTS 

kKERNTag						EQU		$6B65726E			; 'kern' 
kKERNCurrentVersion				EQU		$00010000
kKERNVertical					EQU		$8000				; set if this table has vertical kerning information 
kKERNResetCrossStream			EQU		$8000				; this value in a cross-stream table means reset to zero 
kKERNCrossStream				EQU		$4000				; set if this table contains cross-stream kerning values 
kKERNVariation					EQU		$2000				; set if this table contains variation kerning values 
kKERNUnusedBits					EQU		$1F00				; UNUSED, MUST BE ZERO 
kKERNFormatMask					EQU		$00FF				; format of this subtable 

kKERNOrderedList				EQU		0					; ordered list of kerning pairs 
kKERNStateTable					EQU		1					; state table for n-way contextual kerning 
kKERNSimpleArray				EQU		2					; simple n X m array of kerning values 
kKERNIndexArray					EQU		3					; modifed version of SimpleArray 
;  Message Type Flags 

kKERNLineStart					EQU		$00000001			; Array of glyphs starts a line 
kKERNLineEndKerning				EQU		$00000002			; Array of glyphs ends a line 
kKERNNoCrossKerning				EQU		$00000004			; Prohibit cross kerning 
kKERNNotesRequested				EQU		$00000008			; Caller wants kerning notes 
kKERNNoStakeNote				EQU		1					; Indicates a glyph was involved in a kerning pair/group 
kKERNCrossStreamResetNote		EQU		2					; Indicates a return-to-baseline in cross-stream kerning 
kKERNNotApplied					EQU		$00000001			; All kerning values were zero, kerning call had no effect 
;  TYPES 
; typedef UInt8 						KernTableFormat

; typedef UInt16 						KernSubtableInfo

; typedef SInt16 						KernKerningValue

; typedef UInt16 						KernArrayOffset

;  header for version 0 kerning table 
KernVersion0Header		RECORD 0
version					 ds.w	1				; offset: $0 (0)		;  font version number (will be 0!) 
nTables					 ds.w	1				; offset: $2 (2)		;  number of subtables present 
firstSubtable			 ds.w	1				; offset: $4 (4) <-- really an array of length one ;  first subtable starts here 
sizeof					 EQU *					; size:   $6 (6)
						ENDR
;  Header for a kerning table 
KernTableHeader			RECORD 0
version					 ds.l	1				; offset: $0 (0)		;  font version number (currently 1.0) 
nTables					 ds.l	1				; offset: $4 (4)		;  number of subtables present 
firstSubtable			 ds.w	1				; offset: $8 (8) <-- really an array of length one ;  first subtable starts here 
sizeof					 EQU *					; size:   $A (10)
						ENDR
; typedef struct KernTableHeader *		KernTableHeaderPtr

; typedef KernTableHeaderPtr *			KernTableHeaderHandle

; 
;    F O R M A T   S P E C I F I C   D E F I N I T I O N S
;
;    kernOrderedList:
;    
;    The table is a sorted list of [left glyph, right glyph, value] triples.
;    There's enough information in the header so that the list can be
;    efficiently binary searched. 
;

;  defines a single kerning pair of Glyphcodes  
KernKerningPair			RECORD 0
left					 ds.w	1				; offset: $0 (0)
right					 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
;  a single list entry 
KernOrderedListEntry	RECORD 0
pair					 ds		KernKerningPair ; offset: $0 (0)		;  the kerning pair 
value					 ds.w	1				; offset: $4 (4)		;  the kerning value for the above pair 
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct KernOrderedListEntry *	KernOrderedListEntryPtr

;  the header information for binary searching the list 
KernOrderedListHeader	RECORD 0
nPairs					 ds.w	1				; offset: $0 (0)		;  number of kerning pairs in table 
searchRange				 ds.w	1				; offset: $2 (2)		;  (largest power of two <= nPairs) * entry size 
entrySelector			 ds.w	1				; offset: $4 (4)		;  log2 (largest power of two <= nPairs) 
rangeShift				 ds.w	1				; offset: $6 (6)		;  (nPairs - largest power of two <= nPairs) * entry size 
table					 ds.w	1				; offset: $8 (8) <-- really an array of length one ;  entries are first glyph, second glyph, and value 
sizeof					 EQU *					; size:   $A (10)
						ENDR
;  KernStateTable: like the the generic state tables 
KernStateHeader			RECORD 0
header					 ds		STHeader		; offset: $0 (0)		;  state table header 
valueTable				 ds.w	1				; offset: $8 (8)		;  offset to kerning value table 
firstTable				 ds.b	1				; offset: $A (10) <-- really an array of length one ;  first table starts here 
						 ORG 12
sizeof					 EQU *					; size:   $C (12)
						ENDR
KernStateEntry			RECORD 0
newState				 ds.w	1				; offset: $0 (0)
flags					 ds.w	1				; offset: $2 (2)		;  flags per above enum 
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; 
;    Kern offset table header.
;    The offset table is a trimmed array from firstGlyph to limitGlyph.
;    Glyphs outside of this range should get zero for right-hand glyphs
;    and the offset of the beginning of the kerning array for left-hand glyphs.
;

KernOffsetTable			RECORD 0
firstGlyph				 ds.w	1				; offset: $0 (0)		;  first glyph in class range 
nGlyphs					 ds.w	1				; offset: $2 (2)		;  number of glyphs in class range 
offsetTable				 ds.w	1				; offset: $4 (4) <-- really an array of length one ;  offset table starts here 
sizeof					 EQU *					; size:   $6 (6)
						ENDR
; typedef struct KernOffsetTable *		KernOffsetTablePtr

;  Header information for accessing offset tables and kerning array 
; 
;    KernSimpleArray:
;    
;    The array is an nXm array of kenring values. Each row in the array
;    represents one left-hand glyph, and each column one right-hand glyph.
;    The zeroth row and column always represent glyphs that are out of bounds
;    and will always contain zero.
;    
;    A pair is looked up by indexing the left-hand glyph through the left
;    offset table, the right-hand glyph through the right offset table,
;    adding both offsets to the starting address of the kerning array,
;    and fetching the kerning value pointed to.
;

;  Kern offset table header. 
;  The offset table is a trimmed array from firstGlyph to limitGlyph. 
;  Glyphs outside of this range should get zero for right-hand glyphs 
;  and the offset of the beginning of the kerning array for left- 
;  hand glyphs. 
KernSimpleArrayHeader	RECORD 0
rowWidth				 ds.w	1				; offset: $0 (0)		;  width, in bytes, of a row in the table 
leftOffsetTable			 ds.w	1				; offset: $2 (2)		;  offset to left-hand offset table 
rightOffsetTable		 ds.w	1				; offset: $4 (4)		;  offset to right-hand offset table 
theArray				 ds.w	1				; offset: $6 (6)		;  offset to start of kerning array 
firstTable				 ds.w	1				; offset: $8 (8) <-- really an array of length one ;  first offset table starts here... 
sizeof					 EQU *					; size:   $A (10)
						ENDR
;  Index Array 
KernIndexArrayHeader	RECORD 0
glyphCount				 ds.w	1				; offset: $0 (0)
kernValueCount			 ds.b	1				; offset: $2 (2)
leftClassCount			 ds.b	1				; offset: $3 (3)
rightClassCount			 ds.b	1				; offset: $4 (4)
flags					 ds.b	1				; offset: $5 (5)		;  set to 0 for now 
kernValue				 ds.w	1				; offset: $6 (6) <-- really an array of length one ;  actual kerning values reference by index in kernIndex 
leftClass				 ds.b	1				; offset: $8 (8) <-- really an array of length one ;  maps left glyph to offset into kern index 
rightClass				 ds.b	1				; offset: $9 (9) <-- really an array of length one ;  maps right glyph to offset into kern index 
kernIndex				 ds.b	1				; offset: $A (10) <-- really an array of length one ;  contains indicies into kernValue 
						 ORG 12
sizeof					 EQU *					; size:   $C (12)
						ENDR
;  format specific part of subtable header 
KernFormatSpecificHeader RECORD 0
orderedList				 ds		KernOrderedListHeader ; offset: $0 (0)
						 ORG 0
stateTable				 ds		KernStateHeader ; offset: $0 (0)
						 ORG 0
simpleArray				 ds		KernSimpleArrayHeader ; offset: $0 (0)
						 ORG 0
indexArray				 ds		KernIndexArrayHeader ; offset: $0 (0)
sizeof					 EQU *					; size:   $C (12)
						ENDR
;  version 0 subtable header 
KernVersion0SubtableHeader RECORD 0
version					 ds.w	1				; offset: $0 (0)		;  kerning table version number 
length					 ds.w	1				; offset: $2 (2)		;  length in bytes (including this header) 
stInfo					 ds.w	1				; offset: $4 (4)		;  sub-table info 
fsHeader				 ds		KernFormatSpecificHeader ; offset: $6 (6) ;  format specific sub-header 
sizeof					 EQU *					; size:   $12 (18)
						ENDR
;  Overall Subtable header format 
KernSubtableHeader		RECORD 0
length					 ds.l	1				; offset: $0 (0)		;  length in bytes (including this header) 
stInfo					 ds.w	1				; offset: $4 (4)		;  subtable info 
tupleIndex				 ds.w	1				; offset: $6 (6)		;  tuple index for variation subtables 
fsHeader				 ds		KernFormatSpecificHeader ; offset: $8 (8) ;  format specific sub-header 
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct KernSubtableHeader *	KernSubtableHeaderPtr

;  --------------------------------------------------------------------------- 
;  FORMATS FOR TABLE: 'bsln' 
;  CONSTANTS 

kBSLNTag						EQU		$62736C6E			; 'bsln' 
kBSLNCurrentVersion				EQU		$00010000			; current version number for 'bsln' table 
kBSLNDistanceFormatNoMap		EQU		0
kBSLNDistanceFormatWithMap		EQU		1
kBSLNControlPointFormatNoMap	EQU		2
kBSLNControlPointFormatWithMap	EQU		3
;  Baseline classes and constants 

kBSLNRomanBaseline				EQU		0
kBSLNIdeographicCenterBaseline	EQU		1
kBSLNIdeographicLowBaseline		EQU		2
kBSLNHangingBaseline			EQU		3
kBSLNMathBaseline				EQU		4
kBSLNLastBaseline				EQU		31
kBSLNNumBaselineClasses			EQU		32
kBSLNNoBaselineOverride			EQU		255
;  TYPES 
; typedef UInt32 						BslnBaselineClass

;  The BslnBaselineRecord array defines the baseline deltas for the line. 
BslnBaselineRecord		RECORD 0
elements				 ds.l	32
sizeof					 EQU *					; size:   $80 (128)
						ENDR


; 
;    BslnFormat0Part is the format-specific data for a distance table with no mapping (i.e.
;    all the glyphs belong to the defaultBaseline).
;

BslnFormat0Part			RECORD 0
deltas					 ds.w	32				; offset: $0 (0)
sizeof					 EQU *					; size:   $40 (64)
						ENDR
;  BslnFormat1Part is the format-specific data for a distance table with a gxMapping. 
BslnFormat1Part			RECORD 0
deltas					 ds.w	32				; offset: $0 (0)
mappingData				 ds		SFNTLookupTable ; offset: $40 (64)
sizeof					 EQU *					; size:   $52 (82)
						ENDR
; 
;    BslnFormat2Part is the format-specific data for a control-point table with no
;    mapping (i.e. all the glyphs belong to the defaultBaseline). It specifies a single
;    glyph to use and the set of control points in that glyph that designate each of
;    the baselines.
;

BslnFormat2Part			RECORD 0
stdGlyph				 ds.w	1				; offset: $0 (0)
ctlPoints				 ds.w	32				; offset: $2 (2)
sizeof					 EQU *					; size:   $42 (66)
						ENDR
; 
;    BslnFormat3Part is the format-specific data for a distance table with a mapping. Like
;    format 2, it contains a single glyph and its set of control-point values for each
;    of the baselines.
;

BslnFormat3Part			RECORD 0
stdGlyph				 ds.w	1				; offset: $0 (0)
ctlPoints				 ds.w	32				; offset: $2 (2)
mappingData				 ds		SFNTLookupTable ; offset: $42 (66)
sizeof					 EQU *					; size:   $54 (84)
						ENDR
;  The BslnFormatUnion is a union containing the format-specific parts of the baseline table. 
BslnFormatUnion			RECORD 0
fmt0Part				 ds		BslnFormat0Part ; offset: $0 (0)
						 ORG 0
fmt1Part				 ds		BslnFormat1Part ; offset: $0 (0)
						 ORG 0
fmt2Part				 ds		BslnFormat2Part ; offset: $0 (0)
						 ORG 0
fmt3Part				 ds		BslnFormat3Part ; offset: $0 (0)
sizeof					 EQU *					; size:   $54 (84)
						ENDR
;  The table format used in BaselineTable 
; typedef UInt16 						BslnTableFormat

;  BaselineTable defines the top-level format of the baseline table in the font. 
BslnTable				RECORD 0
version					 ds.l	1				; offset: $0 (0)
format					 ds.w	1				; offset: $4 (4)
defaultBaseline			 ds.w	1				; offset: $6 (6)
parts					 ds		BslnFormatUnion ; offset: $8 (8)
sizeof					 EQU *					; size:   $5C (92)
						ENDR
; typedef struct BslnTable *			BslnTablePtr

;  --------------------------------------------------------------------------- 
	ENDIF ; __SFNTLAYOUTTYPES__ 


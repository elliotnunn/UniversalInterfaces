;
;    File:       Start.a
;
;    Contains:   Start Manager Interfaces.
;
;    Version:    Technology: Mac OS 8.5
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1987-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__START__') = 'UNDEFINED' THEN
__START__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF
	IF &TYPE('__FILES__') = 'UNDEFINED' THEN
	include 'Files.a'
	ENDIF

; 
;    Important: When the major version number of kExtensionTableVersion and the value
;    returned by gestaltExtensionTableVersion change, it indicates that the Extension
;    Table startup mechanism has radically changed and code that doesn't know about
;    the new major version must not attempt to use the Extension Table startup
;    mechanism.
;    
;    Changes to the minor version number of kExtensionTableVersion indicate that the
;    definition of the ExtensionElement structure has been extended, but the fields
;    defined for previous minor versions of kExtensionTableVersion have not changed.
;


kExtensionTableVersion			EQU		$00000100			; current ExtensionTable version (1.0.0) 
;  ExtensionNotification message codes 

extNotificationBeforeFirst		EQU		0					; Before any extensions have loaded 
extNotificationAfterLast		EQU		1					; After all extensions have loaded 
extNotificationBeforeCurrent	EQU		2					; Before extension at extElementIndex is loaded 
extNotificationAfterCurrent		EQU		3					; After extension at extElementIndex is loaded 
ExtensionElement		RECORD 0
fileName				 ds		Str31			; offset: $0 (0)		;  The file name 
parentDirID				 ds.l	1				; offset: $20 (32)		;  the file's parent directory ID 
;  and everything after ioNamePtr in the HParamBlockRec.fileParam variant 
ioVRefNum				 ds.w	1				; offset: $24 (36)		;  always the real volume reference number (not a drive, default, or working dirID) 
ioFRefNum				 ds.w	1				; offset: $26 (38)
ioFVersNum				 ds.b	1				; offset: $28 (40)
filler1					 ds.b	1				; offset: $29 (41)
ioFDirIndex				 ds.w	1				; offset: $2A (42)		;  always 0 in table 
ioFlAttrib				 ds.b	1				; offset: $2C (44)
ioFlVersNum				 ds.b	1				; offset: $2D (45)
ioFlFndrInfo			 ds		FInfo			; offset: $2E (46)
ioDirID					 ds.l	1				; offset: $3E (62)
ioFlStBlk				 ds.w	1				; offset: $42 (66)
ioFlLgLen				 ds.l	1				; offset: $44 (68)
ioFlPyLen				 ds.l	1				; offset: $48 (72)
ioFlRStBlk				 ds.w	1				; offset: $4C (76)
ioFlRLgLen				 ds.l	1				; offset: $4E (78)
ioFlRPyLen				 ds.l	1				; offset: $52 (82)
ioFlCrDat				 ds.l	1				; offset: $56 (86)
ioFlMdDat				 ds.l	1				; offset: $5A (90)
sizeof					 EQU *					; size:   $5E (94)
						ENDR
; typedef struct ExtensionElement *		ExtensionElementPtr

ExtensionTableHeader	RECORD 0
extTableHeaderSize		 ds.l	1				; offset: $0 (0)		;  size of ExtensionTable header ( equal to offsetof(ExtensionTable, extElements[0]) ) 
extTableVersion			 ds.l	1				; offset: $4 (4)		;  current ExtensionTable version (same as returned by gestaltExtTableVersion Gestalt selector) 
extElementIndex			 ds.l	1				; offset: $8 (8)		;  current index into ExtensionElement records (zero-based) 
extElementSize			 ds.l	1				; offset: $C (12)		;  size of ExtensionElement 
extElementCount			 ds.l	1				; offset: $10 (16)		;  number of ExtensionElement records in table (1-based) 
sizeof					 EQU *					; size:   $14 (20)
						ENDR
ExtensionTable			RECORD 0
extTableHeader			 ds		ExtensionTableHeader ; offset: $0 (0)	;  the ExtensionTableHeader 
extElements				 ds		ExtensionElement ; offset: $14 (20) <-- really an array of length one ;  one element for each extension to load 
sizeof					 EQU *					; size:   $72 (114)
						ENDR
; typedef struct ExtensionTable *		ExtensionTablePtr

; typedef ExtensionTablePtr *			ExtensionTableHandle

	IF CALL_NOT_IN_CARBON THEN

; *  NewExtensionNotificationUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  NewExtensionTableHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeExtensionNotificationUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  DisposeExtensionTableHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeExtensionNotificationUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 


; *  InvokeExtensionTableHandlerUPP()
; *  
; *  Availability:
; *    Non-Carbon CFM:   available as macro/inline
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

	ENDIF	; CALL_NOT_IN_CARBON
DefStartRec				RECORD 0
sdExtDevID				 ds.b	1				; offset: $0 (0)
sdPartition				 ds.b	1				; offset: $1 (1)
sdSlotNum				 ds.b	1				; offset: $2 (2)
sdSRsrcID				 ds.b	1				; offset: $3 (3)
						 ORG 0
sdReserved1				 ds.b	1				; offset: $0 (0)
sdReserved2				 ds.b	1				; offset: $1 (1)
sdRefNum				 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef union DefStartRec *			DefStartPtr

DefVideoRec				RECORD 0
sdSlot					 ds.b	1				; offset: $0 (0)
sdsResource				 ds.b	1				; offset: $1 (1)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
; typedef struct DefVideoRec *			DefVideoPtr

DefOSRec				RECORD 0
sdReserved				 ds.b	1				; offset: $0 (0)
sdOSType				 ds.b	1				; offset: $1 (1)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
; typedef struct DefOSRec *				DefOSPtr

	IF CALL_NOT_IN_CARBON THEN

; *  GetDefaultStartup()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void GetDefaultStartup(DefStartPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		_GetDefaultStartup:	OPWORD	$A07D
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetDefaultStartup
	ENDIF


; *  SetDefaultStartup()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void SetDefaultStartup(DefStartPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		_SetDefaultStartup:	OPWORD	$A07E
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetDefaultStartup
	ENDIF


; *  GetVideoDefault()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void GetVideoDefault(DefVideoPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		_GetVideoDefault:	OPWORD	$A080
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetVideoDefault
	ENDIF


; *  SetVideoDefault()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void SetVideoDefault(DefVideoPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		_SetVideoDefault:	OPWORD	$A081
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetVideoDefault
	ENDIF


; *  GetOSDefault()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void GetOSDefault(DefOSPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		_GetOSDefault:	OPWORD	$A084
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetOSDefault
	ENDIF


; *  SetOSDefault()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void SetOSDefault(DefOSPtr paramBlock)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		; parameters:
		;	paramBlock      => A0
		_SetOSDefault:	OPWORD	$A083
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetOSDefault
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	IF CALL_NOT_IN_CARBON THEN

; *  SetTimeout()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void SetTimeout(short count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SetTimeout
			move.w              #$0001,A0
			dc.w            	$A07F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetTimeout
	ENDIF


; *  GetTimeout()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void GetTimeout(short *count)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_GetTimeout
			sub.l               A0,A0
			dc.w            	$A07F
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetTimeout
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
; 
;    InstallExtensionNotificationProc
;
;    Installs an ExtensionNotificationUPP.
;
;    Parameters:
;        extNotificationProc The ExtensionNotificationUPP to install.
;
;    Results:
;        noErr       0       The ExtensionNotificationUPP was installed.
;        paramErr    -50     This ExtensionNotificationUPP has already been installed.
;        memFullErr  -108    Not enough memory to install the ExtensionNotificationUPP.
;

	IF CALL_NOT_IN_CARBON THEN

; *  InstallExtensionNotificationProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr InstallExtensionNotificationProc(ExtensionNotificationUPP extNotificationProc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InstallExtensionNotificationProc
			moveq           	#0,D0
			dc.w            	$AA7D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InstallExtensionNotificationProc
	ENDIF


; 
;    RemoveExtensionNotificationProc
;
;    Removes an ExtensionNotificationUPP.
;    
;    Note:   ExtensionNotificationUPPs can't call RemoveExtensionNotificationProc.
;
;    Parameters:
;        extNotificationProc The ExtensionNotificationUPP to remove.
;
;    Results:
;        noErr       0       The ExtensionNotificationUPP was removed.
;        paramErr    -50     The ExtensionNotificationUPP was not found, or
;                            RemoveExtensionNotificationProc was called from within
;                            a ExtensionNotificationUPP (ExtensionNotificationUPPs can't
;                            call RemoveExtensionNotificationProc).
;


; *  RemoveExtensionNotificationProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr RemoveExtensionNotificationProc(ExtensionNotificationUPP extNotificationProc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RemoveExtensionNotificationProc
			moveq           	#1,D0
			dc.w            	$AA7D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveExtensionNotificationProc
	ENDIF


; 
;    InstallExtensionTableHandlerProc
;
;    Installs an ExtensionTableHandlerUPP. Control is taken away from the system's default
;    handler and the ExtensionTableHandlerUPP is responsible for all changes to the
;    ExtensionTable (except for incrementing extElementIndex between extensions). This is
;    always the first handler called with extNotificationBeforeFirst and
;    extNotificationBeforeCurrent messages and the last handler called with
;    extNotificationAfterLast and extNotificationAfterCurrent messages. extElementIndex
;    is always incremented immediately after the ExtensionTableHandlerUPP is called with
;    the extNotificationAfterCurrent message.
;    
;    There can only be one ExtensionTableHandler installed.
;    
;    Warning:    The only safe time to change what ExtensionElement is at
;                ExtensionTable.extElements[extElementIndex] is when your
;                ExtensionTableHandlerUPP is called with the extNotificationAfterCurrent
;                message. You may change the ExtensionTable or the extElementIndex at other
;                times, but you must ensure that the ExtensionElement at
;                ExtensionTable.extElements[extElementIndex] stays the same.
;                
;    Note:       If the ExtensionTable or the contents of the folders included in the
;                ExtensionTable are changed after installing an ExtensionTableHandler,
;                RemoveExtensionTableHandlerProc cannot be called.
;
;    Parameters:
;        extMgrProc          The ExtensionTableHandlerUPP to install.
;        extTable            A pointer to an ExtensionTableHandle where
;                            InstallExtensionTableHandlerProc will return the current
;                            ExtensionTableHandle. You don't own the handle itself and
;                            must not dispose of it, but you can change the extElementIndex.
;                            the extElementCount, and the ExtensionElements in the table.
;
;    Results:
;        noErr       0       The ExtensionTableHandlerUPP was installed.
;        paramErr    -50     Another ExtensionTableHandlerUPP has already been installed.
;        memFullErr  -108    Not enough memory to install the ExtensionTableHandlerUPP.
;


; *  InstallExtensionTableHandlerProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr InstallExtensionTableHandlerProc(ExtensionTableHandlerUPP extMgrProc, ExtensionTableHandle *extTable)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_InstallExtensionTableHandlerProc
			moveq           	#2,D0
			dc.w            	$AA7D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION InstallExtensionTableHandlerProc
	ENDIF


; 
;    RemoveExtensionTableHandlerProc
;
;    Remove an ExtensionTableUPP. Control is passed back to the default handler.
;
;    Parameters:
;        extMgrProc          The ExtensionTableUPP to remove.
;
;    Results:
;        noErr       0       The ExtensionTableUPP was removed.
;        paramErr    -50     This ExtensionTableUPP was not installed,
;                            or the ExtensionTable no longer matches the
;                            original boot ExtensionTable.
;


; *  RemoveExtensionTableHandlerProc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 8.5 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal OSErr RemoveExtensionTableHandlerProc(ExtensionTableHandlerUPP extMgrProc)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_RemoveExtensionTableHandlerProc
			moveq           	#3,D0
			dc.w            	$AA7D
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION RemoveExtensionTableHandlerProc
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
; 
; * Native StartLib calls - these are implemented ONLY on NewWorld machines (iMac, etc.)
; *
; * These functions should be weak linked.  If unavailable, use older method (Get/SetDefaultStartup)
; 

; 
; * The enums below define pseudo startup devices, such as a network disk.  They can be used in place
; * of driveNums in various StartLib calls
; *
; * NOTE - the values are chosen to avoid conflict with vRefNums (low negative numbers), wdRefNums
; *      (large negative numbers) and drive numbers (low positive numbers)
; 


kNetworkStartupDevice			EQU		32767
kLocalStartupDevice				EQU		32766
; 
; * The enums below determine the maximum string size of parameters for network startup device calls.
; 


kSMProtocolStringSize			EQU		16
kSMAddressStringSize			EQU		16
kSMBootFilenameSize				EQU		128
; 
; * GetSelectedStartupDevice - return the driveNum of the currently selected startup device.  This refers
; * to the device selected by the user via Startup Disk control panel, which may or may not be the
; * device currently booted.
; 

	IF CALL_NOT_IN_CARBON THEN

; *  GetSelectedStartupDevice()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in StartLib 1.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OSErr GetSelectedStartupDevice(UInt16 *driveNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSelectedStartupDevice
	ENDIF

; 
; * GetSelectedStartupDeviceType - return the type of the currently selected startup device.  This refers
; * to the device selected by the user via Startup Disk control panel, which may or may not be the
; * device currently booted.  Returned types are based on kdgInterface  DriverGestalt response 
; * ('scsi', 'ata ', 'fire', etc.)
; 


; *  GetSelectedStartupDeviceType()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in StartLib 1.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OSErr GetSelectedStartupDeviceType(OSType *interfaceType)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSelectedStartupDeviceType
	ENDIF

; 
; * GetSelectedFirewireStartupDeviceInfo - for a startup device of type Firewire, get pertinent info, including
; * GUID, mao and lun.  This refers to the device selected by the user via Startup Disk control panel, which 
; * may or may not be the device currently booted.
; *
; * GetSelectedFirewireStartupDeviceInfo should only be called if GetSelectedStartupDeviceType returns
; * the type kdgFireWireIntf.  If the selected startup device is not kdgFireWireIntf,
; * GetSelectedFirewireStartupDeviceInfo returns an error (nsDrvErr) and the return parameters are
; * undefined.
; 


; *  GetSelectedFirewireStartupDeviceInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in StartLib 1.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OSErr GetSelectedFirewireStartupDeviceInfo(UnsignedWide *GUID, UInt32 *mao, UInt32 *lun)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSelectedFirewireStartupDeviceInfo
	ENDIF

; 
; * GetSelectedNetworkStartupDeviceInfo - for a network startup device, return relevant information (this refers
; * to the device selected by the user via Startup Disk control panel, which may or may not be the
; * device currently booted):
; *
; * See the Open Firmware netbooting recommended practices:
; *      http://playground.sun.com/1275/practice/obp-tftp/tftp1_0.pdf
; *
; * The possible parameters for this call are:
; *
; *      [bootp,]siaddr,filename,ciaddr,giaddr,bootp-retries,tftp-retries
; *
; *          bootp...specifies the use of BOOTP as the “discovery” protocol to be used.
; *          siaddr is the IP address of the intended server.
; *          filename is the filename of the file that is to be loaded by TFTP from the server.
; *          ciaddr is the IP address of the client (i.e., the system being booted).
; *          giaddr is the IP address of the BOOTP ‘gateway’.
; *          bootp-retries is the maximum number of retries that are attempted before the BOOTP process is determined to have failed.
; *          tftp-retries is the maximum number of retries that are attempted before the TFTP process is stopped.
; *
; *      Address parameters are specified as strings, not binary (e.g., "128.1.1.1") and are limited to kSMAddressStringSize
; *      (16 bytes) in length.  filename parameter is limited to kSMBootFilenameSize (128 bytes) in length.  protocol 
; *      parameter is limited to kSMProtocolStringSize in length
; 


; *  GetSelectedNetworkStartupDeviceInfo()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in StartLib 1.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OSErr GetSelectedNetworkStartupDeviceInfo(char *protocol, char *siaddr, char *filename, char *ciaddr, char *giaddr, UInt32 *bootpRetries, UInt32 *tftpRetries, UInt32 reserved)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION GetSelectedNetworkStartupDeviceInfo
	ENDIF

; 
; * IsDriveSelectable - determines if the drive specified by driveNum is a candidate for booting.  This
; * checks criteria, such as necessary driver support and Open Firmware support, which are minimal for
; * the device to be considered as a startup device.  This call does not check other criteria, such as
; * whether or not a valid System Folder is present on the volume.
; 


; *  IsDriveSelectable()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in StartLib 1.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern Boolean IsDriveSelectable(UInt16 driveNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION IsDriveSelectable
	ENDIF

; 
; * SetSelectedStartupDevice - set the device referred to by driveNum to be the startup device.  Passing
; * the pseudo-device kNetworkStartupDevice sets default enet:bootp behavior.  For more complex 
; * scenarios, use SetSelectedNetworkStartupDevice (q.v.).
; 


; *  SetSelectedStartupDevice()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in StartLib 1.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OSErr SetSelectedStartupDevice(UInt16 driveNum)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSelectedStartupDevice
	ENDIF

; 
; * SetSelectedNetworkStartupDevice - set a network device as the startup device.  This is for more
; * complex setup than handled by SetSelectedStartupDevice.
; *
; * See the Open Firmware netbooting recommended practices:
; *      http://playground.sun.com/1275/practice/obp-tftp/tftp1_0.pdf
; *
; * The possible parameters for this call are:
; *
; *      [bootp,]siaddr,filename,ciaddr,giaddr,bootp-retries,tftp-retries
; *
; *          bootp...specifies the use of BOOTP as the “discovery” protocol to be used.
; *              if not specified (parameter is nil), bootp is used by default
; *          siaddr is the IP address of the intended server.
; *          filename is the filename of the file that is to be loaded by TFTP from the server.
; *          ciaddr is the IP address of the client (i.e., the system being booted).
; *          giaddr is the IP address of the BOOTP ‘gateway’.
; *          bootp-retries is the maximum number of retries that are attempted before the BOOTP process is determined to have failed.
; *          tftp-retries is the maximum number of retries that are attempted before the TFTP process is stopped.
; *
; *      Address parameters are specified as strings, not binary (e.g., "128.1.1.1") and are limited to kSMAddressStringSize
; *      (16 bytes) in length.  filename parameter is limited to kSMBootFilenameSize (128 bytes) in length.  protocol 
; *      parameter is limited to kSMProtocolStringSize in length
; *
; *  NOTE - unspecified parameters should be specified as nil, except for retry parameters which should be zero.
; 


; *  SetSelectedNetworkStartupDevice()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in StartLib 1.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern OSErr SetSelectedNetworkStartupDevice(char *protocol, char *siaddr, char *filename, char *ciaddr, char *giaddr, UInt32 bootpRetries, UInt32 tftpRetries, UInt32 reserved)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SetSelectedNetworkStartupDevice
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF ; __START__ 


;
;    File:       UnicodeUtilities.a
;
;    Contains:   Types, constants, prototypes for Unicode Utilities (Unicode input and text utils)
;
;    Version:    Technology: Mac OS 9.0
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  Â© 1997-2001 by Apple Computer, Inc., all rights reserved.
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__UNICODEUTILITIES__') = 'UNDEFINED' THEN
__UNICODEUTILITIES__ SET 1

	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
	include 'MacTypes.a'
	ENDIF

	IF &TYPE('__MACLOCALES__') = 'UNDEFINED' THEN
	include 'MacLocales.a'
	ENDIF
	IF &TYPE('__TEXTCOMMON__') = 'UNDEFINED' THEN
	include 'TextCommon.a'
	ENDIF

;   -------------------------------------------------------------------------------------------------
;   CONSTANTS & DATA STRUCTURES for UCKeyTranslate & UCKeyboardLayout ('uchr' resource)
;   -------------------------------------------------------------------------------------------------




;   -------------------------------------------------------------------------------------------------
;   UCKeyOutput & related stuff
;   The interpretation of UCKeyOutput depends on bits 15-14.
;   If they are 01, then bits 0-13 are an index in UCKeyStateRecordsIndex (resource-wide list).
;   If they are 10, then bits 0-13 are an index in UCKeySequenceDataIndex (resource-wide list),
;     or if UCKeySequenceDataIndex is not present or the index is beyond the end of the list,
;     then bits 0-15 are a single Unicode character.
;   Otherwise, bits 0-15 are a single Unicode character; a value of 0xFFFE-0xFFFF means no character
;     output.
;   UCKeyCharSeq is similar, but does not support indices in UCKeyStateRecordsIndex. For bits 15-14:
;   If they are 10, then bits 0-13 are an index in UCKeySequenceDataIndex (resource-wide list),
;     or if UCKeySequenceDataIndex is not present or the index is beyond the end of the list,
;     then bits 0-15 are a single Unicode character.
;   Otherwise, bits 0-15 are a single Unicode character; a value of 0xFFFE-0xFFFF means no character
;     output.
;   -------------------------------------------------------------------------------------------------



; typedef UInt16 						UCKeyOutput

; typedef UInt16 						UCKeyCharSeq


kUCKeyOutputStateIndexMask		EQU		$4000
kUCKeyOutputSequenceIndexMask	EQU		$8000
kUCKeyOutputTestForIndexMask	EQU		$C000				; test bits 14-15
kUCKeyOutputGetIndexMask		EQU		$3FFF				; get bits 0-13

;   -------------------------------------------------------------------------------------------------
;   UCKeyStateRecord & related stuff
;   The UCKeyStateRecord information is used as follows. If the current state is zero,
;   output stateZeroCharData and set the state to stateZeroNextState. If the current state
;   is non-zero and there is an entry for it in stateEntryData, then output the corresponding
;   charData and set the state to nextState. Otherwise, output the state terminator from
;   UCKeyStateTerminators for the current state (or nothing if there is no UCKeyStateTerminators
;   table or it has no entry for the current state), then output stateZeroCharData and set the
;   state to stateZeroNextState.
;   -------------------------------------------------------------------------------------------------



UCKeyStateRecord		RECORD 0
stateZeroCharData		 ds.w	1				; offset: $0 (0)
stateZeroNextState		 ds.w	1				; offset: $2 (2)
stateEntryCount			 ds.w	1				; offset: $4 (4)
stateEntryFormat		 ds.w	1				; offset: $6 (6)
;  This is followed by an array of stateEntryCount elements
;  in the specified format. Here we just show a dummy array.
stateEntryData			 ds.l	1				; offset: $8 (8) <-- really an array of length one
sizeof					 EQU *					; size:   $C (12)
						ENDR

;   Here are the codes for entry formats currently defined.
;   Each entry maps from curState to charData and nextState.



kUCKeyStateEntryTerminalFormat	EQU		$0001
kUCKeyStateEntryRangeFormat		EQU		$0002

;   For UCKeyStateEntryTerminal -
;   nextState is always 0, so we don't have a field for it



UCKeyStateEntryTerminal	RECORD 0
curState				 ds.w	1				; offset: $0 (0)
charData				 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR

;   For UCKeyStateEntryRange -
;   If curState >= curStateStart and curState <= curStateStart+curStateRange,
;   then it matches the entry, and we transform charData and nextState as follows:
;   If charData < 0xFFFE, then charData += (curState-curStateStart)*deltaMultiplier
;   If nextState != 0, then nextState += (curState-curStateStart)*deltaMultiplier


UCKeyStateEntryRange	RECORD 0
curStateStart			 ds.w	1				; offset: $0 (0)
curStateRange			 ds.b	1				; offset: $2 (2)
deltaMultiplier			 ds.b	1				; offset: $3 (3)
charData				 ds.w	1				; offset: $4 (4)
nextState				 ds.w	1				; offset: $6 (6)
sizeof					 EQU *					; size:   $8 (8)
						ENDR

;   -------------------------------------------------------------------------------------------------
;   UCKeyboardLayout & related stuff
;   The UCKeyboardLayout struct given here is only for the resource header. It specifies
;   offsets to the various subtables which each have their own structs, given below.
;   The keyboardTypeHeadList array selects table offsets that depend on keyboardType. The
;   first entry in keyboardTypeHeadList is the default entry, which will be used if the
;   keyboardType passed to UCKeyTranslate does not match any other entry - i.e. does not fall
;   within the range keyboardTypeFirst..keyboardTypeLast for some entry. The first entry
;   should have keyboardTypeFirst = keyboardTypeLast = 0.
;   -------------------------------------------------------------------------------------------------


UCKeyboardTypeHeader	RECORD 0
keyboardTypeFirst		 ds.l	1				; offset: $0 (0)		;  first keyboardType in this entry
keyboardTypeLast		 ds.l	1				; offset: $4 (4)		;  last keyboardType in this entry
keyModifiersToTableNumOffset  ds.l 1			; offset: $8 (8)		;  required
keyToCharTableIndexOffset  ds.l	1				; offset: $C (12)		;  required
keyStateRecordsIndexOffset  ds.l 1				; offset: $10 (16)		;  0 => no table
keyStateTerminatorsOffset  ds.l	1				; offset: $14 (20)		;  0 => no table
keySequenceDataIndexOffset  ds.l 1				; offset: $18 (24)		;  0 => no table
sizeof					 EQU *					; size:   $1C (28)
						ENDR
UCKeyboardLayout		RECORD 0
;  header only; other tables accessed via offsets
keyLayoutHeaderFormat	 ds.w	1				; offset: $0 (0)		;  =kUCKeyLayoutHeaderFormat
keyLayoutDataVersion	 ds.w	1				; offset: $2 (2)		;  0x0100 = 1.0, 0x0110 = 1.1, etc.
keyLayoutFeatureInfoOffset  ds.l 1				; offset: $4 (4)		;  may be 0                       
keyboardTypeCount		 ds.l	1				; offset: $8 (8)		;  Dimension for keyboardTypeHeadList[]     
keyboardTypeList		 ds		UCKeyboardTypeHeader ; offset: $C (12) <-- really an array of length one
sizeof					 EQU *					; size:   $28 (40)
						ENDR
;  -------------------------------------------------------------------------------------------------
UCKeyLayoutFeatureInfo	RECORD 0
keyLayoutFeatureInfoFormat  ds.w 1				; offset: $0 (0)		;  =kUCKeyLayoutFeatureInfoFormat
reserved				 ds.w	1				; offset: $2 (2)
maxOutputStringLength	 ds.l	1				; offset: $4 (4)		;  longest possible output string
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  -------------------------------------------------------------------------------------------------
UCKeyModifiersToTableNum RECORD 0
keyModifiersToTableNumFormat  ds.w 1			; offset: $0 (0)		;  =kUCKeyModifiersToTableNumFormat
defaultTableNum			 ds.w	1				; offset: $2 (2)		;  For modifier combos not in tableNum[]
modifiersCount			 ds.l	1				; offset: $4 (4)		;  Dimension for tableNum[]
tableNum				 ds.b	1				; offset: $8 (8) <-- really an array of length one
;  Then there is padding to a 4-byte boundary with bytes containing 0, if necessary.
						 ORG 10
sizeof					 EQU *					; size:   $A (10)
						ENDR
;  -------------------------------------------------------------------------------------------------
UCKeyToCharTableIndex	RECORD 0
keyToCharTableIndexFormat  ds.w	1				; offset: $0 (0)		;  =kUCKeyToCharTableIndexFormat
keyToCharTableSize		 ds.w	1				; offset: $2 (2)		;  Max keyCode (128 for ADB keyboards)
keyToCharTableCount		 ds.l	1				; offset: $4 (4)		;  Dimension for keyToCharTableOffsets[] (usually 6 to 12 tables)
keyToCharTableOffsets	 ds.l	1				; offset: $8 (8) <-- really an array of length one
;  Each offset in keyToCharTableOffsets is from the beginning of the resource to a
;  table as follows:
;     UCKeyOutput       keyToCharData[keyToCharTableSize];
;  These tables follow the UCKeyToCharTableIndex.
;  Then there is padding to a 4-byte boundary with bytes containing 0, if necessary.
sizeof					 EQU *					; size:   $C (12)
						ENDR
;  -------------------------------------------------------------------------------------------------
UCKeyStateRecordsIndex	RECORD 0
keyStateRecordsIndexFormat  ds.w 1				; offset: $0 (0)		;  =kUCKeyStateRecordsIndexFormat
keyStateRecordCount		 ds.w	1				; offset: $2 (2)		;  Dimension for keyStateRecordOffsets[]
keyStateRecordOffsets	 ds.l	1				; offset: $4 (4) <-- really an array of length one
;  Each offset in keyStateRecordOffsets is from the beginning of the resource to a
;  UCKeyStateRecord. These UCKeyStateRecords follow the keyStateRecordOffsets[] array.
;  Then there is padding to a 4-byte boundary with bytes containing 0, if necessary.
sizeof					 EQU *					; size:   $8 (8)
						ENDR
;  -------------------------------------------------------------------------------------------------
UCKeyStateTerminators	RECORD 0
keyStateTerminatorsFormat  ds.w	1				; offset: $0 (0)		;  =kUCKeyStateTerminatorsFormat
keyStateTerminatorCount	 ds.w	1				; offset: $2 (2)		;  Dimension for keyStateTerminators[] (# of nonzero states)
keyStateTerminators		 ds.w	1				; offset: $4 (4) <-- really an array of length one
;  Note: keyStateTerminators[0] is terminator for state 1, etc.
;  Then there is padding to a 4-byte boundary with bytes containing 0, if necessary.
sizeof					 EQU *					; size:   $6 (6)
						ENDR
;  -------------------------------------------------------------------------------------------------
UCKeySequenceDataIndex	RECORD 0
keySequenceDataIndexFormat  ds.w 1				; offset: $0 (0)		;  =kUCKeySequenceDataIndexFormat
charSequenceCount		 ds.w	1				; offset: $2 (2)		;  Dimension of charSequenceOffsets[] is charSequenceCount+1
charSequenceOffsets		 ds.w	1				; offset: $4 (4) <-- really an array of length one
;  Each offset in charSequenceOffsets is in bytes, from the beginning of
;  UCKeySequenceDataIndex to a sequence of UniChars; the next offset indicates the
;  end of the sequence. The UniChar sequences follow the UCKeySequenceDataIndex.
;  Then there is padding to a 4-byte boundary with bytes containing 0, if necessary.
sizeof					 EQU *					; size:   $6 (6)
						ENDR
;  -------------------------------------------------------------------------------------------------
;  Current format codes for the various tables (bits 12-15 indicate which table)


kUCKeyLayoutHeaderFormat		EQU		$1002
kUCKeyLayoutFeatureInfoFormat	EQU		$2001
kUCKeyModifiersToTableNumFormat	EQU		$3001
kUCKeyToCharTableIndexFormat	EQU		$4001
kUCKeyStateRecordsIndexFormat	EQU		$5001
kUCKeyStateTerminatorsFormat	EQU		$6001
kUCKeySequenceDataIndexFormat	EQU		$7001


;   -------------------------------------------------------------------------------------------------
;   Constants for keyAction parameter in UCKeyTranslate() 
;   -------------------------------------------------------------------------------------------------




kUCKeyActionDown				EQU		0					; key is going down
kUCKeyActionUp					EQU		1					; key is going up
kUCKeyActionAutoKey				EQU		2					; auto-key down
kUCKeyActionDisplay				EQU		3					; get information for key display (as in Key Caps)      

;   -------------------------------------------------------------------------------------------------
;   Bit assignments & masks for keyTranslateOptions parameter in UCKeyTranslate() 
;   -------------------------------------------------------------------------------------------------




kUCKeyTranslateNoDeadKeysBit	EQU		0					; Prevents setting any new dead-key states

kUCKeyTranslateNoDeadKeysMask	EQU		$00000001

;   -------------------------------------------------------------------------------------------------
;   CONSTANTS & DATA STRUCTURES for Unicode Collation
;   -------------------------------------------------------------------------------------------------


;  constant for LocaleOperationClass

kUnicodeCollationClass			EQU		'ucol'



; typedef UInt32						UCCollateOptions
															; Sensitivity options
kUCCollateComposeInsensitiveMask EQU	$00000002
kUCCollateWidthInsensitiveMask	EQU		$00000004
kUCCollateCaseInsensitiveMask	EQU		$00000008
kUCCollateDiacritInsensitiveMask EQU	$00000010			; Other general options 
kUCCollatePunctuationSignificantMask EQU $00008000			; Number-handling options 
kUCCollateDigitsOverrideMask	EQU		$00010000
kUCCollateDigitsAsNumberMask	EQU		$00020000

kUCCollateStandardOptions		EQU		$00000006

;   Special values to specify various invariant orders for UCCompareTextNoLocale.
;   These values use the high 8 bits of UCCollateOptions.



kUCCollateTypeHFSExtended		EQU		1
;  These constants are used for masking and shifting the invariant order type.

kUCCollateTypeSourceMask		EQU		$000000FF
kUCCollateTypeShiftBits			EQU		24

kUCCollateTypeMask				EQU		$FF000000
; typedef UInt32 						UCCollationValue


;   -------------------------------------------------------------------------------------------------
;   CONSTANTS & DATA STRUCTURES for Unicode TextBreak
;   -------------------------------------------------------------------------------------------------


;  constant for LocaleOperationClass

kUnicodeTextBreakClass			EQU		'ubrk'



; typedef UInt32						UCTextBreakType
kUCTextBreakCharMask			EQU		$00000001
kUCTextBreakClusterMask			EQU		$00000004
kUCTextBreakWordMask			EQU		$00000010
kUCTextBreakLineMask			EQU		$00000040

; typedef UInt32						UCTextBreakOptions
kUCTextBreakLeadingEdgeMask		EQU		$00000001
kUCTextBreakGoBackwardsMask		EQU		$00000002
kUCTextBreakIterateMask			EQU		$00000004

;   -------------------------------------------------------------------------------------------------
;   FUNCTION PROTOTYPES
;   -------------------------------------------------------------------------------------------------




; *  UCKeyTranslate()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in UnicodeUtilitiesCoreLib 8.5 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal OSStatus UCKeyTranslate(const UCKeyboardLayout *keyLayoutPtr, UInt16 virtualKeyCode, UInt16 keyAction, UInt32 modifierKeyState, UInt32 keyboardType, OptionBits keyTranslateOptions, UInt32 *deadKeyState, UniCharCount maxStringLength, UniCharCount *actualStringLength, UniChar unicodeString[])
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UCKeyTranslate
	ENDIF

;  Standard collation functions

; *  UCCreateCollator()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in UnicodeUtilitiesLib 8.6 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus UCCreateCollator(LocaleRef locale, LocaleOperationVariant opVariant, UCCollateOptions options, CollatorRef *collatorRef)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UCCreateCollator
	ENDIF


; *  UCGetCollationKey()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in UnicodeUtilitiesLib 8.6 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus UCGetCollationKey(CollatorRef collatorRef, const UniChar *textPtr, UniCharCount textLength, ItemCount maxKeySize, ItemCount *actualKeySize, UCCollationValue collationKey[])
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UCGetCollationKey
	ENDIF


; *  UCCompareCollationKeys()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in UnicodeUtilitiesCoreLib 8.6 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus UCCompareCollationKeys(const UCCollationValue *key1Ptr, ItemCount key1Length, const UCCollationValue *key2Ptr, ItemCount key2Length, Boolean *equivalent, SInt32 *order)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UCCompareCollationKeys
	ENDIF


; *  UCCompareText()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in UnicodeUtilitiesLib 8.6 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus UCCompareText(CollatorRef collatorRef, const UniChar *text1Ptr, UniCharCount text1Length, const UniChar *text2Ptr, UniCharCount text2Length, Boolean *equivalent, SInt32 *order)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UCCompareText
	ENDIF


; *  UCDisposeCollator()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in UnicodeUtilitiesLib 8.6 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus UCDisposeCollator(CollatorRef *collatorRef)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UCDisposeCollator
	ENDIF

;  Simple collation using default locale


; *  UCCompareTextDefault()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in UnicodeUtilitiesLib 8.6 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus UCCompareTextDefault(UCCollateOptions options, const UniChar *text1Ptr, UniCharCount text1Length, const UniChar *text2Ptr, UniCharCount text2Length, Boolean *equivalent, SInt32 *order)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UCCompareTextDefault
	ENDIF


;  Simple locale-independent collation


; *  UCCompareTextNoLocale()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in UnicodeUtilitiesCoreLib 8.6 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus UCCompareTextNoLocale(UCCollateOptions options, const UniChar *text1Ptr, UniCharCount text1Length, const UniChar *text2Ptr, UniCharCount text2Length, Boolean *equivalent, SInt32 *order)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UCCompareTextNoLocale
	ENDIF

;  Standard text break (text boundary) functions

; *  UCCreateTextBreakLocator()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in UnicodeUtilitiesLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus UCCreateTextBreakLocator(LocaleRef locale, LocaleOperationVariant opVariant, UCTextBreakType breakTypes, TextBreakLocatorRef *breakRef)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UCCreateTextBreakLocator
	ENDIF


; *  UCFindTextBreak()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in UnicodeUtilitiesLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus UCFindTextBreak(TextBreakLocatorRef breakRef, UCTextBreakType breakType, UCTextBreakOptions options, const UniChar *textPtr, UniCharCount textLength, UniCharArrayOffset startOffset, UniCharArrayOffset *breakOffset)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UCFindTextBreak
	ENDIF


; *  UCDisposeTextBreakLocator()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in UnicodeUtilitiesLib 9.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern OSStatus UCDisposeTextBreakLocator(TextBreakLocatorRef *breakRef)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION UCDisposeTextBreakLocator
	ENDIF

	ENDIF ; __UNICODEUTILITIES__ 


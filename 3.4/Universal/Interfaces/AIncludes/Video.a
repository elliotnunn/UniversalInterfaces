;
;    File:       Video.a
;
;    Contains:   Video Driver Interfaces.
;
;    Version:    Technology: System 9.X
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1986-2001 by Apple Computer, Inc., all rights reserved
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__VIDEO__') = 'UNDEFINED' THEN
__VIDEO__ SET 1

	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF


mBaseOffset						EQU		1					;Id of mBaseOffset.
mRowBytes						EQU		2					;Video sResource parameter Id's 
mBounds							EQU		3					;Video sResource parameter Id's 
mVersion						EQU		4					;Video sResource parameter Id's 
mHRes							EQU		5					;Video sResource parameter Id's 
mVRes							EQU		6					;Video sResource parameter Id's 
mPixelType						EQU		7					;Video sResource parameter Id's 
mPixelSize						EQU		8					;Video sResource parameter Id's 
mCmpCount						EQU		9					;Video sResource parameter Id's 
mCmpSize						EQU		10					;Video sResource parameter Id's 
mPlaneBytes						EQU		11					;Video sResource parameter Id's 
mVertRefRate					EQU		14					;Video sResource parameter Id's 
mVidParams						EQU		1					;Video parameter block id.
mTable							EQU		2					;Offset to the table.
mPageCnt						EQU		3					;Number of pages
mDevType						EQU		4					;Device Type
oneBitMode						EQU		128					;Id of OneBitMode Parameter list.
twoBitMode						EQU		129					;Id of TwoBitMode Parameter list.
fourBitMode						EQU		130					;Id of FourBitMode Parameter list.
eightBitMode					EQU		131					;Id of EightBitMode Parameter list.

sixteenBitMode					EQU		132					;Id of SixteenBitMode Parameter list.
thirtyTwoBitMode				EQU		133					;Id of ThirtyTwoBitMode Parameter list.
firstVidMode					EQU		128					;The new, better way to do the above. 
secondVidMode					EQU		129					; QuickDraw only supports six video 
thirdVidMode					EQU		130					; at this time.      
fourthVidMode					EQU		131
fifthVidMode					EQU		132
sixthVidMode					EQU		133
spGammaDir						EQU		64
spVidNamesDir					EQU		65

;  csTimingFormat values in VDTimingInfo 
;  look in the declaration rom for timing info 

kDeclROMtables					EQU		'decl'
kDetailedTimingFormat			EQU		'arba'				; Timing is a detailed timing
;  Size of a block of EDID (Extended Display Identification Data) 

kDDCBlockSize					EQU		128
;  ddcBlockType constants

kDDCBlockTypeEDID				EQU		0					; EDID block type. 
;  ddcFlags constants

kDDCForceReadBit				EQU		0					; Force a new read of the EDID. 
kDDCForceReadMask				EQU		$01					; Mask for kddcForceReadBit. 

;  Timing mode constants for Display Manager MultiMode support
;    Corresponding   .h equates are in Video.h
;                    .a equates are in Video.a
;                    .r equates are in DepVideoEqu.r
;    
;    The second enum is the old names (for compatibility).
;    The first enum is the new names.
;


timingInvalid					EQU		0					;    Unknown timing… force user to confirm. 
timingInvalid_SM_T24			EQU		8					;    Work around bug in SM Thunder24 card.
timingApple_FixedRateLCD		EQU		42					;    Lump all fixed-rate LCDs into one category.
timingApple_512x384_60hz		EQU		130					;  512x384  (60 Hz) Rubik timing. 
timingApple_560x384_60hz		EQU		135					;  560x384  (60 Hz) Rubik-560 timing. 
timingApple_640x480_67hz		EQU		140					;  640x480  (67 Hz) HR timing. 
timingApple_640x400_67hz		EQU		145					;  640x400  (67 Hz) HR-400 timing. 
timingVESA_640x480_60hz			EQU		150					;  640x480  (60 Hz) VGA timing. 
timingVESA_640x480_72hz			EQU		152					;  640x480  (72 Hz) VGA timing. 
timingVESA_640x480_75hz			EQU		154					;  640x480  (75 Hz) VGA timing. 
timingVESA_640x480_85hz			EQU		158					;  640x480  (85 Hz) VGA timing. 
timingGTF_640x480_120hz			EQU		159					;  640x480  (120 Hz) VESA Generalized Timing Formula 
timingApple_640x870_75hz		EQU		160					;  640x870  (75 Hz) FPD timing.
timingApple_640x818_75hz		EQU		165					;  640x818  (75 Hz) FPD-818 timing.
timingApple_832x624_75hz		EQU		170					;  832x624  (75 Hz) GoldFish timing.
timingVESA_800x600_56hz			EQU		180					;  800x600  (56 Hz) SVGA timing. 
timingVESA_800x600_60hz			EQU		182					;  800x600  (60 Hz) SVGA timing. 
timingVESA_800x600_72hz			EQU		184					;  800x600  (72 Hz) SVGA timing. 
timingVESA_800x600_75hz			EQU		186					;  800x600  (75 Hz) SVGA timing. 
timingVESA_800x600_85hz			EQU		188					;  800x600  (85 Hz) SVGA timing. 
timingVESA_1024x768_60hz		EQU		190					; 1024x768  (60 Hz) VESA 1K-60Hz timing. 
timingVESA_1024x768_70hz		EQU		200					; 1024x768  (70 Hz) VESA 1K-70Hz timing. 
timingVESA_1024x768_75hz		EQU		204					; 1024x768  (75 Hz) VESA 1K-75Hz timing (very similar to timingApple_1024x768_75hz). 
timingVESA_1024x768_85hz		EQU		208					; 1024x768  (85 Hz) VESA timing. 
timingApple_1024x768_75hz		EQU		210					; 1024x768  (75 Hz) Apple 19" RGB. 
timingApple_1152x870_75hz		EQU		220					; 1152x870  (75 Hz) Apple 21" RGB. 
timingAppleNTSC_ST				EQU		230					;  512x384  (60 Hz, interlaced, non-convolved). 
timingAppleNTSC_FF				EQU		232					;  640x480  (60 Hz, interlaced, non-convolved). 
timingAppleNTSC_STconv			EQU		234					;  512x384  (60 Hz, interlaced, convolved). 
timingAppleNTSC_FFconv			EQU		236					;  640x480  (60 Hz, interlaced, convolved). 
timingApplePAL_ST				EQU		238					;  640x480  (50 Hz, interlaced, non-convolved). 
timingApplePAL_FF				EQU		240					;  768x576  (50 Hz, interlaced, non-convolved). 
timingApplePAL_STconv			EQU		242					;  640x480  (50 Hz, interlaced, convolved). 
timingApplePAL_FFconv			EQU		244					;  768x576  (50 Hz, interlaced, convolved). 
timingVESA_1280x960_75hz		EQU		250					; 1280x960  (75 Hz) 
timingVESA_1280x960_60hz		EQU		252					; 1280x960  (60 Hz) 
timingVESA_1280x960_85hz		EQU		254					; 1280x960  (85 Hz) 
timingVESA_1280x1024_60hz		EQU		260					; 1280x1024 (60 Hz) 
timingVESA_1280x1024_75hz		EQU		262					; 1280x1024 (75 Hz) 
timingVESA_1280x1024_85hz		EQU		268					; 1280x1024 (85 Hz) 
timingVESA_1600x1200_60hz		EQU		280					; 1600x1200 (60 Hz) VESA timing. 
timingVESA_1600x1200_65hz		EQU		282					; 1600x1200 (65 Hz) VESA timing. 
timingVESA_1600x1200_70hz		EQU		284					; 1600x1200 (70 Hz) VESA timing. 
timingVESA_1600x1200_75hz		EQU		286					; 1600x1200 (75 Hz) VESA timing (pixel clock is 189.2 Mhz dot clock). 
timingVESA_1600x1200_80hz		EQU		288					; 1600x1200 (80 Hz) VESA timing (pixel clock is 216>? Mhz dot clock) - proposed only. 
timingVESA_1600x1200_85hz		EQU		289					; 1600x1200 (85 Hz) VESA timing (pixel clock is 229.5 Mhz dot clock). 
timingVESA_1792x1344_60hz		EQU		296					; 1792x1344 (60 Hz) VESA timing (204.75 Mhz dot clock). 
timingVESA_1792x1344_75hz		EQU		298					; 1792x1344 (75 Hz) VESA timing (261.75 Mhz dot clock). 
timingVESA_1856x1392_60hz		EQU		300					; 1856x1392 (60 Hz) VESA timing (218.25 Mhz dot clock). 
timingVESA_1856x1392_75hz		EQU		302					; 1856x1392 (75 Hz) VESA timing (288 Mhz dot clock). 
timingVESA_1920x1440_60hz		EQU		304					; 1920x1440 (60 Hz) VESA timing (234 Mhz dot clock). 
timingVESA_1920x1440_75hz		EQU		306					; 1920x1440 (75 Hz) VESA timing (297 Mhz dot clock). 
timingSMPTE240M_60hz			EQU		400					; 60Hz V, 33.75KHz H, interlaced timing, 16:9 aspect, typical resolution of 1920x1035. 
timingFilmRate_48hz				EQU		410					; 48Hz V, 25.20KHz H, non-interlaced timing, typical resolution of 640x480. 
timingSony_1600x1024_76hz		EQU		500					; 1600x1024 (76 Hz) Sony timing (pixel clock is 170.447 Mhz dot clock). 
timingSony_1920x1080_60hz		EQU		510					; 1920x1080 (60 Hz) Sony timing (pixel clock is 159.84 Mhz dot clock). 
timingSony_1920x1080_72hz		EQU		520					; 1920x1080 (72 Hz) Sony timing (pixel clock is 216.023 Mhz dot clock). 
timingSony_1920x1200_76hz		EQU		540					; 1900x1200 (76 Hz) Sony timing (pixel clock is 243.20 Mhz dot clock). 
timingApple_0x0_0hz_Offline		EQU		550					; Indicates that this timing will take the display off-line and remove it from the system. 

;  Deprecated timing names.

timingApple12					EQU		130
timingApple12x					EQU		135
timingApple13					EQU		140
timingApple13x					EQU		145
timingAppleVGA					EQU		150
timingApple15					EQU		160
timingApple15x					EQU		165
timingApple16					EQU		170
timingAppleSVGA					EQU		180
timingApple1Ka					EQU		190
timingApple1Kb					EQU		200
timingApple19					EQU		210
timingApple21					EQU		220
timingSony_1900x1200_74hz		EQU		530					; 1900x1200 (74 Hz) Sony timing (pixel clock is 236.25 Mhz dot clock). 
timingSony_1900x1200_76hz		EQU		540					; 1900x1200 (76 Hz) Sony timing (pixel clock is 245.48 Mhz dot clock). 
;  csConnectFlags values in VDDisplayConnectInfo 

kAllModesValid					EQU		0					; All modes not trimmed by primary init are good close enough to try 
kAllModesSafe					EQU		1					; All modes not trimmed by primary init are know to be safe 
kReportsTagging					EQU		2					; Can detect tagged displays (to identify smart monitors) 
kHasDirectConnection			EQU		3					; True implies that driver can talk directly to device (e.g. serial data link via sense lines) 
kIsMonoDev						EQU		4					; Says whether there’s an RGB (0) or Monochrome (1) connection. 
kUncertainConnection			EQU		5					; There may not be a display (no sense lines?). 
kTaggingInfoNonStandard			EQU		6					; Set when csConnectTaggedType/csConnectTaggedData are non-standard (i.e., not the Apple CRT sense codes). 
kReportsDDCConnection			EQU		7					; Card can do ddc (set kHasDirectConnect && kHasDDCConnect if you actually found a ddc display). 
kHasDDCConnection				EQU		8					; Card has ddc connect now. 
kConnectionInactive				EQU		9					; Set when the connection is NOT currently active (generally used in a multiconnection environment). 
kDependentConnection			EQU		10					; Set when some ascpect of THIS connection depends on another (will generally be set in a kModeSimulscan environment). 
kBuiltInConnection				EQU		11					; Set when connection is KNOWN to be built-in (this is not the same as kHasDirectConnection). 
kOverrideConnection				EQU		12					; Set when the reported connection is not the true one, but is one that has been forced through a SetConnection call 
kFastCheckForDDC				EQU		13					; Set when all 3 are true: 1) sense codes indicate DDC display could be attached 2) attempted fast check 3) DDC failed 
kReportsHotPlugging				EQU		14					; Detects and reports hot pluggging on connector (via VSL also implies DDC will be up to date w/o force read) 

;  csDisplayType values in VDDisplayConnectInfo 

kUnknownConnect					EQU		1					; Not sure how we’ll use this, but seems like a good idea. 
kPanelConnect					EQU		2					; For use with fixed-in-place LCD panels. 
kPanelTFTConnect				EQU		2					; Alias for kPanelConnect 
kFixedModeCRTConnect			EQU		3					;  For use with fixed-mode (i.e., very limited range) displays. 
kMultiModeCRT1Connect			EQU		4					; 320x200 maybe, 12" maybe, 13" (default), 16" certain, 19" maybe, 21" maybe 
kMultiModeCRT2Connect			EQU		5					; 320x200 maybe, 12" maybe, 13" certain, 16" (default), 19" certain, 21" maybe 
kMultiModeCRT3Connect			EQU		6					; 320x200 maybe, 12" maybe, 13" certain, 16" certain, 19" default, 21" certain 
kMultiModeCRT4Connect			EQU		7					; Expansion to large multi mode (not yet used) 
kModelessConnect				EQU		8					; Expansion to modeless model (not yet used) 
kFullPageConnect				EQU		9					; 640x818 (to get 8bpp in 512K case) and 640x870 (these two only) 
kVGAConnect						EQU		10					; 640x480 VGA default -- question everything else 
kNTSCConnect					EQU		11					; NTSC ST (default), FF, STconv, FFconv 
kPALConnect						EQU		12					; PAL ST (default), FF, STconv, FFconv 
kHRConnect						EQU		13					; Straight-6 connect -- 640x480 and 640x400 (to get 8bpp in 256K case) (these two only) 
kPanelFSTNConnect				EQU		14					; For use with fixed-in-place LCD FSTN (aka “Supertwist”) panels 
kMonoTwoPageConnect				EQU		15					; 1152x870 Apple color two-page display 
kColorTwoPageConnect			EQU		16					; 1152x870 Apple B&W two-page display 
kColor16Connect					EQU		17					; 832x624 Apple B&W two-page display 
kColor19Connect					EQU		18					; 1024x768 Apple B&W two-page display 
kGenericCRT						EQU		19					; Indicates nothing except that connection is CRT in nature. 
kGenericLCD						EQU		20					; Indicates nothing except that connection is LCD in nature. 
kDDCConnect						EQU		21					; DDC connection, always set kHasDDCConnection 
kNoConnect						EQU		22					; No display is connected - load sensing or similar level of hardware detection is assumed (used by resident drivers that support hot plugging when nothing is currently connected) 
;  csTimingFlags values in VDTimingInfoRec 

kModeValid						EQU		0					; Says that this mode should NOT be trimmed. 
kModeSafe						EQU		1					; This mode does not need confirmation 
kModeDefault					EQU		2					; This is the default mode for this type of connection 
kModeShowNow					EQU		3					; This mode should always be shown (even though it may require a confirm) 
kModeNotResize					EQU		4					; This mode should not be used to resize the display (eg. mode selects a different connector on card) 
kModeRequiresPan				EQU		5					; This mode has more pixels than are actually displayed 
kModeInterlaced					EQU		6					; This mode is interlaced (single pixel lines look bad). 
kModeShowNever					EQU		7					; This mode should not be shown in the user interface. 
kModeSimulscan					EQU		8					; Indicates that more than one display connection can be driven from a single framebuffer controller. 
kModeNotPreset					EQU		9					; Indicates that the timing is not a factory preset for the current display (geometry may need correction) 
kModeBuiltIn					EQU		10					; Indicates that the display mode is for the built-in connect only (on multiconnect devices like the PB 3400) Only the driver is quieried 
kModeStretched					EQU		11					; Indicates that the display mode will be stretched/distorted to match the display aspect ratio 
;  csDepthFlags in VDVideoParametersInfoRec 

kDepthDependent					EQU		0					; Says that this depth mode may cause dependent changes in other framebuffers (and . 
;  csResolutionFlags bit flags for VDResolutionInfoRec 

kResolutionHasMultipleDepthSizes EQU	0					; Says that this mode has different csHorizontalPixels, csVerticalLines at different depths (usually slightly larger at lower depths) 


															;    Power Mode constants for VDPowerStateRec.powerState.  Note the numeric order does not match the power state order 
kAVPowerOff						EQU		0					; Power fully off
kAVPowerStandby					EQU		1
kAVPowerSuspend					EQU		2
kAVPowerOn						EQU		3
kHardwareSleep					EQU		128
kHardwareWake					EQU		129
kHardwareWakeFromSuspend		EQU		130
kHardwareWakeToDoze				EQU		131
kHardwareWakeToDozeFromSuspend	EQU		132

															;    Power Mode masks and bits for VDPowerStateRec.powerFlags.  
kPowerStateNeedsRefresh			EQU		0					; When leaving this power mode, a display will need refreshing   
kPowerStateSleepAwareBit		EQU		1					; if gestaltPCCardDockingSelectorFix, Docking mgr checks this bit before checking kPowerStateSleepAllowedBit 
kPowerStateSleepForbiddenBit	EQU		2					; if kPowerStateSleepAwareBit, Docking mgr checks this bit before sleeping 
kPowerStateSleepCanPowerOffBit	EQU		3					; supports power down sleep (ie PCI power off)
kPowerStateSleepNoDPMSBit		EQU		4					; Bug #2425210.  Do not use DPMS with this display.
kPowerStateSleepWaketoDozeBit	EQU		5					; Supports Wake to Doze 
kPowerStateNeedsRefreshMask		EQU		$00000001
kPowerStateSleepAwareMask		EQU		$00000002
kPowerStateSleepForbiddenMask	EQU		$00000004
kPowerStateSleepCanPowerOffMask	EQU		$00000008
kPowerStateSleepNoDPMSMask		EQU		$00000010
kPowerStateSleepWaketoDozeMask	EQU		$00000020


															; Control Codes 
cscReset						EQU		0
cscKillIO						EQU		1
cscSetMode						EQU		2
cscSetEntries					EQU		3
cscSetGamma						EQU		4
cscGrayPage						EQU		5
cscGrayScreen					EQU		5
cscSetGray						EQU		6
cscSetInterrupt					EQU		7
cscDirectSetEntries				EQU		8
cscSetDefaultMode				EQU		9
cscSwitchMode					EQU		10					; Takes a VDSwitchInfoPtr 
cscSetSync						EQU		11					; Takes a VDSyncInfoPtr 
cscSavePreferredConfiguration	EQU		16					; Takes a VDSwitchInfoPtr 
cscSetHardwareCursor			EQU		22					; Takes a VDSetHardwareCursorPtr 
cscDrawHardwareCursor			EQU		23					; Takes a VDDrawHardwareCursorPtr 
cscSetConvolution				EQU		24					; Takes a VDConvolutionInfoPtr 
cscSetPowerState				EQU		25					; Takes a VDPowerStatePtr 
cscPrivateControlCall			EQU		26					; Takes a VDPrivateSelectorDataPtr 
cscSetMultiConnect				EQU		28					; Takes a VDMultiConnectInfoPtr 
cscSetClutBehavior				EQU		29					; Takes a VDClutBehavior 
cscSetDetailedTiming			EQU		31					; Takes a VDDetailedTimingPtr 
cscDoCommunication				EQU		33					; Takes a VDCommunicationPtr 
cscProbeConnection				EQU		34					; Takes nil pointer (may generate a kFBConnectInterruptServiceType service interrupt)
cscUnusedCall					EQU		127					; This call used to expend the scrn resource.  Its imbedded data contains more control info 

															; Status Codes 
cscGetMode						EQU		2
cscGetEntries					EQU		3
cscGetPageCnt					EQU		4
cscGetPages						EQU		4					; This is what C&D 2 calls it. 
cscGetPageBase					EQU		5
cscGetBaseAddr					EQU		5					; This is what C&D 2 calls it. 
cscGetGray						EQU		6
cscGetInterrupt					EQU		7
cscGetGamma						EQU		8
cscGetDefaultMode				EQU		9
cscGetCurMode					EQU		10					; Takes a VDSwitchInfoPtr 
cscGetSync						EQU		11					; Takes a VDSyncInfoPtr 
cscGetConnection				EQU		12					; Return information about the connection to the display 
cscGetModeTiming				EQU		13					; Return timing info for a mode 
cscGetModeBaseAddress			EQU		14					; Return base address information about a particular mode 
cscGetScanProc					EQU		15					; QuickTime scan chasing routine 
cscGetPreferredConfiguration	EQU		16					; Takes a VDSwitchInfoPtr 
cscGetNextResolution			EQU		17					; Takes a VDResolutionInfoPtr 
cscGetVideoParameters			EQU		18					; Takes a VDVideoParametersInfoPtr 
cscGetGammaInfoList				EQU		20					; Takes a VDGetGammaListPtr 
cscRetrieveGammaTable			EQU		21					; Takes a VDRetrieveGammaPtr 
cscSupportsHardwareCursor		EQU		22					; Takes a VDSupportsHardwareCursorPtr 
cscGetHardwareCursorDrawState	EQU		23					; Takes a VDHardwareCursorDrawStatePtr 
cscGetConvolution				EQU		24					; Takes a VDConvolutionInfoPtr 
cscGetPowerState				EQU		25					; Takes a VDPowerStatePtr 
cscPrivateStatusCall			EQU		26					; Takes a VDPrivateSelectorDataPtr 
cscGetDDCBlock					EQU		27					; Takes a VDDDCBlockPtr  
cscGetMultiConnect				EQU		28					; Takes a VDMultiConnectInfoPtr 
cscGetClutBehavior				EQU		29					; Takes a VDClutBehaviorPtr 
cscGetTimingRanges				EQU		30					; Takes a VDDisplayTimingRangePtr 
cscGetDetailedTiming			EQU		31					; Takes a VDDetailedTimingPtr 
cscGetCommunicationInfo			EQU		32					; Takes a VDCommunicationInfoPtr 
;  Bit definitions for the Get/Set Sync call

kDisableHorizontalSyncBit		EQU		0
kDisableVerticalSyncBit			EQU		1
kDisableCompositeSyncBit		EQU		2
kEnableSyncOnBlue				EQU		3
kEnableSyncOnGreen				EQU		4
kEnableSyncOnRed				EQU		5
kNoSeparateSyncControlBit		EQU		6
kTriStateSyncBit				EQU		7
kHorizontalSyncMask				EQU		$01
kVerticalSyncMask				EQU		$02
kCompositeSyncMask				EQU		$04
kDPMSSyncMask					EQU		$07
kTriStateSyncMask				EQU		$80
kSyncOnBlueMask					EQU		$08
kSyncOnGreenMask				EQU		$10
kSyncOnRedMask					EQU		$20
kSyncOnMask						EQU		$38

															;    Power Mode constants for translating DPMS modes to Get/SetSync calls.  
kDPMSSyncOn						EQU		0
kDPMSSyncStandby				EQU		1
kDPMSSyncSuspend				EQU		2
kDPMSSyncOff					EQU		7
;  Bit definitions for the Get/Set Convolution call

kConvolved						EQU		0
kLiveVideoPassThru				EQU		1
kConvolvedMask					EQU		$01
kLiveVideoPassThruMask			EQU		$02

VPBlock					RECORD 0
vpBaseOffset			 ds.l	1				; offset: $0 (0)		; Offset to page zero of video RAM (From minorBaseOS).
vpRowBytes				 ds.w	1				; offset: $4 (4)		; Width of each row of video memory.
vpBounds				 ds		Rect			; offset: $6 (6)		; BoundsRect for the video display (gives dimensions).
vpVersion				 ds.w	1				; offset: $E (14)		; PixelMap version number.
vpPackType				 ds.w	1				; offset: $10 (16)
vpPackSize				 ds.l	1				; offset: $12 (18)
vpHRes					 ds.l	1				; offset: $16 (22)		; Horizontal resolution of the device (pixels per inch).
vpVRes					 ds.l	1				; offset: $1A (26)		; Vertical resolution of the device (pixels per inch).
vpPixelType				 ds.w	1				; offset: $1E (30)		; Defines the pixel type.
vpPixelSize				 ds.w	1				; offset: $20 (32)		; Number of bits in pixel.
vpCmpCount				 ds.w	1				; offset: $22 (34)		; Number of components in pixel.
vpCmpSize				 ds.w	1				; offset: $24 (36)		; Number of bits per component
vpPlaneBytes			 ds.l	1				; offset: $26 (38)		; Offset from one plane to the next.
sizeof					 EQU *					; size:   $2A (42)
						ENDR
; typedef struct VPBlock *				VPBlockPtr

VDEntryRecord			RECORD 0
csTable					 ds.l	1				; offset: $0 (0)		; (long) pointer to color table entry=value, r,g,b:INTEGER
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct VDEntryRecord *		VDEntRecPtr

;  Parm block for SetGray control call 
VDGrayRecord			RECORD 0
csMode					 ds.b	1				; offset: $0 (0)		; Same as GDDevType value (0=color, 1=mono)
filler					 ds.b	1				; offset: $1 (1)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
; typedef struct VDGrayRecord *			VDGrayPtr

;  Parm block for SetInterrupt call 
VDFlagRecord			RECORD 0
csMode					 ds.b	1				; offset: $0 (0)
filler					 ds.b	1				; offset: $1 (1)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
; typedef struct VDFlagRecord *			VDFlagRecPtr

;  Parm block for SetEntries control call 
VDSetEntryRecord		RECORD 0
csTable					 ds.l	1				; offset: $0 (0)		; Pointer to an array of color specs
csStart					 ds.w	1				; offset: $4 (4)		; Which spec in array to start with, or -1
csCount					 ds.w	1				; offset: $6 (6)		; Number of color spec entries to set
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct VDSetEntryRecord *		VDSetEntryPtr

;  Parm block for SetGamma control call 
VDGammaRecord			RECORD 0
csGTable				 ds.l	1				; offset: $0 (0)		; pointer to gamma table
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct VDGammaRecord *		VDGamRecPtr

VDBaseAddressInfoRec	RECORD 0
csDevData				 ds.l	1				; offset: $0 (0)		;  LONGINT - (long) timing mode 
csDevBase				 ds.l	1				; offset: $4 (4)		;  LONGINT - (long) base address of the mode 
csModeReserved			 ds.w	1				; offset: $8 (8)		;  INTEGER - (short) will some day be the depth 
csModeBase				 ds.l	1				; offset: $A (10)		;  LONGINT - (long) reserved 
sizeof					 EQU *					; size:   $E (14)
						ENDR
; typedef struct VDBaseAddressInfoRec *	VDBaseAddressInfoPtr

VDSwitchInfoRec			RECORD 0
csMode					 ds.w	1				; offset: $0 (0)		; (word) mode depth
csData					 ds.l	1				; offset: $2 (2)		; (long) functional sResource of mode
csPage					 ds.w	1				; offset: $6 (6)		; (word) page to switch in
csBaseAddr				 ds.l	1				; offset: $8 (8)		; (long) base address of page (return value)
csReserved				 ds.l	1				; offset: $C (12)		; (long) Reserved (set to 0) 
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct VDSwitchInfoRec *		VDSwitchInfoPtr

VDTimingInfoRec			RECORD 0
csTimingMode			 ds.l	1				; offset: $0 (0)		;  LONGINT - (long) timing mode (a la InitGDevice) 
csTimingReserved		 ds.l	1				; offset: $4 (4)		;  LONGINT - (long) reserved 
csTimingFormat			 ds.l	1				; offset: $8 (8)		;  LONGINT - (long) what format is the timing info 
csTimingData			 ds.l	1				; offset: $C (12)		;  LONGINT - (long) data supplied by driver 
csTimingFlags			 ds.l	1				; offset: $10 (16)		;  LONGINT - (long) mode within device 
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct VDTimingInfoRec *		VDTimingInfoPtr

VDDisplayConnectInfoRec	RECORD 0
csDisplayType			 ds.w	1				; offset: $0 (0)		;  INTEGER - (word) Type of display connected 
csConnectTaggedType		 ds.b	1				; offset: $2 (2)		;  BYTE - type of tagging 
csConnectTaggedData		 ds.b	1				; offset: $3 (3)		;  BYTE - tagging data 
csConnectFlags			 ds.l	1				; offset: $4 (4)		;  LONGINT - (long) tell us about the connection 
csDisplayComponent		 ds.l	1				; offset: $8 (8)		;  LONGINT - (long) if the card has a direct connection to the display, it returns the display component here (FUTURE) 
csConnectReserved		 ds.l	1				; offset: $C (12)		;  LONGINT - (long) reserved 
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct VDDisplayConnectInfoRec * VDDisplayConnectInfoPtr

VDMultiConnectInfoRec	RECORD 0
csDisplayCountOrNumber	 ds.l	1				; offset: $0 (0)		;  For GetMultiConnect, returns count n of 1..n connections; otherwise, indicates the ith connection.
csConnectInfo			 ds		VDDisplayConnectInfoRec ; offset: $4 (4) ;  Standard VDDisplayConnectionInfo for connection i.
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct VDMultiConnectInfoRec * VDMultiConnectInfoPtr

;  RawSenseCode
;    This abstract data type is not exactly abstract.  Rather, it is merely enumerated constants
;    for the possible raw sense code values when 'standard' sense code hardware is implemented.
;
;    For 'standard' sense code hardware, the raw sense is obtained as follows:
;        • Instruct the frame buffer controller NOT to actively drive any of the monitor sense lines
;        • Read the state of the monitor sense lines 2, 1, and 0.  (2 is the MSB, 0 the LSB)
;
;    IMPORTANT Note: 
;    When the 'kTaggingInfoNonStandard' bit of 'csConnectFlags' is FALSE, then these constants 
;    are valid 'csConnectTaggedType' values in 'VDDisplayConnectInfo' 
;
;

; typedef unsigned char 				RawSenseCode


kRSCZero						EQU		0
kRSCOne							EQU		1
kRSCTwo							EQU		2
kRSCThree						EQU		3
kRSCFour						EQU		4
kRSCFive						EQU		5
kRSCSix							EQU		6
kRSCSeven						EQU		7

;  ExtendedSenseCode
;    This abstract data type is not exactly abstract.  Rather, it is merely enumerated constants
;    for the values which are possible when the extended sense algorithm is applied to hardware
;    which implements 'standard' sense code hardware.
;
;    For 'standard' sense code hardware, the extended sense code algorithm is as follows:
;    (Note:  as described here, sense line 'A' corresponds to '2', 'B' to '1', and 'C' to '0')
;        • Drive sense line 'A' low and read the values of 'B' and 'C'.  
;        • Drive sense line 'B' low and read the values of 'A' and 'C'.
;        • Drive sense line 'C' low and read the values of 'A' and 'B'.
;
;    In this way, a six-bit number of the form BC/AC/AB is generated. 
;
;    IMPORTANT Note: 
;    When the 'kTaggingInfoNonStandard' bit of 'csConnectFlags' is FALSE, then these constants 
;    are valid 'csConnectTaggedData' values in 'VDDisplayConnectInfo' 
;
;

; typedef unsigned char 				ExtendedSenseCode


kESCZero21Inch					EQU		$00					; 21" RGB                     
kESCOnePortraitMono				EQU		$14					; Portrait Monochrome              
kESCTwo12Inch					EQU		$21					; 12" RGB                    
kESCThree21InchRadius			EQU		$31					; 21" RGB (Radius)               
kESCThree21InchMonoRadius		EQU		$34					; 21" Monochrome (Radius)           
kESCThree21InchMono				EQU		$35					; 21" Monochrome               
kESCFourNTSC					EQU		$0A					; NTSC                     
kESCFivePortrait				EQU		$1E					; Portrait RGB              
kESCSixMSB1						EQU		$03					; MultiScan Band-1 (12" thru 1Six")  
kESCSixMSB2						EQU		$0B					; MultiScan Band-2 (13" thru 19")       
kESCSixMSB3						EQU		$23					; MultiScan Band-3 (13" thru 21")       
kESCSixStandard					EQU		$2B					; 13"/14" RGB or 12" Monochrome   
kESCSevenPAL					EQU		$00					; PAL                        
kESCSevenNTSC					EQU		$14					; NTSC                     
kESCSevenVGA					EQU		$17					; VGA                        
kESCSeven16Inch					EQU		$2D					; 16" RGB (GoldFish)               
kESCSevenPALAlternate			EQU		$30					; PAL (Alternate)                
kESCSeven19Inch					EQU		$3A					; Third-Party 19”                 
kESCSevenDDC					EQU		$3E					; DDC display                   
kESCSevenNoDisplay				EQU		$3F					; No display connected           
;  DepthMode
;    This abstract data type is used to to reference RELATIVE pixel depths.
;    Its definition is largely derived from its past usage, analogous to 'xxxVidMode'
;
;    Bits per pixel DOES NOT directly map to 'DepthMode'  For example, on some
;    graphics hardware, 'kDepthMode1' may represent 1 BPP, whereas on other
;    hardware, 'kDepthMode1' may represent 8BPP.
;
;    DepthMode IS considered to be ordinal, i.e., operations such as <, >, ==, etc.
;    behave as expected.  The values of the constants which comprise the set are such
;    that 'kDepthMode4 < kDepthMode6' behaves as expected.
;

; typedef unsigned short 				DepthMode


kDepthMode1						EQU		128
kDepthMode2						EQU		129
kDepthMode3						EQU		130
kDepthMode4						EQU		131
kDepthMode5						EQU		132
kDepthMode6						EQU		133

kFirstDepthMode					EQU		128					; These constants are obsolete, and just included    
kSecondDepthMode				EQU		129					; for clients that have converted to the above     
kThirdDepthMode					EQU		130					; kDepthModeXXX constants.                
kFourthDepthMode				EQU		131
kFifthDepthMode					EQU		132
kSixthDepthMode					EQU		133

VDPageInfo				RECORD 0
csMode					 ds.w	1				; offset: $0 (0)		; (word) mode within device
csData					 ds.l	1				; offset: $2 (2)		; (long) data supplied by driver
csPage					 ds.w	1				; offset: $6 (6)		; (word) page to switch in
csBaseAddr				 ds.l	1				; offset: $8 (8)		; (long) base address of page
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct VDPageInfo *			VDPgInfoPtr

VDSizeInfo				RECORD 0
csHSize					 ds.w	1				; offset: $0 (0)		; (word) desired/returned h size
csHPos					 ds.w	1				; offset: $2 (2)		; (word) desired/returned h position
csVSize					 ds.w	1				; offset: $4 (4)		; (word) desired/returned v size
csVPos					 ds.w	1				; offset: $6 (6)		; (word) desired/returned v position
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct VDSizeInfo *			VDSzInfoPtr

VDSettings				RECORD 0
csParamCnt				 ds.w	1				; offset: $0 (0)		; (word) number of params
csBrightMax				 ds.w	1				; offset: $2 (2)		; (word) max brightness
csBrightDef				 ds.w	1				; offset: $4 (4)		; (word) default brightness
csBrightVal				 ds.w	1				; offset: $6 (6)		; (word) current brightness
csCntrstMax				 ds.w	1				; offset: $8 (8)		; (word) max contrast
csCntrstDef				 ds.w	1				; offset: $A (10)		; (word) default contrast
csCntrstVal				 ds.w	1				; offset: $C (12)		; (word) current contrast
csTintMax				 ds.w	1				; offset: $E (14)		; (word) max tint
csTintDef				 ds.w	1				; offset: $10 (16)		; (word) default tint
csTintVal				 ds.w	1				; offset: $12 (18)		; (word) current tint
csHueMax				 ds.w	1				; offset: $14 (20)		; (word) max hue
csHueDef				 ds.w	1				; offset: $16 (22)		; (word) default hue
csHueVal				 ds.w	1				; offset: $18 (24)		; (word) current hue
csHorizDef				 ds.w	1				; offset: $1A (26)		; (word) default horizontal
csHorizVal				 ds.w	1				; offset: $1C (28)		; (word) current horizontal
csHorizMax				 ds.w	1				; offset: $1E (30)		; (word) max horizontal
csVertDef				 ds.w	1				; offset: $20 (32)		; (word) default vertical
csVertVal				 ds.w	1				; offset: $22 (34)		; (word) current vertical
csVertMax				 ds.w	1				; offset: $24 (36)		; (word) max vertical
sizeof					 EQU *					; size:   $26 (38)
						ENDR
; typedef struct VDSettings *			VDSettingsPtr

VDDefMode				RECORD 0
csID					 ds.b	1				; offset: $0 (0)
filler					 ds.b	1				; offset: $1 (1)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
; typedef struct VDDefMode *			VDDefModePtr

VDSyncInfoRec			RECORD 0
csMode					 ds.b	1				; offset: $0 (0)
csFlags					 ds.b	1				; offset: $1 (1)
sizeof					 EQU *					; size:   $2 (2)
						ENDR
; typedef struct VDSyncInfoRec *		VDSyncInfoPtr

; typedef UInt32 						AVIDType

; typedef AVIDType 						DisplayIDType

; typedef UInt32 						DisplayModeID

; typedef UInt32 						VideoDeviceType

; typedef UInt32 						GammaTableID


;   All displayModeID values from 0x80000000 to 0xFFFFFFFF and 0x00
;   are reserved for Apple Computer.


;  Constants for the cscGetNextResolution call 

kDisplayModeIDCurrent			EQU		$00					; Reference the Current DisplayModeID 
kDisplayModeIDInvalid			EQU		$FFFFFFFF			; A bogus DisplayModeID in all cases 
kDisplayModeIDFindFirstResolution EQU	$FFFFFFFE			; Used in cscGetNextResolution to reset iterator 
kDisplayModeIDNoMoreResolutions	EQU		$FFFFFFFD			; Used in cscGetNextResolution to indicate End Of List 
kDisplayModeIDFindFirstProgrammable EQU	$FFFFFFFC			; Used in cscGetNextResolution to find unused programmable timing 
kDisplayModeIDBootProgrammable	EQU		$FFFFFFFB			; This is the ID given at boot time by the OF driver to a programmable timing 
kDisplayModeIDReservedBase		EQU		$80000000			; Lowest (unsigned) DisplayModeID reserved by Apple 
;  Constants for the GetGammaInfoList call 

kGammaTableIDFindFirst			EQU		$FFFFFFFE			; Get the first gamma table ID 
kGammaTableIDNoMoreTables		EQU		$FFFFFFFD			; Used to indicate end of list 
kGammaTableIDSpecific			EQU		$00					; Return the info for the given table id 
;  Constants for GetMultiConnect call

kGetConnectionCount				EQU		$FFFFFFFF			; Used to get the number of possible connections in a “multi-headed” framebuffer environment.
kActivateConnection				EQU		$00					; Used for activating a connection (csConnectFlags value).
kDeactivateConnection			EQU		$0200				; Used for deactivating a connection (csConnectFlags value.)
;  VDCommunicationRec.csBusID values

kVideoDefaultBus				EQU		0

;  VDCommunicationInfoRec.csBusType values

kVideoBusTypeInvalid			EQU		0
kVideoBusTypeI2C				EQU		1

;  VDCommunicationRec.csSendType and VDCommunicationRec.csReplyType values and bits in VDCommunicationInfoRec.csSupportedTypes.

kVideoNoTransactionType			EQU		0					; No transaction
kVideoSimpleI2CType				EQU		1					; Simple I2C message
kVideoDDCciReplyType			EQU		2					; DDC/ci message (with imbedded length)
;  VDCommunicationRec.csCommFlags and VDCommunicationInfoRec.csSupportedCommFlags

kVideoReplyMicroSecDelayMask	EQU		$01					; If set, the driver should delay csMinReplyDelay micro seconds between send and recieve


VDResolutionInfoRec		RECORD 0
csPreviousDisplayModeID	 ds.l	1				; offset: $0 (0)		;  ID of the previous resolution in a chain 
csDisplayModeID			 ds.l	1				; offset: $4 (4)		;  ID of the next resolution 
csHorizontalPixels		 ds.l	1				; offset: $8 (8)		;  # of pixels in a horizontal line at the max depth 
csVerticalLines			 ds.l	1				; offset: $C (12)		;  # of lines in a screen at the max depth 
csRefreshRate			 ds.l	1				; offset: $10 (16)		;  Vertical Refresh Rate in Hz 
csMaxDepthMode			 ds.w	1				; offset: $14 (20)		;  0x80-based number representing max bit depth 
csResolutionFlags		 ds.l	1				; offset: $16 (22)		;  Reserved - flag bits 
csReserved				 ds.l	1				; offset: $1A (26)		;  Reserved 
sizeof					 EQU *					; size:   $1E (30)
						ENDR
; typedef struct VDResolutionInfoRec *	VDResolutionInfoPtr

VDVideoParametersInfoRec RECORD 0
csDisplayModeID			 ds.l	1				; offset: $0 (0)		;  the ID of the resolution we want info on 
csDepthMode				 ds.w	1				; offset: $4 (4)		;  The bit depth we want the info on (0x80 based) 
csVPBlockPtr			 ds.l	1				; offset: $6 (6)		;  Pointer to a video parameter block 
csPageCount				 ds.l	1				; offset: $A (10)		;  Number of pages supported by the resolution 
csDeviceType			 ds.l	1				; offset: $E (14)		;  Device Type:  Direct, Fixed or CLUT; 
csDepthFlags			 ds.l	1				; offset: $12 (18)		;  Flags 
sizeof					 EQU *					; size:   $16 (22)
						ENDR
; typedef struct VDVideoParametersInfoRec * VDVideoParametersInfoPtr

VDGammaInfoRec			RECORD 0
csLastGammaID			 ds.l	1				; offset: $0 (0)		;  the ID of the previous gamma table 
csNextGammaID			 ds.l	1				; offset: $4 (4)		;  the ID of the next gamma table 
csGammaPtr				 ds.l	1				; offset: $8 (8)		;  Ptr to a gamma table data 
csReserved				 ds.l	1				; offset: $C (12)		;  Reserved 
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct VDGammaInfoRec *		VDGammaInfoPtr

VDGetGammaListRec		RECORD 0
csPreviousGammaTableID	 ds.l	1				; offset: $0 (0)		;  ID of the previous gamma table 
csGammaTableID			 ds.l	1				; offset: $4 (4)		;  ID of the gamma table following csPreviousDisplayModeID 
csGammaTableSize		 ds.l	1				; offset: $8 (8)		;  Size of the gamma table in bytes 
csGammaTableName		 ds.l	1				; offset: $C (12)		;  Gamma table name (c-string) 
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct VDGetGammaListRec *	VDGetGammaListPtr

VDRetrieveGammaRec		RECORD 0
csGammaTableID			 ds.l	1				; offset: $0 (0)		;  ID of gamma table to retrieve 
csGammaTablePtr			 ds.l	1				; offset: $4 (4)		;  Location to copy desired gamma to 
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef struct VDRetrieveGammaRec *	VDRetrieveGammaPtr

VDSetHardwareCursorRec	RECORD 0
csCursorRef				 ds.l	1				; offset: $0 (0)		;  reference to cursor data 
csReserved1				 ds.l	1				; offset: $4 (4)		;  reserved for future use 
csReserved2				 ds.l	1				; offset: $8 (8)		;  should be ignored 
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct VDSetHardwareCursorRec * VDSetHardwareCursorPtr

VDDrawHardwareCursorRec	RECORD 0
csCursorX				 ds.l	1				; offset: $0 (0)		;  x coordinate 
csCursorY				 ds.l	1				; offset: $4 (4)		;  y coordinate 
csCursorVisible			 ds.l	1				; offset: $8 (8)		;  true if cursor is must be visible 
csReserved1				 ds.l	1				; offset: $C (12)		;  reserved for future use 
csReserved2				 ds.l	1				; offset: $10 (16)		;  should be ignored 
sizeof					 EQU *					; size:   $14 (20)
						ENDR
; typedef struct VDDrawHardwareCursorRec * VDDrawHardwareCursorPtr

VDSupportsHardwareCursorRec RECORD 0
csSupportsHardwareCursor  ds.l	1				; offset: $0 (0)
;  true if hardware cursor is supported 
csReserved1				 ds.l	1				; offset: $4 (4)		;  reserved for future use 
csReserved2				 ds.l	1				; offset: $8 (8)		;  must be zero 
sizeof					 EQU *					; size:   $C (12)
						ENDR
; typedef struct VDSupportsHardwareCursorRec * VDSupportsHardwareCursorPtr

VDHardwareCursorDrawStateRec RECORD 0
csCursorX				 ds.l	1				; offset: $0 (0)		;  x coordinate 
csCursorY				 ds.l	1				; offset: $4 (4)		;  y coordinate 
csCursorVisible			 ds.l	1				; offset: $8 (8)		;  true if cursor is visible 
csCursorSet				 ds.l	1				; offset: $C (12)		;  true if cursor successfully set by last set control call 
csReserved1				 ds.l	1				; offset: $10 (16)		;  reserved for future use 
csReserved2				 ds.l	1				; offset: $14 (20)		;  must be zero 
sizeof					 EQU *					; size:   $18 (24)
						ENDR
; typedef struct VDHardwareCursorDrawStateRec * VDHardwareCursorDrawStatePtr

VDConvolutionInfoRec	RECORD 0
csDisplayModeID			 ds.l	1				; offset: $0 (0)		;  the ID of the resolution we want info on 
csDepthMode				 ds.w	1				; offset: $4 (4)		;  The bit depth we want the info on (0x80 based) 
csPage					 ds.l	1				; offset: $6 (6)
csFlags					 ds.l	1				; offset: $A (10)
csReserved				 ds.l	1				; offset: $E (14)
sizeof					 EQU *					; size:   $12 (18)
						ENDR
; typedef struct VDConvolutionInfoRec *	VDConvolutionInfoPtr

VDPowerStateRec			RECORD 0
powerState				 ds.l	1				; offset: $0 (0)
powerFlags				 ds.l	1				; offset: $4 (4)
powerReserved1			 ds.l	1				; offset: $8 (8)
powerReserved2			 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef struct VDPowerStateRec *		VDPowerStatePtr

; 
;    Private Data to video drivers.
;    
;    In versions of MacOS with multiple address spaces (System 8), the OS 
;    must know the extent of parameters in order to move them between the caller
;    and driver.  The old private-selector model for video drivers does not have
;    this information so:
;    
;    For post-7.x Systems private calls should be implemented using the cscPrivateCall
;

VDPrivateSelectorDataRec RECORD 0
privateParameters		 ds.l	1				; offset: $0 (0)		;  Caller's parameters
privateParametersSize	 ds.l	1				; offset: $4 (4)		;  Size of data sent from caller to driver
privateResults			 ds.l	1				; offset: $8 (8)		;  Caller's return area. Can be nil, or same as privateParameters.
privateResultsSize		 ds.l	1				; offset: $C (12)		;  Size of data driver returns to caller. Can be nil, or same as privateParametersSize.
sizeof					 EQU *					; size:   $10 (16)
						ENDR

VDPrivateSelectorRec	RECORD 0
reserved				 ds.l	1				; offset: $0 (0)		;  Reserved (set to 0). 
data					 ds		VDPrivateSelectorDataRec ; offset: $4 (4) <-- really an array of length one
sizeof					 EQU *					; size:   $14 (20)
						ENDR
VDDDCBlockRec			RECORD 0
ddcBlockNumber			 ds.l	1				; offset: $0 (0)		;  Input -- DDC EDID (Extended Display Identification Data) number (1-based) 
ddcBlockType			 ds.l	1				; offset: $4 (4)		;  Input -- DDC block type (EDID/VDIF) 
ddcFlags				 ds.l	1				; offset: $8 (8)		;  Input -- DDC Flags
ddcReserved				 ds.l	1				; offset: $C (12)		;  Reserved 
ddcBlockData			 ds.b	128				; offset: $10 (16)		;  Output -- DDC EDID/VDIF data (kDDCBlockSize) 
sizeof					 EQU *					; size:   $90 (144)
						ENDR
; typedef struct VDDDCBlockRec *		VDDDCBlockPtr



															; timingSyncConfiguration
kSyncInterlaceMask				EQU		$80
kSyncAnalogCompositeMask		EQU		0
kSyncAnalogCompositeSerrateMask	EQU		$04
kSyncAnalogCompositeRGBSyncMask	EQU		$02
kSyncAnalogBipolarMask			EQU		$08
kSyncAnalogBipolarSerrateMask	EQU		$04
kSyncAnalogBipolarSRGBSyncMask	EQU		$02
kSyncDigitalCompositeMask		EQU		$10
kSyncDigitalCompositeSerrateMask EQU	$04
kSyncDigitalCompositeMatchHSyncMask EQU	$04
kSyncDigitalSeperateMask		EQU		$18
kSyncDigitalVSyncPositiveMask	EQU		$04
kSyncDigitalHSyncPositiveMask	EQU		$02


VDDisplayTimingRangeRec	RECORD 0
csRangeSize				 ds.l	1				; offset: $0 (0)		;  Init to sizeof(VDDisplayTimingRangeRec) 
csRangeType				 ds.l	1				; offset: $4 (4)		;  Init to 0 
csRangeVersion			 ds.l	1				; offset: $8 (8)		;  Init to 0 
csRangeReserved			 ds.l	1				; offset: $C (12)		;  Init to 0 
csRangeBlockIndex		 ds.l	1				; offset: $10 (16)		;  Requested block (first index is 0)
csRangeGroup			 ds.l	1				; offset: $14 (20)		;  set to 0 
csRangeBlockCount		 ds.l	1				; offset: $18 (24)		;  # blocks 
csRangeFlags			 ds.l	1				; offset: $1C (28)		;  dependent video 
csMinPixelClock			 ds		UInt64			; offset: $20 (32)		;  Min dot clock in Hz 
csMaxPixelClock			 ds		UInt64			; offset: $28 (40)		;  Max dot clock in Hz 
csMaxPixelError			 ds.l	1				; offset: $30 (48)		;  Max dot clock error 
csTimingRangeSyncFlags	 ds.l	1				; offset: $34 (52)
csTimingRangeSignalLevels  ds.l	1				; offset: $38 (56)
csReserved0				 ds.l	1				; offset: $3C (60)
csMinFrameRate			 ds.l	1				; offset: $40 (64)		;  Hz 
csMaxFrameRate			 ds.l	1				; offset: $44 (68)		;  Hz 
csMinLineRate			 ds.l	1				; offset: $48 (72)		;  Hz 
csMaxLineRate			 ds.l	1				; offset: $4C (76)		;  Hz 
csMaxHorizontalTotal	 ds.l	1				; offset: $50 (80)		;  Clocks - Maximum total (active + blanking) 
csMaxVerticalTotal		 ds.l	1				; offset: $54 (84)		;  Clocks - Maximum total (active + blanking) 
csMaxTotalReserved1		 ds.l	1				; offset: $58 (88)		;  Reserved 
csMaxTotalReserved2		 ds.l	1				; offset: $5C (92)		;  Reserved 
;  Some cards require that some timing elements
;  be multiples of a "character size" (often 8
;  clocks).  The "xxxxCharSize" fields document
;  those requirements.
csCharSizeHorizontalActive  ds.b 1				; offset: $60 (96)		;  Character size 
csCharSizeHorizontalBlanking  ds.b 1			; offset: $61 (97)		;  Character size 
csCharSizeHorizontalSyncOffset  ds.b 1			; offset: $62 (98)		;  Character size 
csCharSizeHorizontalSyncPulse  ds.b 1			; offset: $63 (99)		;  Character size 
csCharSizeVerticalActive  ds.b	1				; offset: $64 (100)		;  Character size 
csCharSizeVerticalBlanking  ds.b 1				; offset: $65 (101)		;  Character size 
csCharSizeVerticalSyncOffset  ds.b 1			; offset: $66 (102)		;  Character size 
csCharSizeVerticalSyncPulse  ds.b 1				; offset: $67 (103)		;  Character size 
csCharSizeHorizontalBorderLeft  ds.b 1			; offset: $68 (104)		;  Character size 
csCharSizeHorizontalBorderRight  ds.b 1			; offset: $69 (105)		;  Character size 
csCharSizeVerticalBorderTop  ds.b 1				; offset: $6A (106)		;  Character size 
csCharSizeVerticalBorderBottom  ds.b 1			; offset: $6B (107)		;  Character size 
csCharSizeHorizontalTotal  ds.b	1				; offset: $6C (108)		;  Character size for active + blanking 
csCharSizeVerticalTotal	 ds.b	1				; offset: $6D (109)		;  Character size for active + blanking 
csCharSizeReserved1		 ds.w	1				; offset: $6E (110)		;  Reserved (Init to 0) 
csMinHorizontalActiveClocks  ds.l 1				; offset: $70 (112)
csMaxHorizontalActiveClocks  ds.l 1				; offset: $74 (116)
csMinHorizontalBlankingClocks  ds.l 1			; offset: $78 (120)
csMaxHorizontalBlankingClocks  ds.l 1			; offset: $7C (124)
csMinHorizontalSyncOffsetClocks  ds.l 1			; offset: $80 (128)
csMaxHorizontalSyncOffsetClocks  ds.l 1			; offset: $84 (132)
csMinHorizontalPulseWidthClocks  ds.l 1			; offset: $88 (136)
csMaxHorizontalPulseWidthClocks  ds.l 1			; offset: $8C (140)
csMinVerticalActiveClocks  ds.l	1				; offset: $90 (144)
csMaxVerticalActiveClocks  ds.l	1				; offset: $94 (148)
csMinVerticalBlankingClocks  ds.l 1				; offset: $98 (152)
csMaxVerticalBlankingClocks  ds.l 1				; offset: $9C (156)
csMinVerticalSyncOffsetClocks  ds.l 1			; offset: $A0 (160)
csMaxVerticalSyncOffsetClocks  ds.l 1			; offset: $A4 (164)
csMinVerticalPulseWidthClocks  ds.l 1			; offset: $A8 (168)
csMaxVerticalPulseWidthClocks  ds.l 1			; offset: $AC (172)
csMinHorizontalBorderLeft  ds.l	1				; offset: $B0 (176)
csMaxHorizontalBorderLeft  ds.l	1				; offset: $B4 (180)
csMinHorizontalBorderRight  ds.l 1				; offset: $B8 (184)
csMaxHorizontalBorderRight  ds.l 1				; offset: $BC (188)
csMinVerticalBorderTop	 ds.l	1				; offset: $C0 (192)
csMaxVerticalBorderTop	 ds.l	1				; offset: $C4 (196)
csMinVerticalBorderBottom  ds.l	1				; offset: $C8 (200)
csMaxVerticalBorderBottom  ds.l	1				; offset: $CC (204)
csReserved1				 ds.l	1				; offset: $D0 (208)		;  Reserved (Init to 0)
csReserved2				 ds.l	1				; offset: $D4 (212)		;  Reserved (Init to 0)
csReserved3				 ds.l	1				; offset: $D8 (216)		;  Reserved (Init to 0)
csReserved4				 ds.l	1				; offset: $DC (220)		;  Reserved (Init to 0)
csReserved5				 ds.l	1				; offset: $E0 (224)		;  Reserved (Init to 0)
csReserved6				 ds.l	1				; offset: $E4 (228)		;  Reserved (Init to 0)
csReserved7				 ds.l	1				; offset: $E8 (232)		;  Reserved (Init to 0)
csReserved8				 ds.l	1				; offset: $EC (236)		;  Reserved (Init to 0)
sizeof					 EQU *					; size:   $F0 (240)
						ENDR
; typedef struct VDDisplayTimingRangeRec * VDDisplayTimingRangePtr



															; csDisplayModeState
kDMSModeReady					EQU		0					; Display Mode ID is configured and ready
kDMSModeNotReady				EQU		1					; Display Mode ID is is being programmed
kDMSModeFree					EQU		2					; Display Mode ID is not associated with a timing

;  Video driver Errors -10930 to -10959 

kTimingChangeRestrictedErr		EQU		-10930
kVideoI2CReplyPendingErr		EQU		-10931
kVideoI2CTransactionErr			EQU		-10932
kVideoI2CBusyErr				EQU		-10933
kVideoI2CTransactionTypeErr		EQU		-10934
kVideoBufferSizeErr				EQU		-10935


															; csTimingRangeSignalLevels
kRangeSupportsSignal_0700_0300_Bit EQU	0
kRangeSupportsSignal_0714_0286_Bit EQU	1
kRangeSupportsSignal_1000_0400_Bit EQU	2
kRangeSupportsSignal_0700_0000_Bit EQU	3
kRangeSupportsSignal_0700_0300_Mask EQU	$01
kRangeSupportsSignal_0714_0286_Mask EQU	$02
kRangeSupportsSignal_1000_0400_Mask EQU	$04
kRangeSupportsSignal_0700_0000_Mask EQU	$08


															; csSignalConfig
kDigitalSignalBit				EQU		0					; Do not set.  Mac OS does not currently support arbitrary digital timings
kAnalogSetupExpectedBit			EQU		1					; Analog displays - display expects a blank-to-black setup or pedestal.  See VESA signal standards.
kDigitalSignalMask				EQU		$01
kAnalogSetupExpectedMask		EQU		$02


															; csSignalLevels for analog
kAnalogSignalLevel_0700_0300	EQU		0
kAnalogSignalLevel_0714_0286	EQU		1
kAnalogSignalLevel_1000_0400	EQU		2
kAnalogSignalLevel_0700_0000	EQU		3


															; csTimingRangeSyncFlags
kRangeSupportsSeperateSyncsBit	EQU		0
kRangeSupportsSyncOnGreenBit	EQU		1
kRangeSupportsCompositeSyncBit	EQU		2
kRangeSupportsVSyncSerrationBit	EQU		3
kRangeSupportsSeperateSyncsMask	EQU		$01
kRangeSupportsSyncOnGreenMask	EQU		$02
kRangeSupportsCompositeSyncMask	EQU		$04
kRangeSupportsVSyncSerrationMask EQU	$08



															; csHorizontalSyncConfig and csVerticalSyncConfig
kSyncPositivePolarityBit		EQU		0					; Digital separate sync polarity for analog interfaces (0 => negative polarity)
kSyncPositivePolarityMask		EQU		$01



;  For timings with kDetailedTimingFormat.
VDDetailedTimingRec		RECORD 0
csTimingSize			 ds.l	1				; offset: $0 (0)		;  Init to sizeof(VDDetailedTimingRec)
csTimingType			 ds.l	1				; offset: $4 (4)		;  Init to 0
csTimingVersion			 ds.l	1				; offset: $8 (8)		;  Init to 0
csTimingReserved		 ds.l	1				; offset: $C (12)		;  Init to 0
csDisplayModeID			 ds.l	1				; offset: $10 (16)		;  Init to 0
csDisplayModeSeed		 ds.l	1				; offset: $14 (20)		;  
csDisplayModeState		 ds.l	1				; offset: $18 (24)		;  Display Mode state
csDisplayModeAlias		 ds.l	1				; offset: $1C (28)		;  Mode to use when programmed.
csSignalConfig			 ds.l	1				; offset: $20 (32)
csSignalLevels			 ds.l	1				; offset: $24 (36)
csPixelClock			 ds		UInt64			; offset: $28 (40)		;  Hz
csMinPixelClock			 ds		UInt64			; offset: $30 (48)		;  Hz - With error what is slowest actual clock 
csMaxPixelClock			 ds		UInt64			; offset: $38 (56)		;  Hz - With error what is fasted actual clock 
csHorizontalActive		 ds.l	1				; offset: $40 (64)		;  Pixels
csHorizontalBlanking	 ds.l	1				; offset: $44 (68)		;  Pixels
csHorizontalSyncOffset	 ds.l	1				; offset: $48 (72)		;  Pixels
csHorizontalSyncPulseWidth  ds.l 1				; offset: $4C (76)		;  Pixels
csVerticalActive		 ds.l	1				; offset: $50 (80)		;  Lines
csVerticalBlanking		 ds.l	1				; offset: $54 (84)		;  Lines
csVerticalSyncOffset	 ds.l	1				; offset: $58 (88)		;  Lines
csVerticalSyncPulseWidth  ds.l	1				; offset: $5C (92)		;  Lines
csHorizontalBorderLeft	 ds.l	1				; offset: $60 (96)		;  Pixels
csHorizontalBorderRight	 ds.l	1				; offset: $64 (100)		;  Pixels
csVerticalBorderTop		 ds.l	1				; offset: $68 (104)		;  Lines
csVerticalBorderBottom	 ds.l	1				; offset: $6C (108)		;  Lines
csHorizontalSyncConfig	 ds.l	1				; offset: $70 (112)
csHorizontalSyncLevel	 ds.l	1				; offset: $74 (116)		;  Future use (init to 0)
csVerticalSyncConfig	 ds.l	1				; offset: $78 (120)
csVerticalSyncLevel		 ds.l	1				; offset: $7C (124)		;  Future use (init to 0)
csReserved1				 ds.l	1				; offset: $80 (128)		;  Init to 0
csReserved2				 ds.l	1				; offset: $84 (132)		;  Init to 0
csReserved3				 ds.l	1				; offset: $88 (136)		;  Init to 0
csReserved4				 ds.l	1				; offset: $8C (140)		;  Init to 0
csReserved5				 ds.l	1				; offset: $90 (144)		;  Init to 0
csReserved6				 ds.l	1				; offset: $94 (148)		;  Init to 0
csReserved7				 ds.l	1				; offset: $98 (152)		;  Init to 0
csReserved8				 ds.l	1				; offset: $9C (156)		;  Init to 0
sizeof					 EQU *					; size:   $A0 (160)
						ENDR
; typedef struct VDDetailedTimingRec *	VDDetailedTimingPtr

; typedef UInt32 						VDClutBehavior

; typedef VDClutBehavior *				VDClutBehaviorPtr


kSetClutAtSetEntries			EQU		0					; SetEntries behavior is to update clut during SetEntries call
kSetClutAtVBL					EQU		1					; SetEntries behavior is to upate clut at next vbl

VDCommunicationRec		RECORD 0
csBusID					 ds.l	1				; offset: $0 (0)		;  kVideoDefaultBus for single headed cards.
csCommFlags				 ds.l	1				; offset: $4 (4)		;  Always zero
csMinReplyDelay			 ds.l	1				; offset: $8 (8)		;  Minimum delay between send and reply transactions (units depend on csCommFlags)
csReserved2				 ds.l	1				; offset: $C (12)		;  Always zero
csSendAddress			 ds.l	1				; offset: $10 (16)		;  Usually I2C address (eg 0x6E)
csSendType				 ds.l	1				; offset: $14 (20)		;  See kVideoSimpleI2CType etc.
csSendBuffer			 ds.l	1				; offset: $18 (24)		;  Pointer to the send buffer
csSendSize				 ds.l	1				; offset: $1C (28)		;  Number of bytes to send
csReplyAddress			 ds.l	1				; offset: $20 (32)		;  Address from which to read (eg 0x6F for kVideoDDCciReplyType I2C address)
csReplyType				 ds.l	1				; offset: $24 (36)		;  See kVideoDDCciReplyType etc.
csReplyBuffer			 ds.l	1				; offset: $28 (40)		;  Pointer to the reply buffer
csReplySize				 ds.l	1				; offset: $2C (44)		;  Max bytes to reply (size of csReplyBuffer)
csReserved3				 ds.l	1				; offset: $30 (48)
csReserved4				 ds.l	1				; offset: $34 (52)
csReserved5				 ds.l	1				; offset: $38 (56)		;  Always zero
csReserved6				 ds.l	1				; offset: $3C (60)		;  Always zero
sizeof					 EQU *					; size:   $40 (64)
						ENDR
; typedef struct VDCommunicationRec *	VDCommunicationPtr

VDCommunicationInfoRec	RECORD 0
csBusID					 ds.l	1				; offset: $0 (0)		;  kVideoDefaultBus for single headed cards. 
csBusType				 ds.l	1				; offset: $4 (4)		;  See kVideoBusI2C etc.
csMinBus				 ds.l	1				; offset: $8 (8)		;  Minimum bus (usually kVideoDefaultBus).  Used to probe additional busses
csMaxBus				 ds.l	1				; offset: $C (12)		;  Max bus (usually kVideoDefaultBus).  Used to probe additional busses
csSupportedTypes		 ds.l	1				; offset: $10 (16)		;  Bit field for first 32 supported transaction types.  Eg. 0x07 => support for kVideoNoTransactionType, kVideoSimpleI2CType and kVideoDDCciReplyType.
csSupportedCommFlags	 ds.l	1				; offset: $14 (20)		;  Return the flags csCommFlags understood by this driver.
csReserved2				 ds.l	1				; offset: $18 (24)		;  Always zero
csReserved3				 ds.l	1				; offset: $1C (28)		;  Always zero
csReserved4				 ds.l	1				; offset: $20 (32)		;  Always zero
csReserved5				 ds.l	1				; offset: $24 (36)		;  Always zero
csReserved6				 ds.l	1				; offset: $28 (40)		;  Always zero
csReserved7				 ds.l	1				; offset: $2C (44)		;  Always zero
sizeof					 EQU *					; size:   $30 (48)
						ENDR
; typedef struct VDCommunicationInfoRec * VDCommunicationInfoPtr

	ENDIF ; __VIDEO__ 


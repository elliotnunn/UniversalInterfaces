;
;    File:       fenv.a
;
;    Contains:   Floating-Point environment for PowerPC and 68K
;
;    Version:    Technology: MathLib v2
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  Â© 1987-2001 by Apple Computer, Inc., all rights reserved.
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__FENV__') = 'UNDEFINED' THEN
__FENV__ SET 1

	IF &TYPE('__CONDITIONALMACROS__') = 'UNDEFINED' THEN
	include 'ConditionalMacros.a'
	ENDIF

	IF TARGET_OS_MAC THEN
; 
;    A collection of functions designed to provide access to the floating
;    point environment for numerical programming. It is modeled after
;    the floating-point requirements in C9X.
;    
;    The file <fenv.h> declares many functions in support of numerical
;    programming.  It provides a set of environmental controls similar to
;    the ones found in <SANE.h>.  Programs that test flags or run under
;    non-default modes must do so under the effect of an enabling
;    "fenv_access" pragma.
;


; ********************************************************************************
;*                                                                               *
;*    fenv_t         is a type for representing the entire floating-point        *
;*                   environment in a single object.                             *
;*                                                                               *
;*    fexcept_t      is a type for representing the floating-point               *
;*                   exception flag state collectively.                          *
;*                                                                               *
;*******************************************************************************

	IF TARGET_CPU_PPC THEN
; typedef long 							fenv_t

; typedef long 							fexcept_t

;     Definitions of floating-point exception macros                          

FE_INEXACT						EQU		$02000000
FE_DIVBYZERO					EQU		$04000000
FE_UNDERFLOW					EQU		$08000000
FE_OVERFLOW						EQU		$10000000
FE_INVALID						EQU		$20000000
FE_ALL_EXCEPT					EQU		$3E000000			; FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID

;     Definitions of rounding direction macros                                

FE_TONEAREST					EQU		$00000000
FE_TOWARDZERO					EQU		$00000001
FE_UPWARD						EQU		$00000002
FE_DOWNWARD						EQU		$00000003
	ENDIF	; TARGET_CPU_PPC
	IF TARGET_CPU_68K THEN
	IF TARGET_RT_MAC_68881 THEN
; typedef long 							fexcept_t

fenv_t					RECORD 0
FPCR					 ds.l	1				; offset: $0 (0)
FPSR					 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR

FE_INEXACT						EQU		$00000008			; ((long)(8))   
FE_DIVBYZERO					EQU		$00000010			; ((long)(16))  
FE_UNDERFLOW					EQU		$00000020			; ((long)(32))  
FE_OVERFLOW						EQU		$00000040			; ((long)(64))  
FE_INVALID						EQU		$00000080			; ((long)(128)) 
FE_ALL_EXCEPT					EQU		$000000F8			; FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID
	ELSE
; typedef short 						fexcept_t

; typedef short 						fenv_t


FE_INVALID						EQU		$0001				; ((short)(1))  
FE_UNDERFLOW					EQU		$0002				; ((short)(2))  
FE_OVERFLOW						EQU		$0004				; ((short)(4))  
FE_DIVBYZERO					EQU		$0008				; ((short)(8))  
FE_INEXACT						EQU		$0010				; ((short)(16)) 
FE_ALL_EXCEPT					EQU		$001F				; FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID
	ENDIF	; TARGET_RT_MAC_68881

FE_TONEAREST					EQU		$0000				; ((short)(0))  
FE_UPWARD						EQU		$0001				; ((short)(1))  
FE_DOWNWARD						EQU		$0002				; ((short)(2))  
FE_TOWARDZERO					EQU		$0003				; ((short)(3))  
;     Definitions of rounding precision macros  (68K only)                    

FE_LDBLPREC						EQU		$0000				; ((short)(0))  
FE_DBLPREC						EQU		$0001				; ((short)(1))  
FE_FLTPREC						EQU		$0002				; ((short)(2))  
	ENDIF	; TARGET_CPU_68K
;  default environment object        

; *  _FE_DFL_ENV
; *  
; *  Availability:
; *    Non-Carbon CFM:   in MathLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.3 and later
; *    Mac OS X:         in after version 10.0
; 

; *******************************************************************************
;*     The following functions provide access to the exception flags.  The      *
;*     "int" input argument can be constructed by bitwise ORs of the exception  *
;*     macros: for example: FE_OVERFLOW | FE_INEXACT.                           *
;******************************************************************************

; *******************************************************************************
;*     The function "feclearexcept" clears the supported exceptions represented *
;*     by its argument.                                                         *
;******************************************************************************


; *  feclearexcept()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in MathLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void feclearexcept(int excepts)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION feclearexcept
	ENDIF



; *******************************************************************************
;*    The function "fegetexcept" stores a representation of the exception       *
;*     flags indicated by the argument "excepts" through the pointer argument   *
;*     "flagp".                                                                 *
;******************************************************************************


; *  fegetexcept()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in MathLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void fegetexcept(fexcept_t *flagp, int excepts)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION fegetexcept
	ENDIF



; *******************************************************************************
;*     The function "feraiseexcept" raises the supported exceptions             *
;*     represented by its argument.                                             *
;******************************************************************************


; *  feraiseexcept()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in MathLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void feraiseexcept(int excepts)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION feraiseexcept
	ENDIF



; *******************************************************************************
;*     The function "fesetexcept" sets or clears the exception flags indicated  *
;*     by the int argument "excepts" according to the representation in the     *
;*     object pointed to by the pointer argument "flagp".  The value of         *
;*     "*flagp" must have been set by a previous call to "fegetexcept".         *
;*     This function does not raise exceptions; it just sets the state of       *
;*     the flags.                                                               *
;******************************************************************************


; *  fesetexcept()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in MathLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void fesetexcept(const fexcept_t *flagp, int excepts)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION fesetexcept
	ENDIF



; *******************************************************************************
;*     The function "fetestexcept" determines which of the specified subset of  *
;*     the exception flags are currently set.  The argument "excepts" specifies *
;*     the exception flags to be queried as a bitwise OR of the exception       *
;*     macros.  This function returns the bitwise OR of the exception macros    *
;*     corresponding to the currently set exceptions included in "excepts".     *
;******************************************************************************


; *  fetestexcept()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in MathLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int fetestexcept(int excepts)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION fetestexcept
	ENDIF



; *******************************************************************************
;*     The following functions provide control of rounding direction modes.     *
;******************************************************************************

; *******************************************************************************
;*     The function "fegetround" returns the value of the rounding direction    *
;*     macro which represents the current rounding direction.                   *
;******************************************************************************


; *  fegetround()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in MathLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int fegetround(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION fegetround
	ENDIF



; *******************************************************************************
;*     The function "fesetround" establishes the rounding direction represented *
;*     by its argument.  It returns nonzero if and only if the argument matches *
;*     a rounding direction macro.  If not, the rounding direction is not       *
;*     changed.                                                                 *
;******************************************************************************


; *  fesetround()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in MathLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int fesetround(int round)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION fesetround
	ENDIF



; *******************************************************************************
;*    The following functions manage the floating-point environment, exception  *
;*    flags and dynamic modes, as one entity.                                   *
;******************************************************************************

; *******************************************************************************
;*     The function "fegetenv" stores the current floating-point environment    *
;*     in the object pointed to by its pointer argument "envp".                 *
;******************************************************************************


; *  fegetenv()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in MathLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void fegetenv(fenv_t *envp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION fegetenv
	ENDIF



; *******************************************************************************
;*     The function "feholdexcept" saves the current environment in the object  *
;*     pointed to by its pointer argument "envp", clears the exception flags,   *
;*     and clears floating-point exception enables.  This function supersedes   *
;*     the SANE function "procentry", but it does not change the current        *
;*     rounding direction mode.                                                 *
;******************************************************************************


; *  feholdexcept()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in MathLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern int feholdexcept(fenv_t *envp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION feholdexcept
	ENDIF



; *******************************************************************************
;*     The function "fesetenv" installs the floating-point environment          *
;*     environment represented by the object pointed to by its argument         *
;*     "envp".  The value of "*envp" must be set by a call to "fegetenv" or     *
;*     "feholdexcept", by an implementation-defined macro of type "fenv_t",     *
;*     or by the use of the pointer macro FE_DFL_ENV as the argument.           *
;******************************************************************************


; *  fesetenv()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in MathLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void fesetenv(const fenv_t *envp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION fesetenv
	ENDIF



; *******************************************************************************
;*     The function "feupdateenv" saves the current exceptions into its         *
;*     automatic storage, installs the environment represented through its      *
;*     pointer argument "envp", and then re-raises the saved exceptions.        *
;*     This function, which supersedes the SANE function "procexit", can be     *
;*     used in conjunction with "feholdexcept" to write routines which hide     *
;*     spurious exceptions from their callers.                                  *
;******************************************************************************


; *  feupdateenv()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in MathLib 1.0 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; extern void feupdateenv(const fenv_t *envp)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION feupdateenv
	ENDIF



	IF TARGET_CPU_68K THEN
; *******************************************************************************
;*     The following functions provide control of rounding precision.           *
;*     Because the PowerPC does not provide this capability, these functions    *  
;*     are available only for the 68K Macintosh.  Rounding precision values     *
;*     are defined by the rounding precision macros.  These functions are       *
;*     equivalent to the SANE functions getprecision and setprecision.          *
;******************************************************************************

	IF CALL_NOT_IN_CARBON THEN

; *  fegetprec()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern int fegetprec(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION fegetprec
	ENDIF


; *  fesetprec()
; *  
; *  Availability:
; *    Non-Carbon CFM:   not available
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern int fesetprec(int precision)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION fesetprec
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF	; TARGET_CPU_68K
	ENDIF	; TARGET_OS_MAC

	ENDIF ; __FENV__ 

